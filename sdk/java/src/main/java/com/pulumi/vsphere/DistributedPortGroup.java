// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.vsphere.DistributedPortGroupArgs;
import com.pulumi.vsphere.Utilities;
import com.pulumi.vsphere.inputs.DistributedPortGroupState;
import com.pulumi.vsphere.outputs.DistributedPortGroupVlanRange;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

@ResourceType(type="vsphere:index/distributedPortGroup:DistributedPortGroup")
public class DistributedPortGroup extends com.pulumi.resources.CustomResource {
    /**
     * List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    @Export(name="activeUplinks", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> activeUplinks;

    /**
     * @return List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    public Output<List<String>> activeUplinks() {
        return this.activeUplinks;
    }
    /**
     * Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
     * that of its own.
     * 
     */
    @Export(name="allowForgedTransmits", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowForgedTransmits;

    /**
     * @return Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
     * that of its own.
     * 
     */
    public Output<Boolean> allowForgedTransmits() {
        return this.allowForgedTransmits;
    }
    /**
     * Controls whether or not the Media Access Control (MAC) address can be changed.
     * 
     */
    @Export(name="allowMacChanges", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowMacChanges;

    /**
     * @return Controls whether or not the Media Access Control (MAC) address can be changed.
     * 
     */
    public Output<Boolean> allowMacChanges() {
        return this.allowMacChanges;
    }
    /**
     * Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    @Export(name="allowPromiscuous", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowPromiscuous;

    /**
     * @return Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    public Output<Boolean> allowPromiscuous() {
        return this.allowPromiscuous;
    }
    /**
     * Allows the port group to create additional ports
     * past the limit specified in `number_of_ports` if necessary. Default: `true`.
     * 
     * &gt; **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`
     * may lead to errors when the port count grows past the amount specified.  If you
     * specify `number_of_ports`, you may wish to set `auto_expand` to `false`.
     * 
     */
    @Export(name="autoExpand", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> autoExpand;

    /**
     * @return Allows the port group to create additional ports
     * past the limit specified in `number_of_ports` if necessary. Default: `true`.
     * 
     * &gt; **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`
     * may lead to errors when the port count grows past the amount specified.  If you
     * specify `number_of_ports`, you may wish to set `auto_expand` to `false`.
     * 
     */
    public Output<Optional<Boolean>> autoExpand() {
        return Codegen.optional(this.autoExpand);
    }
    /**
     * Indicates whether to block all ports by default.
     * 
     */
    @Export(name="blockAllPorts", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> blockAllPorts;

    /**
     * @return Indicates whether to block all ports by default.
     * 
     */
    public Output<Boolean> blockAllPorts() {
        return this.blockAllPorts;
    }
    /**
     * Allow the port shutdown
     * policy to be overridden on an individual port.
     * 
     */
    @Export(name="blockOverrideAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> blockOverrideAllowed;

    /**
     * @return Allow the port shutdown
     * policy to be overridden on an individual port.
     * 
     */
    public Output<Optional<Boolean>> blockOverrideAllowed() {
        return Codegen.optional(this.blockOverrideAllowed);
    }
    /**
     * Enable beacon probing on the ports this policy applies to.
     * 
     */
    @Export(name="checkBeacon", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> checkBeacon;

    /**
     * @return Enable beacon probing on the ports this policy applies to.
     * 
     */
    public Output<Boolean> checkBeacon() {
        return this.checkBeacon;
    }
    /**
     * The current version of the port group configuration,
     * incremented by subsequent updates to the port group.
     * 
     */
    @Export(name="configVersion", refs={String.class}, tree="[0]")
    private Output<String> configVersion;

    /**
     * @return The current version of the port group configuration,
     * incremented by subsequent updates to the port group.
     * 
     */
    public Output<String> configVersion() {
        return this.configVersion;
    }
    /**
     * Map of custom attribute ids to attribute
     * value string to set for port group.
     * 
     * &gt; **NOTE:** Custom attributes are not supported on direct ESXi host
     * connections and require vCenter Server.
     * 
     */
    @Export(name="customAttributes", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> customAttributes;

    /**
     * @return Map of custom attribute ids to attribute
     * value string to set for port group.
     * 
     * &gt; **NOTE:** Custom attributes are not supported on direct ESXi host
     * connections and require vCenter Server.
     * 
     */
    public Output<Optional<Map<String,String>>> customAttributes() {
        return Codegen.optional(this.customAttributes);
    }
    /**
     * An optional description for the port group.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return An optional description for the port group.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Allow VMDirectPath Gen2 on the ports this policy applies to.
     * 
     */
    @Export(name="directpathGen2Allowed", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> directpathGen2Allowed;

    /**
     * @return Allow VMDirectPath Gen2 on the ports this policy applies to.
     * 
     */
    public Output<Boolean> directpathGen2Allowed() {
        return this.directpathGen2Allowed;
    }
    /**
     * The ID of the VDS to add the
     * port group to. Forces a new resource if changed.
     * 
     */
    @Export(name="distributedVirtualSwitchUuid", refs={String.class}, tree="[0]")
    private Output<String> distributedVirtualSwitchUuid;

    /**
     * @return The ID of the VDS to add the
     * port group to. Forces a new resource if changed.
     * 
     */
    public Output<String> distributedVirtualSwitchUuid() {
        return this.distributedVirtualSwitchUuid;
    }
    /**
     * The average egress bandwidth in bits per second if egress shaping is enabled on the port.
     * 
     */
    @Export(name="egressShapingAverageBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> egressShapingAverageBandwidth;

    /**
     * @return The average egress bandwidth in bits per second if egress shaping is enabled on the port.
     * 
     */
    public Output<Integer> egressShapingAverageBandwidth() {
        return this.egressShapingAverageBandwidth;
    }
    /**
     * The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
     * 
     */
    @Export(name="egressShapingBurstSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> egressShapingBurstSize;

    /**
     * @return The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
     * 
     */
    public Output<Integer> egressShapingBurstSize() {
        return this.egressShapingBurstSize;
    }
    /**
     * True if the traffic shaper is enabled for egress traffic on the port.
     * 
     */
    @Export(name="egressShapingEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> egressShapingEnabled;

    /**
     * @return True if the traffic shaper is enabled for egress traffic on the port.
     * 
     */
    public Output<Boolean> egressShapingEnabled() {
        return this.egressShapingEnabled;
    }
    /**
     * The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="egressShapingPeakBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> egressShapingPeakBandwidth;

    /**
     * @return The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> egressShapingPeakBandwidth() {
        return this.egressShapingPeakBandwidth;
    }
    /**
     * If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
     * 
     */
    @Export(name="failback", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> failback;

    /**
     * @return If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
     * 
     */
    public Output<Boolean> failback() {
        return this.failback;
    }
    /**
     * The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
     * 
     */
    @Export(name="ingressShapingAverageBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> ingressShapingAverageBandwidth;

    /**
     * @return The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
     * 
     */
    public Output<Integer> ingressShapingAverageBandwidth() {
        return this.ingressShapingAverageBandwidth;
    }
    /**
     * The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
     * 
     */
    @Export(name="ingressShapingBurstSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> ingressShapingBurstSize;

    /**
     * @return The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
     * 
     */
    public Output<Integer> ingressShapingBurstSize() {
        return this.ingressShapingBurstSize;
    }
    /**
     * True if the traffic shaper is enabled for ingress traffic on the port.
     * 
     */
    @Export(name="ingressShapingEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> ingressShapingEnabled;

    /**
     * @return True if the traffic shaper is enabled for ingress traffic on the port.
     * 
     */
    public Output<Boolean> ingressShapingEnabled() {
        return this.ingressShapingEnabled;
    }
    /**
     * The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="ingressShapingPeakBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> ingressShapingPeakBandwidth;

    /**
     * @return The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> ingressShapingPeakBandwidth() {
        return this.ingressShapingPeakBandwidth;
    }
    /**
     * The generated UUID of the port group.
     * 
     */
    @Export(name="key", refs={String.class}, tree="[0]")
    private Output<String> key;

    /**
     * @return The generated UUID of the port group.
     * 
     */
    public Output<String> key() {
        return this.key;
    }
    /**
     * Whether or not to enable LACP on all uplink ports.
     * 
     */
    @Export(name="lacpEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> lacpEnabled;

    /**
     * @return Whether or not to enable LACP on all uplink ports.
     * 
     */
    public Output<Boolean> lacpEnabled() {
        return this.lacpEnabled;
    }
    /**
     * The uplink LACP mode to use. Can be one of active or passive.
     * 
     */
    @Export(name="lacpMode", refs={String.class}, tree="[0]")
    private Output<String> lacpMode;

    /**
     * @return The uplink LACP mode to use. Can be one of active or passive.
     * 
     */
    public Output<String> lacpMode() {
        return this.lacpMode;
    }
    /**
     * Allow a port in this port group to be
     * moved to another port group while it is connected.
     * 
     */
    @Export(name="livePortMovingAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> livePortMovingAllowed;

    /**
     * @return Allow a port in this port group to be
     * moved to another port group while it is connected.
     * 
     */
    public Output<Optional<Boolean>> livePortMovingAllowed() {
        return Codegen.optional(this.livePortMovingAllowed);
    }
    /**
     * The name of the port group.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the port group.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Indicates whether to enable netflow on all ports.
     * 
     */
    @Export(name="netflowEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> netflowEnabled;

    /**
     * @return Indicates whether to enable netflow on all ports.
     * 
     */
    public Output<Boolean> netflowEnabled() {
        return this.netflowEnabled;
    }
    /**
     * Allow the
     * [Netflow policy][netflow-policy] on this port group to be overridden on an
     * individual port.
     * 
     */
    @Export(name="netflowOverrideAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> netflowOverrideAllowed;

    /**
     * @return Allow the
     * [Netflow policy][netflow-policy] on this port group to be overridden on an
     * individual port.
     * 
     */
    public Output<Optional<Boolean>> netflowOverrideAllowed() {
        return Codegen.optional(this.netflowOverrideAllowed);
    }
    /**
     * The key of a network resource pool
     * to associate with this port group. The default is `-1`, which implies no
     * association.
     * 
     */
    @Export(name="networkResourcePoolKey", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> networkResourcePoolKey;

    /**
     * @return The key of a network resource pool
     * to associate with this port group. The default is `-1`, which implies no
     * association.
     * 
     */
    public Output<Optional<String>> networkResourcePoolKey() {
        return Codegen.optional(this.networkResourcePoolKey);
    }
    /**
     * Allow the network
     * resource pool set on this port group to be overridden on an individual port.
     * 
     */
    @Export(name="networkResourcePoolOverrideAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> networkResourcePoolOverrideAllowed;

    /**
     * @return Allow the network
     * resource pool set on this port group to be overridden on an individual port.
     * 
     */
    public Output<Optional<Boolean>> networkResourcePoolOverrideAllowed() {
        return Codegen.optional(this.networkResourcePoolOverrideAllowed);
    }
    /**
     * If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
     * 
     */
    @Export(name="notifySwitches", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> notifySwitches;

    /**
     * @return If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
     * 
     */
    public Output<Boolean> notifySwitches() {
        return this.notifySwitches;
    }
    /**
     * The number of ports available on this port
     * group. Cannot be decreased below the amount of used ports on the port group.
     * 
     */
    @Export(name="numberOfPorts", refs={Integer.class}, tree="[0]")
    private Output<Integer> numberOfPorts;

    /**
     * @return The number of ports available on this port
     * group. Cannot be decreased below the amount of used ports on the port group.
     * 
     */
    public Output<Integer> numberOfPorts() {
        return this.numberOfPorts;
    }
    /**
     * Reset a port&#39;s settings to the
     * settings defined on this port group policy when the port disconnects.
     * 
     */
    @Export(name="portConfigResetAtDisconnect", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> portConfigResetAtDisconnect;

    /**
     * @return Reset a port&#39;s settings to the
     * settings defined on this port group policy when the port disconnects.
     * 
     */
    public Output<Optional<Boolean>> portConfigResetAtDisconnect() {
        return Codegen.optional(this.portConfigResetAtDisconnect);
    }
    /**
     * An optional formatting policy for naming of
     * the ports in this port group. See the `portNameFormat` attribute listed
     * [here][ext-vsphere-portname-format] for details on the format syntax.
     * 
     * [ext-vsphere-portname-format]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/b50dcbbf-051d-4204-a3e7-e1b618c1e384/538cf2ec-b34f-4bae-a332-3820ef9e7773/vim.dvs.DistributedVirtualPortgroup.ConfigInfo.html#portNameFormat
     * 
     */
    @Export(name="portNameFormat", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portNameFormat;

    /**
     * @return An optional formatting policy for naming of
     * the ports in this port group. See the `portNameFormat` attribute listed
     * [here][ext-vsphere-portname-format] for details on the format syntax.
     * 
     * [ext-vsphere-portname-format]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/b50dcbbf-051d-4204-a3e7-e1b618c1e384/538cf2ec-b34f-4bae-a332-3820ef9e7773/vim.dvs.DistributedVirtualPortgroup.ConfigInfo.html#portNameFormat
     * 
     */
    public Output<Optional<String>> portNameFormat() {
        return Codegen.optional(this.portNameFormat);
    }
    /**
     * The secondary VLAN ID for this port.
     * 
     */
    @Export(name="portPrivateSecondaryVlanId", refs={Integer.class}, tree="[0]")
    private Output<Integer> portPrivateSecondaryVlanId;

    /**
     * @return The secondary VLAN ID for this port.
     * 
     */
    public Output<Integer> portPrivateSecondaryVlanId() {
        return this.portPrivateSecondaryVlanId;
    }
    /**
     * Allow the
     * [security policy settings][sec-policy-settings] defined in this port group
     * policy to be overridden on an individual port.
     * 
     */
    @Export(name="securityPolicyOverrideAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> securityPolicyOverrideAllowed;

    /**
     * @return Allow the
     * [security policy settings][sec-policy-settings] defined in this port group
     * policy to be overridden on an individual port.
     * 
     */
    public Output<Optional<Boolean>> securityPolicyOverrideAllowed() {
        return Codegen.optional(this.securityPolicyOverrideAllowed);
    }
    /**
     * Allow the
     * [traffic shaping options][traffic-shaping-settings] on this port group policy
     * to be overridden on an individual port.
     * 
     */
    @Export(name="shapingOverrideAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> shapingOverrideAllowed;

    /**
     * @return Allow the
     * [traffic shaping options][traffic-shaping-settings] on this port group policy
     * to be overridden on an individual port.
     * 
     */
    public Output<Optional<Boolean>> shapingOverrideAllowed() {
        return Codegen.optional(this.shapingOverrideAllowed);
    }
    /**
     * List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    @Export(name="standbyUplinks", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> standbyUplinks;

    /**
     * @return List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    public Output<List<String>> standbyUplinks() {
        return this.standbyUplinks;
    }
    /**
     * A list of tag IDs to apply to this object.
     * 
     */
    @Export(name="tags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return A list of tag IDs to apply to this object.
     * 
     */
    public Output<Optional<List<String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
     * failover_explicit, or loadbalance_loadbased.
     * 
     */
    @Export(name="teamingPolicy", refs={String.class}, tree="[0]")
    private Output<String> teamingPolicy;

    /**
     * @return The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
     * failover_explicit, or loadbalance_loadbased.
     * 
     */
    public Output<String> teamingPolicy() {
        return this.teamingPolicy;
    }
    /**
     * Allow any traffic filters on
     * this port group to be overridden on an individual port.
     * 
     */
    @Export(name="trafficFilterOverrideAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> trafficFilterOverrideAllowed;

    /**
     * @return Allow any traffic filters on
     * this port group to be overridden on an individual port.
     * 
     */
    public Output<Optional<Boolean>> trafficFilterOverrideAllowed() {
        return Codegen.optional(this.trafficFilterOverrideAllowed);
    }
    /**
     * If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
     * forwarded done by the switch.
     * 
     */
    @Export(name="txUplink", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> txUplink;

    /**
     * @return If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
     * forwarded done by the switch.
     * 
     */
    public Output<Boolean> txUplink() {
        return this.txUplink;
    }
    /**
     * The port group type. Can be one of `earlyBinding` (static
     * binding) or `ephemeral`. Default: `earlyBinding`.
     * 
     */
    @Export(name="type", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> type;

    /**
     * @return The port group type. Can be one of `earlyBinding` (static
     * binding) or `ephemeral`. Default: `earlyBinding`.
     * 
     */
    public Output<Optional<String>> type() {
        return Codegen.optional(this.type);
    }
    /**
     * Allow the
     * [uplink teaming options][uplink-teaming-settings] on this port group to be
     * overridden on an individual port.
     * 
     */
    @Export(name="uplinkTeamingOverrideAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> uplinkTeamingOverrideAllowed;

    /**
     * @return Allow the
     * [uplink teaming options][uplink-teaming-settings] on this port group to be
     * overridden on an individual port.
     * 
     */
    public Output<Optional<Boolean>> uplinkTeamingOverrideAllowed() {
        return Codegen.optional(this.uplinkTeamingOverrideAllowed);
    }
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    @Export(name="vlanId", refs={Integer.class}, tree="[0]")
    private Output<Integer> vlanId;

    /**
     * @return The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    public Output<Integer> vlanId() {
        return this.vlanId;
    }
    /**
     * Allow the
     * [VLAN settings][vlan-settings] on this port group to be overridden on an
     * individual port.
     * 
     */
    @Export(name="vlanOverrideAllowed", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vlanOverrideAllowed;

    /**
     * @return Allow the
     * [VLAN settings][vlan-settings] on this port group to be overridden on an
     * individual port.
     * 
     */
    public Output<Optional<Boolean>> vlanOverrideAllowed() {
        return Codegen.optional(this.vlanOverrideAllowed);
    }
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    @Export(name="vlanRanges", refs={List.class,DistributedPortGroupVlanRange.class}, tree="[0,1]")
    private Output<List<DistributedPortGroupVlanRange>> vlanRanges;

    /**
     * @return The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    public Output<List<DistributedPortGroupVlanRange>> vlanRanges() {
        return this.vlanRanges;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public DistributedPortGroup(String name) {
        this(name, DistributedPortGroupArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public DistributedPortGroup(String name, DistributedPortGroupArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public DistributedPortGroup(String name, DistributedPortGroupArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/distributedPortGroup:DistributedPortGroup", name, args == null ? DistributedPortGroupArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private DistributedPortGroup(String name, Output<String> id, @Nullable DistributedPortGroupState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/distributedPortGroup:DistributedPortGroup", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static DistributedPortGroup get(String name, Output<String> id, @Nullable DistributedPortGroupState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new DistributedPortGroup(name, id, state, options);
    }
}
