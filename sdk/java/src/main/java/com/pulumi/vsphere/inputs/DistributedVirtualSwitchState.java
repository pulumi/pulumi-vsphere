// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.vsphere.inputs.DistributedVirtualSwitchHostArgs;
import com.pulumi.vsphere.inputs.DistributedVirtualSwitchPvlanMappingArgs;
import com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DistributedVirtualSwitchState extends com.pulumi.resources.ResourceArgs {

    public static final DistributedVirtualSwitchState Empty = new DistributedVirtualSwitchState();

    /**
     * A list of active uplinks to be used in load
     * balancing. These uplinks need to match the definitions in the
     * `uplinks` VDS argument. See
     * here for more details.
     * 
     */
    @Import(name="activeUplinks")
    private @Nullable Output<List<String>> activeUplinks;

    /**
     * @return A list of active uplinks to be used in load
     * balancing. These uplinks need to match the definitions in the
     * `uplinks` VDS argument. See
     * here for more details.
     * 
     */
    public Optional<Output<List<String>>> activeUplinks() {
        return Optional.ofNullable(this.activeUplinks);
    }

    /**
     * Controls whether or not a virtual
     * network adapter is allowed to send network traffic with a different MAC
     * address than that of its own.
     * 
     */
    @Import(name="allowForgedTransmits")
    private @Nullable Output<Boolean> allowForgedTransmits;

    /**
     * @return Controls whether or not a virtual
     * network adapter is allowed to send network traffic with a different MAC
     * address than that of its own.
     * 
     */
    public Optional<Output<Boolean>> allowForgedTransmits() {
        return Optional.ofNullable(this.allowForgedTransmits);
    }

    /**
     * Controls whether or not the Media Access
     * Control (MAC) address can be changed.
     * 
     */
    @Import(name="allowMacChanges")
    private @Nullable Output<Boolean> allowMacChanges;

    /**
     * @return Controls whether or not the Media Access
     * Control (MAC) address can be changed.
     * 
     */
    public Optional<Output<Boolean>> allowMacChanges() {
        return Optional.ofNullable(this.allowMacChanges);
    }

    /**
     * Enable promiscuous mode on the network. This
     * flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    @Import(name="allowPromiscuous")
    private @Nullable Output<Boolean> allowPromiscuous;

    /**
     * @return Enable promiscuous mode on the network. This
     * flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    public Optional<Output<Boolean>> allowPromiscuous() {
        return Optional.ofNullable(this.allowPromiscuous);
    }

    /**
     * The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    @Import(name="backupnfcMaximumMbit")
    private @Nullable Output<Integer> backupnfcMaximumMbit;

    /**
     * @return The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> backupnfcMaximumMbit() {
        return Optional.ofNullable(this.backupnfcMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    @Import(name="backupnfcReservationMbit")
    private @Nullable Output<Integer> backupnfcReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> backupnfcReservationMbit() {
        return Optional.ofNullable(this.backupnfcReservationMbit);
    }

    /**
     * The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     * 
     */
    @Import(name="backupnfcShareCount")
    private @Nullable Output<Integer> backupnfcShareCount;

    /**
     * @return The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> backupnfcShareCount() {
        return Optional.ofNullable(this.backupnfcShareCount);
    }

    /**
     * The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="backupnfcShareLevel")
    private @Nullable Output<String> backupnfcShareLevel;

    /**
     * @return The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> backupnfcShareLevel() {
        return Optional.ofNullable(this.backupnfcShareLevel);
    }

    /**
     * Shuts down all ports in the port groups that
     * this policy applies to, effectively blocking all network access to connected
     * virtual devices.
     * 
     */
    @Import(name="blockAllPorts")
    private @Nullable Output<Boolean> blockAllPorts;

    /**
     * @return Shuts down all ports in the port groups that
     * this policy applies to, effectively blocking all network access to connected
     * virtual devices.
     * 
     */
    public Optional<Output<Boolean>> blockAllPorts() {
        return Optional.ofNullable(this.blockAllPorts);
    }

    /**
     * Enables beacon probing as an additional measure
     * to detect NIC failure.
     * 
     * &gt; **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon
     * probing.
     * 
     */
    @Import(name="checkBeacon")
    private @Nullable Output<Boolean> checkBeacon;

    /**
     * @return Enables beacon probing as an additional measure
     * to detect NIC failure.
     * 
     * &gt; **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon
     * probing.
     * 
     */
    public Optional<Output<Boolean>> checkBeacon() {
        return Optional.ofNullable(this.checkBeacon);
    }

    /**
     * The current version of the VDS configuration, incremented
     * by subsequent updates to the VDS.
     * 
     */
    @Import(name="configVersion")
    private @Nullable Output<String> configVersion;

    /**
     * @return The current version of the VDS configuration, incremented
     * by subsequent updates to the VDS.
     * 
     */
    public Optional<Output<String>> configVersion() {
        return Optional.ofNullable(this.configVersion);
    }

    /**
     * The detailed contact information for the person
     * who is responsible for the VDS.
     * 
     */
    @Import(name="contactDetail")
    private @Nullable Output<String> contactDetail;

    /**
     * @return The detailed contact information for the person
     * who is responsible for the VDS.
     * 
     */
    public Optional<Output<String>> contactDetail() {
        return Optional.ofNullable(this.contactDetail);
    }

    /**
     * The name of the person who is responsible for the
     * VDS.
     * 
     */
    @Import(name="contactName")
    private @Nullable Output<String> contactName;

    /**
     * @return The name of the person who is responsible for the
     * VDS.
     * 
     */
    public Optional<Output<String>> contactName() {
        return Optional.ofNullable(this.contactName);
    }

    /**
     * Map of custom attribute ids to attribute
     * value strings to set for VDS.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
     * and requires vCenter Server.
     * 
     */
    @Import(name="customAttributes")
    private @Nullable Output<Map<String,String>> customAttributes;

    /**
     * @return Map of custom attribute ids to attribute
     * value strings to set for VDS.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
     * and requires vCenter Server.
     * 
     */
    public Optional<Output<Map<String,String>>> customAttributes() {
        return Optional.ofNullable(this.customAttributes);
    }

    /**
     * The ID of the datacenter where the VDS will be
     * created. Forces a new resource if changed.
     * 
     */
    @Import(name="datacenterId")
    private @Nullable Output<String> datacenterId;

    /**
     * @return The ID of the datacenter where the VDS will be
     * created. Forces a new resource if changed.
     * 
     */
    public Optional<Output<String>> datacenterId() {
        return Optional.ofNullable(this.datacenterId);
    }

    /**
     * A detailed description for the VDS.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return A detailed description for the VDS.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Allow VMDirectPath Gen2 for the ports
     * for which this policy applies to.
     * 
     */
    @Import(name="directpathGen2Allowed")
    private @Nullable Output<Boolean> directpathGen2Allowed;

    /**
     * @return Allow VMDirectPath Gen2 for the ports
     * for which this policy applies to.
     * 
     */
    public Optional<Output<Boolean>> directpathGen2Allowed() {
        return Optional.ofNullable(this.directpathGen2Allowed);
    }

    /**
     * The average bandwidth in bits
     * per second if egress traffic shaping is enabled on the port.
     * 
     */
    @Import(name="egressShapingAverageBandwidth")
    private @Nullable Output<Integer> egressShapingAverageBandwidth;

    /**
     * @return The average bandwidth in bits
     * per second if egress traffic shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> egressShapingAverageBandwidth() {
        return Optional.ofNullable(this.egressShapingAverageBandwidth);
    }

    /**
     * The maximum burst size allowed in
     * bytes if egress traffic shaping is enabled on the port.
     * 
     */
    @Import(name="egressShapingBurstSize")
    private @Nullable Output<Integer> egressShapingBurstSize;

    /**
     * @return The maximum burst size allowed in
     * bytes if egress traffic shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> egressShapingBurstSize() {
        return Optional.ofNullable(this.egressShapingBurstSize);
    }

    /**
     * `true` if the traffic shaper is enabled
     * on the port for egress traffic.
     * 
     */
    @Import(name="egressShapingEnabled")
    private @Nullable Output<Boolean> egressShapingEnabled;

    /**
     * @return `true` if the traffic shaper is enabled
     * on the port for egress traffic.
     * 
     */
    public Optional<Output<Boolean>> egressShapingEnabled() {
        return Optional.ofNullable(this.egressShapingEnabled);
    }

    /**
     * The peak bandwidth during bursts
     * in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    @Import(name="egressShapingPeakBandwidth")
    private @Nullable Output<Integer> egressShapingPeakBandwidth;

    /**
     * @return The peak bandwidth during bursts
     * in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> egressShapingPeakBandwidth() {
        return Optional.ofNullable(this.egressShapingPeakBandwidth);
    }

    /**
     * If `true`, the teaming policy will re-activate failed
     * uplinks higher in precedence when they come back up.
     * 
     */
    @Import(name="failback")
    private @Nullable Output<Boolean> failback;

    /**
     * @return If `true`, the teaming policy will re-activate failed
     * uplinks higher in precedence when they come back up.
     * 
     */
    public Optional<Output<Boolean>> failback() {
        return Optional.ofNullable(this.failback);
    }

    /**
     * The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    @Import(name="faulttoleranceMaximumMbit")
    private @Nullable Output<Integer> faulttoleranceMaximumMbit;

    /**
     * @return The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> faulttoleranceMaximumMbit() {
        return Optional.ofNullable(this.faulttoleranceMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    @Import(name="faulttoleranceReservationMbit")
    private @Nullable Output<Integer> faulttoleranceReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> faulttoleranceReservationMbit() {
        return Optional.ofNullable(this.faulttoleranceReservationMbit);
    }

    /**
     * The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     * 
     */
    @Import(name="faulttoleranceShareCount")
    private @Nullable Output<Integer> faulttoleranceShareCount;

    /**
     * @return The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> faulttoleranceShareCount() {
        return Optional.ofNullable(this.faulttoleranceShareCount);
    }

    /**
     * The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="faulttoleranceShareLevel")
    private @Nullable Output<String> faulttoleranceShareLevel;

    /**
     * @return The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> faulttoleranceShareLevel() {
        return Optional.ofNullable(this.faulttoleranceShareLevel);
    }

    /**
     * The folder in which to create the VDS.
     * Forces a new resource if changed.
     * 
     */
    @Import(name="folder")
    private @Nullable Output<String> folder;

    /**
     * @return The folder in which to create the VDS.
     * Forces a new resource if changed.
     * 
     */
    public Optional<Output<String>> folder() {
        return Optional.ofNullable(this.folder);
    }

    /**
     * The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     * 
     */
    @Import(name="hbrMaximumMbit")
    private @Nullable Output<Integer> hbrMaximumMbit;

    /**
     * @return The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> hbrMaximumMbit() {
        return Optional.ofNullable(this.hbrMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     * 
     */
    @Import(name="hbrReservationMbit")
    private @Nullable Output<Integer> hbrReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> hbrReservationMbit() {
        return Optional.ofNullable(this.hbrReservationMbit);
    }

    /**
     * The amount of shares to allocate to the hbr traffic class for a custom share level.
     * 
     */
    @Import(name="hbrShareCount")
    private @Nullable Output<Integer> hbrShareCount;

    /**
     * @return The amount of shares to allocate to the hbr traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> hbrShareCount() {
        return Optional.ofNullable(this.hbrShareCount);
    }

    /**
     * The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="hbrShareLevel")
    private @Nullable Output<String> hbrShareLevel;

    /**
     * @return The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> hbrShareLevel() {
        return Optional.ofNullable(this.hbrShareLevel);
    }

    /**
     * Use the `host` block to declare a host specification. The
     * options are:
     * 
     */
    @Import(name="hosts")
    private @Nullable Output<List<DistributedVirtualSwitchHostArgs>> hosts;

    /**
     * @return Use the `host` block to declare a host specification. The
     * options are:
     * 
     */
    public Optional<Output<List<DistributedVirtualSwitchHostArgs>>> hosts() {
        return Optional.ofNullable(this.hosts);
    }

    /**
     * Whether to ignore existing PVLAN
     * mappings not managed by this resource. Defaults to false.
     * 
     */
    @Import(name="ignoreOtherPvlanMappings")
    private @Nullable Output<Boolean> ignoreOtherPvlanMappings;

    /**
     * @return Whether to ignore existing PVLAN
     * mappings not managed by this resource. Defaults to false.
     * 
     */
    public Optional<Output<Boolean>> ignoreOtherPvlanMappings() {
        return Optional.ofNullable(this.ignoreOtherPvlanMappings);
    }

    /**
     * The average bandwidth in
     * bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    @Import(name="ingressShapingAverageBandwidth")
    private @Nullable Output<Integer> ingressShapingAverageBandwidth;

    /**
     * @return The average bandwidth in
     * bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> ingressShapingAverageBandwidth() {
        return Optional.ofNullable(this.ingressShapingAverageBandwidth);
    }

    /**
     * The maximum burst size allowed in
     * bytes if ingress traffic shaping is enabled on the port.
     * 
     */
    @Import(name="ingressShapingBurstSize")
    private @Nullable Output<Integer> ingressShapingBurstSize;

    /**
     * @return The maximum burst size allowed in
     * bytes if ingress traffic shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> ingressShapingBurstSize() {
        return Optional.ofNullable(this.ingressShapingBurstSize);
    }

    /**
     * `true` if the traffic shaper is
     * enabled on the port for ingress traffic.
     * 
     */
    @Import(name="ingressShapingEnabled")
    private @Nullable Output<Boolean> ingressShapingEnabled;

    /**
     * @return `true` if the traffic shaper is
     * enabled on the port for ingress traffic.
     * 
     */
    public Optional<Output<Boolean>> ingressShapingEnabled() {
        return Optional.ofNullable(this.ingressShapingEnabled);
    }

    /**
     * The peak bandwidth during
     * bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    @Import(name="ingressShapingPeakBandwidth")
    private @Nullable Output<Integer> ingressShapingPeakBandwidth;

    /**
     * @return The peak bandwidth during
     * bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> ingressShapingPeakBandwidth() {
        return Optional.ofNullable(this.ingressShapingPeakBandwidth);
    }

    /**
     * An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments.
     * 
     */
    @Import(name="ipv4Address")
    private @Nullable Output<String> ipv4Address;

    /**
     * @return An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments.
     * 
     */
    public Optional<Output<String>> ipv4Address() {
        return Optional.ofNullable(this.ipv4Address);
    }

    /**
     * The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    @Import(name="iscsiMaximumMbit")
    private @Nullable Output<Integer> iscsiMaximumMbit;

    /**
     * @return The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> iscsiMaximumMbit() {
        return Optional.ofNullable(this.iscsiMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    @Import(name="iscsiReservationMbit")
    private @Nullable Output<Integer> iscsiReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> iscsiReservationMbit() {
        return Optional.ofNullable(this.iscsiReservationMbit);
    }

    /**
     * The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     * 
     */
    @Import(name="iscsiShareCount")
    private @Nullable Output<Integer> iscsiShareCount;

    /**
     * @return The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> iscsiShareCount() {
        return Optional.ofNullable(this.iscsiShareCount);
    }

    /**
     * The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="iscsiShareLevel")
    private @Nullable Output<String> iscsiShareLevel;

    /**
     * @return The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> iscsiShareLevel() {
        return Optional.ofNullable(this.iscsiShareLevel);
    }

    /**
     * The Link Aggregation Control Protocol group
     * version to use with the VDS. Possible values are `singleLag` and
     * `multipleLag`.
     * 
     */
    @Import(name="lacpApiVersion")
    private @Nullable Output<String> lacpApiVersion;

    /**
     * @return The Link Aggregation Control Protocol group
     * version to use with the VDS. Possible values are `singleLag` and
     * `multipleLag`.
     * 
     */
    public Optional<Output<String>> lacpApiVersion() {
        return Optional.ofNullable(this.lacpApiVersion);
    }

    /**
     * Enables LACP for the ports that this policy
     * applies to.
     * 
     */
    @Import(name="lacpEnabled")
    private @Nullable Output<Boolean> lacpEnabled;

    /**
     * @return Enables LACP for the ports that this policy
     * applies to.
     * 
     */
    public Optional<Output<Boolean>> lacpEnabled() {
        return Optional.ofNullable(this.lacpEnabled);
    }

    /**
     * The LACP mode. Can be one of `active` or `passive`.
     * 
     */
    @Import(name="lacpMode")
    private @Nullable Output<String> lacpMode;

    /**
     * @return The LACP mode. Can be one of `active` or `passive`.
     * 
     */
    public Optional<Output<String>> lacpMode() {
        return Optional.ofNullable(this.lacpMode);
    }

    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic.
     * 
     */
    @Import(name="linkDiscoveryOperation")
    private @Nullable Output<String> linkDiscoveryOperation;

    /**
     * @return Whether to `advertise` or `listen`
     * for link discovery traffic.
     * 
     */
    public Optional<Output<String>> linkDiscoveryOperation() {
        return Optional.ofNullable(this.linkDiscoveryOperation);
    }

    /**
     * The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     * 
     */
    @Import(name="linkDiscoveryProtocol")
    private @Nullable Output<String> linkDiscoveryProtocol;

    /**
     * @return The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     * 
     */
    public Optional<Output<String>> linkDiscoveryProtocol() {
        return Optional.ofNullable(this.linkDiscoveryProtocol);
    }

    /**
     * The maximum allowed usage for the management traffic class, in Mbits/sec.
     * 
     */
    @Import(name="managementMaximumMbit")
    private @Nullable Output<Integer> managementMaximumMbit;

    /**
     * @return The maximum allowed usage for the management traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> managementMaximumMbit() {
        return Optional.ofNullable(this.managementMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     * 
     */
    @Import(name="managementReservationMbit")
    private @Nullable Output<Integer> managementReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> managementReservationMbit() {
        return Optional.ofNullable(this.managementReservationMbit);
    }

    /**
     * The amount of shares to allocate to the management traffic class for a custom share level.
     * 
     */
    @Import(name="managementShareCount")
    private @Nullable Output<Integer> managementShareCount;

    /**
     * @return The amount of shares to allocate to the management traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> managementShareCount() {
        return Optional.ofNullable(this.managementShareCount);
    }

    /**
     * The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="managementShareLevel")
    private @Nullable Output<String> managementShareLevel;

    /**
     * @return The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> managementShareLevel() {
        return Optional.ofNullable(this.managementShareLevel);
    }

    /**
     * The maximum transmission unit (MTU) for the VDS.
     * 
     */
    @Import(name="maxMtu")
    private @Nullable Output<Integer> maxMtu;

    /**
     * @return The maximum transmission unit (MTU) for the VDS.
     * 
     */
    public Optional<Output<Integer>> maxMtu() {
        return Optional.ofNullable(this.maxMtu);
    }

    /**
     * The multicast filtering mode to use
     * with the VDS. Can be one of `legacyFiltering` or `snooping`.
     * 
     */
    @Import(name="multicastFilteringMode")
    private @Nullable Output<String> multicastFilteringMode;

    /**
     * @return The multicast filtering mode to use
     * with the VDS. Can be one of `legacyFiltering` or `snooping`.
     * 
     */
    public Optional<Output<String>> multicastFilteringMode() {
        return Optional.ofNullable(this.multicastFilteringMode);
    }

    /**
     * The name of the VDS.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the VDS.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The number of seconds after which
     * active flows are forced to be exported to the collector. Allowed range is
     * `60` to `3600`. Default: `60`.
     * 
     */
    @Import(name="netflowActiveFlowTimeout")
    private @Nullable Output<Integer> netflowActiveFlowTimeout;

    /**
     * @return The number of seconds after which
     * active flows are forced to be exported to the collector. Allowed range is
     * `60` to `3600`. Default: `60`.
     * 
     */
    public Optional<Output<Integer>> netflowActiveFlowTimeout() {
        return Optional.ofNullable(this.netflowActiveFlowTimeout);
    }

    /**
     * IP address for the Netflow
     * collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
     * Must be set before Netflow can be enabled.
     * 
     */
    @Import(name="netflowCollectorIpAddress")
    private @Nullable Output<String> netflowCollectorIpAddress;

    /**
     * @return IP address for the Netflow
     * collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
     * Must be set before Netflow can be enabled.
     * 
     */
    public Optional<Output<String>> netflowCollectorIpAddress() {
        return Optional.ofNullable(this.netflowCollectorIpAddress);
    }

    /**
     * Port for the Netflow collector. This
     * must be set before Netflow can be enabled.
     * 
     */
    @Import(name="netflowCollectorPort")
    private @Nullable Output<Integer> netflowCollectorPort;

    /**
     * @return Port for the Netflow collector. This
     * must be set before Netflow can be enabled.
     * 
     */
    public Optional<Output<Integer>> netflowCollectorPort() {
        return Optional.ofNullable(this.netflowCollectorPort);
    }

    /**
     * Enables Netflow on all ports that this policy
     * applies to.
     * 
     */
    @Import(name="netflowEnabled")
    private @Nullable Output<Boolean> netflowEnabled;

    /**
     * @return Enables Netflow on all ports that this policy
     * applies to.
     * 
     */
    public Optional<Output<Boolean>> netflowEnabled() {
        return Optional.ofNullable(this.netflowEnabled);
    }

    /**
     * The number of seconds after which
     * idle flows are forced to be exported to the collector. Allowed range is `10`
     * to `600`. Default: `15`.
     * 
     */
    @Import(name="netflowIdleFlowTimeout")
    private @Nullable Output<Integer> netflowIdleFlowTimeout;

    /**
     * @return The number of seconds after which
     * idle flows are forced to be exported to the collector. Allowed range is `10`
     * to `600`. Default: `15`.
     * 
     */
    public Optional<Output<Integer>> netflowIdleFlowTimeout() {
        return Optional.ofNullable(this.netflowIdleFlowTimeout);
    }

    /**
     * Whether to limit analysis to
     * traffic that has both source and destination served by the same host.
     * Default: `false`.
     * 
     */
    @Import(name="netflowInternalFlowsOnly")
    private @Nullable Output<Boolean> netflowInternalFlowsOnly;

    /**
     * @return Whether to limit analysis to
     * traffic that has both source and destination served by the same host.
     * Default: `false`.
     * 
     */
    public Optional<Output<Boolean>> netflowInternalFlowsOnly() {
        return Optional.ofNullable(this.netflowInternalFlowsOnly);
    }

    /**
     * The observation domain ID for
     * the Netflow collector.
     * 
     */
    @Import(name="netflowObservationDomainId")
    private @Nullable Output<Integer> netflowObservationDomainId;

    /**
     * @return The observation domain ID for
     * the Netflow collector.
     * 
     */
    public Optional<Output<Integer>> netflowObservationDomainId() {
        return Optional.ofNullable(this.netflowObservationDomainId);
    }

    /**
     * The ratio of total number of packets to
     * the number of packets analyzed. The default is `0`, which indicates that the
     * VDS should analyze all packets. The maximum value is `1000`, which
     * indicates an analysis rate of 0.001%.
     * 
     */
    @Import(name="netflowSamplingRate")
    private @Nullable Output<Integer> netflowSamplingRate;

    /**
     * @return The ratio of total number of packets to
     * the number of packets analyzed. The default is `0`, which indicates that the
     * VDS should analyze all packets. The maximum value is `1000`, which
     * indicates an analysis rate of 0.001%.
     * 
     */
    public Optional<Output<Integer>> netflowSamplingRate() {
        return Optional.ofNullable(this.netflowSamplingRate);
    }

    /**
     * Set to `true` to enable
     * network I/O control. Default: `false`.
     * 
     */
    @Import(name="networkResourceControlEnabled")
    private @Nullable Output<Boolean> networkResourceControlEnabled;

    /**
     * @return Set to `true` to enable
     * network I/O control. Default: `false`.
     * 
     */
    public Optional<Output<Boolean>> networkResourceControlEnabled() {
        return Optional.ofNullable(this.networkResourceControlEnabled);
    }

    /**
     * The version of network I/O
     * control to use. Can be one of `version2` or `version3`. Default: `version2`.
     * 
     */
    @Import(name="networkResourceControlVersion")
    private @Nullable Output<String> networkResourceControlVersion;

    /**
     * @return The version of network I/O
     * control to use. Can be one of `version2` or `version3`. Default: `version2`.
     * 
     */
    public Optional<Output<String>> networkResourceControlVersion() {
        return Optional.ofNullable(this.networkResourceControlVersion);
    }

    /**
     * The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     * 
     */
    @Import(name="nfsMaximumMbit")
    private @Nullable Output<Integer> nfsMaximumMbit;

    /**
     * @return The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> nfsMaximumMbit() {
        return Optional.ofNullable(this.nfsMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     * 
     */
    @Import(name="nfsReservationMbit")
    private @Nullable Output<Integer> nfsReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> nfsReservationMbit() {
        return Optional.ofNullable(this.nfsReservationMbit);
    }

    /**
     * The amount of shares to allocate to the nfs traffic class for a custom share level.
     * 
     */
    @Import(name="nfsShareCount")
    private @Nullable Output<Integer> nfsShareCount;

    /**
     * @return The amount of shares to allocate to the nfs traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> nfsShareCount() {
        return Optional.ofNullable(this.nfsShareCount);
    }

    /**
     * The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="nfsShareLevel")
    private @Nullable Output<String> nfsShareLevel;

    /**
     * @return The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> nfsShareLevel() {
        return Optional.ofNullable(this.nfsShareLevel);
    }

    /**
     * If `true`, the teaming policy will notify the
     * broadcast network of an uplink failover, triggering cache updates.
     * 
     */
    @Import(name="notifySwitches")
    private @Nullable Output<Boolean> notifySwitches;

    /**
     * @return If `true`, the teaming policy will notify the
     * broadcast network of an uplink failover, triggering cache updates.
     * 
     */
    public Optional<Output<Boolean>> notifySwitches() {
        return Optional.ofNullable(this.notifySwitches);
    }

    /**
     * Used to define a secondary VLAN
     * ID when using private VLANs.
     * 
     */
    @Import(name="portPrivateSecondaryVlanId")
    private @Nullable Output<Integer> portPrivateSecondaryVlanId;

    /**
     * @return Used to define a secondary VLAN
     * ID when using private VLANs.
     * 
     */
    public Optional<Output<Integer>> portPrivateSecondaryVlanId() {
        return Optional.ofNullable(this.portPrivateSecondaryVlanId);
    }

    /**
     * Use the `pvlan_mapping` block to declare a
     * private VLAN mapping. The options are:
     * 
     */
    @Import(name="pvlanMappings")
    private @Nullable Output<List<DistributedVirtualSwitchPvlanMappingArgs>> pvlanMappings;

    /**
     * @return Use the `pvlan_mapping` block to declare a
     * private VLAN mapping. The options are:
     * 
     */
    public Optional<Output<List<DistributedVirtualSwitchPvlanMappingArgs>>> pvlanMappings() {
        return Optional.ofNullable(this.pvlanMappings);
    }

    /**
     * A list of standby uplinks to be used in
     * failover. These uplinks need to match the definitions in the
     * `uplinks` VDS argument. See
     * here for more details.
     * 
     */
    @Import(name="standbyUplinks")
    private @Nullable Output<List<String>> standbyUplinks;

    /**
     * @return A list of standby uplinks to be used in
     * failover. These uplinks need to match the definitions in the
     * `uplinks` VDS argument. See
     * here for more details.
     * 
     */
    public Optional<Output<List<String>>> standbyUplinks() {
        return Optional.ofNullable(this.standbyUplinks);
    }

    /**
     * The IDs of any tags to attach to this resource.
     * 
     * &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return The IDs of any tags to attach to this resource.
     * 
     * &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * The uplink teaming policy. Can be one of
     * `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,
     * `failover_explicit`, or `loadbalance_loadbased`.
     * 
     */
    @Import(name="teamingPolicy")
    private @Nullable Output<String> teamingPolicy;

    /**
     * @return The uplink teaming policy. Can be one of
     * `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,
     * `failover_explicit`, or `loadbalance_loadbased`.
     * 
     */
    public Optional<Output<String>> teamingPolicy() {
        return Optional.ofNullable(this.teamingPolicy);
    }

    /**
     * Forward all traffic transmitted by ports for which
     * this policy applies to its VDS uplinks.
     * 
     */
    @Import(name="txUplink")
    private @Nullable Output<Boolean> txUplink;

    /**
     * @return Forward all traffic transmitted by ports for which
     * this policy applies to its VDS uplinks.
     * 
     */
    public Optional<Output<Boolean>> txUplink() {
        return Optional.ofNullable(this.txUplink);
    }

    /**
     * A list of strings that uniquely identifies the names
     * of the uplinks on the VDS across hosts. The number of items in this list
     * controls the number of uplinks that exist on the VDS, in addition to the
     * names. See here for an example on how to
     * use this option.
     * 
     */
    @Import(name="uplinks")
    private @Nullable Output<List<String>> uplinks;

    /**
     * @return A list of strings that uniquely identifies the names
     * of the uplinks on the VDS across hosts. The number of items in this list
     * controls the number of uplinks that exist on the VDS, in addition to the
     * names. See here for an example on how to
     * use this option.
     * 
     */
    public Optional<Output<List<String>>> uplinks() {
        return Optional.ofNullable(this.uplinks);
    }

    /**
     * The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     * 
     */
    @Import(name="vdpMaximumMbit")
    private @Nullable Output<Integer> vdpMaximumMbit;

    /**
     * @return The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> vdpMaximumMbit() {
        return Optional.ofNullable(this.vdpMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     * 
     */
    @Import(name="vdpReservationMbit")
    private @Nullable Output<Integer> vdpReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> vdpReservationMbit() {
        return Optional.ofNullable(this.vdpReservationMbit);
    }

    /**
     * The amount of shares to allocate to the vdp traffic class for a custom share level.
     * 
     */
    @Import(name="vdpShareCount")
    private @Nullable Output<Integer> vdpShareCount;

    /**
     * @return The amount of shares to allocate to the vdp traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> vdpShareCount() {
        return Optional.ofNullable(this.vdpShareCount);
    }

    /**
     * The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="vdpShareLevel")
    private @Nullable Output<String> vdpShareLevel;

    /**
     * @return The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> vdpShareLevel() {
        return Optional.ofNullable(this.vdpShareLevel);
    }

    /**
     * The version of the VDS. BY default, a VDS is created
     * at the latest version supported by the vSphere version if not specified.
     * A VDS can be upgraded to a newer version, but can not be downgraded.
     * 
     */
    @Import(name="version")
    private @Nullable Output<String> version;

    /**
     * @return The version of the VDS. BY default, a VDS is created
     * at the latest version supported by the vSphere version if not specified.
     * A VDS can be upgraded to a newer version, but can not be downgraded.
     * 
     */
    public Optional<Output<String>> version() {
        return Optional.ofNullable(this.version);
    }

    /**
     * The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    @Import(name="virtualmachineMaximumMbit")
    private @Nullable Output<Integer> virtualmachineMaximumMbit;

    /**
     * @return The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> virtualmachineMaximumMbit() {
        return Optional.ofNullable(this.virtualmachineMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    @Import(name="virtualmachineReservationMbit")
    private @Nullable Output<Integer> virtualmachineReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> virtualmachineReservationMbit() {
        return Optional.ofNullable(this.virtualmachineReservationMbit);
    }

    /**
     * The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     * 
     */
    @Import(name="virtualmachineShareCount")
    private @Nullable Output<Integer> virtualmachineShareCount;

    /**
     * @return The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> virtualmachineShareCount() {
        return Optional.ofNullable(this.virtualmachineShareCount);
    }

    /**
     * The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="virtualmachineShareLevel")
    private @Nullable Output<String> virtualmachineShareLevel;

    /**
     * @return The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> virtualmachineShareLevel() {
        return Optional.ofNullable(this.virtualmachineShareLevel);
    }

    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    @Import(name="vlanId")
    private @Nullable Output<Integer> vlanId;

    /**
     * @return The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    public Optional<Output<Integer>> vlanId() {
        return Optional.ofNullable(this.vlanId);
    }

    /**
     * Used to denote VLAN trunking. Use the `min_vlan`
     * and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
     * `vlan_range` definitions are allowed, but they must not overlap. Example
     * below:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vsphere.DistributedVirtualSwitch;
     * import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
     * import com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var vds = new DistributedVirtualSwitch(&#34;vds&#34;, DistributedVirtualSwitchArgs.builder()        
     *             .vlanRanges(            
     *                 DistributedVirtualSwitchVlanRangeArgs.builder()
     *                     .maxVlan(199)
     *                     .minVlan(100)
     *                     .build(),
     *                 DistributedVirtualSwitchVlanRangeArgs.builder()
     *                     .maxVlan(399)
     *                     .minVlan(300)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    @Import(name="vlanRanges")
    private @Nullable Output<List<DistributedVirtualSwitchVlanRangeArgs>> vlanRanges;

    /**
     * @return Used to denote VLAN trunking. Use the `min_vlan`
     * and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
     * `vlan_range` definitions are allowed, but they must not overlap. Example
     * below:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vsphere.DistributedVirtualSwitch;
     * import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
     * import com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var vds = new DistributedVirtualSwitch(&#34;vds&#34;, DistributedVirtualSwitchArgs.builder()        
     *             .vlanRanges(            
     *                 DistributedVirtualSwitchVlanRangeArgs.builder()
     *                     .maxVlan(199)
     *                     .minVlan(100)
     *                     .build(),
     *                 DistributedVirtualSwitchVlanRangeArgs.builder()
     *                     .maxVlan(399)
     *                     .minVlan(300)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public Optional<Output<List<DistributedVirtualSwitchVlanRangeArgs>>> vlanRanges() {
        return Optional.ofNullable(this.vlanRanges);
    }

    /**
     * The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     * 
     */
    @Import(name="vmotionMaximumMbit")
    private @Nullable Output<Integer> vmotionMaximumMbit;

    /**
     * @return The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> vmotionMaximumMbit() {
        return Optional.ofNullable(this.vmotionMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     * 
     */
    @Import(name="vmotionReservationMbit")
    private @Nullable Output<Integer> vmotionReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> vmotionReservationMbit() {
        return Optional.ofNullable(this.vmotionReservationMbit);
    }

    /**
     * The amount of shares to allocate to the vmotion traffic class for a custom share level.
     * 
     */
    @Import(name="vmotionShareCount")
    private @Nullable Output<Integer> vmotionShareCount;

    /**
     * @return The amount of shares to allocate to the vmotion traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> vmotionShareCount() {
        return Optional.ofNullable(this.vmotionShareCount);
    }

    /**
     * The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="vmotionShareLevel")
    private @Nullable Output<String> vmotionShareLevel;

    /**
     * @return The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> vmotionShareLevel() {
        return Optional.ofNullable(this.vmotionShareLevel);
    }

    /**
     * The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     * 
     */
    @Import(name="vsanMaximumMbit")
    private @Nullable Output<Integer> vsanMaximumMbit;

    /**
     * @return The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> vsanMaximumMbit() {
        return Optional.ofNullable(this.vsanMaximumMbit);
    }

    /**
     * The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     * 
     */
    @Import(name="vsanReservationMbit")
    private @Nullable Output<Integer> vsanReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     * 
     */
    public Optional<Output<Integer>> vsanReservationMbit() {
        return Optional.ofNullable(this.vsanReservationMbit);
    }

    /**
     * The amount of shares to allocate to the vsan traffic class for a custom share level.
     * 
     */
    @Import(name="vsanShareCount")
    private @Nullable Output<Integer> vsanShareCount;

    /**
     * @return The amount of shares to allocate to the vsan traffic class for a custom share level.
     * 
     */
    public Optional<Output<Integer>> vsanShareCount() {
        return Optional.ofNullable(this.vsanShareCount);
    }

    /**
     * The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="vsanShareLevel")
    private @Nullable Output<String> vsanShareLevel;

    /**
     * @return The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> vsanShareLevel() {
        return Optional.ofNullable(this.vsanShareLevel);
    }

    private DistributedVirtualSwitchState() {}

    private DistributedVirtualSwitchState(DistributedVirtualSwitchState $) {
        this.activeUplinks = $.activeUplinks;
        this.allowForgedTransmits = $.allowForgedTransmits;
        this.allowMacChanges = $.allowMacChanges;
        this.allowPromiscuous = $.allowPromiscuous;
        this.backupnfcMaximumMbit = $.backupnfcMaximumMbit;
        this.backupnfcReservationMbit = $.backupnfcReservationMbit;
        this.backupnfcShareCount = $.backupnfcShareCount;
        this.backupnfcShareLevel = $.backupnfcShareLevel;
        this.blockAllPorts = $.blockAllPorts;
        this.checkBeacon = $.checkBeacon;
        this.configVersion = $.configVersion;
        this.contactDetail = $.contactDetail;
        this.contactName = $.contactName;
        this.customAttributes = $.customAttributes;
        this.datacenterId = $.datacenterId;
        this.description = $.description;
        this.directpathGen2Allowed = $.directpathGen2Allowed;
        this.egressShapingAverageBandwidth = $.egressShapingAverageBandwidth;
        this.egressShapingBurstSize = $.egressShapingBurstSize;
        this.egressShapingEnabled = $.egressShapingEnabled;
        this.egressShapingPeakBandwidth = $.egressShapingPeakBandwidth;
        this.failback = $.failback;
        this.faulttoleranceMaximumMbit = $.faulttoleranceMaximumMbit;
        this.faulttoleranceReservationMbit = $.faulttoleranceReservationMbit;
        this.faulttoleranceShareCount = $.faulttoleranceShareCount;
        this.faulttoleranceShareLevel = $.faulttoleranceShareLevel;
        this.folder = $.folder;
        this.hbrMaximumMbit = $.hbrMaximumMbit;
        this.hbrReservationMbit = $.hbrReservationMbit;
        this.hbrShareCount = $.hbrShareCount;
        this.hbrShareLevel = $.hbrShareLevel;
        this.hosts = $.hosts;
        this.ignoreOtherPvlanMappings = $.ignoreOtherPvlanMappings;
        this.ingressShapingAverageBandwidth = $.ingressShapingAverageBandwidth;
        this.ingressShapingBurstSize = $.ingressShapingBurstSize;
        this.ingressShapingEnabled = $.ingressShapingEnabled;
        this.ingressShapingPeakBandwidth = $.ingressShapingPeakBandwidth;
        this.ipv4Address = $.ipv4Address;
        this.iscsiMaximumMbit = $.iscsiMaximumMbit;
        this.iscsiReservationMbit = $.iscsiReservationMbit;
        this.iscsiShareCount = $.iscsiShareCount;
        this.iscsiShareLevel = $.iscsiShareLevel;
        this.lacpApiVersion = $.lacpApiVersion;
        this.lacpEnabled = $.lacpEnabled;
        this.lacpMode = $.lacpMode;
        this.linkDiscoveryOperation = $.linkDiscoveryOperation;
        this.linkDiscoveryProtocol = $.linkDiscoveryProtocol;
        this.managementMaximumMbit = $.managementMaximumMbit;
        this.managementReservationMbit = $.managementReservationMbit;
        this.managementShareCount = $.managementShareCount;
        this.managementShareLevel = $.managementShareLevel;
        this.maxMtu = $.maxMtu;
        this.multicastFilteringMode = $.multicastFilteringMode;
        this.name = $.name;
        this.netflowActiveFlowTimeout = $.netflowActiveFlowTimeout;
        this.netflowCollectorIpAddress = $.netflowCollectorIpAddress;
        this.netflowCollectorPort = $.netflowCollectorPort;
        this.netflowEnabled = $.netflowEnabled;
        this.netflowIdleFlowTimeout = $.netflowIdleFlowTimeout;
        this.netflowInternalFlowsOnly = $.netflowInternalFlowsOnly;
        this.netflowObservationDomainId = $.netflowObservationDomainId;
        this.netflowSamplingRate = $.netflowSamplingRate;
        this.networkResourceControlEnabled = $.networkResourceControlEnabled;
        this.networkResourceControlVersion = $.networkResourceControlVersion;
        this.nfsMaximumMbit = $.nfsMaximumMbit;
        this.nfsReservationMbit = $.nfsReservationMbit;
        this.nfsShareCount = $.nfsShareCount;
        this.nfsShareLevel = $.nfsShareLevel;
        this.notifySwitches = $.notifySwitches;
        this.portPrivateSecondaryVlanId = $.portPrivateSecondaryVlanId;
        this.pvlanMappings = $.pvlanMappings;
        this.standbyUplinks = $.standbyUplinks;
        this.tags = $.tags;
        this.teamingPolicy = $.teamingPolicy;
        this.txUplink = $.txUplink;
        this.uplinks = $.uplinks;
        this.vdpMaximumMbit = $.vdpMaximumMbit;
        this.vdpReservationMbit = $.vdpReservationMbit;
        this.vdpShareCount = $.vdpShareCount;
        this.vdpShareLevel = $.vdpShareLevel;
        this.version = $.version;
        this.virtualmachineMaximumMbit = $.virtualmachineMaximumMbit;
        this.virtualmachineReservationMbit = $.virtualmachineReservationMbit;
        this.virtualmachineShareCount = $.virtualmachineShareCount;
        this.virtualmachineShareLevel = $.virtualmachineShareLevel;
        this.vlanId = $.vlanId;
        this.vlanRanges = $.vlanRanges;
        this.vmotionMaximumMbit = $.vmotionMaximumMbit;
        this.vmotionReservationMbit = $.vmotionReservationMbit;
        this.vmotionShareCount = $.vmotionShareCount;
        this.vmotionShareLevel = $.vmotionShareLevel;
        this.vsanMaximumMbit = $.vsanMaximumMbit;
        this.vsanReservationMbit = $.vsanReservationMbit;
        this.vsanShareCount = $.vsanShareCount;
        this.vsanShareLevel = $.vsanShareLevel;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DistributedVirtualSwitchState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DistributedVirtualSwitchState $;

        public Builder() {
            $ = new DistributedVirtualSwitchState();
        }

        public Builder(DistributedVirtualSwitchState defaults) {
            $ = new DistributedVirtualSwitchState(Objects.requireNonNull(defaults));
        }

        /**
         * @param activeUplinks A list of active uplinks to be used in load
         * balancing. These uplinks need to match the definitions in the
         * `uplinks` VDS argument. See
         * here for more details.
         * 
         * @return builder
         * 
         */
        public Builder activeUplinks(@Nullable Output<List<String>> activeUplinks) {
            $.activeUplinks = activeUplinks;
            return this;
        }

        /**
         * @param activeUplinks A list of active uplinks to be used in load
         * balancing. These uplinks need to match the definitions in the
         * `uplinks` VDS argument. See
         * here for more details.
         * 
         * @return builder
         * 
         */
        public Builder activeUplinks(List<String> activeUplinks) {
            return activeUplinks(Output.of(activeUplinks));
        }

        /**
         * @param activeUplinks A list of active uplinks to be used in load
         * balancing. These uplinks need to match the definitions in the
         * `uplinks` VDS argument. See
         * here for more details.
         * 
         * @return builder
         * 
         */
        public Builder activeUplinks(String... activeUplinks) {
            return activeUplinks(List.of(activeUplinks));
        }

        /**
         * @param allowForgedTransmits Controls whether or not a virtual
         * network adapter is allowed to send network traffic with a different MAC
         * address than that of its own.
         * 
         * @return builder
         * 
         */
        public Builder allowForgedTransmits(@Nullable Output<Boolean> allowForgedTransmits) {
            $.allowForgedTransmits = allowForgedTransmits;
            return this;
        }

        /**
         * @param allowForgedTransmits Controls whether or not a virtual
         * network adapter is allowed to send network traffic with a different MAC
         * address than that of its own.
         * 
         * @return builder
         * 
         */
        public Builder allowForgedTransmits(Boolean allowForgedTransmits) {
            return allowForgedTransmits(Output.of(allowForgedTransmits));
        }

        /**
         * @param allowMacChanges Controls whether or not the Media Access
         * Control (MAC) address can be changed.
         * 
         * @return builder
         * 
         */
        public Builder allowMacChanges(@Nullable Output<Boolean> allowMacChanges) {
            $.allowMacChanges = allowMacChanges;
            return this;
        }

        /**
         * @param allowMacChanges Controls whether or not the Media Access
         * Control (MAC) address can be changed.
         * 
         * @return builder
         * 
         */
        public Builder allowMacChanges(Boolean allowMacChanges) {
            return allowMacChanges(Output.of(allowMacChanges));
        }

        /**
         * @param allowPromiscuous Enable promiscuous mode on the network. This
         * flag indicates whether or not all traffic is seen on a given port.
         * 
         * @return builder
         * 
         */
        public Builder allowPromiscuous(@Nullable Output<Boolean> allowPromiscuous) {
            $.allowPromiscuous = allowPromiscuous;
            return this;
        }

        /**
         * @param allowPromiscuous Enable promiscuous mode on the network. This
         * flag indicates whether or not all traffic is seen on a given port.
         * 
         * @return builder
         * 
         */
        public Builder allowPromiscuous(Boolean allowPromiscuous) {
            return allowPromiscuous(Output.of(allowPromiscuous));
        }

        /**
         * @param backupnfcMaximumMbit The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder backupnfcMaximumMbit(@Nullable Output<Integer> backupnfcMaximumMbit) {
            $.backupnfcMaximumMbit = backupnfcMaximumMbit;
            return this;
        }

        /**
         * @param backupnfcMaximumMbit The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder backupnfcMaximumMbit(Integer backupnfcMaximumMbit) {
            return backupnfcMaximumMbit(Output.of(backupnfcMaximumMbit));
        }

        /**
         * @param backupnfcReservationMbit The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder backupnfcReservationMbit(@Nullable Output<Integer> backupnfcReservationMbit) {
            $.backupnfcReservationMbit = backupnfcReservationMbit;
            return this;
        }

        /**
         * @param backupnfcReservationMbit The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder backupnfcReservationMbit(Integer backupnfcReservationMbit) {
            return backupnfcReservationMbit(Output.of(backupnfcReservationMbit));
        }

        /**
         * @param backupnfcShareCount The amount of shares to allocate to the backupNfc traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder backupnfcShareCount(@Nullable Output<Integer> backupnfcShareCount) {
            $.backupnfcShareCount = backupnfcShareCount;
            return this;
        }

        /**
         * @param backupnfcShareCount The amount of shares to allocate to the backupNfc traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder backupnfcShareCount(Integer backupnfcShareCount) {
            return backupnfcShareCount(Output.of(backupnfcShareCount));
        }

        /**
         * @param backupnfcShareLevel The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder backupnfcShareLevel(@Nullable Output<String> backupnfcShareLevel) {
            $.backupnfcShareLevel = backupnfcShareLevel;
            return this;
        }

        /**
         * @param backupnfcShareLevel The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder backupnfcShareLevel(String backupnfcShareLevel) {
            return backupnfcShareLevel(Output.of(backupnfcShareLevel));
        }

        /**
         * @param blockAllPorts Shuts down all ports in the port groups that
         * this policy applies to, effectively blocking all network access to connected
         * virtual devices.
         * 
         * @return builder
         * 
         */
        public Builder blockAllPorts(@Nullable Output<Boolean> blockAllPorts) {
            $.blockAllPorts = blockAllPorts;
            return this;
        }

        /**
         * @param blockAllPorts Shuts down all ports in the port groups that
         * this policy applies to, effectively blocking all network access to connected
         * virtual devices.
         * 
         * @return builder
         * 
         */
        public Builder blockAllPorts(Boolean blockAllPorts) {
            return blockAllPorts(Output.of(blockAllPorts));
        }

        /**
         * @param checkBeacon Enables beacon probing as an additional measure
         * to detect NIC failure.
         * 
         * &gt; **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon
         * probing.
         * 
         * @return builder
         * 
         */
        public Builder checkBeacon(@Nullable Output<Boolean> checkBeacon) {
            $.checkBeacon = checkBeacon;
            return this;
        }

        /**
         * @param checkBeacon Enables beacon probing as an additional measure
         * to detect NIC failure.
         * 
         * &gt; **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon
         * probing.
         * 
         * @return builder
         * 
         */
        public Builder checkBeacon(Boolean checkBeacon) {
            return checkBeacon(Output.of(checkBeacon));
        }

        /**
         * @param configVersion The current version of the VDS configuration, incremented
         * by subsequent updates to the VDS.
         * 
         * @return builder
         * 
         */
        public Builder configVersion(@Nullable Output<String> configVersion) {
            $.configVersion = configVersion;
            return this;
        }

        /**
         * @param configVersion The current version of the VDS configuration, incremented
         * by subsequent updates to the VDS.
         * 
         * @return builder
         * 
         */
        public Builder configVersion(String configVersion) {
            return configVersion(Output.of(configVersion));
        }

        /**
         * @param contactDetail The detailed contact information for the person
         * who is responsible for the VDS.
         * 
         * @return builder
         * 
         */
        public Builder contactDetail(@Nullable Output<String> contactDetail) {
            $.contactDetail = contactDetail;
            return this;
        }

        /**
         * @param contactDetail The detailed contact information for the person
         * who is responsible for the VDS.
         * 
         * @return builder
         * 
         */
        public Builder contactDetail(String contactDetail) {
            return contactDetail(Output.of(contactDetail));
        }

        /**
         * @param contactName The name of the person who is responsible for the
         * VDS.
         * 
         * @return builder
         * 
         */
        public Builder contactName(@Nullable Output<String> contactName) {
            $.contactName = contactName;
            return this;
        }

        /**
         * @param contactName The name of the person who is responsible for the
         * VDS.
         * 
         * @return builder
         * 
         */
        public Builder contactName(String contactName) {
            return contactName(Output.of(contactName));
        }

        /**
         * @param customAttributes Map of custom attribute ids to attribute
         * value strings to set for VDS.
         * 
         * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
         * and requires vCenter Server.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(@Nullable Output<Map<String,String>> customAttributes) {
            $.customAttributes = customAttributes;
            return this;
        }

        /**
         * @param customAttributes Map of custom attribute ids to attribute
         * value strings to set for VDS.
         * 
         * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
         * and requires vCenter Server.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(Map<String,String> customAttributes) {
            return customAttributes(Output.of(customAttributes));
        }

        /**
         * @param datacenterId The ID of the datacenter where the VDS will be
         * created. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder datacenterId(@Nullable Output<String> datacenterId) {
            $.datacenterId = datacenterId;
            return this;
        }

        /**
         * @param datacenterId The ID of the datacenter where the VDS will be
         * created. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder datacenterId(String datacenterId) {
            return datacenterId(Output.of(datacenterId));
        }

        /**
         * @param description A detailed description for the VDS.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description A detailed description for the VDS.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param directpathGen2Allowed Allow VMDirectPath Gen2 for the ports
         * for which this policy applies to.
         * 
         * @return builder
         * 
         */
        public Builder directpathGen2Allowed(@Nullable Output<Boolean> directpathGen2Allowed) {
            $.directpathGen2Allowed = directpathGen2Allowed;
            return this;
        }

        /**
         * @param directpathGen2Allowed Allow VMDirectPath Gen2 for the ports
         * for which this policy applies to.
         * 
         * @return builder
         * 
         */
        public Builder directpathGen2Allowed(Boolean directpathGen2Allowed) {
            return directpathGen2Allowed(Output.of(directpathGen2Allowed));
        }

        /**
         * @param egressShapingAverageBandwidth The average bandwidth in bits
         * per second if egress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingAverageBandwidth(@Nullable Output<Integer> egressShapingAverageBandwidth) {
            $.egressShapingAverageBandwidth = egressShapingAverageBandwidth;
            return this;
        }

        /**
         * @param egressShapingAverageBandwidth The average bandwidth in bits
         * per second if egress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingAverageBandwidth(Integer egressShapingAverageBandwidth) {
            return egressShapingAverageBandwidth(Output.of(egressShapingAverageBandwidth));
        }

        /**
         * @param egressShapingBurstSize The maximum burst size allowed in
         * bytes if egress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingBurstSize(@Nullable Output<Integer> egressShapingBurstSize) {
            $.egressShapingBurstSize = egressShapingBurstSize;
            return this;
        }

        /**
         * @param egressShapingBurstSize The maximum burst size allowed in
         * bytes if egress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingBurstSize(Integer egressShapingBurstSize) {
            return egressShapingBurstSize(Output.of(egressShapingBurstSize));
        }

        /**
         * @param egressShapingEnabled `true` if the traffic shaper is enabled
         * on the port for egress traffic.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingEnabled(@Nullable Output<Boolean> egressShapingEnabled) {
            $.egressShapingEnabled = egressShapingEnabled;
            return this;
        }

        /**
         * @param egressShapingEnabled `true` if the traffic shaper is enabled
         * on the port for egress traffic.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingEnabled(Boolean egressShapingEnabled) {
            return egressShapingEnabled(Output.of(egressShapingEnabled));
        }

        /**
         * @param egressShapingPeakBandwidth The peak bandwidth during bursts
         * in bits per second if egress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingPeakBandwidth(@Nullable Output<Integer> egressShapingPeakBandwidth) {
            $.egressShapingPeakBandwidth = egressShapingPeakBandwidth;
            return this;
        }

        /**
         * @param egressShapingPeakBandwidth The peak bandwidth during bursts
         * in bits per second if egress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingPeakBandwidth(Integer egressShapingPeakBandwidth) {
            return egressShapingPeakBandwidth(Output.of(egressShapingPeakBandwidth));
        }

        /**
         * @param failback If `true`, the teaming policy will re-activate failed
         * uplinks higher in precedence when they come back up.
         * 
         * @return builder
         * 
         */
        public Builder failback(@Nullable Output<Boolean> failback) {
            $.failback = failback;
            return this;
        }

        /**
         * @param failback If `true`, the teaming policy will re-activate failed
         * uplinks higher in precedence when they come back up.
         * 
         * @return builder
         * 
         */
        public Builder failback(Boolean failback) {
            return failback(Output.of(failback));
        }

        /**
         * @param faulttoleranceMaximumMbit The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder faulttoleranceMaximumMbit(@Nullable Output<Integer> faulttoleranceMaximumMbit) {
            $.faulttoleranceMaximumMbit = faulttoleranceMaximumMbit;
            return this;
        }

        /**
         * @param faulttoleranceMaximumMbit The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder faulttoleranceMaximumMbit(Integer faulttoleranceMaximumMbit) {
            return faulttoleranceMaximumMbit(Output.of(faulttoleranceMaximumMbit));
        }

        /**
         * @param faulttoleranceReservationMbit The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder faulttoleranceReservationMbit(@Nullable Output<Integer> faulttoleranceReservationMbit) {
            $.faulttoleranceReservationMbit = faulttoleranceReservationMbit;
            return this;
        }

        /**
         * @param faulttoleranceReservationMbit The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder faulttoleranceReservationMbit(Integer faulttoleranceReservationMbit) {
            return faulttoleranceReservationMbit(Output.of(faulttoleranceReservationMbit));
        }

        /**
         * @param faulttoleranceShareCount The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder faulttoleranceShareCount(@Nullable Output<Integer> faulttoleranceShareCount) {
            $.faulttoleranceShareCount = faulttoleranceShareCount;
            return this;
        }

        /**
         * @param faulttoleranceShareCount The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder faulttoleranceShareCount(Integer faulttoleranceShareCount) {
            return faulttoleranceShareCount(Output.of(faulttoleranceShareCount));
        }

        /**
         * @param faulttoleranceShareLevel The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder faulttoleranceShareLevel(@Nullable Output<String> faulttoleranceShareLevel) {
            $.faulttoleranceShareLevel = faulttoleranceShareLevel;
            return this;
        }

        /**
         * @param faulttoleranceShareLevel The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder faulttoleranceShareLevel(String faulttoleranceShareLevel) {
            return faulttoleranceShareLevel(Output.of(faulttoleranceShareLevel));
        }

        /**
         * @param folder The folder in which to create the VDS.
         * Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder folder(@Nullable Output<String> folder) {
            $.folder = folder;
            return this;
        }

        /**
         * @param folder The folder in which to create the VDS.
         * Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder folder(String folder) {
            return folder(Output.of(folder));
        }

        /**
         * @param hbrMaximumMbit The maximum allowed usage for the hbr traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder hbrMaximumMbit(@Nullable Output<Integer> hbrMaximumMbit) {
            $.hbrMaximumMbit = hbrMaximumMbit;
            return this;
        }

        /**
         * @param hbrMaximumMbit The maximum allowed usage for the hbr traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder hbrMaximumMbit(Integer hbrMaximumMbit) {
            return hbrMaximumMbit(Output.of(hbrMaximumMbit));
        }

        /**
         * @param hbrReservationMbit The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder hbrReservationMbit(@Nullable Output<Integer> hbrReservationMbit) {
            $.hbrReservationMbit = hbrReservationMbit;
            return this;
        }

        /**
         * @param hbrReservationMbit The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder hbrReservationMbit(Integer hbrReservationMbit) {
            return hbrReservationMbit(Output.of(hbrReservationMbit));
        }

        /**
         * @param hbrShareCount The amount of shares to allocate to the hbr traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder hbrShareCount(@Nullable Output<Integer> hbrShareCount) {
            $.hbrShareCount = hbrShareCount;
            return this;
        }

        /**
         * @param hbrShareCount The amount of shares to allocate to the hbr traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder hbrShareCount(Integer hbrShareCount) {
            return hbrShareCount(Output.of(hbrShareCount));
        }

        /**
         * @param hbrShareLevel The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder hbrShareLevel(@Nullable Output<String> hbrShareLevel) {
            $.hbrShareLevel = hbrShareLevel;
            return this;
        }

        /**
         * @param hbrShareLevel The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder hbrShareLevel(String hbrShareLevel) {
            return hbrShareLevel(Output.of(hbrShareLevel));
        }

        /**
         * @param hosts Use the `host` block to declare a host specification. The
         * options are:
         * 
         * @return builder
         * 
         */
        public Builder hosts(@Nullable Output<List<DistributedVirtualSwitchHostArgs>> hosts) {
            $.hosts = hosts;
            return this;
        }

        /**
         * @param hosts Use the `host` block to declare a host specification. The
         * options are:
         * 
         * @return builder
         * 
         */
        public Builder hosts(List<DistributedVirtualSwitchHostArgs> hosts) {
            return hosts(Output.of(hosts));
        }

        /**
         * @param hosts Use the `host` block to declare a host specification. The
         * options are:
         * 
         * @return builder
         * 
         */
        public Builder hosts(DistributedVirtualSwitchHostArgs... hosts) {
            return hosts(List.of(hosts));
        }

        /**
         * @param ignoreOtherPvlanMappings Whether to ignore existing PVLAN
         * mappings not managed by this resource. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder ignoreOtherPvlanMappings(@Nullable Output<Boolean> ignoreOtherPvlanMappings) {
            $.ignoreOtherPvlanMappings = ignoreOtherPvlanMappings;
            return this;
        }

        /**
         * @param ignoreOtherPvlanMappings Whether to ignore existing PVLAN
         * mappings not managed by this resource. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder ignoreOtherPvlanMappings(Boolean ignoreOtherPvlanMappings) {
            return ignoreOtherPvlanMappings(Output.of(ignoreOtherPvlanMappings));
        }

        /**
         * @param ingressShapingAverageBandwidth The average bandwidth in
         * bits per second if ingress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingAverageBandwidth(@Nullable Output<Integer> ingressShapingAverageBandwidth) {
            $.ingressShapingAverageBandwidth = ingressShapingAverageBandwidth;
            return this;
        }

        /**
         * @param ingressShapingAverageBandwidth The average bandwidth in
         * bits per second if ingress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingAverageBandwidth(Integer ingressShapingAverageBandwidth) {
            return ingressShapingAverageBandwidth(Output.of(ingressShapingAverageBandwidth));
        }

        /**
         * @param ingressShapingBurstSize The maximum burst size allowed in
         * bytes if ingress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingBurstSize(@Nullable Output<Integer> ingressShapingBurstSize) {
            $.ingressShapingBurstSize = ingressShapingBurstSize;
            return this;
        }

        /**
         * @param ingressShapingBurstSize The maximum burst size allowed in
         * bytes if ingress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingBurstSize(Integer ingressShapingBurstSize) {
            return ingressShapingBurstSize(Output.of(ingressShapingBurstSize));
        }

        /**
         * @param ingressShapingEnabled `true` if the traffic shaper is
         * enabled on the port for ingress traffic.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingEnabled(@Nullable Output<Boolean> ingressShapingEnabled) {
            $.ingressShapingEnabled = ingressShapingEnabled;
            return this;
        }

        /**
         * @param ingressShapingEnabled `true` if the traffic shaper is
         * enabled on the port for ingress traffic.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingEnabled(Boolean ingressShapingEnabled) {
            return ingressShapingEnabled(Output.of(ingressShapingEnabled));
        }

        /**
         * @param ingressShapingPeakBandwidth The peak bandwidth during
         * bursts in bits per second if ingress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingPeakBandwidth(@Nullable Output<Integer> ingressShapingPeakBandwidth) {
            $.ingressShapingPeakBandwidth = ingressShapingPeakBandwidth;
            return this;
        }

        /**
         * @param ingressShapingPeakBandwidth The peak bandwidth during
         * bursts in bits per second if ingress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingPeakBandwidth(Integer ingressShapingPeakBandwidth) {
            return ingressShapingPeakBandwidth(Output.of(ingressShapingPeakBandwidth));
        }

        /**
         * @param ipv4Address An IPv4 address to identify the switch. This is
         * mostly useful when used with the Netflow arguments.
         * 
         * @return builder
         * 
         */
        public Builder ipv4Address(@Nullable Output<String> ipv4Address) {
            $.ipv4Address = ipv4Address;
            return this;
        }

        /**
         * @param ipv4Address An IPv4 address to identify the switch. This is
         * mostly useful when used with the Netflow arguments.
         * 
         * @return builder
         * 
         */
        public Builder ipv4Address(String ipv4Address) {
            return ipv4Address(Output.of(ipv4Address));
        }

        /**
         * @param iscsiMaximumMbit The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder iscsiMaximumMbit(@Nullable Output<Integer> iscsiMaximumMbit) {
            $.iscsiMaximumMbit = iscsiMaximumMbit;
            return this;
        }

        /**
         * @param iscsiMaximumMbit The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder iscsiMaximumMbit(Integer iscsiMaximumMbit) {
            return iscsiMaximumMbit(Output.of(iscsiMaximumMbit));
        }

        /**
         * @param iscsiReservationMbit The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder iscsiReservationMbit(@Nullable Output<Integer> iscsiReservationMbit) {
            $.iscsiReservationMbit = iscsiReservationMbit;
            return this;
        }

        /**
         * @param iscsiReservationMbit The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder iscsiReservationMbit(Integer iscsiReservationMbit) {
            return iscsiReservationMbit(Output.of(iscsiReservationMbit));
        }

        /**
         * @param iscsiShareCount The amount of shares to allocate to the iSCSI traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder iscsiShareCount(@Nullable Output<Integer> iscsiShareCount) {
            $.iscsiShareCount = iscsiShareCount;
            return this;
        }

        /**
         * @param iscsiShareCount The amount of shares to allocate to the iSCSI traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder iscsiShareCount(Integer iscsiShareCount) {
            return iscsiShareCount(Output.of(iscsiShareCount));
        }

        /**
         * @param iscsiShareLevel The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder iscsiShareLevel(@Nullable Output<String> iscsiShareLevel) {
            $.iscsiShareLevel = iscsiShareLevel;
            return this;
        }

        /**
         * @param iscsiShareLevel The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder iscsiShareLevel(String iscsiShareLevel) {
            return iscsiShareLevel(Output.of(iscsiShareLevel));
        }

        /**
         * @param lacpApiVersion The Link Aggregation Control Protocol group
         * version to use with the VDS. Possible values are `singleLag` and
         * `multipleLag`.
         * 
         * @return builder
         * 
         */
        public Builder lacpApiVersion(@Nullable Output<String> lacpApiVersion) {
            $.lacpApiVersion = lacpApiVersion;
            return this;
        }

        /**
         * @param lacpApiVersion The Link Aggregation Control Protocol group
         * version to use with the VDS. Possible values are `singleLag` and
         * `multipleLag`.
         * 
         * @return builder
         * 
         */
        public Builder lacpApiVersion(String lacpApiVersion) {
            return lacpApiVersion(Output.of(lacpApiVersion));
        }

        /**
         * @param lacpEnabled Enables LACP for the ports that this policy
         * applies to.
         * 
         * @return builder
         * 
         */
        public Builder lacpEnabled(@Nullable Output<Boolean> lacpEnabled) {
            $.lacpEnabled = lacpEnabled;
            return this;
        }

        /**
         * @param lacpEnabled Enables LACP for the ports that this policy
         * applies to.
         * 
         * @return builder
         * 
         */
        public Builder lacpEnabled(Boolean lacpEnabled) {
            return lacpEnabled(Output.of(lacpEnabled));
        }

        /**
         * @param lacpMode The LACP mode. Can be one of `active` or `passive`.
         * 
         * @return builder
         * 
         */
        public Builder lacpMode(@Nullable Output<String> lacpMode) {
            $.lacpMode = lacpMode;
            return this;
        }

        /**
         * @param lacpMode The LACP mode. Can be one of `active` or `passive`.
         * 
         * @return builder
         * 
         */
        public Builder lacpMode(String lacpMode) {
            return lacpMode(Output.of(lacpMode));
        }

        /**
         * @param linkDiscoveryOperation Whether to `advertise` or `listen`
         * for link discovery traffic.
         * 
         * @return builder
         * 
         */
        public Builder linkDiscoveryOperation(@Nullable Output<String> linkDiscoveryOperation) {
            $.linkDiscoveryOperation = linkDiscoveryOperation;
            return this;
        }

        /**
         * @param linkDiscoveryOperation Whether to `advertise` or `listen`
         * for link discovery traffic.
         * 
         * @return builder
         * 
         */
        public Builder linkDiscoveryOperation(String linkDiscoveryOperation) {
            return linkDiscoveryOperation(Output.of(linkDiscoveryOperation));
        }

        /**
         * @param linkDiscoveryProtocol The discovery protocol type. Valid
         * types are `cdp` and `lldp`.
         * 
         * @return builder
         * 
         */
        public Builder linkDiscoveryProtocol(@Nullable Output<String> linkDiscoveryProtocol) {
            $.linkDiscoveryProtocol = linkDiscoveryProtocol;
            return this;
        }

        /**
         * @param linkDiscoveryProtocol The discovery protocol type. Valid
         * types are `cdp` and `lldp`.
         * 
         * @return builder
         * 
         */
        public Builder linkDiscoveryProtocol(String linkDiscoveryProtocol) {
            return linkDiscoveryProtocol(Output.of(linkDiscoveryProtocol));
        }

        /**
         * @param managementMaximumMbit The maximum allowed usage for the management traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder managementMaximumMbit(@Nullable Output<Integer> managementMaximumMbit) {
            $.managementMaximumMbit = managementMaximumMbit;
            return this;
        }

        /**
         * @param managementMaximumMbit The maximum allowed usage for the management traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder managementMaximumMbit(Integer managementMaximumMbit) {
            return managementMaximumMbit(Output.of(managementMaximumMbit));
        }

        /**
         * @param managementReservationMbit The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder managementReservationMbit(@Nullable Output<Integer> managementReservationMbit) {
            $.managementReservationMbit = managementReservationMbit;
            return this;
        }

        /**
         * @param managementReservationMbit The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder managementReservationMbit(Integer managementReservationMbit) {
            return managementReservationMbit(Output.of(managementReservationMbit));
        }

        /**
         * @param managementShareCount The amount of shares to allocate to the management traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder managementShareCount(@Nullable Output<Integer> managementShareCount) {
            $.managementShareCount = managementShareCount;
            return this;
        }

        /**
         * @param managementShareCount The amount of shares to allocate to the management traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder managementShareCount(Integer managementShareCount) {
            return managementShareCount(Output.of(managementShareCount));
        }

        /**
         * @param managementShareLevel The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder managementShareLevel(@Nullable Output<String> managementShareLevel) {
            $.managementShareLevel = managementShareLevel;
            return this;
        }

        /**
         * @param managementShareLevel The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder managementShareLevel(String managementShareLevel) {
            return managementShareLevel(Output.of(managementShareLevel));
        }

        /**
         * @param maxMtu The maximum transmission unit (MTU) for the VDS.
         * 
         * @return builder
         * 
         */
        public Builder maxMtu(@Nullable Output<Integer> maxMtu) {
            $.maxMtu = maxMtu;
            return this;
        }

        /**
         * @param maxMtu The maximum transmission unit (MTU) for the VDS.
         * 
         * @return builder
         * 
         */
        public Builder maxMtu(Integer maxMtu) {
            return maxMtu(Output.of(maxMtu));
        }

        /**
         * @param multicastFilteringMode The multicast filtering mode to use
         * with the VDS. Can be one of `legacyFiltering` or `snooping`.
         * 
         * @return builder
         * 
         */
        public Builder multicastFilteringMode(@Nullable Output<String> multicastFilteringMode) {
            $.multicastFilteringMode = multicastFilteringMode;
            return this;
        }

        /**
         * @param multicastFilteringMode The multicast filtering mode to use
         * with the VDS. Can be one of `legacyFiltering` or `snooping`.
         * 
         * @return builder
         * 
         */
        public Builder multicastFilteringMode(String multicastFilteringMode) {
            return multicastFilteringMode(Output.of(multicastFilteringMode));
        }

        /**
         * @param name The name of the VDS.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the VDS.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param netflowActiveFlowTimeout The number of seconds after which
         * active flows are forced to be exported to the collector. Allowed range is
         * `60` to `3600`. Default: `60`.
         * 
         * @return builder
         * 
         */
        public Builder netflowActiveFlowTimeout(@Nullable Output<Integer> netflowActiveFlowTimeout) {
            $.netflowActiveFlowTimeout = netflowActiveFlowTimeout;
            return this;
        }

        /**
         * @param netflowActiveFlowTimeout The number of seconds after which
         * active flows are forced to be exported to the collector. Allowed range is
         * `60` to `3600`. Default: `60`.
         * 
         * @return builder
         * 
         */
        public Builder netflowActiveFlowTimeout(Integer netflowActiveFlowTimeout) {
            return netflowActiveFlowTimeout(Output.of(netflowActiveFlowTimeout));
        }

        /**
         * @param netflowCollectorIpAddress IP address for the Netflow
         * collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
         * Must be set before Netflow can be enabled.
         * 
         * @return builder
         * 
         */
        public Builder netflowCollectorIpAddress(@Nullable Output<String> netflowCollectorIpAddress) {
            $.netflowCollectorIpAddress = netflowCollectorIpAddress;
            return this;
        }

        /**
         * @param netflowCollectorIpAddress IP address for the Netflow
         * collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
         * Must be set before Netflow can be enabled.
         * 
         * @return builder
         * 
         */
        public Builder netflowCollectorIpAddress(String netflowCollectorIpAddress) {
            return netflowCollectorIpAddress(Output.of(netflowCollectorIpAddress));
        }

        /**
         * @param netflowCollectorPort Port for the Netflow collector. This
         * must be set before Netflow can be enabled.
         * 
         * @return builder
         * 
         */
        public Builder netflowCollectorPort(@Nullable Output<Integer> netflowCollectorPort) {
            $.netflowCollectorPort = netflowCollectorPort;
            return this;
        }

        /**
         * @param netflowCollectorPort Port for the Netflow collector. This
         * must be set before Netflow can be enabled.
         * 
         * @return builder
         * 
         */
        public Builder netflowCollectorPort(Integer netflowCollectorPort) {
            return netflowCollectorPort(Output.of(netflowCollectorPort));
        }

        /**
         * @param netflowEnabled Enables Netflow on all ports that this policy
         * applies to.
         * 
         * @return builder
         * 
         */
        public Builder netflowEnabled(@Nullable Output<Boolean> netflowEnabled) {
            $.netflowEnabled = netflowEnabled;
            return this;
        }

        /**
         * @param netflowEnabled Enables Netflow on all ports that this policy
         * applies to.
         * 
         * @return builder
         * 
         */
        public Builder netflowEnabled(Boolean netflowEnabled) {
            return netflowEnabled(Output.of(netflowEnabled));
        }

        /**
         * @param netflowIdleFlowTimeout The number of seconds after which
         * idle flows are forced to be exported to the collector. Allowed range is `10`
         * to `600`. Default: `15`.
         * 
         * @return builder
         * 
         */
        public Builder netflowIdleFlowTimeout(@Nullable Output<Integer> netflowIdleFlowTimeout) {
            $.netflowIdleFlowTimeout = netflowIdleFlowTimeout;
            return this;
        }

        /**
         * @param netflowIdleFlowTimeout The number of seconds after which
         * idle flows are forced to be exported to the collector. Allowed range is `10`
         * to `600`. Default: `15`.
         * 
         * @return builder
         * 
         */
        public Builder netflowIdleFlowTimeout(Integer netflowIdleFlowTimeout) {
            return netflowIdleFlowTimeout(Output.of(netflowIdleFlowTimeout));
        }

        /**
         * @param netflowInternalFlowsOnly Whether to limit analysis to
         * traffic that has both source and destination served by the same host.
         * Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder netflowInternalFlowsOnly(@Nullable Output<Boolean> netflowInternalFlowsOnly) {
            $.netflowInternalFlowsOnly = netflowInternalFlowsOnly;
            return this;
        }

        /**
         * @param netflowInternalFlowsOnly Whether to limit analysis to
         * traffic that has both source and destination served by the same host.
         * Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder netflowInternalFlowsOnly(Boolean netflowInternalFlowsOnly) {
            return netflowInternalFlowsOnly(Output.of(netflowInternalFlowsOnly));
        }

        /**
         * @param netflowObservationDomainId The observation domain ID for
         * the Netflow collector.
         * 
         * @return builder
         * 
         */
        public Builder netflowObservationDomainId(@Nullable Output<Integer> netflowObservationDomainId) {
            $.netflowObservationDomainId = netflowObservationDomainId;
            return this;
        }

        /**
         * @param netflowObservationDomainId The observation domain ID for
         * the Netflow collector.
         * 
         * @return builder
         * 
         */
        public Builder netflowObservationDomainId(Integer netflowObservationDomainId) {
            return netflowObservationDomainId(Output.of(netflowObservationDomainId));
        }

        /**
         * @param netflowSamplingRate The ratio of total number of packets to
         * the number of packets analyzed. The default is `0`, which indicates that the
         * VDS should analyze all packets. The maximum value is `1000`, which
         * indicates an analysis rate of 0.001%.
         * 
         * @return builder
         * 
         */
        public Builder netflowSamplingRate(@Nullable Output<Integer> netflowSamplingRate) {
            $.netflowSamplingRate = netflowSamplingRate;
            return this;
        }

        /**
         * @param netflowSamplingRate The ratio of total number of packets to
         * the number of packets analyzed. The default is `0`, which indicates that the
         * VDS should analyze all packets. The maximum value is `1000`, which
         * indicates an analysis rate of 0.001%.
         * 
         * @return builder
         * 
         */
        public Builder netflowSamplingRate(Integer netflowSamplingRate) {
            return netflowSamplingRate(Output.of(netflowSamplingRate));
        }

        /**
         * @param networkResourceControlEnabled Set to `true` to enable
         * network I/O control. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder networkResourceControlEnabled(@Nullable Output<Boolean> networkResourceControlEnabled) {
            $.networkResourceControlEnabled = networkResourceControlEnabled;
            return this;
        }

        /**
         * @param networkResourceControlEnabled Set to `true` to enable
         * network I/O control. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder networkResourceControlEnabled(Boolean networkResourceControlEnabled) {
            return networkResourceControlEnabled(Output.of(networkResourceControlEnabled));
        }

        /**
         * @param networkResourceControlVersion The version of network I/O
         * control to use. Can be one of `version2` or `version3`. Default: `version2`.
         * 
         * @return builder
         * 
         */
        public Builder networkResourceControlVersion(@Nullable Output<String> networkResourceControlVersion) {
            $.networkResourceControlVersion = networkResourceControlVersion;
            return this;
        }

        /**
         * @param networkResourceControlVersion The version of network I/O
         * control to use. Can be one of `version2` or `version3`. Default: `version2`.
         * 
         * @return builder
         * 
         */
        public Builder networkResourceControlVersion(String networkResourceControlVersion) {
            return networkResourceControlVersion(Output.of(networkResourceControlVersion));
        }

        /**
         * @param nfsMaximumMbit The maximum allowed usage for the nfs traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder nfsMaximumMbit(@Nullable Output<Integer> nfsMaximumMbit) {
            $.nfsMaximumMbit = nfsMaximumMbit;
            return this;
        }

        /**
         * @param nfsMaximumMbit The maximum allowed usage for the nfs traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder nfsMaximumMbit(Integer nfsMaximumMbit) {
            return nfsMaximumMbit(Output.of(nfsMaximumMbit));
        }

        /**
         * @param nfsReservationMbit The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder nfsReservationMbit(@Nullable Output<Integer> nfsReservationMbit) {
            $.nfsReservationMbit = nfsReservationMbit;
            return this;
        }

        /**
         * @param nfsReservationMbit The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder nfsReservationMbit(Integer nfsReservationMbit) {
            return nfsReservationMbit(Output.of(nfsReservationMbit));
        }

        /**
         * @param nfsShareCount The amount of shares to allocate to the nfs traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder nfsShareCount(@Nullable Output<Integer> nfsShareCount) {
            $.nfsShareCount = nfsShareCount;
            return this;
        }

        /**
         * @param nfsShareCount The amount of shares to allocate to the nfs traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder nfsShareCount(Integer nfsShareCount) {
            return nfsShareCount(Output.of(nfsShareCount));
        }

        /**
         * @param nfsShareLevel The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder nfsShareLevel(@Nullable Output<String> nfsShareLevel) {
            $.nfsShareLevel = nfsShareLevel;
            return this;
        }

        /**
         * @param nfsShareLevel The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder nfsShareLevel(String nfsShareLevel) {
            return nfsShareLevel(Output.of(nfsShareLevel));
        }

        /**
         * @param notifySwitches If `true`, the teaming policy will notify the
         * broadcast network of an uplink failover, triggering cache updates.
         * 
         * @return builder
         * 
         */
        public Builder notifySwitches(@Nullable Output<Boolean> notifySwitches) {
            $.notifySwitches = notifySwitches;
            return this;
        }

        /**
         * @param notifySwitches If `true`, the teaming policy will notify the
         * broadcast network of an uplink failover, triggering cache updates.
         * 
         * @return builder
         * 
         */
        public Builder notifySwitches(Boolean notifySwitches) {
            return notifySwitches(Output.of(notifySwitches));
        }

        /**
         * @param portPrivateSecondaryVlanId Used to define a secondary VLAN
         * ID when using private VLANs.
         * 
         * @return builder
         * 
         */
        public Builder portPrivateSecondaryVlanId(@Nullable Output<Integer> portPrivateSecondaryVlanId) {
            $.portPrivateSecondaryVlanId = portPrivateSecondaryVlanId;
            return this;
        }

        /**
         * @param portPrivateSecondaryVlanId Used to define a secondary VLAN
         * ID when using private VLANs.
         * 
         * @return builder
         * 
         */
        public Builder portPrivateSecondaryVlanId(Integer portPrivateSecondaryVlanId) {
            return portPrivateSecondaryVlanId(Output.of(portPrivateSecondaryVlanId));
        }

        /**
         * @param pvlanMappings Use the `pvlan_mapping` block to declare a
         * private VLAN mapping. The options are:
         * 
         * @return builder
         * 
         */
        public Builder pvlanMappings(@Nullable Output<List<DistributedVirtualSwitchPvlanMappingArgs>> pvlanMappings) {
            $.pvlanMappings = pvlanMappings;
            return this;
        }

        /**
         * @param pvlanMappings Use the `pvlan_mapping` block to declare a
         * private VLAN mapping. The options are:
         * 
         * @return builder
         * 
         */
        public Builder pvlanMappings(List<DistributedVirtualSwitchPvlanMappingArgs> pvlanMappings) {
            return pvlanMappings(Output.of(pvlanMappings));
        }

        /**
         * @param pvlanMappings Use the `pvlan_mapping` block to declare a
         * private VLAN mapping. The options are:
         * 
         * @return builder
         * 
         */
        public Builder pvlanMappings(DistributedVirtualSwitchPvlanMappingArgs... pvlanMappings) {
            return pvlanMappings(List.of(pvlanMappings));
        }

        /**
         * @param standbyUplinks A list of standby uplinks to be used in
         * failover. These uplinks need to match the definitions in the
         * `uplinks` VDS argument. See
         * here for more details.
         * 
         * @return builder
         * 
         */
        public Builder standbyUplinks(@Nullable Output<List<String>> standbyUplinks) {
            $.standbyUplinks = standbyUplinks;
            return this;
        }

        /**
         * @param standbyUplinks A list of standby uplinks to be used in
         * failover. These uplinks need to match the definitions in the
         * `uplinks` VDS argument. See
         * here for more details.
         * 
         * @return builder
         * 
         */
        public Builder standbyUplinks(List<String> standbyUplinks) {
            return standbyUplinks(Output.of(standbyUplinks));
        }

        /**
         * @param standbyUplinks A list of standby uplinks to be used in
         * failover. These uplinks need to match the definitions in the
         * `uplinks` VDS argument. See
         * here for more details.
         * 
         * @return builder
         * 
         */
        public Builder standbyUplinks(String... standbyUplinks) {
            return standbyUplinks(List.of(standbyUplinks));
        }

        /**
         * @param tags The IDs of any tags to attach to this resource.
         * 
         * &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags The IDs of any tags to attach to this resource.
         * 
         * &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags The IDs of any tags to attach to this resource.
         * 
         * &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param teamingPolicy The uplink teaming policy. Can be one of
         * `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,
         * `failover_explicit`, or `loadbalance_loadbased`.
         * 
         * @return builder
         * 
         */
        public Builder teamingPolicy(@Nullable Output<String> teamingPolicy) {
            $.teamingPolicy = teamingPolicy;
            return this;
        }

        /**
         * @param teamingPolicy The uplink teaming policy. Can be one of
         * `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,
         * `failover_explicit`, or `loadbalance_loadbased`.
         * 
         * @return builder
         * 
         */
        public Builder teamingPolicy(String teamingPolicy) {
            return teamingPolicy(Output.of(teamingPolicy));
        }

        /**
         * @param txUplink Forward all traffic transmitted by ports for which
         * this policy applies to its VDS uplinks.
         * 
         * @return builder
         * 
         */
        public Builder txUplink(@Nullable Output<Boolean> txUplink) {
            $.txUplink = txUplink;
            return this;
        }

        /**
         * @param txUplink Forward all traffic transmitted by ports for which
         * this policy applies to its VDS uplinks.
         * 
         * @return builder
         * 
         */
        public Builder txUplink(Boolean txUplink) {
            return txUplink(Output.of(txUplink));
        }

        /**
         * @param uplinks A list of strings that uniquely identifies the names
         * of the uplinks on the VDS across hosts. The number of items in this list
         * controls the number of uplinks that exist on the VDS, in addition to the
         * names. See here for an example on how to
         * use this option.
         * 
         * @return builder
         * 
         */
        public Builder uplinks(@Nullable Output<List<String>> uplinks) {
            $.uplinks = uplinks;
            return this;
        }

        /**
         * @param uplinks A list of strings that uniquely identifies the names
         * of the uplinks on the VDS across hosts. The number of items in this list
         * controls the number of uplinks that exist on the VDS, in addition to the
         * names. See here for an example on how to
         * use this option.
         * 
         * @return builder
         * 
         */
        public Builder uplinks(List<String> uplinks) {
            return uplinks(Output.of(uplinks));
        }

        /**
         * @param uplinks A list of strings that uniquely identifies the names
         * of the uplinks on the VDS across hosts. The number of items in this list
         * controls the number of uplinks that exist on the VDS, in addition to the
         * names. See here for an example on how to
         * use this option.
         * 
         * @return builder
         * 
         */
        public Builder uplinks(String... uplinks) {
            return uplinks(List.of(uplinks));
        }

        /**
         * @param vdpMaximumMbit The maximum allowed usage for the vdp traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vdpMaximumMbit(@Nullable Output<Integer> vdpMaximumMbit) {
            $.vdpMaximumMbit = vdpMaximumMbit;
            return this;
        }

        /**
         * @param vdpMaximumMbit The maximum allowed usage for the vdp traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vdpMaximumMbit(Integer vdpMaximumMbit) {
            return vdpMaximumMbit(Output.of(vdpMaximumMbit));
        }

        /**
         * @param vdpReservationMbit The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vdpReservationMbit(@Nullable Output<Integer> vdpReservationMbit) {
            $.vdpReservationMbit = vdpReservationMbit;
            return this;
        }

        /**
         * @param vdpReservationMbit The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vdpReservationMbit(Integer vdpReservationMbit) {
            return vdpReservationMbit(Output.of(vdpReservationMbit));
        }

        /**
         * @param vdpShareCount The amount of shares to allocate to the vdp traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder vdpShareCount(@Nullable Output<Integer> vdpShareCount) {
            $.vdpShareCount = vdpShareCount;
            return this;
        }

        /**
         * @param vdpShareCount The amount of shares to allocate to the vdp traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder vdpShareCount(Integer vdpShareCount) {
            return vdpShareCount(Output.of(vdpShareCount));
        }

        /**
         * @param vdpShareLevel The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder vdpShareLevel(@Nullable Output<String> vdpShareLevel) {
            $.vdpShareLevel = vdpShareLevel;
            return this;
        }

        /**
         * @param vdpShareLevel The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder vdpShareLevel(String vdpShareLevel) {
            return vdpShareLevel(Output.of(vdpShareLevel));
        }

        /**
         * @param version The version of the VDS. BY default, a VDS is created
         * at the latest version supported by the vSphere version if not specified.
         * A VDS can be upgraded to a newer version, but can not be downgraded.
         * 
         * @return builder
         * 
         */
        public Builder version(@Nullable Output<String> version) {
            $.version = version;
            return this;
        }

        /**
         * @param version The version of the VDS. BY default, a VDS is created
         * at the latest version supported by the vSphere version if not specified.
         * A VDS can be upgraded to a newer version, but can not be downgraded.
         * 
         * @return builder
         * 
         */
        public Builder version(String version) {
            return version(Output.of(version));
        }

        /**
         * @param virtualmachineMaximumMbit The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder virtualmachineMaximumMbit(@Nullable Output<Integer> virtualmachineMaximumMbit) {
            $.virtualmachineMaximumMbit = virtualmachineMaximumMbit;
            return this;
        }

        /**
         * @param virtualmachineMaximumMbit The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder virtualmachineMaximumMbit(Integer virtualmachineMaximumMbit) {
            return virtualmachineMaximumMbit(Output.of(virtualmachineMaximumMbit));
        }

        /**
         * @param virtualmachineReservationMbit The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder virtualmachineReservationMbit(@Nullable Output<Integer> virtualmachineReservationMbit) {
            $.virtualmachineReservationMbit = virtualmachineReservationMbit;
            return this;
        }

        /**
         * @param virtualmachineReservationMbit The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder virtualmachineReservationMbit(Integer virtualmachineReservationMbit) {
            return virtualmachineReservationMbit(Output.of(virtualmachineReservationMbit));
        }

        /**
         * @param virtualmachineShareCount The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder virtualmachineShareCount(@Nullable Output<Integer> virtualmachineShareCount) {
            $.virtualmachineShareCount = virtualmachineShareCount;
            return this;
        }

        /**
         * @param virtualmachineShareCount The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder virtualmachineShareCount(Integer virtualmachineShareCount) {
            return virtualmachineShareCount(Output.of(virtualmachineShareCount));
        }

        /**
         * @param virtualmachineShareLevel The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder virtualmachineShareLevel(@Nullable Output<String> virtualmachineShareLevel) {
            $.virtualmachineShareLevel = virtualmachineShareLevel;
            return this;
        }

        /**
         * @param virtualmachineShareLevel The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder virtualmachineShareLevel(String virtualmachineShareLevel) {
            return virtualmachineShareLevel(Output.of(virtualmachineShareLevel));
        }

        /**
         * @param vlanId The VLAN ID for single VLAN mode. 0 denotes no VLAN.
         * 
         * @return builder
         * 
         */
        public Builder vlanId(@Nullable Output<Integer> vlanId) {
            $.vlanId = vlanId;
            return this;
        }

        /**
         * @param vlanId The VLAN ID for single VLAN mode. 0 denotes no VLAN.
         * 
         * @return builder
         * 
         */
        public Builder vlanId(Integer vlanId) {
            return vlanId(Output.of(vlanId));
        }

        /**
         * @param vlanRanges Used to denote VLAN trunking. Use the `min_vlan`
         * and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
         * `vlan_range` definitions are allowed, but they must not overlap. Example
         * below:
         * 
         * &lt;!--Start PulumiCodeChooser --&gt;
         * ```java
         * package generated_program;
         * 
         * import com.pulumi.Context;
         * import com.pulumi.Pulumi;
         * import com.pulumi.core.Output;
         * import com.pulumi.vsphere.DistributedVirtualSwitch;
         * import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
         * import com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;
         * import java.util.List;
         * import java.util.ArrayList;
         * import java.util.Map;
         * import java.io.File;
         * import java.nio.file.Files;
         * import java.nio.file.Paths;
         * 
         * public class App {
         *     public static void main(String[] args) {
         *         Pulumi.run(App::stack);
         *     }
         * 
         *     public static void stack(Context ctx) {
         *         var vds = new DistributedVirtualSwitch(&#34;vds&#34;, DistributedVirtualSwitchArgs.builder()        
         *             .vlanRanges(            
         *                 DistributedVirtualSwitchVlanRangeArgs.builder()
         *                     .maxVlan(199)
         *                     .minVlan(100)
         *                     .build(),
         *                 DistributedVirtualSwitchVlanRangeArgs.builder()
         *                     .maxVlan(399)
         *                     .minVlan(300)
         *                     .build())
         *             .build());
         * 
         *     }
         * }
         * ```
         * &lt;!--End PulumiCodeChooser --&gt;
         * 
         * @return builder
         * 
         */
        public Builder vlanRanges(@Nullable Output<List<DistributedVirtualSwitchVlanRangeArgs>> vlanRanges) {
            $.vlanRanges = vlanRanges;
            return this;
        }

        /**
         * @param vlanRanges Used to denote VLAN trunking. Use the `min_vlan`
         * and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
         * `vlan_range` definitions are allowed, but they must not overlap. Example
         * below:
         * 
         * &lt;!--Start PulumiCodeChooser --&gt;
         * ```java
         * package generated_program;
         * 
         * import com.pulumi.Context;
         * import com.pulumi.Pulumi;
         * import com.pulumi.core.Output;
         * import com.pulumi.vsphere.DistributedVirtualSwitch;
         * import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
         * import com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;
         * import java.util.List;
         * import java.util.ArrayList;
         * import java.util.Map;
         * import java.io.File;
         * import java.nio.file.Files;
         * import java.nio.file.Paths;
         * 
         * public class App {
         *     public static void main(String[] args) {
         *         Pulumi.run(App::stack);
         *     }
         * 
         *     public static void stack(Context ctx) {
         *         var vds = new DistributedVirtualSwitch(&#34;vds&#34;, DistributedVirtualSwitchArgs.builder()        
         *             .vlanRanges(            
         *                 DistributedVirtualSwitchVlanRangeArgs.builder()
         *                     .maxVlan(199)
         *                     .minVlan(100)
         *                     .build(),
         *                 DistributedVirtualSwitchVlanRangeArgs.builder()
         *                     .maxVlan(399)
         *                     .minVlan(300)
         *                     .build())
         *             .build());
         * 
         *     }
         * }
         * ```
         * &lt;!--End PulumiCodeChooser --&gt;
         * 
         * @return builder
         * 
         */
        public Builder vlanRanges(List<DistributedVirtualSwitchVlanRangeArgs> vlanRanges) {
            return vlanRanges(Output.of(vlanRanges));
        }

        /**
         * @param vlanRanges Used to denote VLAN trunking. Use the `min_vlan`
         * and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
         * `vlan_range` definitions are allowed, but they must not overlap. Example
         * below:
         * 
         * &lt;!--Start PulumiCodeChooser --&gt;
         * ```java
         * package generated_program;
         * 
         * import com.pulumi.Context;
         * import com.pulumi.Pulumi;
         * import com.pulumi.core.Output;
         * import com.pulumi.vsphere.DistributedVirtualSwitch;
         * import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
         * import com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;
         * import java.util.List;
         * import java.util.ArrayList;
         * import java.util.Map;
         * import java.io.File;
         * import java.nio.file.Files;
         * import java.nio.file.Paths;
         * 
         * public class App {
         *     public static void main(String[] args) {
         *         Pulumi.run(App::stack);
         *     }
         * 
         *     public static void stack(Context ctx) {
         *         var vds = new DistributedVirtualSwitch(&#34;vds&#34;, DistributedVirtualSwitchArgs.builder()        
         *             .vlanRanges(            
         *                 DistributedVirtualSwitchVlanRangeArgs.builder()
         *                     .maxVlan(199)
         *                     .minVlan(100)
         *                     .build(),
         *                 DistributedVirtualSwitchVlanRangeArgs.builder()
         *                     .maxVlan(399)
         *                     .minVlan(300)
         *                     .build())
         *             .build());
         * 
         *     }
         * }
         * ```
         * &lt;!--End PulumiCodeChooser --&gt;
         * 
         * @return builder
         * 
         */
        public Builder vlanRanges(DistributedVirtualSwitchVlanRangeArgs... vlanRanges) {
            return vlanRanges(List.of(vlanRanges));
        }

        /**
         * @param vmotionMaximumMbit The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vmotionMaximumMbit(@Nullable Output<Integer> vmotionMaximumMbit) {
            $.vmotionMaximumMbit = vmotionMaximumMbit;
            return this;
        }

        /**
         * @param vmotionMaximumMbit The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vmotionMaximumMbit(Integer vmotionMaximumMbit) {
            return vmotionMaximumMbit(Output.of(vmotionMaximumMbit));
        }

        /**
         * @param vmotionReservationMbit The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vmotionReservationMbit(@Nullable Output<Integer> vmotionReservationMbit) {
            $.vmotionReservationMbit = vmotionReservationMbit;
            return this;
        }

        /**
         * @param vmotionReservationMbit The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vmotionReservationMbit(Integer vmotionReservationMbit) {
            return vmotionReservationMbit(Output.of(vmotionReservationMbit));
        }

        /**
         * @param vmotionShareCount The amount of shares to allocate to the vmotion traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder vmotionShareCount(@Nullable Output<Integer> vmotionShareCount) {
            $.vmotionShareCount = vmotionShareCount;
            return this;
        }

        /**
         * @param vmotionShareCount The amount of shares to allocate to the vmotion traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder vmotionShareCount(Integer vmotionShareCount) {
            return vmotionShareCount(Output.of(vmotionShareCount));
        }

        /**
         * @param vmotionShareLevel The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder vmotionShareLevel(@Nullable Output<String> vmotionShareLevel) {
            $.vmotionShareLevel = vmotionShareLevel;
            return this;
        }

        /**
         * @param vmotionShareLevel The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder vmotionShareLevel(String vmotionShareLevel) {
            return vmotionShareLevel(Output.of(vmotionShareLevel));
        }

        /**
         * @param vsanMaximumMbit The maximum allowed usage for the vsan traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vsanMaximumMbit(@Nullable Output<Integer> vsanMaximumMbit) {
            $.vsanMaximumMbit = vsanMaximumMbit;
            return this;
        }

        /**
         * @param vsanMaximumMbit The maximum allowed usage for the vsan traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vsanMaximumMbit(Integer vsanMaximumMbit) {
            return vsanMaximumMbit(Output.of(vsanMaximumMbit));
        }

        /**
         * @param vsanReservationMbit The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vsanReservationMbit(@Nullable Output<Integer> vsanReservationMbit) {
            $.vsanReservationMbit = vsanReservationMbit;
            return this;
        }

        /**
         * @param vsanReservationMbit The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
         * 
         * @return builder
         * 
         */
        public Builder vsanReservationMbit(Integer vsanReservationMbit) {
            return vsanReservationMbit(Output.of(vsanReservationMbit));
        }

        /**
         * @param vsanShareCount The amount of shares to allocate to the vsan traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder vsanShareCount(@Nullable Output<Integer> vsanShareCount) {
            $.vsanShareCount = vsanShareCount;
            return this;
        }

        /**
         * @param vsanShareCount The amount of shares to allocate to the vsan traffic class for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder vsanShareCount(Integer vsanShareCount) {
            return vsanShareCount(Output.of(vsanShareCount));
        }

        /**
         * @param vsanShareLevel The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder vsanShareLevel(@Nullable Output<String> vsanShareLevel) {
            $.vsanShareLevel = vsanShareLevel;
            return this;
        }

        /**
         * @param vsanShareLevel The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder vsanShareLevel(String vsanShareLevel) {
            return vsanShareLevel(Output.of(vsanShareLevel));
        }

        public DistributedVirtualSwitchState build() {
            return $;
        }
    }

}
