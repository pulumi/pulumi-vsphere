// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class VirtualMachineDiskArgs extends com.pulumi.resources.ResourceArgs {

    public static final VirtualMachineDiskArgs Empty = new VirtualMachineDiskArgs();

    /**
     * If this is true, the disk is attached instead of created. Implies keep_on_remove.
     * 
     */
    @Import(name="attach")
    private @Nullable Output<Boolean> attach;

    /**
     * @return If this is true, the disk is attached instead of created. Implies keep_on_remove.
     * 
     */
    public Optional<Output<Boolean>> attach() {
        return Optional.ofNullable(this.attach);
    }

    /**
     * The type of controller the disk should be connected to. Must be &#39;scsi&#39;, &#39;sata&#39;, &#39;nvme&#39;, or &#39;ide&#39;.
     * 
     */
    @Import(name="controllerType")
    private @Nullable Output<String> controllerType;

    /**
     * @return The type of controller the disk should be connected to. Must be &#39;scsi&#39;, &#39;sata&#39;, &#39;nvme&#39;, or &#39;ide&#39;.
     * 
     */
    public Optional<Output<String>> controllerType() {
        return Optional.ofNullable(this.controllerType);
    }

    /**
     * The datastore ID for this virtual disk, if different than the virtual machine.
     * 
     */
    @Import(name="datastoreId")
    private @Nullable Output<String> datastoreId;

    /**
     * @return The datastore ID for this virtual disk, if different than the virtual machine.
     * 
     */
    public Optional<Output<String>> datastoreId() {
        return Optional.ofNullable(this.datastoreId);
    }

    /**
     * An address internal to Terraform that helps locate the device when `key` is unavailable. This follows a convention of `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device unit `1` on SCSI bus `0`.
     * 
     */
    @Import(name="deviceAddress")
    private @Nullable Output<String> deviceAddress;

    /**
     * @return An address internal to Terraform that helps locate the device when `key` is unavailable. This follows a convention of `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device unit `1` on SCSI bus `0`.
     * 
     */
    public Optional<Output<String>> deviceAddress() {
        return Optional.ofNullable(this.deviceAddress);
    }

    /**
     * The mode of this this virtual disk for purposes of writes and snapshotting. Can be one of append, independent_nonpersistent, independent_persistent, nonpersistent, persistent, or undoable.
     * 
     */
    @Import(name="diskMode")
    private @Nullable Output<String> diskMode;

    /**
     * @return The mode of this this virtual disk for purposes of writes and snapshotting. Can be one of append, independent_nonpersistent, independent_persistent, nonpersistent, persistent, or undoable.
     * 
     */
    public Optional<Output<String>> diskMode() {
        return Optional.ofNullable(this.diskMode);
    }

    /**
     * The sharing mode of this virtual disk. Can be one of sharingMultiWriter or sharingNone.
     * 
     */
    @Import(name="diskSharing")
    private @Nullable Output<String> diskSharing;

    /**
     * @return The sharing mode of this virtual disk. Can be one of sharingMultiWriter or sharingNone.
     * 
     */
    public Optional<Output<String>> diskSharing() {
        return Optional.ofNullable(this.diskSharing);
    }

    /**
     * The virtual disk file zeroing policy when thinProvision is not true. The default is false, which lazily-zeros the disk, speeding up thick-provisioned disk creation time.
     * 
     */
    @Import(name="eagerlyScrub")
    private @Nullable Output<Boolean> eagerlyScrub;

    /**
     * @return The virtual disk file zeroing policy when thinProvision is not true. The default is false, which lazily-zeros the disk, speeding up thick-provisioned disk creation time.
     * 
     */
    public Optional<Output<Boolean>> eagerlyScrub() {
        return Optional.ofNullable(this.eagerlyScrub);
    }

    /**
     * The upper limit of IOPS that this disk can use.
     * 
     */
    @Import(name="ioLimit")
    private @Nullable Output<Integer> ioLimit;

    /**
     * @return The upper limit of IOPS that this disk can use.
     * 
     */
    public Optional<Output<Integer>> ioLimit() {
        return Optional.ofNullable(this.ioLimit);
    }

    /**
     * The I/O guarantee that this disk has, in IOPS.
     * 
     */
    @Import(name="ioReservation")
    private @Nullable Output<Integer> ioReservation;

    /**
     * @return The I/O guarantee that this disk has, in IOPS.
     * 
     */
    public Optional<Output<Integer>> ioReservation() {
        return Optional.ofNullable(this.ioReservation);
    }

    /**
     * The share count for this disk when the share level is custom.
     * 
     */
    @Import(name="ioShareCount")
    private @Nullable Output<Integer> ioShareCount;

    /**
     * @return The share count for this disk when the share level is custom.
     * 
     */
    public Optional<Output<Integer>> ioShareCount() {
        return Optional.ofNullable(this.ioShareCount);
    }

    /**
     * The share allocation level for this disk. Can be one of low, normal, high, or custom.
     * 
     */
    @Import(name="ioShareLevel")
    private @Nullable Output<String> ioShareLevel;

    /**
     * @return The share allocation level for this disk. Can be one of low, normal, high, or custom.
     * 
     */
    public Optional<Output<String>> ioShareLevel() {
        return Optional.ofNullable(this.ioShareLevel);
    }

    /**
     * Set to true to keep the underlying VMDK file when removing this virtual disk from configuration.
     * 
     */
    @Import(name="keepOnRemove")
    private @Nullable Output<Boolean> keepOnRemove;

    /**
     * @return Set to true to keep the underlying VMDK file when removing this virtual disk from configuration.
     * 
     */
    public Optional<Output<Boolean>> keepOnRemove() {
        return Optional.ofNullable(this.keepOnRemove);
    }

    /**
     * The ID of the device within the virtual machine.
     * 
     */
    @Import(name="key")
    private @Nullable Output<Integer> key;

    /**
     * @return The ID of the device within the virtual machine.
     * 
     */
    public Optional<Output<Integer>> key() {
        return Optional.ofNullable(this.key);
    }

    /**
     * A unique label for this disk.
     * 
     */
    @Import(name="label", required=true)
    private Output<String> label;

    /**
     * @return A unique label for this disk.
     * 
     */
    public Output<String> label() {
        return this.label;
    }

    /**
     * The full path of the virtual disk. This can only be provided if attach is set to true, otherwise it is a read-only value.
     * 
     */
    @Import(name="path")
    private @Nullable Output<String> path;

    /**
     * @return The full path of the virtual disk. This can only be provided if attach is set to true, otherwise it is a read-only value.
     * 
     */
    public Optional<Output<String>> path() {
        return Optional.ofNullable(this.path);
    }

    /**
     * The size of the disk, in GB.
     * 
     */
    @Import(name="size")
    private @Nullable Output<Integer> size;

    /**
     * @return The size of the disk, in GB.
     * 
     */
    public Optional<Output<Integer>> size() {
        return Optional.ofNullable(this.size);
    }

    /**
     * The ID of the storage policy to assign to the virtual disk in VM.
     * 
     */
    @Import(name="storagePolicyId")
    private @Nullable Output<String> storagePolicyId;

    /**
     * @return The ID of the storage policy to assign to the virtual disk in VM.
     * 
     */
    public Optional<Output<String>> storagePolicyId() {
        return Optional.ofNullable(this.storagePolicyId);
    }

    /**
     * If true, this disk is thin provisioned, with space for the file being allocated on an as-needed basis.
     * 
     */
    @Import(name="thinProvisioned")
    private @Nullable Output<Boolean> thinProvisioned;

    /**
     * @return If true, this disk is thin provisioned, with space for the file being allocated on an as-needed basis.
     * 
     */
    public Optional<Output<Boolean>> thinProvisioned() {
        return Optional.ofNullable(this.thinProvisioned);
    }

    /**
     * The unique device number for this disk. This number determines where on the SCSI bus this device will be attached.
     * 
     */
    @Import(name="unitNumber")
    private @Nullable Output<Integer> unitNumber;

    /**
     * @return The unique device number for this disk. This number determines where on the SCSI bus this device will be attached.
     * 
     */
    public Optional<Output<Integer>> unitNumber() {
        return Optional.ofNullable(this.unitNumber);
    }

    /**
     * The UUID of the virtual machine. Also exposed as the `id` of the resource.
     * 
     */
    @Import(name="uuid")
    private @Nullable Output<String> uuid;

    /**
     * @return The UUID of the virtual machine. Also exposed as the `id` of the resource.
     * 
     */
    public Optional<Output<String>> uuid() {
        return Optional.ofNullable(this.uuid);
    }

    /**
     * If true, writes for this disk are sent directly to the filesystem immediately instead of being buffered.
     * 
     */
    @Import(name="writeThrough")
    private @Nullable Output<Boolean> writeThrough;

    /**
     * @return If true, writes for this disk are sent directly to the filesystem immediately instead of being buffered.
     * 
     */
    public Optional<Output<Boolean>> writeThrough() {
        return Optional.ofNullable(this.writeThrough);
    }

    private VirtualMachineDiskArgs() {}

    private VirtualMachineDiskArgs(VirtualMachineDiskArgs $) {
        this.attach = $.attach;
        this.controllerType = $.controllerType;
        this.datastoreId = $.datastoreId;
        this.deviceAddress = $.deviceAddress;
        this.diskMode = $.diskMode;
        this.diskSharing = $.diskSharing;
        this.eagerlyScrub = $.eagerlyScrub;
        this.ioLimit = $.ioLimit;
        this.ioReservation = $.ioReservation;
        this.ioShareCount = $.ioShareCount;
        this.ioShareLevel = $.ioShareLevel;
        this.keepOnRemove = $.keepOnRemove;
        this.key = $.key;
        this.label = $.label;
        this.path = $.path;
        this.size = $.size;
        this.storagePolicyId = $.storagePolicyId;
        this.thinProvisioned = $.thinProvisioned;
        this.unitNumber = $.unitNumber;
        this.uuid = $.uuid;
        this.writeThrough = $.writeThrough;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(VirtualMachineDiskArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private VirtualMachineDiskArgs $;

        public Builder() {
            $ = new VirtualMachineDiskArgs();
        }

        public Builder(VirtualMachineDiskArgs defaults) {
            $ = new VirtualMachineDiskArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param attach If this is true, the disk is attached instead of created. Implies keep_on_remove.
         * 
         * @return builder
         * 
         */
        public Builder attach(@Nullable Output<Boolean> attach) {
            $.attach = attach;
            return this;
        }

        /**
         * @param attach If this is true, the disk is attached instead of created. Implies keep_on_remove.
         * 
         * @return builder
         * 
         */
        public Builder attach(Boolean attach) {
            return attach(Output.of(attach));
        }

        /**
         * @param controllerType The type of controller the disk should be connected to. Must be &#39;scsi&#39;, &#39;sata&#39;, &#39;nvme&#39;, or &#39;ide&#39;.
         * 
         * @return builder
         * 
         */
        public Builder controllerType(@Nullable Output<String> controllerType) {
            $.controllerType = controllerType;
            return this;
        }

        /**
         * @param controllerType The type of controller the disk should be connected to. Must be &#39;scsi&#39;, &#39;sata&#39;, &#39;nvme&#39;, or &#39;ide&#39;.
         * 
         * @return builder
         * 
         */
        public Builder controllerType(String controllerType) {
            return controllerType(Output.of(controllerType));
        }

        /**
         * @param datastoreId The datastore ID for this virtual disk, if different than the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder datastoreId(@Nullable Output<String> datastoreId) {
            $.datastoreId = datastoreId;
            return this;
        }

        /**
         * @param datastoreId The datastore ID for this virtual disk, if different than the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder datastoreId(String datastoreId) {
            return datastoreId(Output.of(datastoreId));
        }

        /**
         * @param deviceAddress An address internal to Terraform that helps locate the device when `key` is unavailable. This follows a convention of `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device unit `1` on SCSI bus `0`.
         * 
         * @return builder
         * 
         */
        public Builder deviceAddress(@Nullable Output<String> deviceAddress) {
            $.deviceAddress = deviceAddress;
            return this;
        }

        /**
         * @param deviceAddress An address internal to Terraform that helps locate the device when `key` is unavailable. This follows a convention of `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device unit `1` on SCSI bus `0`.
         * 
         * @return builder
         * 
         */
        public Builder deviceAddress(String deviceAddress) {
            return deviceAddress(Output.of(deviceAddress));
        }

        /**
         * @param diskMode The mode of this this virtual disk for purposes of writes and snapshotting. Can be one of append, independent_nonpersistent, independent_persistent, nonpersistent, persistent, or undoable.
         * 
         * @return builder
         * 
         */
        public Builder diskMode(@Nullable Output<String> diskMode) {
            $.diskMode = diskMode;
            return this;
        }

        /**
         * @param diskMode The mode of this this virtual disk for purposes of writes and snapshotting. Can be one of append, independent_nonpersistent, independent_persistent, nonpersistent, persistent, or undoable.
         * 
         * @return builder
         * 
         */
        public Builder diskMode(String diskMode) {
            return diskMode(Output.of(diskMode));
        }

        /**
         * @param diskSharing The sharing mode of this virtual disk. Can be one of sharingMultiWriter or sharingNone.
         * 
         * @return builder
         * 
         */
        public Builder diskSharing(@Nullable Output<String> diskSharing) {
            $.diskSharing = diskSharing;
            return this;
        }

        /**
         * @param diskSharing The sharing mode of this virtual disk. Can be one of sharingMultiWriter or sharingNone.
         * 
         * @return builder
         * 
         */
        public Builder diskSharing(String diskSharing) {
            return diskSharing(Output.of(diskSharing));
        }

        /**
         * @param eagerlyScrub The virtual disk file zeroing policy when thinProvision is not true. The default is false, which lazily-zeros the disk, speeding up thick-provisioned disk creation time.
         * 
         * @return builder
         * 
         */
        public Builder eagerlyScrub(@Nullable Output<Boolean> eagerlyScrub) {
            $.eagerlyScrub = eagerlyScrub;
            return this;
        }

        /**
         * @param eagerlyScrub The virtual disk file zeroing policy when thinProvision is not true. The default is false, which lazily-zeros the disk, speeding up thick-provisioned disk creation time.
         * 
         * @return builder
         * 
         */
        public Builder eagerlyScrub(Boolean eagerlyScrub) {
            return eagerlyScrub(Output.of(eagerlyScrub));
        }

        /**
         * @param ioLimit The upper limit of IOPS that this disk can use.
         * 
         * @return builder
         * 
         */
        public Builder ioLimit(@Nullable Output<Integer> ioLimit) {
            $.ioLimit = ioLimit;
            return this;
        }

        /**
         * @param ioLimit The upper limit of IOPS that this disk can use.
         * 
         * @return builder
         * 
         */
        public Builder ioLimit(Integer ioLimit) {
            return ioLimit(Output.of(ioLimit));
        }

        /**
         * @param ioReservation The I/O guarantee that this disk has, in IOPS.
         * 
         * @return builder
         * 
         */
        public Builder ioReservation(@Nullable Output<Integer> ioReservation) {
            $.ioReservation = ioReservation;
            return this;
        }

        /**
         * @param ioReservation The I/O guarantee that this disk has, in IOPS.
         * 
         * @return builder
         * 
         */
        public Builder ioReservation(Integer ioReservation) {
            return ioReservation(Output.of(ioReservation));
        }

        /**
         * @param ioShareCount The share count for this disk when the share level is custom.
         * 
         * @return builder
         * 
         */
        public Builder ioShareCount(@Nullable Output<Integer> ioShareCount) {
            $.ioShareCount = ioShareCount;
            return this;
        }

        /**
         * @param ioShareCount The share count for this disk when the share level is custom.
         * 
         * @return builder
         * 
         */
        public Builder ioShareCount(Integer ioShareCount) {
            return ioShareCount(Output.of(ioShareCount));
        }

        /**
         * @param ioShareLevel The share allocation level for this disk. Can be one of low, normal, high, or custom.
         * 
         * @return builder
         * 
         */
        public Builder ioShareLevel(@Nullable Output<String> ioShareLevel) {
            $.ioShareLevel = ioShareLevel;
            return this;
        }

        /**
         * @param ioShareLevel The share allocation level for this disk. Can be one of low, normal, high, or custom.
         * 
         * @return builder
         * 
         */
        public Builder ioShareLevel(String ioShareLevel) {
            return ioShareLevel(Output.of(ioShareLevel));
        }

        /**
         * @param keepOnRemove Set to true to keep the underlying VMDK file when removing this virtual disk from configuration.
         * 
         * @return builder
         * 
         */
        public Builder keepOnRemove(@Nullable Output<Boolean> keepOnRemove) {
            $.keepOnRemove = keepOnRemove;
            return this;
        }

        /**
         * @param keepOnRemove Set to true to keep the underlying VMDK file when removing this virtual disk from configuration.
         * 
         * @return builder
         * 
         */
        public Builder keepOnRemove(Boolean keepOnRemove) {
            return keepOnRemove(Output.of(keepOnRemove));
        }

        /**
         * @param key The ID of the device within the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder key(@Nullable Output<Integer> key) {
            $.key = key;
            return this;
        }

        /**
         * @param key The ID of the device within the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder key(Integer key) {
            return key(Output.of(key));
        }

        /**
         * @param label A unique label for this disk.
         * 
         * @return builder
         * 
         */
        public Builder label(Output<String> label) {
            $.label = label;
            return this;
        }

        /**
         * @param label A unique label for this disk.
         * 
         * @return builder
         * 
         */
        public Builder label(String label) {
            return label(Output.of(label));
        }

        /**
         * @param path The full path of the virtual disk. This can only be provided if attach is set to true, otherwise it is a read-only value.
         * 
         * @return builder
         * 
         */
        public Builder path(@Nullable Output<String> path) {
            $.path = path;
            return this;
        }

        /**
         * @param path The full path of the virtual disk. This can only be provided if attach is set to true, otherwise it is a read-only value.
         * 
         * @return builder
         * 
         */
        public Builder path(String path) {
            return path(Output.of(path));
        }

        /**
         * @param size The size of the disk, in GB.
         * 
         * @return builder
         * 
         */
        public Builder size(@Nullable Output<Integer> size) {
            $.size = size;
            return this;
        }

        /**
         * @param size The size of the disk, in GB.
         * 
         * @return builder
         * 
         */
        public Builder size(Integer size) {
            return size(Output.of(size));
        }

        /**
         * @param storagePolicyId The ID of the storage policy to assign to the virtual disk in VM.
         * 
         * @return builder
         * 
         */
        public Builder storagePolicyId(@Nullable Output<String> storagePolicyId) {
            $.storagePolicyId = storagePolicyId;
            return this;
        }

        /**
         * @param storagePolicyId The ID of the storage policy to assign to the virtual disk in VM.
         * 
         * @return builder
         * 
         */
        public Builder storagePolicyId(String storagePolicyId) {
            return storagePolicyId(Output.of(storagePolicyId));
        }

        /**
         * @param thinProvisioned If true, this disk is thin provisioned, with space for the file being allocated on an as-needed basis.
         * 
         * @return builder
         * 
         */
        public Builder thinProvisioned(@Nullable Output<Boolean> thinProvisioned) {
            $.thinProvisioned = thinProvisioned;
            return this;
        }

        /**
         * @param thinProvisioned If true, this disk is thin provisioned, with space for the file being allocated on an as-needed basis.
         * 
         * @return builder
         * 
         */
        public Builder thinProvisioned(Boolean thinProvisioned) {
            return thinProvisioned(Output.of(thinProvisioned));
        }

        /**
         * @param unitNumber The unique device number for this disk. This number determines where on the SCSI bus this device will be attached.
         * 
         * @return builder
         * 
         */
        public Builder unitNumber(@Nullable Output<Integer> unitNumber) {
            $.unitNumber = unitNumber;
            return this;
        }

        /**
         * @param unitNumber The unique device number for this disk. This number determines where on the SCSI bus this device will be attached.
         * 
         * @return builder
         * 
         */
        public Builder unitNumber(Integer unitNumber) {
            return unitNumber(Output.of(unitNumber));
        }

        /**
         * @param uuid The UUID of the virtual machine. Also exposed as the `id` of the resource.
         * 
         * @return builder
         * 
         */
        public Builder uuid(@Nullable Output<String> uuid) {
            $.uuid = uuid;
            return this;
        }

        /**
         * @param uuid The UUID of the virtual machine. Also exposed as the `id` of the resource.
         * 
         * @return builder
         * 
         */
        public Builder uuid(String uuid) {
            return uuid(Output.of(uuid));
        }

        /**
         * @param writeThrough If true, writes for this disk are sent directly to the filesystem immediately instead of being buffered.
         * 
         * @return builder
         * 
         */
        public Builder writeThrough(@Nullable Output<Boolean> writeThrough) {
            $.writeThrough = writeThrough;
            return this;
        }

        /**
         * @param writeThrough If true, writes for this disk are sent directly to the filesystem immediately instead of being buffered.
         * 
         * @return builder
         * 
         */
        public Builder writeThrough(Boolean writeThrough) {
            return writeThrough(Output.of(writeThrough));
        }

        public VirtualMachineDiskArgs build() {
            if ($.label == null) {
                throw new MissingRequiredPropertyException("VirtualMachineDiskArgs", "label");
            }
            return $;
        }
    }

}
