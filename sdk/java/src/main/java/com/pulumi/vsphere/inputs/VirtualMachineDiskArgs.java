// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class VirtualMachineDiskArgs extends com.pulumi.resources.ResourceArgs {

    public static final VirtualMachineDiskArgs Empty = new VirtualMachineDiskArgs();

    /**
     * Attach an external disk instead of creating a new one. Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`, `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
     * 
     * &gt; **NOTE:** External disks cannot be attached when `datastore_cluster_id` is used.
     * 
     */
    @Import(name="attach")
    private @Nullable Output<Boolean> attach;

    /**
     * @return Attach an external disk instead of creating a new one. Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`, `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
     * 
     * &gt; **NOTE:** External disks cannot be attached when `datastore_cluster_id` is used.
     * 
     */
    public Optional<Output<Boolean>> attach() {
        return Optional.ofNullable(this.attach);
    }

    /**
     * The type of storage controller to attach the  disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate number of controllers enabled for the selected type. Default `scsi`.
     * 
     */
    @Import(name="controllerType")
    private @Nullable Output<String> controllerType;

    /**
     * @return The type of storage controller to attach the  disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate number of controllers enabled for the selected type. Default `scsi`.
     * 
     */
    public Optional<Output<String>> controllerType() {
        return Optional.ofNullable(this.controllerType);
    }

    /**
     * The [managed object reference ID][docs-about-morefs] for the datastore on which the virtual disk is placed. The default is to use the datastore of the virtual machine. See the section on virtual machine migration for information on modifying this value.
     * 
     * &gt; **NOTE:** Datastores cannot be assigned to individual disks when `datastore_cluster_id` is used.
     * 
     */
    @Import(name="datastoreId")
    private @Nullable Output<String> datastoreId;

    /**
     * @return The [managed object reference ID][docs-about-morefs] for the datastore on which the virtual disk is placed. The default is to use the datastore of the virtual machine. See the section on virtual machine migration for information on modifying this value.
     * 
     * &gt; **NOTE:** Datastores cannot be assigned to individual disks when `datastore_cluster_id` is used.
     * 
     */
    public Optional<Output<String>> datastoreId() {
        return Optional.ofNullable(this.datastoreId);
    }

    @Import(name="deviceAddress")
    private @Nullable Output<String> deviceAddress;

    public Optional<Output<String>> deviceAddress() {
        return Optional.ofNullable(this.deviceAddress);
    }

    /**
     * The mode of this this virtual disk for purposes of writes and snapshots. One of `append`, `independent_nonpersistent`, `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`. Default: `persistent`. For more information on these option, please refer to the [product documentation][vmware-docs-disk-mode].
     * 
     */
    @Import(name="diskMode")
    private @Nullable Output<String> diskMode;

    /**
     * @return The mode of this this virtual disk for purposes of writes and snapshots. One of `append`, `independent_nonpersistent`, `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`. Default: `persistent`. For more information on these option, please refer to the [product documentation][vmware-docs-disk-mode].
     * 
     */
    public Optional<Output<String>> diskMode() {
        return Optional.ofNullable(this.diskMode);
    }

    /**
     * The sharing mode of this virtual disk. One of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
     * 
     * &gt; **NOTE:** Disk sharing is only available on vSphere 6.0 and later.
     * 
     */
    @Import(name="diskSharing")
    private @Nullable Output<String> diskSharing;

    /**
     * @return The sharing mode of this virtual disk. One of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
     * 
     * &gt; **NOTE:** Disk sharing is only available on vSphere 6.0 and later.
     * 
     */
    public Optional<Output<String>> diskSharing() {
        return Optional.ofNullable(this.diskSharing);
    }

    /**
     * If set to `true`, the disk space is zeroed out when the virtual machine is created. This will delay the creation of the virtual disk. Cannot be set to `true` when `thin_provisioned` is `true`.  See the section on picking a disk type for more information.  Default: `false`.
     * 
     */
    @Import(name="eagerlyScrub")
    private @Nullable Output<Boolean> eagerlyScrub;

    /**
     * @return If set to `true`, the disk space is zeroed out when the virtual machine is created. This will delay the creation of the virtual disk. Cannot be set to `true` when `thin_provisioned` is `true`.  See the section on picking a disk type for more information.  Default: `false`.
     * 
     */
    public Optional<Output<Boolean>> eagerlyScrub() {
        return Optional.ofNullable(this.eagerlyScrub);
    }

    /**
     * The upper limit of IOPS that this disk can use. The default is no limit.
     * 
     */
    @Import(name="ioLimit")
    private @Nullable Output<Integer> ioLimit;

    /**
     * @return The upper limit of IOPS that this disk can use. The default is no limit.
     * 
     */
    public Optional<Output<Integer>> ioLimit() {
        return Optional.ofNullable(this.ioLimit);
    }

    /**
     * The I/O reservation (guarantee) for the virtual disk has, in IOPS.  The default is no reservation.
     * 
     */
    @Import(name="ioReservation")
    private @Nullable Output<Integer> ioReservation;

    /**
     * @return The I/O reservation (guarantee) for the virtual disk has, in IOPS.  The default is no reservation.
     * 
     */
    public Optional<Output<Integer>> ioReservation() {
        return Optional.ofNullable(this.ioReservation);
    }

    /**
     * The share count for the virtual disk when the share level is `custom`.
     * 
     */
    @Import(name="ioShareCount")
    private @Nullable Output<Integer> ioShareCount;

    /**
     * @return The share count for the virtual disk when the share level is `custom`.
     * 
     */
    public Optional<Output<Integer>> ioShareCount() {
        return Optional.ofNullable(this.ioShareCount);
    }

    /**
     * The share allocation level for the virtual disk. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
     * 
     */
    @Import(name="ioShareLevel")
    private @Nullable Output<String> ioShareLevel;

    /**
     * @return The share allocation level for the virtual disk. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
     * 
     */
    public Optional<Output<String>> ioShareLevel() {
        return Optional.ofNullable(this.ioShareLevel);
    }

    /**
     * Keep this disk when removing the device or destroying the virtual machine. Default: `false`.
     * 
     */
    @Import(name="keepOnRemove")
    private @Nullable Output<Boolean> keepOnRemove;

    /**
     * @return Keep this disk when removing the device or destroying the virtual machine. Default: `false`.
     * 
     */
    public Optional<Output<Boolean>> keepOnRemove() {
        return Optional.ofNullable(this.keepOnRemove);
    }

    /**
     * The ID of the device within the virtual machine.
     * 
     */
    @Import(name="key")
    private @Nullable Output<Integer> key;

    /**
     * @return The ID of the device within the virtual machine.
     * 
     */
    public Optional<Output<Integer>> key() {
        return Optional.ofNullable(this.key);
    }

    @Import(name="label", required=true)
    private Output<String> label;

    public Output<String> label() {
        return this.label;
    }

    /**
     * When using `attach`, this parameter controls the path of a virtual disk to attach externally. Otherwise, it is a computed attribute that contains the virtual disk filename.
     * 
     */
    @Import(name="path")
    private @Nullable Output<String> path;

    /**
     * @return When using `attach`, this parameter controls the path of a virtual disk to attach externally. Otherwise, it is a computed attribute that contains the virtual disk filename.
     * 
     */
    public Optional<Output<String>> path() {
        return Optional.ofNullable(this.path);
    }

    /**
     * The size of the disk, in GB. Must be a whole number.
     * 
     */
    @Import(name="size")
    private @Nullable Output<Integer> size;

    /**
     * @return The size of the disk, in GB. Must be a whole number.
     * 
     */
    public Optional<Output<Integer>> size() {
        return Optional.ofNullable(this.size);
    }

    /**
     * The UUID of the storage policy to assign to the virtual disk.
     * 
     */
    @Import(name="storagePolicyId")
    private @Nullable Output<String> storagePolicyId;

    /**
     * @return The UUID of the storage policy to assign to the virtual disk.
     * 
     */
    public Optional<Output<String>> storagePolicyId() {
        return Optional.ofNullable(this.storagePolicyId);
    }

    /**
     * If `true`, the disk is thin provisioned, with space for the file being allocated on an as-needed basis. Cannot be set to `true` when `eagerly_scrub` is `true`. See the section on selecting a disk type for more information. Default: `true`.
     * 
     */
    @Import(name="thinProvisioned")
    private @Nullable Output<Boolean> thinProvisioned;

    /**
     * @return If `true`, the disk is thin provisioned, with space for the file being allocated on an as-needed basis. Cannot be set to `true` when `eagerly_scrub` is `true`. See the section on selecting a disk type for more information. Default: `true`.
     * 
     */
    public Optional<Output<Boolean>> thinProvisioned() {
        return Optional.ofNullable(this.thinProvisioned);
    }

    /**
     * The disk number on the storage bus. The maximum value for this setting is the value of the controller count times the controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE). Duplicate unit numbers are not allowed. Default `0`, for which one disk must be set to.
     * 
     */
    @Import(name="unitNumber")
    private @Nullable Output<Integer> unitNumber;

    /**
     * @return The disk number on the storage bus. The maximum value for this setting is the value of the controller count times the controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE). Duplicate unit numbers are not allowed. Default `0`, for which one disk must be set to.
     * 
     */
    public Optional<Output<Integer>> unitNumber() {
        return Optional.ofNullable(this.unitNumber);
    }

    /**
     * The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.
     * 
     */
    @Import(name="uuid")
    private @Nullable Output<String> uuid;

    /**
     * @return The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.
     * 
     */
    public Optional<Output<String>> uuid() {
        return Optional.ofNullable(this.uuid);
    }

    /**
     * If `true`, writes for this disk are sent directly to the filesystem immediately instead of being buffered. Default: `false`.
     * 
     */
    @Import(name="writeThrough")
    private @Nullable Output<Boolean> writeThrough;

    /**
     * @return If `true`, writes for this disk are sent directly to the filesystem immediately instead of being buffered. Default: `false`.
     * 
     */
    public Optional<Output<Boolean>> writeThrough() {
        return Optional.ofNullable(this.writeThrough);
    }

    private VirtualMachineDiskArgs() {}

    private VirtualMachineDiskArgs(VirtualMachineDiskArgs $) {
        this.attach = $.attach;
        this.controllerType = $.controllerType;
        this.datastoreId = $.datastoreId;
        this.deviceAddress = $.deviceAddress;
        this.diskMode = $.diskMode;
        this.diskSharing = $.diskSharing;
        this.eagerlyScrub = $.eagerlyScrub;
        this.ioLimit = $.ioLimit;
        this.ioReservation = $.ioReservation;
        this.ioShareCount = $.ioShareCount;
        this.ioShareLevel = $.ioShareLevel;
        this.keepOnRemove = $.keepOnRemove;
        this.key = $.key;
        this.label = $.label;
        this.path = $.path;
        this.size = $.size;
        this.storagePolicyId = $.storagePolicyId;
        this.thinProvisioned = $.thinProvisioned;
        this.unitNumber = $.unitNumber;
        this.uuid = $.uuid;
        this.writeThrough = $.writeThrough;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(VirtualMachineDiskArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private VirtualMachineDiskArgs $;

        public Builder() {
            $ = new VirtualMachineDiskArgs();
        }

        public Builder(VirtualMachineDiskArgs defaults) {
            $ = new VirtualMachineDiskArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param attach Attach an external disk instead of creating a new one. Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`, `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
         * 
         * &gt; **NOTE:** External disks cannot be attached when `datastore_cluster_id` is used.
         * 
         * @return builder
         * 
         */
        public Builder attach(@Nullable Output<Boolean> attach) {
            $.attach = attach;
            return this;
        }

        /**
         * @param attach Attach an external disk instead of creating a new one. Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`, `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
         * 
         * &gt; **NOTE:** External disks cannot be attached when `datastore_cluster_id` is used.
         * 
         * @return builder
         * 
         */
        public Builder attach(Boolean attach) {
            return attach(Output.of(attach));
        }

        /**
         * @param controllerType The type of storage controller to attach the  disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate number of controllers enabled for the selected type. Default `scsi`.
         * 
         * @return builder
         * 
         */
        public Builder controllerType(@Nullable Output<String> controllerType) {
            $.controllerType = controllerType;
            return this;
        }

        /**
         * @param controllerType The type of storage controller to attach the  disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate number of controllers enabled for the selected type. Default `scsi`.
         * 
         * @return builder
         * 
         */
        public Builder controllerType(String controllerType) {
            return controllerType(Output.of(controllerType));
        }

        /**
         * @param datastoreId The [managed object reference ID][docs-about-morefs] for the datastore on which the virtual disk is placed. The default is to use the datastore of the virtual machine. See the section on virtual machine migration for information on modifying this value.
         * 
         * &gt; **NOTE:** Datastores cannot be assigned to individual disks when `datastore_cluster_id` is used.
         * 
         * @return builder
         * 
         */
        public Builder datastoreId(@Nullable Output<String> datastoreId) {
            $.datastoreId = datastoreId;
            return this;
        }

        /**
         * @param datastoreId The [managed object reference ID][docs-about-morefs] for the datastore on which the virtual disk is placed. The default is to use the datastore of the virtual machine. See the section on virtual machine migration for information on modifying this value.
         * 
         * &gt; **NOTE:** Datastores cannot be assigned to individual disks when `datastore_cluster_id` is used.
         * 
         * @return builder
         * 
         */
        public Builder datastoreId(String datastoreId) {
            return datastoreId(Output.of(datastoreId));
        }

        public Builder deviceAddress(@Nullable Output<String> deviceAddress) {
            $.deviceAddress = deviceAddress;
            return this;
        }

        public Builder deviceAddress(String deviceAddress) {
            return deviceAddress(Output.of(deviceAddress));
        }

        /**
         * @param diskMode The mode of this this virtual disk for purposes of writes and snapshots. One of `append`, `independent_nonpersistent`, `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`. Default: `persistent`. For more information on these option, please refer to the [product documentation][vmware-docs-disk-mode].
         * 
         * @return builder
         * 
         */
        public Builder diskMode(@Nullable Output<String> diskMode) {
            $.diskMode = diskMode;
            return this;
        }

        /**
         * @param diskMode The mode of this this virtual disk for purposes of writes and snapshots. One of `append`, `independent_nonpersistent`, `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`. Default: `persistent`. For more information on these option, please refer to the [product documentation][vmware-docs-disk-mode].
         * 
         * @return builder
         * 
         */
        public Builder diskMode(String diskMode) {
            return diskMode(Output.of(diskMode));
        }

        /**
         * @param diskSharing The sharing mode of this virtual disk. One of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
         * 
         * &gt; **NOTE:** Disk sharing is only available on vSphere 6.0 and later.
         * 
         * @return builder
         * 
         */
        public Builder diskSharing(@Nullable Output<String> diskSharing) {
            $.diskSharing = diskSharing;
            return this;
        }

        /**
         * @param diskSharing The sharing mode of this virtual disk. One of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
         * 
         * &gt; **NOTE:** Disk sharing is only available on vSphere 6.0 and later.
         * 
         * @return builder
         * 
         */
        public Builder diskSharing(String diskSharing) {
            return diskSharing(Output.of(diskSharing));
        }

        /**
         * @param eagerlyScrub If set to `true`, the disk space is zeroed out when the virtual machine is created. This will delay the creation of the virtual disk. Cannot be set to `true` when `thin_provisioned` is `true`.  See the section on picking a disk type for more information.  Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder eagerlyScrub(@Nullable Output<Boolean> eagerlyScrub) {
            $.eagerlyScrub = eagerlyScrub;
            return this;
        }

        /**
         * @param eagerlyScrub If set to `true`, the disk space is zeroed out when the virtual machine is created. This will delay the creation of the virtual disk. Cannot be set to `true` when `thin_provisioned` is `true`.  See the section on picking a disk type for more information.  Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder eagerlyScrub(Boolean eagerlyScrub) {
            return eagerlyScrub(Output.of(eagerlyScrub));
        }

        /**
         * @param ioLimit The upper limit of IOPS that this disk can use. The default is no limit.
         * 
         * @return builder
         * 
         */
        public Builder ioLimit(@Nullable Output<Integer> ioLimit) {
            $.ioLimit = ioLimit;
            return this;
        }

        /**
         * @param ioLimit The upper limit of IOPS that this disk can use. The default is no limit.
         * 
         * @return builder
         * 
         */
        public Builder ioLimit(Integer ioLimit) {
            return ioLimit(Output.of(ioLimit));
        }

        /**
         * @param ioReservation The I/O reservation (guarantee) for the virtual disk has, in IOPS.  The default is no reservation.
         * 
         * @return builder
         * 
         */
        public Builder ioReservation(@Nullable Output<Integer> ioReservation) {
            $.ioReservation = ioReservation;
            return this;
        }

        /**
         * @param ioReservation The I/O reservation (guarantee) for the virtual disk has, in IOPS.  The default is no reservation.
         * 
         * @return builder
         * 
         */
        public Builder ioReservation(Integer ioReservation) {
            return ioReservation(Output.of(ioReservation));
        }

        /**
         * @param ioShareCount The share count for the virtual disk when the share level is `custom`.
         * 
         * @return builder
         * 
         */
        public Builder ioShareCount(@Nullable Output<Integer> ioShareCount) {
            $.ioShareCount = ioShareCount;
            return this;
        }

        /**
         * @param ioShareCount The share count for the virtual disk when the share level is `custom`.
         * 
         * @return builder
         * 
         */
        public Builder ioShareCount(Integer ioShareCount) {
            return ioShareCount(Output.of(ioShareCount));
        }

        /**
         * @param ioShareLevel The share allocation level for the virtual disk. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
         * 
         * @return builder
         * 
         */
        public Builder ioShareLevel(@Nullable Output<String> ioShareLevel) {
            $.ioShareLevel = ioShareLevel;
            return this;
        }

        /**
         * @param ioShareLevel The share allocation level for the virtual disk. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
         * 
         * @return builder
         * 
         */
        public Builder ioShareLevel(String ioShareLevel) {
            return ioShareLevel(Output.of(ioShareLevel));
        }

        /**
         * @param keepOnRemove Keep this disk when removing the device or destroying the virtual machine. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder keepOnRemove(@Nullable Output<Boolean> keepOnRemove) {
            $.keepOnRemove = keepOnRemove;
            return this;
        }

        /**
         * @param keepOnRemove Keep this disk when removing the device or destroying the virtual machine. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder keepOnRemove(Boolean keepOnRemove) {
            return keepOnRemove(Output.of(keepOnRemove));
        }

        /**
         * @param key The ID of the device within the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder key(@Nullable Output<Integer> key) {
            $.key = key;
            return this;
        }

        /**
         * @param key The ID of the device within the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder key(Integer key) {
            return key(Output.of(key));
        }

        public Builder label(Output<String> label) {
            $.label = label;
            return this;
        }

        public Builder label(String label) {
            return label(Output.of(label));
        }

        /**
         * @param path When using `attach`, this parameter controls the path of a virtual disk to attach externally. Otherwise, it is a computed attribute that contains the virtual disk filename.
         * 
         * @return builder
         * 
         */
        public Builder path(@Nullable Output<String> path) {
            $.path = path;
            return this;
        }

        /**
         * @param path When using `attach`, this parameter controls the path of a virtual disk to attach externally. Otherwise, it is a computed attribute that contains the virtual disk filename.
         * 
         * @return builder
         * 
         */
        public Builder path(String path) {
            return path(Output.of(path));
        }

        /**
         * @param size The size of the disk, in GB. Must be a whole number.
         * 
         * @return builder
         * 
         */
        public Builder size(@Nullable Output<Integer> size) {
            $.size = size;
            return this;
        }

        /**
         * @param size The size of the disk, in GB. Must be a whole number.
         * 
         * @return builder
         * 
         */
        public Builder size(Integer size) {
            return size(Output.of(size));
        }

        /**
         * @param storagePolicyId The UUID of the storage policy to assign to the virtual disk.
         * 
         * @return builder
         * 
         */
        public Builder storagePolicyId(@Nullable Output<String> storagePolicyId) {
            $.storagePolicyId = storagePolicyId;
            return this;
        }

        /**
         * @param storagePolicyId The UUID of the storage policy to assign to the virtual disk.
         * 
         * @return builder
         * 
         */
        public Builder storagePolicyId(String storagePolicyId) {
            return storagePolicyId(Output.of(storagePolicyId));
        }

        /**
         * @param thinProvisioned If `true`, the disk is thin provisioned, with space for the file being allocated on an as-needed basis. Cannot be set to `true` when `eagerly_scrub` is `true`. See the section on selecting a disk type for more information. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder thinProvisioned(@Nullable Output<Boolean> thinProvisioned) {
            $.thinProvisioned = thinProvisioned;
            return this;
        }

        /**
         * @param thinProvisioned If `true`, the disk is thin provisioned, with space for the file being allocated on an as-needed basis. Cannot be set to `true` when `eagerly_scrub` is `true`. See the section on selecting a disk type for more information. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder thinProvisioned(Boolean thinProvisioned) {
            return thinProvisioned(Output.of(thinProvisioned));
        }

        /**
         * @param unitNumber The disk number on the storage bus. The maximum value for this setting is the value of the controller count times the controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE). Duplicate unit numbers are not allowed. Default `0`, for which one disk must be set to.
         * 
         * @return builder
         * 
         */
        public Builder unitNumber(@Nullable Output<Integer> unitNumber) {
            $.unitNumber = unitNumber;
            return this;
        }

        /**
         * @param unitNumber The disk number on the storage bus. The maximum value for this setting is the value of the controller count times the controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE). Duplicate unit numbers are not allowed. Default `0`, for which one disk must be set to.
         * 
         * @return builder
         * 
         */
        public Builder unitNumber(Integer unitNumber) {
            return unitNumber(Output.of(unitNumber));
        }

        /**
         * @param uuid The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder uuid(@Nullable Output<String> uuid) {
            $.uuid = uuid;
            return this;
        }

        /**
         * @param uuid The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder uuid(String uuid) {
            return uuid(Output.of(uuid));
        }

        /**
         * @param writeThrough If `true`, writes for this disk are sent directly to the filesystem immediately instead of being buffered. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder writeThrough(@Nullable Output<Boolean> writeThrough) {
            $.writeThrough = writeThrough;
            return this;
        }

        /**
         * @param writeThrough If `true`, writes for this disk are sent directly to the filesystem immediately instead of being buffered. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder writeThrough(Boolean writeThrough) {
            return writeThrough(Output.of(writeThrough));
        }

        public VirtualMachineDiskArgs build() {
            $.label = Objects.requireNonNull($.label, "expected parameter 'label' to be non-null");
            return $;
        }
    }

}
