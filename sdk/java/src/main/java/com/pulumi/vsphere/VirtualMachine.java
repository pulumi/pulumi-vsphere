// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.vsphere.Utilities;
import com.pulumi.vsphere.VirtualMachineArgs;
import com.pulumi.vsphere.inputs.VirtualMachineState;
import com.pulumi.vsphere.outputs.VirtualMachineCdrom;
import com.pulumi.vsphere.outputs.VirtualMachineClone;
import com.pulumi.vsphere.outputs.VirtualMachineDisk;
import com.pulumi.vsphere.outputs.VirtualMachineNetworkInterface;
import com.pulumi.vsphere.outputs.VirtualMachineOvfDeploy;
import com.pulumi.vsphere.outputs.VirtualMachineVapp;
import com.pulumi.vsphere.outputs.VirtualMachineVtpm;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Import
 * 
 * ### Additional Importing Requirements
 * 
 * Many of the requirements for [cloning](#additional-requirements-and-notes-for-cloning) apply to importing. Although importing writes directly to the Terraform state, some rules can not be enforced during import time, so every effort should be made to ensure the correctness of the configuration before the import.
 * 
 * The following requirements apply to import:
 * 
 * * The disks must have a [`label`](#label) argument assigned in a convention matching `Hard Disk`, starting with disk number 0, based on each virtual disk order on the SCSI bus. As an example, a disk on SCSI controller `0` with a unit number of `0` would be labeled as `Hard Disk 0`, a disk on the same controller with a unit number of `1` would be `Hard Disk 1`, but the next disk, which is on SCSI controller `1` with a unit number of `0`, still becomes `Hard Disk 2`.
 * 
 * * Disks are always imported with [`keep_on_remove`](#keep_on_remove) enabled until the first `pulumi up` run which will remove the setting for known disks. This process safeguards against naming or accounting mistakes in the disk configuration.
 * 
 * * The storage controller count for the resource is set to the number of contiguous storage controllers found, starting with the controller at SCSI bus number `0`. If no storage controllers are discovered, the virtual machine is not eligible for import. For maximum compatibility, ensure that the virtual machine has the exact number of storage controllers needed and set the storage controller count accordingly.
 * 
 * After importing, you should run `pulumi preview`. Unless you have changed anything else in the configuration that would cause other attributes to change. The only difference should be configuration-only changes, which are typically comprised of:
 * 
 * * The [`imported`](#imported) flag will transition from `true` to `false`.
 * 
 * * The [`keep_on_remove`](#keep_on_remove) of known disks will transition from `true` to `false`.
 * 
 * * Configuration supplied in the [`clone`](#clone) block, if present, will be persisted to state. This initial persistence operation does not perform any cloning or customization actions, nor does it force a new resource. After the first apply operation, further changes to `clone` will force the creation of a new resource.
 * 
 * These changes only update Terraform state when applied. Hence, it is safe to run when the virtual machine is running. If more settings are modified, you may need to plan maintenance accordingly for any necessary virtual machine re-configurations.
 * 
 */
@ResourceType(type="vsphere:index/virtualMachine:VirtualMachine")
public class VirtualMachine extends com.pulumi.resources.CustomResource {
    /**
     * The guest name for the operating system when guest_id is otherGuest or otherGuest64.
     * 
     */
    @Export(name="alternateGuestName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> alternateGuestName;

    /**
     * @return The guest name for the operating system when guest_id is otherGuest or otherGuest64.
     * 
     */
    public Output<Optional<String>> alternateGuestName() {
        return Codegen.optional(this.alternateGuestName);
    }
    /**
     * User-provided description of the virtual machine.
     * 
     */
    @Export(name="annotation", refs={String.class}, tree="[0]")
    private Output<String> annotation;

    /**
     * @return User-provided description of the virtual machine.
     * 
     */
    public Output<String> annotation() {
        return this.annotation;
    }
    /**
     * The number of milliseconds to wait before starting the boot sequence.
     * 
     */
    @Export(name="bootDelay", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> bootDelay;

    /**
     * @return The number of milliseconds to wait before starting the boot sequence.
     * 
     */
    public Output<Optional<Integer>> bootDelay() {
        return Codegen.optional(this.bootDelay);
    }
    /**
     * The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.
     * 
     */
    @Export(name="bootRetryDelay", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> bootRetryDelay;

    /**
     * @return The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.
     * 
     */
    public Output<Optional<Integer>> bootRetryDelay() {
        return Codegen.optional(this.bootRetryDelay);
    }
    /**
     * If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
     * 
     */
    @Export(name="bootRetryEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> bootRetryEnabled;

    /**
     * @return If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
     * 
     */
    public Output<Optional<Boolean>> bootRetryEnabled() {
        return Codegen.optional(this.bootRetryEnabled);
    }
    /**
     * A specification for a CDROM device on this virtual machine.
     * 
     */
    @Export(name="cdroms", refs={List.class,VirtualMachineCdrom.class}, tree="[0,1]")
    private Output</* @Nullable */ List<VirtualMachineCdrom>> cdroms;

    /**
     * @return A specification for a CDROM device on this virtual machine.
     * 
     */
    public Output<Optional<List<VirtualMachineCdrom>>> cdroms() {
        return Codegen.optional(this.cdroms);
    }
    /**
     * A unique identifier for a given version of the last configuration was applied.
     * 
     */
    @Export(name="changeVersion", refs={String.class}, tree="[0]")
    private Output<String> changeVersion;

    /**
     * @return A unique identifier for a given version of the last configuration was applied.
     * 
     */
    public Output<String> changeVersion() {
        return this.changeVersion;
    }
    /**
     * A specification for cloning a virtual machine from template.
     * 
     */
    @Export(name="clone", refs={VirtualMachineClone.class}, tree="[0]")
    private Output</* @Nullable */ VirtualMachineClone> clone;

    /**
     * @return A specification for cloning a virtual machine from template.
     * 
     */
    public Output<Optional<VirtualMachineClone>> clone_() {
        return Codegen.optional(this.clone);
    }
    /**
     * Allow CPUs to be added to this virtual machine while it is running.
     * 
     */
    @Export(name="cpuHotAddEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> cpuHotAddEnabled;

    /**
     * @return Allow CPUs to be added to this virtual machine while it is running.
     * 
     */
    public Output<Optional<Boolean>> cpuHotAddEnabled() {
        return Codegen.optional(this.cpuHotAddEnabled);
    }
    /**
     * Allow CPUs to be added to this virtual machine while it is running.
     * 
     */
    @Export(name="cpuHotRemoveEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> cpuHotRemoveEnabled;

    /**
     * @return Allow CPUs to be added to this virtual machine while it is running.
     * 
     */
    public Output<Optional<Boolean>> cpuHotRemoveEnabled() {
        return Codegen.optional(this.cpuHotRemoveEnabled);
    }
    /**
     * The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
     * 
     */
    @Export(name="cpuLimit", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> cpuLimit;

    /**
     * @return The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
     * 
     */
    public Output<Optional<Integer>> cpuLimit() {
        return Codegen.optional(this.cpuLimit);
    }
    /**
     * Enable CPU performance counters on this virtual machine.
     * 
     */
    @Export(name="cpuPerformanceCountersEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> cpuPerformanceCountersEnabled;

    /**
     * @return Enable CPU performance counters on this virtual machine.
     * 
     */
    public Output<Optional<Boolean>> cpuPerformanceCountersEnabled() {
        return Codegen.optional(this.cpuPerformanceCountersEnabled);
    }
    /**
     * The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
     * 
     */
    @Export(name="cpuReservation", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> cpuReservation;

    /**
     * @return The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
     * 
     */
    public Output<Optional<Integer>> cpuReservation() {
        return Codegen.optional(this.cpuReservation);
    }
    /**
     * The amount of shares to allocate to cpu for a custom share level.
     * 
     */
    @Export(name="cpuShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> cpuShareCount;

    /**
     * @return The amount of shares to allocate to cpu for a custom share level.
     * 
     */
    public Output<Integer> cpuShareCount() {
        return this.cpuShareCount;
    }
    /**
     * The allocation level for cpu resources. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="cpuShareLevel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> cpuShareLevel;

    /**
     * @return The allocation level for cpu resources. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<Optional<String>> cpuShareLevel() {
        return Codegen.optional(this.cpuShareLevel);
    }
    /**
     * A list of custom attributes to set on this resource.
     * 
     */
    @Export(name="customAttributes", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> customAttributes;

    /**
     * @return A list of custom attributes to set on this resource.
     * 
     */
    public Output<Optional<Map<String,String>>> customAttributes() {
        return Codegen.optional(this.customAttributes);
    }
    /**
     * The ID of the datacenter where the VM is to be created.
     * 
     */
    @Export(name="datacenterId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> datacenterId;

    /**
     * @return The ID of the datacenter where the VM is to be created.
     * 
     */
    public Output<Optional<String>> datacenterId() {
        return Codegen.optional(this.datacenterId);
    }
    /**
     * The ID of a datastore cluster to put the virtual machine in.
     * 
     */
    @Export(name="datastoreClusterId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> datastoreClusterId;

    /**
     * @return The ID of a datastore cluster to put the virtual machine in.
     * 
     */
    public Output<Optional<String>> datastoreClusterId() {
        return Codegen.optional(this.datastoreClusterId);
    }
    /**
     * The ID of the virtual machine&#39;s datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
     * 
     */
    @Export(name="datastoreId", refs={String.class}, tree="[0]")
    private Output<String> datastoreId;

    /**
     * @return The ID of the virtual machine&#39;s datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
     * 
     */
    public Output<String> datastoreId() {
        return this.datastoreId;
    }
    /**
     * The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.
     * 
     */
    @Export(name="defaultIpAddress", refs={String.class}, tree="[0]")
    private Output<String> defaultIpAddress;

    /**
     * @return The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.
     * 
     */
    public Output<String> defaultIpAddress() {
        return this.defaultIpAddress;
    }
    /**
     * A specification for a virtual disk device on this virtual machine.
     * 
     */
    @Export(name="disks", refs={List.class,VirtualMachineDisk.class}, tree="[0,1]")
    private Output<List<VirtualMachineDisk>> disks;

    /**
     * @return A specification for a virtual disk device on this virtual machine.
     * 
     */
    public Output<List<VirtualMachineDisk>> disks() {
        return this.disks;
    }
    /**
     * When the boot type set in firmware is efi, this enables EFI secure boot.
     * 
     */
    @Export(name="efiSecureBootEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> efiSecureBootEnabled;

    /**
     * @return When the boot type set in firmware is efi, this enables EFI secure boot.
     * 
     */
    public Output<Optional<Boolean>> efiSecureBootEnabled() {
        return Codegen.optional(this.efiSecureBootEnabled);
    }
    /**
     * Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
     * 
     */
    @Export(name="enableDiskUuid", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableDiskUuid;

    /**
     * @return Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
     * 
     */
    public Output<Optional<Boolean>> enableDiskUuid() {
        return Codegen.optional(this.enableDiskUuid);
    }
    /**
     * Enable logging on this virtual machine.
     * 
     */
    @Export(name="enableLogging", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableLogging;

    /**
     * @return Enable logging on this virtual machine.
     * 
     */
    public Output<Optional<Boolean>> enableLogging() {
        return Codegen.optional(this.enableLogging);
    }
    /**
     * The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
     * 
     */
    @Export(name="eptRviMode", refs={String.class}, tree="[0]")
    private Output<String> eptRviMode;

    /**
     * @return The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
     * 
     */
    public Output<String> eptRviMode() {
        return this.eptRviMode;
    }
    /**
     * Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
     * 
     */
    @Export(name="extraConfig", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> extraConfig;

    /**
     * @return Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
     * 
     */
    public Output<Optional<Map<String,String>>> extraConfig() {
        return Codegen.optional(this.extraConfig);
    }
    /**
     * Allow the virtual machine to be rebooted when a change to `extra_config` occurs.
     * 
     */
    @Export(name="extraConfigRebootRequired", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> extraConfigRebootRequired;

    /**
     * @return Allow the virtual machine to be rebooted when a change to `extra_config` occurs.
     * 
     */
    public Output<Optional<Boolean>> extraConfigRebootRequired() {
        return Codegen.optional(this.extraConfigRebootRequired);
    }
    /**
     * The firmware interface to use on the virtual machine. Can be one of bios or efi.
     * 
     */
    @Export(name="firmware", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> firmware;

    /**
     * @return The firmware interface to use on the virtual machine. Can be one of bios or efi.
     * 
     */
    public Output<Optional<String>> firmware() {
        return Codegen.optional(this.firmware);
    }
    /**
     * The name of the folder to locate the virtual machine in.
     * 
     */
    @Export(name="folder", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> folder;

    /**
     * @return The name of the folder to locate the virtual machine in.
     * 
     */
    public Output<Optional<String>> folder() {
        return Codegen.optional(this.folder);
    }
    /**
     * Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
     * 
     */
    @Export(name="forcePowerOff", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forcePowerOff;

    /**
     * @return Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
     * 
     */
    public Output<Optional<Boolean>> forcePowerOff() {
        return Codegen.optional(this.forcePowerOff);
    }
    /**
     * The guest ID for the operating system.
     * 
     */
    @Export(name="guestId", refs={String.class}, tree="[0]")
    private Output<String> guestId;

    /**
     * @return The guest ID for the operating system.
     * 
     */
    public Output<String> guestId() {
        return this.guestId;
    }
    /**
     * The current list of IP addresses on this machine, including the value of `default_ip_address`. If VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this list will be empty.
     * 
     */
    @Export(name="guestIpAddresses", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> guestIpAddresses;

    /**
     * @return The current list of IP addresses on this machine, including the value of `default_ip_address`. If VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this list will be empty.
     * 
     */
    public Output<List<String>> guestIpAddresses() {
        return this.guestIpAddresses;
    }
    /**
     * The hardware version for the virtual machine. Allows versions within ranges: 4, 7-11, 13-15, 17-22.
     * 
     */
    @Export(name="hardwareVersion", refs={Integer.class}, tree="[0]")
    private Output<Integer> hardwareVersion;

    /**
     * @return The hardware version for the virtual machine. Allows versions within ranges: 4, 7-11, 13-15, 17-22.
     * 
     */
    public Output<Integer> hardwareVersion() {
        return this.hardwareVersion;
    }
    /**
     * The ID of an optional host system to pin the virtual machine to.
     * 
     */
    @Export(name="hostSystemId", refs={String.class}, tree="[0]")
    private Output<String> hostSystemId;

    /**
     * @return The ID of an optional host system to pin the virtual machine to.
     * 
     */
    public Output<String> hostSystemId() {
        return this.hostSystemId;
    }
    /**
     * The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
     * 
     */
    @Export(name="hvMode", refs={String.class}, tree="[0]")
    private Output<String> hvMode;

    /**
     * @return The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
     * 
     */
    public Output<String> hvMode() {
        return this.hvMode;
    }
    @Export(name="ideControllerCount", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> ideControllerCount;

    public Output<Optional<Integer>> ideControllerCount() {
        return Codegen.optional(this.ideControllerCount);
    }
    /**
     * List of IP addresses and CIDR networks to ignore while waiting for an IP
     * 
     */
    @Export(name="ignoredGuestIps", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> ignoredGuestIps;

    /**
     * @return List of IP addresses and CIDR networks to ignore while waiting for an IP
     * 
     */
    public Output<Optional<List<String>>> ignoredGuestIps() {
        return Codegen.optional(this.ignoredGuestIps);
    }
    /**
     * Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.
     * 
     */
    @Export(name="imported", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> imported;

    /**
     * @return Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.
     * 
     */
    public Output<Boolean> imported() {
        return this.imported;
    }
    /**
     * Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
     * 
     */
    @Export(name="latencySensitivity", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> latencySensitivity;

    /**
     * @return Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
     * 
     */
    public Output<Optional<String>> latencySensitivity() {
        return Codegen.optional(this.latencySensitivity);
    }
    /**
     * The size of the virtual machine&#39;s memory, in MB.
     * 
     */
    @Export(name="memory", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> memory;

    /**
     * @return The size of the virtual machine&#39;s memory, in MB.
     * 
     */
    public Output<Optional<Integer>> memory() {
        return Codegen.optional(this.memory);
    }
    /**
     * Allow memory to be added to this virtual machine while it is running.
     * 
     */
    @Export(name="memoryHotAddEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> memoryHotAddEnabled;

    /**
     * @return Allow memory to be added to this virtual machine while it is running.
     * 
     */
    public Output<Optional<Boolean>> memoryHotAddEnabled() {
        return Codegen.optional(this.memoryHotAddEnabled);
    }
    /**
     * The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
     * 
     */
    @Export(name="memoryLimit", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> memoryLimit;

    /**
     * @return The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
     * 
     */
    public Output<Optional<Integer>> memoryLimit() {
        return Codegen.optional(this.memoryLimit);
    }
    /**
     * The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
     * 
     */
    @Export(name="memoryReservation", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> memoryReservation;

    /**
     * @return The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
     * 
     */
    public Output<Optional<Integer>> memoryReservation() {
        return Codegen.optional(this.memoryReservation);
    }
    /**
     * If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine&#39;s memory size;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature may only be enabled if it is currently possible to reserve all of the virtual machine&#39;s memory.
     * 
     */
    @Export(name="memoryReservationLockedToMax", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> memoryReservationLockedToMax;

    /**
     * @return If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine&#39;s memory size;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature may only be enabled if it is currently possible to reserve all of the virtual machine&#39;s memory.
     * 
     */
    public Output<Optional<Boolean>> memoryReservationLockedToMax() {
        return Codegen.optional(this.memoryReservationLockedToMax);
    }
    /**
     * The amount of shares to allocate to memory for a custom share level.
     * 
     */
    @Export(name="memoryShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> memoryShareCount;

    /**
     * @return The amount of shares to allocate to memory for a custom share level.
     * 
     */
    public Output<Integer> memoryShareCount() {
        return this.memoryShareCount;
    }
    /**
     * The allocation level for memory resources. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="memoryShareLevel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> memoryShareLevel;

    /**
     * @return The allocation level for memory resources. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<Optional<String>> memoryShareLevel() {
        return Codegen.optional(this.memoryShareLevel);
    }
    /**
     * The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
     * 
     */
    @Export(name="migrateWaitTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> migrateWaitTimeout;

    /**
     * @return The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
     * 
     */
    public Output<Optional<Integer>> migrateWaitTimeout() {
        return Codegen.optional(this.migrateWaitTimeout);
    }
    /**
     * The managed object reference ID of the created virtual machine.
     * 
     */
    @Export(name="moid", refs={String.class}, tree="[0]")
    private Output<String> moid;

    /**
     * @return The managed object reference ID of the created virtual machine.
     * 
     */
    public Output<String> moid() {
        return this.moid;
    }
    /**
     * The name of this virtual machine.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of this virtual machine.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
     * 
     */
    @Export(name="nestedHvEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> nestedHvEnabled;

    /**
     * @return Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
     * 
     */
    public Output<Optional<Boolean>> nestedHvEnabled() {
        return Codegen.optional(this.nestedHvEnabled);
    }
    /**
     * A specification for a virtual NIC on this virtual machine.
     * 
     */
    @Export(name="networkInterfaces", refs={List.class,VirtualMachineNetworkInterface.class}, tree="[0,1]")
    private Output</* @Nullable */ List<VirtualMachineNetworkInterface>> networkInterfaces;

    /**
     * @return A specification for a virtual NIC on this virtual machine.
     * 
     */
    public Output<Optional<List<VirtualMachineNetworkInterface>>> networkInterfaces() {
        return Codegen.optional(this.networkInterfaces);
    }
    /**
     * The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus must be evenly divisible by this value.
     * 
     */
    @Export(name="numCoresPerSocket", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> numCoresPerSocket;

    /**
     * @return The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus must be evenly divisible by this value.
     * 
     */
    public Output<Optional<Integer>> numCoresPerSocket() {
        return Codegen.optional(this.numCoresPerSocket);
    }
    /**
     * The number of virtual processors to assign to this virtual machine.
     * 
     */
    @Export(name="numCpus", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> numCpus;

    /**
     * @return The number of virtual processors to assign to this virtual machine.
     * 
     */
    public Output<Optional<Integer>> numCpus() {
        return Codegen.optional(this.numCpus);
    }
    @Export(name="nvmeControllerCount", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> nvmeControllerCount;

    public Output<Optional<Integer>> nvmeControllerCount() {
        return Codegen.optional(this.nvmeControllerCount);
    }
    /**
     * A specification for deploying a virtual machine from ovf/ova template.
     * 
     */
    @Export(name="ovfDeploy", refs={VirtualMachineOvfDeploy.class}, tree="[0]")
    private Output</* @Nullable */ VirtualMachineOvfDeploy> ovfDeploy;

    /**
     * @return A specification for deploying a virtual machine from ovf/ova template.
     * 
     */
    public Output<Optional<VirtualMachineOvfDeploy>> ovfDeploy() {
        return Codegen.optional(this.ovfDeploy);
    }
    /**
     * A list of PCI passthrough devices
     * 
     */
    @Export(name="pciDeviceIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> pciDeviceIds;

    /**
     * @return A list of PCI passthrough devices
     * 
     */
    public Output<Optional<List<String>>> pciDeviceIds() {
        return Codegen.optional(this.pciDeviceIds);
    }
    /**
     * A computed value for the current power state of the virtual machine. One of `on`, `off`, or `suspended`.
     * 
     */
    @Export(name="powerState", refs={String.class}, tree="[0]")
    private Output<String> powerState;

    /**
     * @return A computed value for the current power state of the virtual machine. One of `on`, `off`, or `suspended`.
     * 
     */
    public Output<String> powerState() {
        return this.powerState;
    }
    /**
     * The amount of time, in seconds, that we will be trying to power on a VM
     * 
     */
    @Export(name="poweronTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> poweronTimeout;

    /**
     * @return The amount of time, in seconds, that we will be trying to power on a VM
     * 
     */
    public Output<Optional<Integer>> poweronTimeout() {
        return Codegen.optional(this.poweronTimeout);
    }
    @Export(name="rebootRequired", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> rebootRequired;

    public Output<Boolean> rebootRequired() {
        return this.rebootRequired;
    }
    /**
     * Triggers replacement of resource whenever it changes.
     * 
     */
    @Export(name="replaceTrigger", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> replaceTrigger;

    /**
     * @return Triggers replacement of resource whenever it changes.
     * 
     */
    public Output<Optional<String>> replaceTrigger() {
        return Codegen.optional(this.replaceTrigger);
    }
    /**
     * The ID of a resource pool to put the virtual machine in.
     * 
     */
    @Export(name="resourcePoolId", refs={String.class}, tree="[0]")
    private Output<String> resourcePoolId;

    /**
     * @return The ID of a resource pool to put the virtual machine in.
     * 
     */
    public Output<String> resourcePoolId() {
        return this.resourcePoolId;
    }
    /**
     * Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
     * 
     */
    @Export(name="runToolsScriptsAfterPowerOn", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> runToolsScriptsAfterPowerOn;

    /**
     * @return Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
     * 
     */
    public Output<Optional<Boolean>> runToolsScriptsAfterPowerOn() {
        return Codegen.optional(this.runToolsScriptsAfterPowerOn);
    }
    /**
     * Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
     * 
     */
    @Export(name="runToolsScriptsAfterResume", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> runToolsScriptsAfterResume;

    /**
     * @return Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
     * 
     */
    public Output<Optional<Boolean>> runToolsScriptsAfterResume() {
        return Codegen.optional(this.runToolsScriptsAfterResume);
    }
    /**
     * Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
     * 
     */
    @Export(name="runToolsScriptsBeforeGuestReboot", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> runToolsScriptsBeforeGuestReboot;

    /**
     * @return Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
     * 
     */
    public Output<Optional<Boolean>> runToolsScriptsBeforeGuestReboot() {
        return Codegen.optional(this.runToolsScriptsBeforeGuestReboot);
    }
    /**
     * Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
     * 
     */
    @Export(name="runToolsScriptsBeforeGuestShutdown", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> runToolsScriptsBeforeGuestShutdown;

    /**
     * @return Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
     * 
     */
    public Output<Optional<Boolean>> runToolsScriptsBeforeGuestShutdown() {
        return Codegen.optional(this.runToolsScriptsBeforeGuestShutdown);
    }
    /**
     * Enable the run of scripts before guest operating system standby when VMware Tools is installed.
     * 
     */
    @Export(name="runToolsScriptsBeforeGuestStandby", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> runToolsScriptsBeforeGuestStandby;

    /**
     * @return Enable the run of scripts before guest operating system standby when VMware Tools is installed.
     * 
     */
    public Output<Optional<Boolean>> runToolsScriptsBeforeGuestStandby() {
        return Codegen.optional(this.runToolsScriptsBeforeGuestStandby);
    }
    @Export(name="sataControllerCount", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> sataControllerCount;

    public Output<Optional<Integer>> sataControllerCount() {
        return Codegen.optional(this.sataControllerCount);
    }
    /**
     * Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
     * 
     */
    @Export(name="scsiBusSharing", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> scsiBusSharing;

    /**
     * @return Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
     * 
     */
    public Output<Optional<String>> scsiBusSharing() {
        return Codegen.optional(this.scsiBusSharing);
    }
    @Export(name="scsiControllerCount", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> scsiControllerCount;

    public Output<Optional<Integer>> scsiControllerCount() {
        return Codegen.optional(this.scsiControllerCount);
    }
    /**
     * The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
     * 
     */
    @Export(name="scsiType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> scsiType;

    /**
     * @return The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
     * 
     */
    public Output<Optional<String>> scsiType() {
        return Codegen.optional(this.scsiType);
    }
    /**
     * The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
     * 
     */
    @Export(name="shutdownWaitTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> shutdownWaitTimeout;

    /**
     * @return The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
     * 
     */
    public Output<Optional<Integer>> shutdownWaitTimeout() {
        return Codegen.optional(this.shutdownWaitTimeout);
    }
    /**
     * The ID of the storage policy to assign to the virtual machine home directory.
     * 
     */
    @Export(name="storagePolicyId", refs={String.class}, tree="[0]")
    private Output<String> storagePolicyId;

    /**
     * @return The ID of the storage policy to assign to the virtual machine home directory.
     * 
     */
    public Output<String> storagePolicyId() {
        return this.storagePolicyId;
    }
    /**
     * The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
     * 
     */
    @Export(name="swapPlacementPolicy", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> swapPlacementPolicy;

    /**
     * @return The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
     * 
     */
    public Output<Optional<String>> swapPlacementPolicy() {
        return Codegen.optional(this.swapPlacementPolicy);
    }
    /**
     * Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
     * 
     */
    @Export(name="syncTimeWithHost", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> syncTimeWithHost;

    /**
     * @return Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
     * 
     */
    public Output<Optional<Boolean>> syncTimeWithHost() {
        return Codegen.optional(this.syncTimeWithHost);
    }
    /**
     * Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.
     * 
     */
    @Export(name="syncTimeWithHostPeriodically", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> syncTimeWithHostPeriodically;

    /**
     * @return Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.
     * 
     */
    public Output<Optional<Boolean>> syncTimeWithHostPeriodically() {
        return Codegen.optional(this.syncTimeWithHostPeriodically);
    }
    /**
     * A list of tag IDs to apply to this object.
     * 
     */
    @Export(name="tags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return A list of tag IDs to apply to this object.
     * 
     */
    public Output<Optional<List<String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.
     * 
     */
    @Export(name="toolsUpgradePolicy", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> toolsUpgradePolicy;

    /**
     * @return Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.
     * 
     */
    public Output<Optional<String>> toolsUpgradePolicy() {
        return Codegen.optional(this.toolsUpgradePolicy);
    }
    /**
     * The UUID of the virtual machine. Also exposed as the `id` of the resource.
     * 
     */
    @Export(name="uuid", refs={String.class}, tree="[0]")
    private Output<String> uuid;

    /**
     * @return The UUID of the virtual machine. Also exposed as the `id` of the resource.
     * 
     */
    public Output<String> uuid() {
        return this.uuid;
    }
    /**
     * vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
     * 
     */
    @Export(name="vapp", refs={VirtualMachineVapp.class}, tree="[0]")
    private Output</* @Nullable */ VirtualMachineVapp> vapp;

    /**
     * @return vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
     * 
     */
    public Output<Optional<VirtualMachineVapp>> vapp() {
        return Codegen.optional(this.vapp);
    }
    /**
     * Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.
     * 
     */
    @Export(name="vappTransports", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> vappTransports;

    /**
     * @return Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.
     * 
     */
    public Output<List<String>> vappTransports() {
        return this.vappTransports;
    }
    /**
     * Flag to specify if Virtualization-based security is enabled for this virtual machine.
     * 
     */
    @Export(name="vbsEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vbsEnabled;

    /**
     * @return Flag to specify if Virtualization-based security is enabled for this virtual machine.
     * 
     */
    public Output<Optional<Boolean>> vbsEnabled() {
        return Codegen.optional(this.vbsEnabled);
    }
    /**
     * The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.
     * 
     */
    @Export(name="vmwareToolsStatus", refs={String.class}, tree="[0]")
    private Output<String> vmwareToolsStatus;

    /**
     * @return The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.
     * 
     */
    public Output<String> vmwareToolsStatus() {
        return this.vmwareToolsStatus;
    }
    /**
     * The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.
     * 
     */
    @Export(name="vmxPath", refs={String.class}, tree="[0]")
    private Output<String> vmxPath;

    /**
     * @return The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.
     * 
     */
    public Output<String> vmxPath() {
        return this.vmxPath;
    }
    /**
     * A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.
     * 
     */
    @Export(name="vtpm", refs={VirtualMachineVtpm.class}, tree="[0]")
    private Output</* @Nullable */ VirtualMachineVtpm> vtpm;

    /**
     * @return A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.
     * 
     */
    public Output<Optional<VirtualMachineVtpm>> vtpm() {
        return Codegen.optional(this.vtpm);
    }
    /**
     * Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
     * 
     */
    @Export(name="vvtdEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vvtdEnabled;

    /**
     * @return Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
     * 
     */
    public Output<Optional<Boolean>> vvtdEnabled() {
        return Codegen.optional(this.vvtdEnabled);
    }
    /**
     * The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
     * 
     */
    @Export(name="waitForGuestIpTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> waitForGuestIpTimeout;

    /**
     * @return The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
     * 
     */
    public Output<Optional<Integer>> waitForGuestIpTimeout() {
        return Codegen.optional(this.waitForGuestIpTimeout);
    }
    /**
     * Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
     * 
     */
    @Export(name="waitForGuestNetRoutable", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> waitForGuestNetRoutable;

    /**
     * @return Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
     * 
     */
    public Output<Optional<Boolean>> waitForGuestNetRoutable() {
        return Codegen.optional(this.waitForGuestNetRoutable);
    }
    /**
     * The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
     * 
     */
    @Export(name="waitForGuestNetTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> waitForGuestNetTimeout;

    /**
     * @return The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
     * 
     */
    public Output<Optional<Integer>> waitForGuestNetTimeout() {
        return Codegen.optional(this.waitForGuestNetTimeout);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public VirtualMachine(java.lang.String name) {
        this(name, VirtualMachineArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public VirtualMachine(java.lang.String name, VirtualMachineArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public VirtualMachine(java.lang.String name, VirtualMachineArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/virtualMachine:VirtualMachine", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private VirtualMachine(java.lang.String name, Output<java.lang.String> id, @Nullable VirtualMachineState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/virtualMachine:VirtualMachine", name, state, makeResourceOptions(options, id), false);
    }

    private static VirtualMachineArgs makeArgs(VirtualMachineArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? VirtualMachineArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static VirtualMachine get(java.lang.String name, Output<java.lang.String> id, @Nullable VirtualMachineState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new VirtualMachine(name, id, state, options);
    }
}
