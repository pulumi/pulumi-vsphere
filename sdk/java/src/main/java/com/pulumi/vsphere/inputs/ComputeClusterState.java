// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.vsphere.inputs.ComputeClusterHostImageArgs;
import com.pulumi.vsphere.inputs.ComputeClusterVsanDiskGroupArgs;
import com.pulumi.vsphere.inputs.ComputeClusterVsanFaultDomainArgs;
import com.pulumi.vsphere.inputs.ComputeClusterVsanStretchedClusterArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ComputeClusterState extends com.pulumi.resources.ResourceArgs {

    public static final ComputeClusterState Empty = new ComputeClusterState();

    /**
     * A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
     * and require vCenter Server.
     * 
     */
    @Import(name="customAttributes")
    private @Nullable Output<Map<String,String>> customAttributes;

    /**
     * @return A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
     * and require vCenter Server.
     * 
     */
    public Optional<Output<Map<String,String>>> customAttributes() {
        return Optional.ofNullable(this.customAttributes);
    }

    /**
     * The managed object ID of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     * 
     */
    @Import(name="datacenterId")
    private @Nullable Output<String> datacenterId;

    /**
     * @return The managed object ID of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     * 
     */
    public Optional<Output<String>> datacenterId() {
        return Optional.ofNullable(this.datacenterId);
    }

    /**
     * The automation level for host power operations in this cluster. Can be one of manual or automated.
     * 
     */
    @Import(name="dpmAutomationLevel")
    private @Nullable Output<String> dpmAutomationLevel;

    /**
     * @return The automation level for host power operations in this cluster. Can be one of manual or automated.
     * 
     */
    public Optional<Output<String>> dpmAutomationLevel() {
        return Optional.ofNullable(this.dpmAutomationLevel);
    }

    /**
     * Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual machines in the cluster. Requires that DRS be enabled.
     * 
     */
    @Import(name="dpmEnabled")
    private @Nullable Output<Boolean> dpmEnabled;

    /**
     * @return Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual machines in the cluster. Requires that DRS be enabled.
     * 
     */
    public Optional<Output<Boolean>> dpmEnabled() {
        return Optional.ofNullable(this.dpmEnabled);
    }

    /**
     * A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher setting.
     * 
     */
    @Import(name="dpmThreshold")
    private @Nullable Output<Integer> dpmThreshold;

    /**
     * @return A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher setting.
     * 
     */
    public Optional<Output<Integer>> dpmThreshold() {
        return Optional.ofNullable(this.dpmThreshold);
    }

    /**
     * Advanced configuration options for DRS and DPM.
     * 
     */
    @Import(name="drsAdvancedOptions")
    private @Nullable Output<Map<String,String>> drsAdvancedOptions;

    /**
     * @return Advanced configuration options for DRS and DPM.
     * 
     */
    public Optional<Output<Map<String,String>>> drsAdvancedOptions() {
        return Optional.ofNullable(this.drsAdvancedOptions);
    }

    /**
     * The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or fullyAutomated.
     * 
     */
    @Import(name="drsAutomationLevel")
    private @Nullable Output<String> drsAutomationLevel;

    /**
     * @return The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or fullyAutomated.
     * 
     */
    public Optional<Output<String>> drsAutomationLevel() {
        return Optional.ofNullable(this.drsAutomationLevel);
    }

    /**
     * When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     * 
     */
    @Import(name="drsEnablePredictiveDrs")
    private @Nullable Output<Boolean> drsEnablePredictiveDrs;

    /**
     * @return When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     * 
     */
    public Optional<Output<Boolean>> drsEnablePredictiveDrs() {
        return Optional.ofNullable(this.drsEnablePredictiveDrs);
    }

    /**
     * When true, allows individual VM overrides within this cluster to be set.
     * 
     */
    @Import(name="drsEnableVmOverrides")
    private @Nullable Output<Boolean> drsEnableVmOverrides;

    /**
     * @return When true, allows individual VM overrides within this cluster to be set.
     * 
     */
    public Optional<Output<Boolean>> drsEnableVmOverrides() {
        return Optional.ofNullable(this.drsEnableVmOverrides);
    }

    /**
     * Enable DRS for this cluster.
     * 
     */
    @Import(name="drsEnabled")
    private @Nullable Output<Boolean> drsEnabled;

    /**
     * @return Enable DRS for this cluster.
     * 
     */
    public Optional<Output<Boolean>> drsEnabled() {
        return Optional.ofNullable(this.drsEnabled);
    }

    /**
     * A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate more imbalance while a higher setting will tolerate less.
     * 
     */
    @Import(name="drsMigrationThreshold")
    private @Nullable Output<Integer> drsMigrationThreshold;

    /**
     * @return A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate more imbalance while a higher setting will tolerate less.
     * 
     */
    public Optional<Output<Integer>> drsMigrationThreshold() {
        return Optional.ofNullable(this.drsMigrationThreshold);
    }

    /**
     * Enable scalable shares for all descendants of this cluster.
     * 
     */
    @Import(name="drsScaleDescendantsShares")
    private @Nullable Output<String> drsScaleDescendantsShares;

    /**
     * @return Enable scalable shares for all descendants of this cluster.
     * 
     */
    public Optional<Output<String>> drsScaleDescendantsShares() {
        return Optional.ofNullable(this.drsScaleDescendantsShares);
    }

    /**
     * The relative path to a folder to put this cluster in.
     * This is a path relative to the datacenter you are deploying the cluster to.
     * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
     * The provider will place a cluster named `compute-cluster-test` in a
     * host folder located at `/dc1/host/foo/bar`, with the final inventory path
     * being `/dc1/host/foo/bar/datastore-cluster-test`.
     * 
     */
    @Import(name="folder")
    private @Nullable Output<String> folder;

    /**
     * @return The relative path to a folder to put this cluster in.
     * This is a path relative to the datacenter you are deploying the cluster to.
     * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
     * The provider will place a cluster named `compute-cluster-test` in a
     * host folder located at `/dc1/host/foo/bar`, with the final inventory path
     * being `/dc1/host/foo/bar/datastore-cluster-test`.
     * 
     */
    public Optional<Output<String>> folder() {
        return Optional.ofNullable(this.folder);
    }

    /**
     * Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists for testing and is not recommended in normal use.
     * 
     */
    @Import(name="forceEvacuateOnDestroy")
    private @Nullable Output<Boolean> forceEvacuateOnDestroy;

    /**
     * @return Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists for testing and is not recommended in normal use.
     * 
     */
    public Optional<Output<Boolean>> forceEvacuateOnDestroy() {
        return Optional.ofNullable(this.forceEvacuateOnDestroy);
    }

    /**
     * When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS will ignore the host when making recommendations.
     * 
     */
    @Import(name="haAdmissionControlFailoverHostSystemIds")
    private @Nullable Output<List<String>> haAdmissionControlFailoverHostSystemIds;

    /**
     * @return When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS will ignore the host when making recommendations.
     * 
     */
    public Optional<Output<List<String>>> haAdmissionControlFailoverHostSystemIds() {
        return Optional.ofNullable(this.haAdmissionControlFailoverHostSystemIds);
    }

    /**
     * The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual machine operations. The maximum is one less than the number of hosts in the cluster.
     * 
     */
    @Import(name="haAdmissionControlHostFailureTolerance")
    private @Nullable Output<Integer> haAdmissionControlHostFailureTolerance;

    /**
     * @return The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual machine operations. The maximum is one less than the number of hosts in the cluster.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlHostFailureTolerance() {
        return Optional.ofNullable(this.haAdmissionControlHostFailureTolerance);
    }

    /**
     * The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces warnings only, whereas a value of 100 disables the setting.
     * 
     */
    @Import(name="haAdmissionControlPerformanceTolerance")
    private @Nullable Output<Integer> haAdmissionControlPerformanceTolerance;

    /**
     * @return The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces warnings only, whereas a value of 100 disables the setting.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlPerformanceTolerance() {
        return Optional.ofNullable(this.haAdmissionControlPerformanceTolerance);
    }

    /**
     * The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage, slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service issues.
     * 
     */
    @Import(name="haAdmissionControlPolicy")
    private @Nullable Output<String> haAdmissionControlPolicy;

    /**
     * @return The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage, slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service issues.
     * 
     */
    public Optional<Output<String>> haAdmissionControlPolicy() {
        return Optional.ofNullable(this.haAdmissionControlPolicy);
    }

    /**
     * When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting from the total amount of resources in the cluster. Disable to supply user-defined values.
     * 
     */
    @Import(name="haAdmissionControlResourcePercentageAutoCompute")
    private @Nullable Output<Boolean> haAdmissionControlResourcePercentageAutoCompute;

    /**
     * @return When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting from the total amount of resources in the cluster. Disable to supply user-defined values.
     * 
     */
    public Optional<Output<Boolean>> haAdmissionControlResourcePercentageAutoCompute() {
        return Optional.ofNullable(this.haAdmissionControlResourcePercentageAutoCompute);
    }

    /**
     * When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in the cluster to reserve for failover.
     * 
     */
    @Import(name="haAdmissionControlResourcePercentageCpu")
    private @Nullable Output<Integer> haAdmissionControlResourcePercentageCpu;

    /**
     * @return When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in the cluster to reserve for failover.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlResourcePercentageCpu() {
        return Optional.ofNullable(this.haAdmissionControlResourcePercentageCpu);
    }

    /**
     * When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in the cluster to reserve for failover.
     * 
     */
    @Import(name="haAdmissionControlResourcePercentageMemory")
    private @Nullable Output<Integer> haAdmissionControlResourcePercentageMemory;

    /**
     * @return When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in the cluster to reserve for failover.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlResourcePercentageMemory() {
        return Optional.ofNullable(this.haAdmissionControlResourcePercentageMemory);
    }

    /**
     * When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     * 
     */
    @Import(name="haAdmissionControlSlotPolicyExplicitCpu")
    private @Nullable Output<Integer> haAdmissionControlSlotPolicyExplicitCpu;

    /**
     * @return When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlSlotPolicyExplicitCpu() {
        return Optional.ofNullable(this.haAdmissionControlSlotPolicyExplicitCpu);
    }

    /**
     * When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.
     * 
     */
    @Import(name="haAdmissionControlSlotPolicyExplicitMemory")
    private @Nullable Output<Integer> haAdmissionControlSlotPolicyExplicitMemory;

    /**
     * @return When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlSlotPolicyExplicitMemory() {
        return Optional.ofNullable(this.haAdmissionControlSlotPolicyExplicitMemory);
    }

    /**
     * When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines currently in the cluster.
     * 
     */
    @Import(name="haAdmissionControlSlotPolicyUseExplicitSize")
    private @Nullable Output<Boolean> haAdmissionControlSlotPolicyUseExplicitSize;

    /**
     * @return When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines currently in the cluster.
     * 
     */
    public Optional<Output<Boolean>> haAdmissionControlSlotPolicyUseExplicitSize() {
        return Optional.ofNullable(this.haAdmissionControlSlotPolicyUseExplicitSize);
    }

    /**
     * Advanced configuration options for vSphere HA.
     * 
     */
    @Import(name="haAdvancedOptions")
    private @Nullable Output<Map<String,String>> haAdvancedOptions;

    /**
     * @return Advanced configuration options for vSphere HA.
     * 
     */
    public Optional<Output<Map<String,String>>> haAdvancedOptions() {
        return Optional.ofNullable(this.haAdvancedOptions);
    }

    /**
     * When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an affected datastore clears in the middle of an APD event. Can be one of none or reset.
     * 
     */
    @Import(name="haDatastoreApdRecoveryAction")
    private @Nullable Output<String> haDatastoreApdRecoveryAction;

    /**
     * @return When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an affected datastore clears in the middle of an APD event. Can be one of none or reset.
     * 
     */
    public Optional<Output<String>> haDatastoreApdRecoveryAction() {
        return Optional.ofNullable(this.haDatastoreApdRecoveryAction);
    }

    /**
     * When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
     * 
     */
    @Import(name="haDatastoreApdResponse")
    private @Nullable Output<String> haDatastoreApdResponse;

    /**
     * @return When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
     * 
     */
    public Optional<Output<String>> haDatastoreApdResponse() {
        return Optional.ofNullable(this.haDatastoreApdResponse);
    }

    /**
     * When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the response action defined in ha_datastore_apd_response.
     * 
     */
    @Import(name="haDatastoreApdResponseDelay")
    private @Nullable Output<Integer> haDatastoreApdResponseDelay;

    /**
     * @return When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the response action defined in ha_datastore_apd_response.
     * 
     */
    public Optional<Output<Integer>> haDatastoreApdResponseDelay() {
        return Optional.ofNullable(this.haDatastoreApdResponseDelay);
    }

    /**
     * When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     * 
     */
    @Import(name="haDatastorePdlResponse")
    private @Nullable Output<String> haDatastorePdlResponse;

    /**
     * @return When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     * 
     */
    public Optional<Output<String>> haDatastorePdlResponse() {
        return Optional.ofNullable(this.haDatastorePdlResponse);
    }

    /**
     * Enable vSphere HA for this cluster.
     * 
     */
    @Import(name="haEnabled")
    private @Nullable Output<Boolean> haEnabled;

    /**
     * @return Enable vSphere HA for this cluster.
     * 
     */
    public Optional<Output<Boolean>> haEnabled() {
        return Optional.ofNullable(this.haEnabled);
    }

    /**
     * The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     * 
     */
    @Import(name="haHeartbeatDatastoreIds")
    private @Nullable Output<List<String>> haHeartbeatDatastoreIds;

    /**
     * @return The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     * 
     */
    public Optional<Output<List<String>>> haHeartbeatDatastoreIds() {
        return Optional.ofNullable(this.haHeartbeatDatastoreIds);
    }

    /**
     * The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference.
     * 
     */
    @Import(name="haHeartbeatDatastorePolicy")
    private @Nullable Output<String> haHeartbeatDatastorePolicy;

    /**
     * @return The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference.
     * 
     */
    public Optional<Output<String>> haHeartbeatDatastorePolicy() {
        return Optional.ofNullable(this.haHeartbeatDatastorePolicy);
    }

    /**
     * The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster. Can be one of none, powerOff, or shutdown.
     * 
     */
    @Import(name="haHostIsolationResponse")
    private @Nullable Output<String> haHostIsolationResponse;

    /**
     * @return The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster. Can be one of none, powerOff, or shutdown.
     * 
     */
    public Optional<Output<String>> haHostIsolationResponse() {
        return Optional.ofNullable(this.haHostIsolationResponse);
    }

    /**
     * Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     * 
     */
    @Import(name="haHostMonitoring")
    private @Nullable Output<String> haHostMonitoring;

    /**
     * @return Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     * 
     */
    public Optional<Output<String>> haHostMonitoring() {
        return Optional.ofNullable(this.haHostMonitoring);
    }

    /**
     * Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     * 
     */
    @Import(name="haVmComponentProtection")
    private @Nullable Output<String> haVmComponentProtection;

    /**
     * @return Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     * 
     */
    public Optional<Output<String>> haVmComponentProtection() {
        return Optional.ofNullable(this.haVmComponentProtection);
    }

    /**
     * The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     * 
     */
    @Import(name="haVmDependencyRestartCondition")
    private @Nullable Output<String> haVmDependencyRestartCondition;

    /**
     * @return The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     * 
     */
    public Optional<Output<String>> haVmDependencyRestartCondition() {
        return Optional.ofNullable(this.haVmDependencyRestartCondition);
    }

    /**
     * If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as failed. The value is in seconds.
     * 
     */
    @Import(name="haVmFailureInterval")
    private @Nullable Output<Integer> haVmFailureInterval;

    /**
     * @return If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as failed. The value is in seconds.
     * 
     */
    public Optional<Output<Integer>> haVmFailureInterval() {
        return Optional.ofNullable(this.haVmFailureInterval);
    }

    /**
     * The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset time is allotted.
     * 
     */
    @Import(name="haVmMaximumFailureWindow")
    private @Nullable Output<Integer> haVmMaximumFailureWindow;

    /**
     * @return The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset time is allotted.
     * 
     */
    public Optional<Output<Integer>> haVmMaximumFailureWindow() {
        return Optional.ofNullable(this.haVmMaximumFailureWindow);
    }

    /**
     * The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     * 
     */
    @Import(name="haVmMaximumResets")
    private @Nullable Output<Integer> haVmMaximumResets;

    /**
     * @return The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     * 
     */
    public Optional<Output<Integer>> haVmMaximumResets() {
        return Optional.ofNullable(this.haVmMaximumResets);
    }

    /**
     * The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     * 
     */
    @Import(name="haVmMinimumUptime")
    private @Nullable Output<Integer> haVmMinimumUptime;

    /**
     * @return The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     * 
     */
    public Optional<Output<Integer>> haVmMinimumUptime() {
        return Optional.ofNullable(this.haVmMinimumUptime);
    }

    /**
     * The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring.
     * 
     */
    @Import(name="haVmMonitoring")
    private @Nullable Output<String> haVmMonitoring;

    /**
     * @return The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring.
     * 
     */
    public Optional<Output<String>> haVmMonitoring() {
        return Optional.ofNullable(this.haVmMonitoring);
    }

    /**
     * Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     * 
     */
    @Import(name="haVmRestartAdditionalDelay")
    private @Nullable Output<Integer> haVmRestartAdditionalDelay;

    /**
     * @return Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     * 
     */
    public Optional<Output<Integer>> haVmRestartAdditionalDelay() {
        return Optional.ofNullable(this.haVmRestartAdditionalDelay);
    }

    /**
     * The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium, high, or highest.
     * 
     */
    @Import(name="haVmRestartPriority")
    private @Nullable Output<String> haVmRestartPriority;

    /**
     * @return The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium, high, or highest.
     * 
     */
    public Optional<Output<String>> haVmRestartPriority() {
        return Optional.ofNullable(this.haVmRestartPriority);
    }

    /**
     * The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before proceeding with the next priority.
     * 
     */
    @Import(name="haVmRestartTimeout")
    private @Nullable Output<Integer> haVmRestartTimeout;

    /**
     * @return The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before proceeding with the next priority.
     * 
     */
    public Optional<Output<Integer>> haVmRestartTimeout() {
        return Optional.ofNullable(this.haVmRestartTimeout);
    }

    /**
     * The timeout for each host maintenance mode operation when removing hosts from a cluster.
     * 
     */
    @Import(name="hostClusterExitTimeout")
    private @Nullable Output<Integer> hostClusterExitTimeout;

    /**
     * @return The timeout for each host maintenance mode operation when removing hosts from a cluster.
     * 
     */
    public Optional<Output<Integer>> hostClusterExitTimeout() {
        return Optional.ofNullable(this.hostClusterExitTimeout);
    }

    /**
     * Details about the host image which should be applied to the cluster.
     * 
     */
    @Import(name="hostImage")
    private @Nullable Output<ComputeClusterHostImageArgs> hostImage;

    /**
     * @return Details about the host image which should be applied to the cluster.
     * 
     */
    public Optional<Output<ComputeClusterHostImageArgs>> hostImage() {
        return Optional.ofNullable(this.hostImage);
    }

    /**
     * Must be set if cluster enrollment is managed from host resource.
     * 
     */
    @Import(name="hostManaged")
    private @Nullable Output<Boolean> hostManaged;

    /**
     * @return Must be set if cluster enrollment is managed from host resource.
     * 
     */
    public Optional<Output<Boolean>> hostManaged() {
        return Optional.ofNullable(this.hostManaged);
    }

    /**
     * The managed object IDs of the hosts to put in the cluster.
     * 
     */
    @Import(name="hostSystemIds")
    private @Nullable Output<List<String>> hostSystemIds;

    /**
     * @return The managed object IDs of the hosts to put in the cluster.
     * 
     */
    public Optional<Output<List<String>>> hostSystemIds() {
        return Optional.ofNullable(this.hostSystemIds);
    }

    /**
     * The name of the cluster.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the cluster.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     * 
     */
    @Import(name="proactiveHaAutomationLevel")
    private @Nullable Output<String> proactiveHaAutomationLevel;

    /**
     * @return The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     * 
     */
    public Optional<Output<String>> proactiveHaAutomationLevel() {
        return Optional.ofNullable(this.proactiveHaAutomationLevel);
    }

    /**
     * Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     * 
     */
    @Import(name="proactiveHaEnabled")
    private @Nullable Output<Boolean> proactiveHaEnabled;

    /**
     * @return Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     * 
     */
    public Optional<Output<Boolean>> proactiveHaEnabled() {
        return Optional.ofNullable(this.proactiveHaEnabled);
    }

    /**
     * The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.
     * 
     */
    @Import(name="proactiveHaModerateRemediation")
    private @Nullable Output<String> proactiveHaModerateRemediation;

    /**
     * @return The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.
     * 
     */
    public Optional<Output<String>> proactiveHaModerateRemediation() {
        return Optional.ofNullable(this.proactiveHaModerateRemediation);
    }

    /**
     * The list of IDs for health update providers configured for this cluster.
     * 
     */
    @Import(name="proactiveHaProviderIds")
    private @Nullable Output<List<String>> proactiveHaProviderIds;

    /**
     * @return The list of IDs for health update providers configured for this cluster.
     * 
     */
    public Optional<Output<List<String>>> proactiveHaProviderIds() {
        return Optional.ofNullable(this.proactiveHaProviderIds);
    }

    /**
     * The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.
     * 
     */
    @Import(name="proactiveHaSevereRemediation")
    private @Nullable Output<String> proactiveHaSevereRemediation;

    /**
     * @return The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.
     * 
     */
    public Optional<Output<String>> proactiveHaSevereRemediation() {
        return Optional.ofNullable(this.proactiveHaSevereRemediation);
    }

    /**
     * The managed object ID of the primary
     * resource pool for this cluster. This can be passed directly to the
     * `resource_pool_id`
     * attribute of the
     * `vsphere.VirtualMachine` resource.
     * 
     */
    @Import(name="resourcePoolId")
    private @Nullable Output<String> resourcePoolId;

    /**
     * @return The managed object ID of the primary
     * resource pool for this cluster. This can be passed directly to the
     * `resource_pool_id`
     * attribute of the
     * `vsphere.VirtualMachine` resource.
     * 
     */
    public Optional<Output<String>> resourcePoolId() {
        return Optional.ofNullable(this.resourcePoolId);
    }

    /**
     * The IDs of any tags to attach to this resource.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return The IDs of any tags to attach to this resource.
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * Whether the vSAN compression service is enabled for the cluster.
     * 
     */
    @Import(name="vsanCompressionEnabled")
    private @Nullable Output<Boolean> vsanCompressionEnabled;

    /**
     * @return Whether the vSAN compression service is enabled for the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanCompressionEnabled() {
        return Optional.ofNullable(this.vsanCompressionEnabled);
    }

    /**
     * Whether the vSAN deduplication service is enabled for the cluster.
     * 
     */
    @Import(name="vsanDedupEnabled")
    private @Nullable Output<Boolean> vsanDedupEnabled;

    /**
     * @return Whether the vSAN deduplication service is enabled for the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanDedupEnabled() {
        return Optional.ofNullable(this.vsanDedupEnabled);
    }

    /**
     * A list of disk UUIDs to add to the vSAN cluster.
     * 
     */
    @Import(name="vsanDiskGroups")
    private @Nullable Output<List<ComputeClusterVsanDiskGroupArgs>> vsanDiskGroups;

    /**
     * @return A list of disk UUIDs to add to the vSAN cluster.
     * 
     */
    public Optional<Output<List<ComputeClusterVsanDiskGroupArgs>>> vsanDiskGroups() {
        return Optional.ofNullable(this.vsanDiskGroups);
    }

    /**
     * Whether the vSAN data-in-transit encryption is enabled for the cluster.
     * 
     */
    @Import(name="vsanDitEncryptionEnabled")
    private @Nullable Output<Boolean> vsanDitEncryptionEnabled;

    /**
     * @return Whether the vSAN data-in-transit encryption is enabled for the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanDitEncryptionEnabled() {
        return Optional.ofNullable(this.vsanDitEncryptionEnabled);
    }

    /**
     * When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     * 
     */
    @Import(name="vsanDitRekeyInterval")
    private @Nullable Output<Integer> vsanDitRekeyInterval;

    /**
     * @return When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     * 
     */
    public Optional<Output<Integer>> vsanDitRekeyInterval() {
        return Optional.ofNullable(this.vsanDitRekeyInterval);
    }

    /**
     * Whether the vSAN service is enabled for the cluster.
     * 
     */
    @Import(name="vsanEnabled")
    private @Nullable Output<Boolean> vsanEnabled;

    /**
     * @return Whether the vSAN service is enabled for the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanEnabled() {
        return Optional.ofNullable(this.vsanEnabled);
    }

    /**
     * Whether the vSAN ESA service is enabled for the cluster.
     * 
     */
    @Import(name="vsanEsaEnabled")
    private @Nullable Output<Boolean> vsanEsaEnabled;

    /**
     * @return Whether the vSAN ESA service is enabled for the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanEsaEnabled() {
        return Optional.ofNullable(this.vsanEsaEnabled);
    }

    /**
     * The configuration for vSAN fault domains.
     * 
     */
    @Import(name="vsanFaultDomains")
    private @Nullable Output<List<ComputeClusterVsanFaultDomainArgs>> vsanFaultDomains;

    /**
     * @return The configuration for vSAN fault domains.
     * 
     */
    public Optional<Output<List<ComputeClusterVsanFaultDomainArgs>>> vsanFaultDomains() {
        return Optional.ofNullable(this.vsanFaultDomains);
    }

    /**
     * Whether the vSAN network diagnostic mode is enabled for the cluster.
     * 
     */
    @Import(name="vsanNetworkDiagnosticModeEnabled")
    private @Nullable Output<Boolean> vsanNetworkDiagnosticModeEnabled;

    /**
     * @return Whether the vSAN network diagnostic mode is enabled for the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanNetworkDiagnosticModeEnabled() {
        return Optional.ofNullable(this.vsanNetworkDiagnosticModeEnabled);
    }

    /**
     * Whether the vSAN performance service is enabled for the cluster.
     * 
     */
    @Import(name="vsanPerformanceEnabled")
    private @Nullable Output<Boolean> vsanPerformanceEnabled;

    /**
     * @return Whether the vSAN performance service is enabled for the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanPerformanceEnabled() {
        return Optional.ofNullable(this.vsanPerformanceEnabled);
    }

    /**
     * The managed object IDs of the vSAN datastore to be mounted on the cluster.
     * 
     */
    @Import(name="vsanRemoteDatastoreIds")
    private @Nullable Output<List<String>> vsanRemoteDatastoreIds;

    /**
     * @return The managed object IDs of the vSAN datastore to be mounted on the cluster.
     * 
     */
    public Optional<Output<List<String>>> vsanRemoteDatastoreIds() {
        return Optional.ofNullable(this.vsanRemoteDatastoreIds);
    }

    /**
     * The configuration for stretched cluster.
     * 
     */
    @Import(name="vsanStretchedCluster")
    private @Nullable Output<ComputeClusterVsanStretchedClusterArgs> vsanStretchedCluster;

    /**
     * @return The configuration for stretched cluster.
     * 
     */
    public Optional<Output<ComputeClusterVsanStretchedClusterArgs>> vsanStretchedCluster() {
        return Optional.ofNullable(this.vsanStretchedCluster);
    }

    /**
     * Whether the vSAN unmap service is enabled for the cluster.
     * 
     */
    @Import(name="vsanUnmapEnabled")
    private @Nullable Output<Boolean> vsanUnmapEnabled;

    /**
     * @return Whether the vSAN unmap service is enabled for the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanUnmapEnabled() {
        return Optional.ofNullable(this.vsanUnmapEnabled);
    }

    /**
     * Whether the vSAN verbose mode is enabled for the cluster.
     * 
     */
    @Import(name="vsanVerboseModeEnabled")
    private @Nullable Output<Boolean> vsanVerboseModeEnabled;

    /**
     * @return Whether the vSAN verbose mode is enabled for the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanVerboseModeEnabled() {
        return Optional.ofNullable(this.vsanVerboseModeEnabled);
    }

    private ComputeClusterState() {}

    private ComputeClusterState(ComputeClusterState $) {
        this.customAttributes = $.customAttributes;
        this.datacenterId = $.datacenterId;
        this.dpmAutomationLevel = $.dpmAutomationLevel;
        this.dpmEnabled = $.dpmEnabled;
        this.dpmThreshold = $.dpmThreshold;
        this.drsAdvancedOptions = $.drsAdvancedOptions;
        this.drsAutomationLevel = $.drsAutomationLevel;
        this.drsEnablePredictiveDrs = $.drsEnablePredictiveDrs;
        this.drsEnableVmOverrides = $.drsEnableVmOverrides;
        this.drsEnabled = $.drsEnabled;
        this.drsMigrationThreshold = $.drsMigrationThreshold;
        this.drsScaleDescendantsShares = $.drsScaleDescendantsShares;
        this.folder = $.folder;
        this.forceEvacuateOnDestroy = $.forceEvacuateOnDestroy;
        this.haAdmissionControlFailoverHostSystemIds = $.haAdmissionControlFailoverHostSystemIds;
        this.haAdmissionControlHostFailureTolerance = $.haAdmissionControlHostFailureTolerance;
        this.haAdmissionControlPerformanceTolerance = $.haAdmissionControlPerformanceTolerance;
        this.haAdmissionControlPolicy = $.haAdmissionControlPolicy;
        this.haAdmissionControlResourcePercentageAutoCompute = $.haAdmissionControlResourcePercentageAutoCompute;
        this.haAdmissionControlResourcePercentageCpu = $.haAdmissionControlResourcePercentageCpu;
        this.haAdmissionControlResourcePercentageMemory = $.haAdmissionControlResourcePercentageMemory;
        this.haAdmissionControlSlotPolicyExplicitCpu = $.haAdmissionControlSlotPolicyExplicitCpu;
        this.haAdmissionControlSlotPolicyExplicitMemory = $.haAdmissionControlSlotPolicyExplicitMemory;
        this.haAdmissionControlSlotPolicyUseExplicitSize = $.haAdmissionControlSlotPolicyUseExplicitSize;
        this.haAdvancedOptions = $.haAdvancedOptions;
        this.haDatastoreApdRecoveryAction = $.haDatastoreApdRecoveryAction;
        this.haDatastoreApdResponse = $.haDatastoreApdResponse;
        this.haDatastoreApdResponseDelay = $.haDatastoreApdResponseDelay;
        this.haDatastorePdlResponse = $.haDatastorePdlResponse;
        this.haEnabled = $.haEnabled;
        this.haHeartbeatDatastoreIds = $.haHeartbeatDatastoreIds;
        this.haHeartbeatDatastorePolicy = $.haHeartbeatDatastorePolicy;
        this.haHostIsolationResponse = $.haHostIsolationResponse;
        this.haHostMonitoring = $.haHostMonitoring;
        this.haVmComponentProtection = $.haVmComponentProtection;
        this.haVmDependencyRestartCondition = $.haVmDependencyRestartCondition;
        this.haVmFailureInterval = $.haVmFailureInterval;
        this.haVmMaximumFailureWindow = $.haVmMaximumFailureWindow;
        this.haVmMaximumResets = $.haVmMaximumResets;
        this.haVmMinimumUptime = $.haVmMinimumUptime;
        this.haVmMonitoring = $.haVmMonitoring;
        this.haVmRestartAdditionalDelay = $.haVmRestartAdditionalDelay;
        this.haVmRestartPriority = $.haVmRestartPriority;
        this.haVmRestartTimeout = $.haVmRestartTimeout;
        this.hostClusterExitTimeout = $.hostClusterExitTimeout;
        this.hostImage = $.hostImage;
        this.hostManaged = $.hostManaged;
        this.hostSystemIds = $.hostSystemIds;
        this.name = $.name;
        this.proactiveHaAutomationLevel = $.proactiveHaAutomationLevel;
        this.proactiveHaEnabled = $.proactiveHaEnabled;
        this.proactiveHaModerateRemediation = $.proactiveHaModerateRemediation;
        this.proactiveHaProviderIds = $.proactiveHaProviderIds;
        this.proactiveHaSevereRemediation = $.proactiveHaSevereRemediation;
        this.resourcePoolId = $.resourcePoolId;
        this.tags = $.tags;
        this.vsanCompressionEnabled = $.vsanCompressionEnabled;
        this.vsanDedupEnabled = $.vsanDedupEnabled;
        this.vsanDiskGroups = $.vsanDiskGroups;
        this.vsanDitEncryptionEnabled = $.vsanDitEncryptionEnabled;
        this.vsanDitRekeyInterval = $.vsanDitRekeyInterval;
        this.vsanEnabled = $.vsanEnabled;
        this.vsanEsaEnabled = $.vsanEsaEnabled;
        this.vsanFaultDomains = $.vsanFaultDomains;
        this.vsanNetworkDiagnosticModeEnabled = $.vsanNetworkDiagnosticModeEnabled;
        this.vsanPerformanceEnabled = $.vsanPerformanceEnabled;
        this.vsanRemoteDatastoreIds = $.vsanRemoteDatastoreIds;
        this.vsanStretchedCluster = $.vsanStretchedCluster;
        this.vsanUnmapEnabled = $.vsanUnmapEnabled;
        this.vsanVerboseModeEnabled = $.vsanVerboseModeEnabled;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ComputeClusterState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ComputeClusterState $;

        public Builder() {
            $ = new ComputeClusterState();
        }

        public Builder(ComputeClusterState defaults) {
            $ = new ComputeClusterState(Objects.requireNonNull(defaults));
        }

        /**
         * @param customAttributes A map of custom attribute ids to attribute
         * value strings to set for the datastore cluster.
         * 
         * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
         * and require vCenter Server.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(@Nullable Output<Map<String,String>> customAttributes) {
            $.customAttributes = customAttributes;
            return this;
        }

        /**
         * @param customAttributes A map of custom attribute ids to attribute
         * value strings to set for the datastore cluster.
         * 
         * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
         * and require vCenter Server.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(Map<String,String> customAttributes) {
            return customAttributes(Output.of(customAttributes));
        }

        /**
         * @param datacenterId The managed object ID of
         * the datacenter to create the cluster in. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder datacenterId(@Nullable Output<String> datacenterId) {
            $.datacenterId = datacenterId;
            return this;
        }

        /**
         * @param datacenterId The managed object ID of
         * the datacenter to create the cluster in. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder datacenterId(String datacenterId) {
            return datacenterId(Output.of(datacenterId));
        }

        /**
         * @param dpmAutomationLevel The automation level for host power operations in this cluster. Can be one of manual or automated.
         * 
         * @return builder
         * 
         */
        public Builder dpmAutomationLevel(@Nullable Output<String> dpmAutomationLevel) {
            $.dpmAutomationLevel = dpmAutomationLevel;
            return this;
        }

        /**
         * @param dpmAutomationLevel The automation level for host power operations in this cluster. Can be one of manual or automated.
         * 
         * @return builder
         * 
         */
        public Builder dpmAutomationLevel(String dpmAutomationLevel) {
            return dpmAutomationLevel(Output.of(dpmAutomationLevel));
        }

        /**
         * @param dpmEnabled Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual machines in the cluster. Requires that DRS be enabled.
         * 
         * @return builder
         * 
         */
        public Builder dpmEnabled(@Nullable Output<Boolean> dpmEnabled) {
            $.dpmEnabled = dpmEnabled;
            return this;
        }

        /**
         * @param dpmEnabled Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual machines in the cluster. Requires that DRS be enabled.
         * 
         * @return builder
         * 
         */
        public Builder dpmEnabled(Boolean dpmEnabled) {
            return dpmEnabled(Output.of(dpmEnabled));
        }

        /**
         * @param dpmThreshold A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher setting.
         * 
         * @return builder
         * 
         */
        public Builder dpmThreshold(@Nullable Output<Integer> dpmThreshold) {
            $.dpmThreshold = dpmThreshold;
            return this;
        }

        /**
         * @param dpmThreshold A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher setting.
         * 
         * @return builder
         * 
         */
        public Builder dpmThreshold(Integer dpmThreshold) {
            return dpmThreshold(Output.of(dpmThreshold));
        }

        /**
         * @param drsAdvancedOptions Advanced configuration options for DRS and DPM.
         * 
         * @return builder
         * 
         */
        public Builder drsAdvancedOptions(@Nullable Output<Map<String,String>> drsAdvancedOptions) {
            $.drsAdvancedOptions = drsAdvancedOptions;
            return this;
        }

        /**
         * @param drsAdvancedOptions Advanced configuration options for DRS and DPM.
         * 
         * @return builder
         * 
         */
        public Builder drsAdvancedOptions(Map<String,String> drsAdvancedOptions) {
            return drsAdvancedOptions(Output.of(drsAdvancedOptions));
        }

        /**
         * @param drsAutomationLevel The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or fullyAutomated.
         * 
         * @return builder
         * 
         */
        public Builder drsAutomationLevel(@Nullable Output<String> drsAutomationLevel) {
            $.drsAutomationLevel = drsAutomationLevel;
            return this;
        }

        /**
         * @param drsAutomationLevel The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or fullyAutomated.
         * 
         * @return builder
         * 
         */
        public Builder drsAutomationLevel(String drsAutomationLevel) {
            return drsAutomationLevel(Output.of(drsAutomationLevel));
        }

        /**
         * @param drsEnablePredictiveDrs When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
         * 
         * @return builder
         * 
         */
        public Builder drsEnablePredictiveDrs(@Nullable Output<Boolean> drsEnablePredictiveDrs) {
            $.drsEnablePredictiveDrs = drsEnablePredictiveDrs;
            return this;
        }

        /**
         * @param drsEnablePredictiveDrs When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
         * 
         * @return builder
         * 
         */
        public Builder drsEnablePredictiveDrs(Boolean drsEnablePredictiveDrs) {
            return drsEnablePredictiveDrs(Output.of(drsEnablePredictiveDrs));
        }

        /**
         * @param drsEnableVmOverrides When true, allows individual VM overrides within this cluster to be set.
         * 
         * @return builder
         * 
         */
        public Builder drsEnableVmOverrides(@Nullable Output<Boolean> drsEnableVmOverrides) {
            $.drsEnableVmOverrides = drsEnableVmOverrides;
            return this;
        }

        /**
         * @param drsEnableVmOverrides When true, allows individual VM overrides within this cluster to be set.
         * 
         * @return builder
         * 
         */
        public Builder drsEnableVmOverrides(Boolean drsEnableVmOverrides) {
            return drsEnableVmOverrides(Output.of(drsEnableVmOverrides));
        }

        /**
         * @param drsEnabled Enable DRS for this cluster.
         * 
         * @return builder
         * 
         */
        public Builder drsEnabled(@Nullable Output<Boolean> drsEnabled) {
            $.drsEnabled = drsEnabled;
            return this;
        }

        /**
         * @param drsEnabled Enable DRS for this cluster.
         * 
         * @return builder
         * 
         */
        public Builder drsEnabled(Boolean drsEnabled) {
            return drsEnabled(Output.of(drsEnabled));
        }

        /**
         * @param drsMigrationThreshold A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate more imbalance while a higher setting will tolerate less.
         * 
         * @return builder
         * 
         */
        public Builder drsMigrationThreshold(@Nullable Output<Integer> drsMigrationThreshold) {
            $.drsMigrationThreshold = drsMigrationThreshold;
            return this;
        }

        /**
         * @param drsMigrationThreshold A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate more imbalance while a higher setting will tolerate less.
         * 
         * @return builder
         * 
         */
        public Builder drsMigrationThreshold(Integer drsMigrationThreshold) {
            return drsMigrationThreshold(Output.of(drsMigrationThreshold));
        }

        /**
         * @param drsScaleDescendantsShares Enable scalable shares for all descendants of this cluster.
         * 
         * @return builder
         * 
         */
        public Builder drsScaleDescendantsShares(@Nullable Output<String> drsScaleDescendantsShares) {
            $.drsScaleDescendantsShares = drsScaleDescendantsShares;
            return this;
        }

        /**
         * @param drsScaleDescendantsShares Enable scalable shares for all descendants of this cluster.
         * 
         * @return builder
         * 
         */
        public Builder drsScaleDescendantsShares(String drsScaleDescendantsShares) {
            return drsScaleDescendantsShares(Output.of(drsScaleDescendantsShares));
        }

        /**
         * @param folder The relative path to a folder to put this cluster in.
         * This is a path relative to the datacenter you are deploying the cluster to.
         * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
         * The provider will place a cluster named `compute-cluster-test` in a
         * host folder located at `/dc1/host/foo/bar`, with the final inventory path
         * being `/dc1/host/foo/bar/datastore-cluster-test`.
         * 
         * @return builder
         * 
         */
        public Builder folder(@Nullable Output<String> folder) {
            $.folder = folder;
            return this;
        }

        /**
         * @param folder The relative path to a folder to put this cluster in.
         * This is a path relative to the datacenter you are deploying the cluster to.
         * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
         * The provider will place a cluster named `compute-cluster-test` in a
         * host folder located at `/dc1/host/foo/bar`, with the final inventory path
         * being `/dc1/host/foo/bar/datastore-cluster-test`.
         * 
         * @return builder
         * 
         */
        public Builder folder(String folder) {
            return folder(Output.of(folder));
        }

        /**
         * @param forceEvacuateOnDestroy Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists for testing and is not recommended in normal use.
         * 
         * @return builder
         * 
         */
        public Builder forceEvacuateOnDestroy(@Nullable Output<Boolean> forceEvacuateOnDestroy) {
            $.forceEvacuateOnDestroy = forceEvacuateOnDestroy;
            return this;
        }

        /**
         * @param forceEvacuateOnDestroy Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists for testing and is not recommended in normal use.
         * 
         * @return builder
         * 
         */
        public Builder forceEvacuateOnDestroy(Boolean forceEvacuateOnDestroy) {
            return forceEvacuateOnDestroy(Output.of(forceEvacuateOnDestroy));
        }

        /**
         * @param haAdmissionControlFailoverHostSystemIds When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS will ignore the host when making recommendations.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlFailoverHostSystemIds(@Nullable Output<List<String>> haAdmissionControlFailoverHostSystemIds) {
            $.haAdmissionControlFailoverHostSystemIds = haAdmissionControlFailoverHostSystemIds;
            return this;
        }

        /**
         * @param haAdmissionControlFailoverHostSystemIds When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS will ignore the host when making recommendations.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlFailoverHostSystemIds(List<String> haAdmissionControlFailoverHostSystemIds) {
            return haAdmissionControlFailoverHostSystemIds(Output.of(haAdmissionControlFailoverHostSystemIds));
        }

        /**
         * @param haAdmissionControlFailoverHostSystemIds When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS will ignore the host when making recommendations.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlFailoverHostSystemIds(String... haAdmissionControlFailoverHostSystemIds) {
            return haAdmissionControlFailoverHostSystemIds(List.of(haAdmissionControlFailoverHostSystemIds));
        }

        /**
         * @param haAdmissionControlHostFailureTolerance The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual machine operations. The maximum is one less than the number of hosts in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlHostFailureTolerance(@Nullable Output<Integer> haAdmissionControlHostFailureTolerance) {
            $.haAdmissionControlHostFailureTolerance = haAdmissionControlHostFailureTolerance;
            return this;
        }

        /**
         * @param haAdmissionControlHostFailureTolerance The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual machine operations. The maximum is one less than the number of hosts in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlHostFailureTolerance(Integer haAdmissionControlHostFailureTolerance) {
            return haAdmissionControlHostFailureTolerance(Output.of(haAdmissionControlHostFailureTolerance));
        }

        /**
         * @param haAdmissionControlPerformanceTolerance The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces warnings only, whereas a value of 100 disables the setting.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlPerformanceTolerance(@Nullable Output<Integer> haAdmissionControlPerformanceTolerance) {
            $.haAdmissionControlPerformanceTolerance = haAdmissionControlPerformanceTolerance;
            return this;
        }

        /**
         * @param haAdmissionControlPerformanceTolerance The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces warnings only, whereas a value of 100 disables the setting.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlPerformanceTolerance(Integer haAdmissionControlPerformanceTolerance) {
            return haAdmissionControlPerformanceTolerance(Output.of(haAdmissionControlPerformanceTolerance));
        }

        /**
         * @param haAdmissionControlPolicy The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage, slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service issues.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlPolicy(@Nullable Output<String> haAdmissionControlPolicy) {
            $.haAdmissionControlPolicy = haAdmissionControlPolicy;
            return this;
        }

        /**
         * @param haAdmissionControlPolicy The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage, slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service issues.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlPolicy(String haAdmissionControlPolicy) {
            return haAdmissionControlPolicy(Output.of(haAdmissionControlPolicy));
        }

        /**
         * @param haAdmissionControlResourcePercentageAutoCompute When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting from the total amount of resources in the cluster. Disable to supply user-defined values.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageAutoCompute(@Nullable Output<Boolean> haAdmissionControlResourcePercentageAutoCompute) {
            $.haAdmissionControlResourcePercentageAutoCompute = haAdmissionControlResourcePercentageAutoCompute;
            return this;
        }

        /**
         * @param haAdmissionControlResourcePercentageAutoCompute When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting from the total amount of resources in the cluster. Disable to supply user-defined values.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageAutoCompute(Boolean haAdmissionControlResourcePercentageAutoCompute) {
            return haAdmissionControlResourcePercentageAutoCompute(Output.of(haAdmissionControlResourcePercentageAutoCompute));
        }

        /**
         * @param haAdmissionControlResourcePercentageCpu When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in the cluster to reserve for failover.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageCpu(@Nullable Output<Integer> haAdmissionControlResourcePercentageCpu) {
            $.haAdmissionControlResourcePercentageCpu = haAdmissionControlResourcePercentageCpu;
            return this;
        }

        /**
         * @param haAdmissionControlResourcePercentageCpu When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in the cluster to reserve for failover.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageCpu(Integer haAdmissionControlResourcePercentageCpu) {
            return haAdmissionControlResourcePercentageCpu(Output.of(haAdmissionControlResourcePercentageCpu));
        }

        /**
         * @param haAdmissionControlResourcePercentageMemory When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in the cluster to reserve for failover.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageMemory(@Nullable Output<Integer> haAdmissionControlResourcePercentageMemory) {
            $.haAdmissionControlResourcePercentageMemory = haAdmissionControlResourcePercentageMemory;
            return this;
        }

        /**
         * @param haAdmissionControlResourcePercentageMemory When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in the cluster to reserve for failover.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageMemory(Integer haAdmissionControlResourcePercentageMemory) {
            return haAdmissionControlResourcePercentageMemory(Output.of(haAdmissionControlResourcePercentageMemory));
        }

        /**
         * @param haAdmissionControlSlotPolicyExplicitCpu When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyExplicitCpu(@Nullable Output<Integer> haAdmissionControlSlotPolicyExplicitCpu) {
            $.haAdmissionControlSlotPolicyExplicitCpu = haAdmissionControlSlotPolicyExplicitCpu;
            return this;
        }

        /**
         * @param haAdmissionControlSlotPolicyExplicitCpu When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyExplicitCpu(Integer haAdmissionControlSlotPolicyExplicitCpu) {
            return haAdmissionControlSlotPolicyExplicitCpu(Output.of(haAdmissionControlSlotPolicyExplicitCpu));
        }

        /**
         * @param haAdmissionControlSlotPolicyExplicitMemory When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyExplicitMemory(@Nullable Output<Integer> haAdmissionControlSlotPolicyExplicitMemory) {
            $.haAdmissionControlSlotPolicyExplicitMemory = haAdmissionControlSlotPolicyExplicitMemory;
            return this;
        }

        /**
         * @param haAdmissionControlSlotPolicyExplicitMemory When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyExplicitMemory(Integer haAdmissionControlSlotPolicyExplicitMemory) {
            return haAdmissionControlSlotPolicyExplicitMemory(Output.of(haAdmissionControlSlotPolicyExplicitMemory));
        }

        /**
         * @param haAdmissionControlSlotPolicyUseExplicitSize When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines currently in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyUseExplicitSize(@Nullable Output<Boolean> haAdmissionControlSlotPolicyUseExplicitSize) {
            $.haAdmissionControlSlotPolicyUseExplicitSize = haAdmissionControlSlotPolicyUseExplicitSize;
            return this;
        }

        /**
         * @param haAdmissionControlSlotPolicyUseExplicitSize When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines currently in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyUseExplicitSize(Boolean haAdmissionControlSlotPolicyUseExplicitSize) {
            return haAdmissionControlSlotPolicyUseExplicitSize(Output.of(haAdmissionControlSlotPolicyUseExplicitSize));
        }

        /**
         * @param haAdvancedOptions Advanced configuration options for vSphere HA.
         * 
         * @return builder
         * 
         */
        public Builder haAdvancedOptions(@Nullable Output<Map<String,String>> haAdvancedOptions) {
            $.haAdvancedOptions = haAdvancedOptions;
            return this;
        }

        /**
         * @param haAdvancedOptions Advanced configuration options for vSphere HA.
         * 
         * @return builder
         * 
         */
        public Builder haAdvancedOptions(Map<String,String> haAdvancedOptions) {
            return haAdvancedOptions(Output.of(haAdvancedOptions));
        }

        /**
         * @param haDatastoreApdRecoveryAction When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an affected datastore clears in the middle of an APD event. Can be one of none or reset.
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdRecoveryAction(@Nullable Output<String> haDatastoreApdRecoveryAction) {
            $.haDatastoreApdRecoveryAction = haDatastoreApdRecoveryAction;
            return this;
        }

        /**
         * @param haDatastoreApdRecoveryAction When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an affected datastore clears in the middle of an APD event. Can be one of none or reset.
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdRecoveryAction(String haDatastoreApdRecoveryAction) {
            return haDatastoreApdRecoveryAction(Output.of(haDatastoreApdRecoveryAction));
        }

        /**
         * @param haDatastoreApdResponse When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdResponse(@Nullable Output<String> haDatastoreApdResponse) {
            $.haDatastoreApdResponse = haDatastoreApdResponse;
            return this;
        }

        /**
         * @param haDatastoreApdResponse When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdResponse(String haDatastoreApdResponse) {
            return haDatastoreApdResponse(Output.of(haDatastoreApdResponse));
        }

        /**
         * @param haDatastoreApdResponseDelay When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the response action defined in ha_datastore_apd_response.
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdResponseDelay(@Nullable Output<Integer> haDatastoreApdResponseDelay) {
            $.haDatastoreApdResponseDelay = haDatastoreApdResponseDelay;
            return this;
        }

        /**
         * @param haDatastoreApdResponseDelay When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the response action defined in ha_datastore_apd_response.
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdResponseDelay(Integer haDatastoreApdResponseDelay) {
            return haDatastoreApdResponseDelay(Output.of(haDatastoreApdResponseDelay));
        }

        /**
         * @param haDatastorePdlResponse When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
         * 
         * @return builder
         * 
         */
        public Builder haDatastorePdlResponse(@Nullable Output<String> haDatastorePdlResponse) {
            $.haDatastorePdlResponse = haDatastorePdlResponse;
            return this;
        }

        /**
         * @param haDatastorePdlResponse When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
         * 
         * @return builder
         * 
         */
        public Builder haDatastorePdlResponse(String haDatastorePdlResponse) {
            return haDatastorePdlResponse(Output.of(haDatastorePdlResponse));
        }

        /**
         * @param haEnabled Enable vSphere HA for this cluster.
         * 
         * @return builder
         * 
         */
        public Builder haEnabled(@Nullable Output<Boolean> haEnabled) {
            $.haEnabled = haEnabled;
            return this;
        }

        /**
         * @param haEnabled Enable vSphere HA for this cluster.
         * 
         * @return builder
         * 
         */
        public Builder haEnabled(Boolean haEnabled) {
            return haEnabled(Output.of(haEnabled));
        }

        /**
         * @param haHeartbeatDatastoreIds The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastoreIds(@Nullable Output<List<String>> haHeartbeatDatastoreIds) {
            $.haHeartbeatDatastoreIds = haHeartbeatDatastoreIds;
            return this;
        }

        /**
         * @param haHeartbeatDatastoreIds The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastoreIds(List<String> haHeartbeatDatastoreIds) {
            return haHeartbeatDatastoreIds(Output.of(haHeartbeatDatastoreIds));
        }

        /**
         * @param haHeartbeatDatastoreIds The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastoreIds(String... haHeartbeatDatastoreIds) {
            return haHeartbeatDatastoreIds(List.of(haHeartbeatDatastoreIds));
        }

        /**
         * @param haHeartbeatDatastorePolicy The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastorePolicy(@Nullable Output<String> haHeartbeatDatastorePolicy) {
            $.haHeartbeatDatastorePolicy = haHeartbeatDatastorePolicy;
            return this;
        }

        /**
         * @param haHeartbeatDatastorePolicy The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastorePolicy(String haHeartbeatDatastorePolicy) {
            return haHeartbeatDatastorePolicy(Output.of(haHeartbeatDatastorePolicy));
        }

        /**
         * @param haHostIsolationResponse The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster. Can be one of none, powerOff, or shutdown.
         * 
         * @return builder
         * 
         */
        public Builder haHostIsolationResponse(@Nullable Output<String> haHostIsolationResponse) {
            $.haHostIsolationResponse = haHostIsolationResponse;
            return this;
        }

        /**
         * @param haHostIsolationResponse The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster. Can be one of none, powerOff, or shutdown.
         * 
         * @return builder
         * 
         */
        public Builder haHostIsolationResponse(String haHostIsolationResponse) {
            return haHostIsolationResponse(Output.of(haHostIsolationResponse));
        }

        /**
         * @param haHostMonitoring Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
         * 
         * @return builder
         * 
         */
        public Builder haHostMonitoring(@Nullable Output<String> haHostMonitoring) {
            $.haHostMonitoring = haHostMonitoring;
            return this;
        }

        /**
         * @param haHostMonitoring Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
         * 
         * @return builder
         * 
         */
        public Builder haHostMonitoring(String haHostMonitoring) {
            return haHostMonitoring(Output.of(haHostMonitoring));
        }

        /**
         * @param haVmComponentProtection Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
         * 
         * @return builder
         * 
         */
        public Builder haVmComponentProtection(@Nullable Output<String> haVmComponentProtection) {
            $.haVmComponentProtection = haVmComponentProtection;
            return this;
        }

        /**
         * @param haVmComponentProtection Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
         * 
         * @return builder
         * 
         */
        public Builder haVmComponentProtection(String haVmComponentProtection) {
            return haVmComponentProtection(Output.of(haVmComponentProtection));
        }

        /**
         * @param haVmDependencyRestartCondition The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
         * 
         * @return builder
         * 
         */
        public Builder haVmDependencyRestartCondition(@Nullable Output<String> haVmDependencyRestartCondition) {
            $.haVmDependencyRestartCondition = haVmDependencyRestartCondition;
            return this;
        }

        /**
         * @param haVmDependencyRestartCondition The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
         * 
         * @return builder
         * 
         */
        public Builder haVmDependencyRestartCondition(String haVmDependencyRestartCondition) {
            return haVmDependencyRestartCondition(Output.of(haVmDependencyRestartCondition));
        }

        /**
         * @param haVmFailureInterval If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as failed. The value is in seconds.
         * 
         * @return builder
         * 
         */
        public Builder haVmFailureInterval(@Nullable Output<Integer> haVmFailureInterval) {
            $.haVmFailureInterval = haVmFailureInterval;
            return this;
        }

        /**
         * @param haVmFailureInterval If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as failed. The value is in seconds.
         * 
         * @return builder
         * 
         */
        public Builder haVmFailureInterval(Integer haVmFailureInterval) {
            return haVmFailureInterval(Output.of(haVmFailureInterval));
        }

        /**
         * @param haVmMaximumFailureWindow The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset time is allotted.
         * 
         * @return builder
         * 
         */
        public Builder haVmMaximumFailureWindow(@Nullable Output<Integer> haVmMaximumFailureWindow) {
            $.haVmMaximumFailureWindow = haVmMaximumFailureWindow;
            return this;
        }

        /**
         * @param haVmMaximumFailureWindow The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset time is allotted.
         * 
         * @return builder
         * 
         */
        public Builder haVmMaximumFailureWindow(Integer haVmMaximumFailureWindow) {
            return haVmMaximumFailureWindow(Output.of(haVmMaximumFailureWindow));
        }

        /**
         * @param haVmMaximumResets The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
         * 
         * @return builder
         * 
         */
        public Builder haVmMaximumResets(@Nullable Output<Integer> haVmMaximumResets) {
            $.haVmMaximumResets = haVmMaximumResets;
            return this;
        }

        /**
         * @param haVmMaximumResets The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
         * 
         * @return builder
         * 
         */
        public Builder haVmMaximumResets(Integer haVmMaximumResets) {
            return haVmMaximumResets(Output.of(haVmMaximumResets));
        }

        /**
         * @param haVmMinimumUptime The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
         * 
         * @return builder
         * 
         */
        public Builder haVmMinimumUptime(@Nullable Output<Integer> haVmMinimumUptime) {
            $.haVmMinimumUptime = haVmMinimumUptime;
            return this;
        }

        /**
         * @param haVmMinimumUptime The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
         * 
         * @return builder
         * 
         */
        public Builder haVmMinimumUptime(Integer haVmMinimumUptime) {
            return haVmMinimumUptime(Output.of(haVmMinimumUptime));
        }

        /**
         * @param haVmMonitoring The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring.
         * 
         * @return builder
         * 
         */
        public Builder haVmMonitoring(@Nullable Output<String> haVmMonitoring) {
            $.haVmMonitoring = haVmMonitoring;
            return this;
        }

        /**
         * @param haVmMonitoring The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring.
         * 
         * @return builder
         * 
         */
        public Builder haVmMonitoring(String haVmMonitoring) {
            return haVmMonitoring(Output.of(haVmMonitoring));
        }

        /**
         * @param haVmRestartAdditionalDelay Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartAdditionalDelay(@Nullable Output<Integer> haVmRestartAdditionalDelay) {
            $.haVmRestartAdditionalDelay = haVmRestartAdditionalDelay;
            return this;
        }

        /**
         * @param haVmRestartAdditionalDelay Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartAdditionalDelay(Integer haVmRestartAdditionalDelay) {
            return haVmRestartAdditionalDelay(Output.of(haVmRestartAdditionalDelay));
        }

        /**
         * @param haVmRestartPriority The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium, high, or highest.
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartPriority(@Nullable Output<String> haVmRestartPriority) {
            $.haVmRestartPriority = haVmRestartPriority;
            return this;
        }

        /**
         * @param haVmRestartPriority The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium, high, or highest.
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartPriority(String haVmRestartPriority) {
            return haVmRestartPriority(Output.of(haVmRestartPriority));
        }

        /**
         * @param haVmRestartTimeout The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before proceeding with the next priority.
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartTimeout(@Nullable Output<Integer> haVmRestartTimeout) {
            $.haVmRestartTimeout = haVmRestartTimeout;
            return this;
        }

        /**
         * @param haVmRestartTimeout The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before proceeding with the next priority.
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartTimeout(Integer haVmRestartTimeout) {
            return haVmRestartTimeout(Output.of(haVmRestartTimeout));
        }

        /**
         * @param hostClusterExitTimeout The timeout for each host maintenance mode operation when removing hosts from a cluster.
         * 
         * @return builder
         * 
         */
        public Builder hostClusterExitTimeout(@Nullable Output<Integer> hostClusterExitTimeout) {
            $.hostClusterExitTimeout = hostClusterExitTimeout;
            return this;
        }

        /**
         * @param hostClusterExitTimeout The timeout for each host maintenance mode operation when removing hosts from a cluster.
         * 
         * @return builder
         * 
         */
        public Builder hostClusterExitTimeout(Integer hostClusterExitTimeout) {
            return hostClusterExitTimeout(Output.of(hostClusterExitTimeout));
        }

        /**
         * @param hostImage Details about the host image which should be applied to the cluster.
         * 
         * @return builder
         * 
         */
        public Builder hostImage(@Nullable Output<ComputeClusterHostImageArgs> hostImage) {
            $.hostImage = hostImage;
            return this;
        }

        /**
         * @param hostImage Details about the host image which should be applied to the cluster.
         * 
         * @return builder
         * 
         */
        public Builder hostImage(ComputeClusterHostImageArgs hostImage) {
            return hostImage(Output.of(hostImage));
        }

        /**
         * @param hostManaged Must be set if cluster enrollment is managed from host resource.
         * 
         * @return builder
         * 
         */
        public Builder hostManaged(@Nullable Output<Boolean> hostManaged) {
            $.hostManaged = hostManaged;
            return this;
        }

        /**
         * @param hostManaged Must be set if cluster enrollment is managed from host resource.
         * 
         * @return builder
         * 
         */
        public Builder hostManaged(Boolean hostManaged) {
            return hostManaged(Output.of(hostManaged));
        }

        /**
         * @param hostSystemIds The managed object IDs of the hosts to put in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemIds(@Nullable Output<List<String>> hostSystemIds) {
            $.hostSystemIds = hostSystemIds;
            return this;
        }

        /**
         * @param hostSystemIds The managed object IDs of the hosts to put in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemIds(List<String> hostSystemIds) {
            return hostSystemIds(Output.of(hostSystemIds));
        }

        /**
         * @param hostSystemIds The managed object IDs of the hosts to put in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemIds(String... hostSystemIds) {
            return hostSystemIds(List.of(hostSystemIds));
        }

        /**
         * @param name The name of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param proactiveHaAutomationLevel The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaAutomationLevel(@Nullable Output<String> proactiveHaAutomationLevel) {
            $.proactiveHaAutomationLevel = proactiveHaAutomationLevel;
            return this;
        }

        /**
         * @param proactiveHaAutomationLevel The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaAutomationLevel(String proactiveHaAutomationLevel) {
            return proactiveHaAutomationLevel(Output.of(proactiveHaAutomationLevel));
        }

        /**
         * @param proactiveHaEnabled Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaEnabled(@Nullable Output<Boolean> proactiveHaEnabled) {
            $.proactiveHaEnabled = proactiveHaEnabled;
            return this;
        }

        /**
         * @param proactiveHaEnabled Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaEnabled(Boolean proactiveHaEnabled) {
            return proactiveHaEnabled(Output.of(proactiveHaEnabled));
        }

        /**
         * @param proactiveHaModerateRemediation The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaModerateRemediation(@Nullable Output<String> proactiveHaModerateRemediation) {
            $.proactiveHaModerateRemediation = proactiveHaModerateRemediation;
            return this;
        }

        /**
         * @param proactiveHaModerateRemediation The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaModerateRemediation(String proactiveHaModerateRemediation) {
            return proactiveHaModerateRemediation(Output.of(proactiveHaModerateRemediation));
        }

        /**
         * @param proactiveHaProviderIds The list of IDs for health update providers configured for this cluster.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaProviderIds(@Nullable Output<List<String>> proactiveHaProviderIds) {
            $.proactiveHaProviderIds = proactiveHaProviderIds;
            return this;
        }

        /**
         * @param proactiveHaProviderIds The list of IDs for health update providers configured for this cluster.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaProviderIds(List<String> proactiveHaProviderIds) {
            return proactiveHaProviderIds(Output.of(proactiveHaProviderIds));
        }

        /**
         * @param proactiveHaProviderIds The list of IDs for health update providers configured for this cluster.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaProviderIds(String... proactiveHaProviderIds) {
            return proactiveHaProviderIds(List.of(proactiveHaProviderIds));
        }

        /**
         * @param proactiveHaSevereRemediation The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaSevereRemediation(@Nullable Output<String> proactiveHaSevereRemediation) {
            $.proactiveHaSevereRemediation = proactiveHaSevereRemediation;
            return this;
        }

        /**
         * @param proactiveHaSevereRemediation The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaSevereRemediation(String proactiveHaSevereRemediation) {
            return proactiveHaSevereRemediation(Output.of(proactiveHaSevereRemediation));
        }

        /**
         * @param resourcePoolId The managed object ID of the primary
         * resource pool for this cluster. This can be passed directly to the
         * `resource_pool_id`
         * attribute of the
         * `vsphere.VirtualMachine` resource.
         * 
         * @return builder
         * 
         */
        public Builder resourcePoolId(@Nullable Output<String> resourcePoolId) {
            $.resourcePoolId = resourcePoolId;
            return this;
        }

        /**
         * @param resourcePoolId The managed object ID of the primary
         * resource pool for this cluster. This can be passed directly to the
         * `resource_pool_id`
         * attribute of the
         * `vsphere.VirtualMachine` resource.
         * 
         * @return builder
         * 
         */
        public Builder resourcePoolId(String resourcePoolId) {
            return resourcePoolId(Output.of(resourcePoolId));
        }

        /**
         * @param tags The IDs of any tags to attach to this resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags The IDs of any tags to attach to this resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags The IDs of any tags to attach to this resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param vsanCompressionEnabled Whether the vSAN compression service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanCompressionEnabled(@Nullable Output<Boolean> vsanCompressionEnabled) {
            $.vsanCompressionEnabled = vsanCompressionEnabled;
            return this;
        }

        /**
         * @param vsanCompressionEnabled Whether the vSAN compression service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanCompressionEnabled(Boolean vsanCompressionEnabled) {
            return vsanCompressionEnabled(Output.of(vsanCompressionEnabled));
        }

        /**
         * @param vsanDedupEnabled Whether the vSAN deduplication service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDedupEnabled(@Nullable Output<Boolean> vsanDedupEnabled) {
            $.vsanDedupEnabled = vsanDedupEnabled;
            return this;
        }

        /**
         * @param vsanDedupEnabled Whether the vSAN deduplication service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDedupEnabled(Boolean vsanDedupEnabled) {
            return vsanDedupEnabled(Output.of(vsanDedupEnabled));
        }

        /**
         * @param vsanDiskGroups A list of disk UUIDs to add to the vSAN cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDiskGroups(@Nullable Output<List<ComputeClusterVsanDiskGroupArgs>> vsanDiskGroups) {
            $.vsanDiskGroups = vsanDiskGroups;
            return this;
        }

        /**
         * @param vsanDiskGroups A list of disk UUIDs to add to the vSAN cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDiskGroups(List<ComputeClusterVsanDiskGroupArgs> vsanDiskGroups) {
            return vsanDiskGroups(Output.of(vsanDiskGroups));
        }

        /**
         * @param vsanDiskGroups A list of disk UUIDs to add to the vSAN cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDiskGroups(ComputeClusterVsanDiskGroupArgs... vsanDiskGroups) {
            return vsanDiskGroups(List.of(vsanDiskGroups));
        }

        /**
         * @param vsanDitEncryptionEnabled Whether the vSAN data-in-transit encryption is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDitEncryptionEnabled(@Nullable Output<Boolean> vsanDitEncryptionEnabled) {
            $.vsanDitEncryptionEnabled = vsanDitEncryptionEnabled;
            return this;
        }

        /**
         * @param vsanDitEncryptionEnabled Whether the vSAN data-in-transit encryption is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDitEncryptionEnabled(Boolean vsanDitEncryptionEnabled) {
            return vsanDitEncryptionEnabled(Output.of(vsanDitEncryptionEnabled));
        }

        /**
         * @param vsanDitRekeyInterval When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
         * 
         * @return builder
         * 
         */
        public Builder vsanDitRekeyInterval(@Nullable Output<Integer> vsanDitRekeyInterval) {
            $.vsanDitRekeyInterval = vsanDitRekeyInterval;
            return this;
        }

        /**
         * @param vsanDitRekeyInterval When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
         * 
         * @return builder
         * 
         */
        public Builder vsanDitRekeyInterval(Integer vsanDitRekeyInterval) {
            return vsanDitRekeyInterval(Output.of(vsanDitRekeyInterval));
        }

        /**
         * @param vsanEnabled Whether the vSAN service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanEnabled(@Nullable Output<Boolean> vsanEnabled) {
            $.vsanEnabled = vsanEnabled;
            return this;
        }

        /**
         * @param vsanEnabled Whether the vSAN service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanEnabled(Boolean vsanEnabled) {
            return vsanEnabled(Output.of(vsanEnabled));
        }

        /**
         * @param vsanEsaEnabled Whether the vSAN ESA service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanEsaEnabled(@Nullable Output<Boolean> vsanEsaEnabled) {
            $.vsanEsaEnabled = vsanEsaEnabled;
            return this;
        }

        /**
         * @param vsanEsaEnabled Whether the vSAN ESA service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanEsaEnabled(Boolean vsanEsaEnabled) {
            return vsanEsaEnabled(Output.of(vsanEsaEnabled));
        }

        /**
         * @param vsanFaultDomains The configuration for vSAN fault domains.
         * 
         * @return builder
         * 
         */
        public Builder vsanFaultDomains(@Nullable Output<List<ComputeClusterVsanFaultDomainArgs>> vsanFaultDomains) {
            $.vsanFaultDomains = vsanFaultDomains;
            return this;
        }

        /**
         * @param vsanFaultDomains The configuration for vSAN fault domains.
         * 
         * @return builder
         * 
         */
        public Builder vsanFaultDomains(List<ComputeClusterVsanFaultDomainArgs> vsanFaultDomains) {
            return vsanFaultDomains(Output.of(vsanFaultDomains));
        }

        /**
         * @param vsanFaultDomains The configuration for vSAN fault domains.
         * 
         * @return builder
         * 
         */
        public Builder vsanFaultDomains(ComputeClusterVsanFaultDomainArgs... vsanFaultDomains) {
            return vsanFaultDomains(List.of(vsanFaultDomains));
        }

        /**
         * @param vsanNetworkDiagnosticModeEnabled Whether the vSAN network diagnostic mode is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanNetworkDiagnosticModeEnabled(@Nullable Output<Boolean> vsanNetworkDiagnosticModeEnabled) {
            $.vsanNetworkDiagnosticModeEnabled = vsanNetworkDiagnosticModeEnabled;
            return this;
        }

        /**
         * @param vsanNetworkDiagnosticModeEnabled Whether the vSAN network diagnostic mode is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanNetworkDiagnosticModeEnabled(Boolean vsanNetworkDiagnosticModeEnabled) {
            return vsanNetworkDiagnosticModeEnabled(Output.of(vsanNetworkDiagnosticModeEnabled));
        }

        /**
         * @param vsanPerformanceEnabled Whether the vSAN performance service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanPerformanceEnabled(@Nullable Output<Boolean> vsanPerformanceEnabled) {
            $.vsanPerformanceEnabled = vsanPerformanceEnabled;
            return this;
        }

        /**
         * @param vsanPerformanceEnabled Whether the vSAN performance service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanPerformanceEnabled(Boolean vsanPerformanceEnabled) {
            return vsanPerformanceEnabled(Output.of(vsanPerformanceEnabled));
        }

        /**
         * @param vsanRemoteDatastoreIds The managed object IDs of the vSAN datastore to be mounted on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanRemoteDatastoreIds(@Nullable Output<List<String>> vsanRemoteDatastoreIds) {
            $.vsanRemoteDatastoreIds = vsanRemoteDatastoreIds;
            return this;
        }

        /**
         * @param vsanRemoteDatastoreIds The managed object IDs of the vSAN datastore to be mounted on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanRemoteDatastoreIds(List<String> vsanRemoteDatastoreIds) {
            return vsanRemoteDatastoreIds(Output.of(vsanRemoteDatastoreIds));
        }

        /**
         * @param vsanRemoteDatastoreIds The managed object IDs of the vSAN datastore to be mounted on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanRemoteDatastoreIds(String... vsanRemoteDatastoreIds) {
            return vsanRemoteDatastoreIds(List.of(vsanRemoteDatastoreIds));
        }

        /**
         * @param vsanStretchedCluster The configuration for stretched cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanStretchedCluster(@Nullable Output<ComputeClusterVsanStretchedClusterArgs> vsanStretchedCluster) {
            $.vsanStretchedCluster = vsanStretchedCluster;
            return this;
        }

        /**
         * @param vsanStretchedCluster The configuration for stretched cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanStretchedCluster(ComputeClusterVsanStretchedClusterArgs vsanStretchedCluster) {
            return vsanStretchedCluster(Output.of(vsanStretchedCluster));
        }

        /**
         * @param vsanUnmapEnabled Whether the vSAN unmap service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanUnmapEnabled(@Nullable Output<Boolean> vsanUnmapEnabled) {
            $.vsanUnmapEnabled = vsanUnmapEnabled;
            return this;
        }

        /**
         * @param vsanUnmapEnabled Whether the vSAN unmap service is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanUnmapEnabled(Boolean vsanUnmapEnabled) {
            return vsanUnmapEnabled(Output.of(vsanUnmapEnabled));
        }

        /**
         * @param vsanVerboseModeEnabled Whether the vSAN verbose mode is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanVerboseModeEnabled(@Nullable Output<Boolean> vsanVerboseModeEnabled) {
            $.vsanVerboseModeEnabled = vsanVerboseModeEnabled;
            return this;
        }

        /**
         * @param vsanVerboseModeEnabled Whether the vSAN verbose mode is enabled for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanVerboseModeEnabled(Boolean vsanVerboseModeEnabled) {
            return vsanVerboseModeEnabled(Output.of(vsanVerboseModeEnabled));
        }

        public ComputeClusterState build() {
            return $;
        }
    }

}
