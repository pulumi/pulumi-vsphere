// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.vsphere.inputs.ComputeClusterVsanDiskGroupArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ComputeClusterState extends com.pulumi.resources.ResourceArgs {

    public static final ComputeClusterState Empty = new ComputeClusterState();

    /**
     * A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
     * and require vCenter Server.
     * 
     */
    @Import(name="customAttributes")
    private @Nullable Output<Map<String,String>> customAttributes;

    /**
     * @return A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
     * and require vCenter Server.
     * 
     */
    public Optional<Output<Map<String,String>>> customAttributes() {
        return Optional.ofNullable(this.customAttributes);
    }

    /**
     * The managed object ID of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     * 
     */
    @Import(name="datacenterId")
    private @Nullable Output<String> datacenterId;

    /**
     * @return The managed object ID of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     * 
     */
    public Optional<Output<String>> datacenterId() {
        return Optional.ofNullable(this.datacenterId);
    }

    /**
     * The automation level for host power
     * operations in this cluster. Can be one of `manual` or `automated`. Default:
     * `manual`.
     * 
     */
    @Import(name="dpmAutomationLevel")
    private @Nullable Output<String> dpmAutomationLevel;

    /**
     * @return The automation level for host power
     * operations in this cluster. Can be one of `manual` or `automated`. Default:
     * `manual`.
     * 
     */
    public Optional<Output<String>> dpmAutomationLevel() {
        return Optional.ofNullable(this.dpmAutomationLevel);
    }

    /**
     * Enable DPM support for DRS in this cluster.
     * Requires `drs_enabled` to be `true` in order to be effective.
     * Default: `false`.
     * 
     */
    @Import(name="dpmEnabled")
    private @Nullable Output<Boolean> dpmEnabled;

    /**
     * @return Enable DPM support for DRS in this cluster.
     * Requires `drs_enabled` to be `true` in order to be effective.
     * Default: `false`.
     * 
     */
    public Optional<Output<Boolean>> dpmEnabled() {
        return Optional.ofNullable(this.dpmEnabled);
    }

    /**
     * A value between `1` and `5` indicating the
     * threshold of load within the cluster that influences host power operations.
     * This affects both power on and power off operations - a lower setting will
     * tolerate more of a surplus/deficit than a higher setting. Default: `3`.
     * 
     */
    @Import(name="dpmThreshold")
    private @Nullable Output<Integer> dpmThreshold;

    /**
     * @return A value between `1` and `5` indicating the
     * threshold of load within the cluster that influences host power operations.
     * This affects both power on and power off operations - a lower setting will
     * tolerate more of a surplus/deficit than a higher setting. Default: `3`.
     * 
     */
    public Optional<Output<Integer>> dpmThreshold() {
        return Optional.ofNullable(this.dpmThreshold);
    }

    /**
     * A key/value map that specifies advanced
     * options for DRS and DPM.
     * 
     */
    @Import(name="drsAdvancedOptions")
    private @Nullable Output<Map<String,String>> drsAdvancedOptions;

    /**
     * @return A key/value map that specifies advanced
     * options for DRS and DPM.
     * 
     */
    public Optional<Output<Map<String,String>>> drsAdvancedOptions() {
        return Optional.ofNullable(this.drsAdvancedOptions);
    }

    /**
     * The default automation level for all
     * virtual machines in this cluster. Can be one of `manual`,
     * `partiallyAutomated`, or `fullyAutomated`. Default: `manual`.
     * 
     */
    @Import(name="drsAutomationLevel")
    private @Nullable Output<String> drsAutomationLevel;

    /**
     * @return The default automation level for all
     * virtual machines in this cluster. Can be one of `manual`,
     * `partiallyAutomated`, or `fullyAutomated`. Default: `manual`.
     * 
     */
    public Optional<Output<String>> drsAutomationLevel() {
        return Optional.ofNullable(this.drsAutomationLevel);
    }

    /**
     * When `true`, enables DRS to use data
     * from [vRealize Operations Manager][ref-vsphere-vrops] to make proactive DRS
     * recommendations. &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="drsEnablePredictiveDrs")
    private @Nullable Output<Boolean> drsEnablePredictiveDrs;

    /**
     * @return When `true`, enables DRS to use data
     * from [vRealize Operations Manager][ref-vsphere-vrops] to make proactive DRS
     * recommendations. &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<Boolean>> drsEnablePredictiveDrs() {
        return Optional.ofNullable(this.drsEnablePredictiveDrs);
    }

    /**
     * Allow individual DRS overrides to be
     * set for virtual machines in the cluster. Default: `true`.
     * 
     */
    @Import(name="drsEnableVmOverrides")
    private @Nullable Output<Boolean> drsEnableVmOverrides;

    /**
     * @return Allow individual DRS overrides to be
     * set for virtual machines in the cluster. Default: `true`.
     * 
     */
    public Optional<Output<Boolean>> drsEnableVmOverrides() {
        return Optional.ofNullable(this.drsEnableVmOverrides);
    }

    /**
     * Enable DRS for this cluster. Default: `false`.
     * 
     */
    @Import(name="drsEnabled")
    private @Nullable Output<Boolean> drsEnabled;

    /**
     * @return Enable DRS for this cluster. Default: `false`.
     * 
     */
    public Optional<Output<Boolean>> drsEnabled() {
        return Optional.ofNullable(this.drsEnabled);
    }

    /**
     * A value between `1` and `5` indicating
     * the threshold of imbalance tolerated between hosts. A lower setting will
     * tolerate more imbalance while a higher setting will tolerate less. Default:
     * `3`.
     * 
     */
    @Import(name="drsMigrationThreshold")
    private @Nullable Output<Integer> drsMigrationThreshold;

    /**
     * @return A value between `1` and `5` indicating
     * the threshold of imbalance tolerated between hosts. A lower setting will
     * tolerate more imbalance while a higher setting will tolerate less. Default:
     * `3`.
     * 
     */
    public Optional<Output<Integer>> drsMigrationThreshold() {
        return Optional.ofNullable(this.drsMigrationThreshold);
    }

    /**
     * Enable scalable shares for all
     * resource pools in the cluster. Can be one of `disabled` or
     * `scaleCpuAndMemoryShares`. Default: `disabled`.
     * 
     */
    @Import(name="drsScaleDescendantsShares")
    private @Nullable Output<String> drsScaleDescendantsShares;

    /**
     * @return Enable scalable shares for all
     * resource pools in the cluster. Can be one of `disabled` or
     * `scaleCpuAndMemoryShares`. Default: `disabled`.
     * 
     */
    public Optional<Output<String>> drsScaleDescendantsShares() {
        return Optional.ofNullable(this.drsScaleDescendantsShares);
    }

    /**
     * The relative path to a folder to put this cluster in.
     * This is a path relative to the datacenter you are deploying the cluster to.
     * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
     * The provider will place a cluster named `compute-cluster-test` in a
     * host folder located at `/dc1/host/foo/bar`, with the final inventory path
     * being `/dc1/host/foo/bar/datastore-cluster-test`.
     * 
     */
    @Import(name="folder")
    private @Nullable Output<String> folder;

    /**
     * @return The relative path to a folder to put this cluster in.
     * This is a path relative to the datacenter you are deploying the cluster to.
     * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
     * The provider will place a cluster named `compute-cluster-test` in a
     * host folder located at `/dc1/host/foo/bar`, with the final inventory path
     * being `/dc1/host/foo/bar/datastore-cluster-test`.
     * 
     */
    public Optional<Output<String>> folder() {
        return Optional.ofNullable(this.folder);
    }

    /**
     * When destroying the resource, setting this to
     * `true` will auto-remove any hosts that are currently a member of the cluster,
     * as if they were removed by taking their entry out of `host_system_ids` (see
     * below. This is an advanced
     * option and should only be used for testing. Default: `false`.
     * 
     * &gt; **NOTE:** Do not set `force_evacuate_on_destroy` in production operation as
     * there are many pitfalls to its use when working with complex cluster
     * configurations. Depending on the virtual machines currently on the cluster, and
     * your DRS and HA settings, the full host evacuation may fail. Instead,
     * incrementally remove hosts from your configuration by adjusting the contents of
     * the `host_system_ids` attribute.
     * 
     */
    @Import(name="forceEvacuateOnDestroy")
    private @Nullable Output<Boolean> forceEvacuateOnDestroy;

    /**
     * @return When destroying the resource, setting this to
     * `true` will auto-remove any hosts that are currently a member of the cluster,
     * as if they were removed by taking their entry out of `host_system_ids` (see
     * below. This is an advanced
     * option and should only be used for testing. Default: `false`.
     * 
     * &gt; **NOTE:** Do not set `force_evacuate_on_destroy` in production operation as
     * there are many pitfalls to its use when working with complex cluster
     * configurations. Depending on the virtual machines currently on the cluster, and
     * your DRS and HA settings, the full host evacuation may fail. Instead,
     * incrementally remove hosts from your configuration by adjusting the contents of
     * the `host_system_ids` attribute.
     * 
     */
    public Optional<Output<Boolean>> forceEvacuateOnDestroy() {
        return Optional.ofNullable(this.forceEvacuateOnDestroy);
    }

    /**
     * Defines the
     * managed object IDs of hosts to use as dedicated failover
     * hosts. These hosts are kept as available as possible - admission control will
     * block access to the host, and DRS will ignore the host when making
     * recommendations.
     * 
     */
    @Import(name="haAdmissionControlFailoverHostSystemIds")
    private @Nullable Output<List<String>> haAdmissionControlFailoverHostSystemIds;

    /**
     * @return Defines the
     * managed object IDs of hosts to use as dedicated failover
     * hosts. These hosts are kept as available as possible - admission control will
     * block access to the host, and DRS will ignore the host when making
     * recommendations.
     * 
     */
    public Optional<Output<List<String>>> haAdmissionControlFailoverHostSystemIds() {
        return Optional.ofNullable(this.haAdmissionControlFailoverHostSystemIds);
    }

    /**
     * The maximum number
     * of failed hosts that admission control tolerates when making decisions on
     * whether to permit virtual machine operations. The maximum is one less than
     * the number of hosts in the cluster. Default: `1`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haAdmissionControlHostFailureTolerance")
    private @Nullable Output<Integer> haAdmissionControlHostFailureTolerance;

    /**
     * @return The maximum number
     * of failed hosts that admission control tolerates when making decisions on
     * whether to permit virtual machine operations. The maximum is one less than
     * the number of hosts in the cluster. Default: `1`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlHostFailureTolerance() {
        return Optional.ofNullable(this.haAdmissionControlHostFailureTolerance);
    }

    /**
     * The percentage of
     * resource reduction that a cluster of virtual machines can tolerate in case of
     * a failover. A value of 0 produces warnings only, whereas a value of 100
     * disables the setting. Default: `100` (disabled).
     * 
     */
    @Import(name="haAdmissionControlPerformanceTolerance")
    private @Nullable Output<Integer> haAdmissionControlPerformanceTolerance;

    /**
     * @return The percentage of
     * resource reduction that a cluster of virtual machines can tolerate in case of
     * a failover. A value of 0 produces warnings only, whereas a value of 100
     * disables the setting. Default: `100` (disabled).
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlPerformanceTolerance() {
        return Optional.ofNullable(this.haAdmissionControlPerformanceTolerance);
    }

    /**
     * The type of admission control
     * policy to use with vSphere HA. Can be one of `resourcePercentage`,
     * `slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.
     * 
     */
    @Import(name="haAdmissionControlPolicy")
    private @Nullable Output<String> haAdmissionControlPolicy;

    /**
     * @return The type of admission control
     * policy to use with vSphere HA. Can be one of `resourcePercentage`,
     * `slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.
     * 
     */
    public Optional<Output<String>> haAdmissionControlPolicy() {
        return Optional.ofNullable(this.haAdmissionControlPolicy);
    }

    /**
     * Automatically determine available resource percentages by subtracting the
     * average number of host resources represented by the
     * `ha_admission_control_host_failure_tolerance`
     * setting from the total amount of resources in the cluster. Disable to supply
     * user-defined values. Default: `true`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haAdmissionControlResourcePercentageAutoCompute")
    private @Nullable Output<Boolean> haAdmissionControlResourcePercentageAutoCompute;

    /**
     * @return Automatically determine available resource percentages by subtracting the
     * average number of host resources represented by the
     * `ha_admission_control_host_failure_tolerance`
     * setting from the total amount of resources in the cluster. Disable to supply
     * user-defined values. Default: `true`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<Boolean>> haAdmissionControlResourcePercentageAutoCompute() {
        return Optional.ofNullable(this.haAdmissionControlResourcePercentageAutoCompute);
    }

    /**
     * Controls the
     * user-defined percentage of CPU resources in the cluster to reserve for
     * failover. Default: `100`.
     * 
     */
    @Import(name="haAdmissionControlResourcePercentageCpu")
    private @Nullable Output<Integer> haAdmissionControlResourcePercentageCpu;

    /**
     * @return Controls the
     * user-defined percentage of CPU resources in the cluster to reserve for
     * failover. Default: `100`.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlResourcePercentageCpu() {
        return Optional.ofNullable(this.haAdmissionControlResourcePercentageCpu);
    }

    /**
     * Controls the
     * user-defined percentage of memory resources in the cluster to reserve for
     * failover. Default: `100`.
     * 
     */
    @Import(name="haAdmissionControlResourcePercentageMemory")
    private @Nullable Output<Integer> haAdmissionControlResourcePercentageMemory;

    /**
     * @return Controls the
     * user-defined percentage of memory resources in the cluster to reserve for
     * failover. Default: `100`.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlResourcePercentageMemory() {
        return Optional.ofNullable(this.haAdmissionControlResourcePercentageMemory);
    }

    /**
     * Controls the
     * user-defined CPU slot size, in MHz. Default: `32`.
     * 
     */
    @Import(name="haAdmissionControlSlotPolicyExplicitCpu")
    private @Nullable Output<Integer> haAdmissionControlSlotPolicyExplicitCpu;

    /**
     * @return Controls the
     * user-defined CPU slot size, in MHz. Default: `32`.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlSlotPolicyExplicitCpu() {
        return Optional.ofNullable(this.haAdmissionControlSlotPolicyExplicitCpu);
    }

    /**
     * Controls the
     * user-defined memory slot size, in MB. Default: `100`.
     * 
     */
    @Import(name="haAdmissionControlSlotPolicyExplicitMemory")
    private @Nullable Output<Integer> haAdmissionControlSlotPolicyExplicitMemory;

    /**
     * @return Controls the
     * user-defined memory slot size, in MB. Default: `100`.
     * 
     */
    public Optional<Output<Integer>> haAdmissionControlSlotPolicyExplicitMemory() {
        return Optional.ofNullable(this.haAdmissionControlSlotPolicyExplicitMemory);
    }

    /**
     * Controls
     * whether or not you wish to supply explicit values to CPU and memory slot
     * sizes. The default is `false`, which tells vSphere to gather a automatic
     * average based on all powered-on virtual machines currently in the cluster.
     * 
     */
    @Import(name="haAdmissionControlSlotPolicyUseExplicitSize")
    private @Nullable Output<Boolean> haAdmissionControlSlotPolicyUseExplicitSize;

    /**
     * @return Controls
     * whether or not you wish to supply explicit values to CPU and memory slot
     * sizes. The default is `false`, which tells vSphere to gather a automatic
     * average based on all powered-on virtual machines currently in the cluster.
     * 
     */
    public Optional<Output<Boolean>> haAdmissionControlSlotPolicyUseExplicitSize() {
        return Optional.ofNullable(this.haAdmissionControlSlotPolicyUseExplicitSize);
    }

    /**
     * A key/value map that specifies advanced
     * options for vSphere HA.
     * 
     */
    @Import(name="haAdvancedOptions")
    private @Nullable Output<Map<String,String>> haAdvancedOptions;

    /**
     * @return A key/value map that specifies advanced
     * options for vSphere HA.
     * 
     */
    public Optional<Output<Map<String,String>>> haAdvancedOptions() {
        return Optional.ofNullable(this.haAdvancedOptions);
    }

    /**
     * Controls the action to take
     * on virtual machines if an APD status on an affected datastore clears in the
     * middle of an APD event. Can be one of `none` or `reset`. Default: `none`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haDatastoreApdRecoveryAction")
    private @Nullable Output<String> haDatastoreApdRecoveryAction;

    /**
     * @return Controls the action to take
     * on virtual machines if an APD status on an affected datastore clears in the
     * middle of an APD event. Can be one of `none` or `reset`. Default: `none`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<String>> haDatastoreApdRecoveryAction() {
        return Optional.ofNullable(this.haDatastoreApdRecoveryAction);
    }

    /**
     * Controls the action to take on
     * virtual machines when the cluster has detected loss to all paths to a
     * relevant datastore. Can be one of `disabled`, `warning`,
     * `restartConservative`, or `restartAggressive`.  Default: `disabled`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haDatastoreApdResponse")
    private @Nullable Output<String> haDatastoreApdResponse;

    /**
     * @return Controls the action to take on
     * virtual machines when the cluster has detected loss to all paths to a
     * relevant datastore. Can be one of `disabled`, `warning`,
     * `restartConservative`, or `restartAggressive`.  Default: `disabled`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<String>> haDatastoreApdResponse() {
        return Optional.ofNullable(this.haDatastoreApdResponse);
    }

    /**
     * The time, in seconds,
     * to wait after an APD timeout event to run the response action defined in
     * `ha_datastore_apd_response`. Default: `180`
     * seconds (3 minutes). &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haDatastoreApdResponseDelay")
    private @Nullable Output<Integer> haDatastoreApdResponseDelay;

    /**
     * @return The time, in seconds,
     * to wait after an APD timeout event to run the response action defined in
     * `ha_datastore_apd_response`. Default: `180`
     * seconds (3 minutes). &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<Integer>> haDatastoreApdResponseDelay() {
        return Optional.ofNullable(this.haDatastoreApdResponseDelay);
    }

    /**
     * Controls the action to take on
     * virtual machines when the cluster has detected a permanent device loss to a
     * relevant datastore. Can be one of `disabled`, `warning`, or
     * `restartAggressive`. Default: `disabled`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haDatastorePdlResponse")
    private @Nullable Output<String> haDatastorePdlResponse;

    /**
     * @return Controls the action to take on
     * virtual machines when the cluster has detected a permanent device loss to a
     * relevant datastore. Can be one of `disabled`, `warning`, or
     * `restartAggressive`. Default: `disabled`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<String>> haDatastorePdlResponse() {
        return Optional.ofNullable(this.haDatastorePdlResponse);
    }

    /**
     * Enable vSphere HA for this cluster. Default:
     * `false`.
     * 
     */
    @Import(name="haEnabled")
    private @Nullable Output<Boolean> haEnabled;

    /**
     * @return Enable vSphere HA for this cluster. Default:
     * `false`.
     * 
     */
    public Optional<Output<Boolean>> haEnabled() {
        return Optional.ofNullable(this.haEnabled);
    }

    /**
     * The list of managed object IDs for
     * preferred datastores to use for HA heartbeating. This setting is only useful
     * when `ha_heartbeat_datastore_policy` is set
     * to either `userSelectedDs` or `allFeasibleDsWithUserPreference`.
     * 
     */
    @Import(name="haHeartbeatDatastoreIds")
    private @Nullable Output<List<String>> haHeartbeatDatastoreIds;

    /**
     * @return The list of managed object IDs for
     * preferred datastores to use for HA heartbeating. This setting is only useful
     * when `ha_heartbeat_datastore_policy` is set
     * to either `userSelectedDs` or `allFeasibleDsWithUserPreference`.
     * 
     */
    public Optional<Output<List<String>>> haHeartbeatDatastoreIds() {
        return Optional.ofNullable(this.haHeartbeatDatastoreIds);
    }

    /**
     * The selection policy for HA
     * heartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or
     * `allFeasibleDsWithUserPreference`. Default:
     * `allFeasibleDsWithUserPreference`.
     * 
     */
    @Import(name="haHeartbeatDatastorePolicy")
    private @Nullable Output<String> haHeartbeatDatastorePolicy;

    /**
     * @return The selection policy for HA
     * heartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or
     * `allFeasibleDsWithUserPreference`. Default:
     * `allFeasibleDsWithUserPreference`.
     * 
     */
    public Optional<Output<String>> haHeartbeatDatastorePolicy() {
        return Optional.ofNullable(this.haHeartbeatDatastorePolicy);
    }

    /**
     * The action to take on virtual
     * machines when a host has detected that it has been isolated from the rest of
     * the cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:
     * `none`.
     * 
     */
    @Import(name="haHostIsolationResponse")
    private @Nullable Output<String> haHostIsolationResponse;

    /**
     * @return The action to take on virtual
     * machines when a host has detected that it has been isolated from the rest of
     * the cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:
     * `none`.
     * 
     */
    public Optional<Output<String>> haHostIsolationResponse() {
        return Optional.ofNullable(this.haHostIsolationResponse);
    }

    /**
     * Global setting that controls whether
     * vSphere HA remediates virtual machines on host failure. Can be one of `enabled`
     * or `disabled`. Default: `enabled`.
     * 
     */
    @Import(name="haHostMonitoring")
    private @Nullable Output<String> haHostMonitoring;

    /**
     * @return Global setting that controls whether
     * vSphere HA remediates virtual machines on host failure. Can be one of `enabled`
     * or `disabled`. Default: `enabled`.
     * 
     */
    public Optional<Output<String>> haHostMonitoring() {
        return Optional.ofNullable(this.haHostMonitoring);
    }

    /**
     * Controls vSphere VM component
     * protection for virtual machines in this cluster. Can be one of `enabled` or
     * `disabled`. Default: `enabled`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haVmComponentProtection")
    private @Nullable Output<String> haVmComponentProtection;

    /**
     * @return Controls vSphere VM component
     * protection for virtual machines in this cluster. Can be one of `enabled` or
     * `disabled`. Default: `enabled`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<String>> haVmComponentProtection() {
        return Optional.ofNullable(this.haVmComponentProtection);
    }

    /**
     * The condition used to
     * determine whether or not virtual machines in a certain restart priority class
     * are online, allowing HA to move on to restarting virtual machines on the next
     * priority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or
     * `appHbStatusGreen`. The default is `none`, which means that a virtual machine
     * is considered ready immediately after a host is found to start it on.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haVmDependencyRestartCondition")
    private @Nullable Output<String> haVmDependencyRestartCondition;

    /**
     * @return The condition used to
     * determine whether or not virtual machines in a certain restart priority class
     * are online, allowing HA to move on to restarting virtual machines on the next
     * priority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or
     * `appHbStatusGreen`. The default is `none`, which means that a virtual machine
     * is considered ready immediately after a host is found to start it on.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<String>> haVmDependencyRestartCondition() {
        return Optional.ofNullable(this.haVmDependencyRestartCondition);
    }

    /**
     * The time interval, in seconds, a heartbeat
     * from a virtual machine is not received within this configured interval,
     * the virtual machine is marked as failed. Default: `30` seconds.
     * 
     */
    @Import(name="haVmFailureInterval")
    private @Nullable Output<Integer> haVmFailureInterval;

    /**
     * @return The time interval, in seconds, a heartbeat
     * from a virtual machine is not received within this configured interval,
     * the virtual machine is marked as failed. Default: `30` seconds.
     * 
     */
    public Optional<Output<Integer>> haVmFailureInterval() {
        return Optional.ofNullable(this.haVmFailureInterval);
    }

    /**
     * The time, in seconds, for the reset window in
     * which `ha_vm_maximum_resets` can operate. When this
     * window expires, no more resets are attempted regardless of the setting
     * configured in `ha_vm_maximum_resets`. `-1` means no window, meaning an
     * unlimited reset time is allotted. Default: `-1` (no window).
     * 
     */
    @Import(name="haVmMaximumFailureWindow")
    private @Nullable Output<Integer> haVmMaximumFailureWindow;

    /**
     * @return The time, in seconds, for the reset window in
     * which `ha_vm_maximum_resets` can operate. When this
     * window expires, no more resets are attempted regardless of the setting
     * configured in `ha_vm_maximum_resets`. `-1` means no window, meaning an
     * unlimited reset time is allotted. Default: `-1` (no window).
     * 
     */
    public Optional<Output<Integer>> haVmMaximumFailureWindow() {
        return Optional.ofNullable(this.haVmMaximumFailureWindow);
    }

    /**
     * The maximum number of resets that HA will
     * perform to a virtual machine when responding to a failure event. Default: `3`
     * 
     */
    @Import(name="haVmMaximumResets")
    private @Nullable Output<Integer> haVmMaximumResets;

    /**
     * @return The maximum number of resets that HA will
     * perform to a virtual machine when responding to a failure event. Default: `3`
     * 
     */
    public Optional<Output<Integer>> haVmMaximumResets() {
        return Optional.ofNullable(this.haVmMaximumResets);
    }

    /**
     * The time, in seconds, that HA waits after
     * powering on a virtual machine before monitoring for heartbeats. Default:
     * `120` seconds (2 minutes).
     * 
     */
    @Import(name="haVmMinimumUptime")
    private @Nullable Output<Integer> haVmMinimumUptime;

    /**
     * @return The time, in seconds, that HA waits after
     * powering on a virtual machine before monitoring for heartbeats. Default:
     * `120` seconds (2 minutes).
     * 
     */
    public Optional<Output<Integer>> haVmMinimumUptime() {
        return Optional.ofNullable(this.haVmMinimumUptime);
    }

    /**
     * The type of virtual machine monitoring to use
     * when HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,
     * `vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.
     * 
     */
    @Import(name="haVmMonitoring")
    private @Nullable Output<String> haVmMonitoring;

    /**
     * @return The type of virtual machine monitoring to use
     * when HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,
     * `vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.
     * 
     */
    public Optional<Output<String>> haVmMonitoring() {
        return Optional.ofNullable(this.haVmMonitoring);
    }

    /**
     * Additional delay, in seconds,
     * after ready condition is met. A VM is considered ready at this point.
     * Default: `0` seconds (no delay). &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haVmRestartAdditionalDelay")
    private @Nullable Output<Integer> haVmRestartAdditionalDelay;

    /**
     * @return Additional delay, in seconds,
     * after ready condition is met. A VM is considered ready at this point.
     * Default: `0` seconds (no delay). &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<Integer>> haVmRestartAdditionalDelay() {
        return Optional.ofNullable(this.haVmRestartAdditionalDelay);
    }

    /**
     * The default restart priority
     * for affected virtual machines when vSphere detects a host failure. Can be one
     * of `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.
     * 
     */
    @Import(name="haVmRestartPriority")
    private @Nullable Output<String> haVmRestartPriority;

    /**
     * @return The default restart priority
     * for affected virtual machines when vSphere detects a host failure. Can be one
     * of `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.
     * 
     */
    public Optional<Output<String>> haVmRestartPriority() {
        return Optional.ofNullable(this.haVmRestartPriority);
    }

    /**
     * The maximum time, in seconds,
     * that vSphere HA will wait for virtual machines in one priority to be ready
     * before proceeding with the next priority. Default: `600` seconds (10 minutes).
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="haVmRestartTimeout")
    private @Nullable Output<Integer> haVmRestartTimeout;

    /**
     * @return The maximum time, in seconds,
     * that vSphere HA will wait for virtual machines in one priority to be ready
     * before proceeding with the next priority. Default: `600` seconds (10 minutes).
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<Integer>> haVmRestartTimeout() {
        return Optional.ofNullable(this.haVmRestartTimeout);
    }

    /**
     * The timeout, in seconds, for each host maintenance
     * mode operation when removing hosts from a cluster. Default: `3600` seconds (1 hour).
     * 
     */
    @Import(name="hostClusterExitTimeout")
    private @Nullable Output<Integer> hostClusterExitTimeout;

    /**
     * @return The timeout, in seconds, for each host maintenance
     * mode operation when removing hosts from a cluster. Default: `3600` seconds (1 hour).
     * 
     */
    public Optional<Output<Integer>> hostClusterExitTimeout() {
        return Optional.ofNullable(this.hostClusterExitTimeout);
    }

    /**
     * Can be set to `true` if compute cluster
     * membership will be managed through the `host` resource rather than the
     * `compute_cluster` resource. Conflicts with: `host_system_ids`.
     * 
     */
    @Import(name="hostManaged")
    private @Nullable Output<Boolean> hostManaged;

    /**
     * @return Can be set to `true` if compute cluster
     * membership will be managed through the `host` resource rather than the
     * `compute_cluster` resource. Conflicts with: `host_system_ids`.
     * 
     */
    public Optional<Output<Boolean>> hostManaged() {
        return Optional.ofNullable(this.hostManaged);
    }

    /**
     * The managed object IDs of
     * the hosts to put in the cluster. Conflicts with: `host_managed`.
     * 
     */
    @Import(name="hostSystemIds")
    private @Nullable Output<List<String>> hostSystemIds;

    /**
     * @return The managed object IDs of
     * the hosts to put in the cluster. Conflicts with: `host_managed`.
     * 
     */
    public Optional<Output<List<String>>> hostSystemIds() {
        return Optional.ofNullable(this.hostSystemIds);
    }

    /**
     * The name of the cluster.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the cluster.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Determines how the host
     * quarantine, maintenance mode, or virtual machine migration recommendations
     * made by proactive HA are to be handled. Can be one of `Automated` or
     * `Manual`. Default: `Manual`. &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="proactiveHaAutomationLevel")
    private @Nullable Output<String> proactiveHaAutomationLevel;

    /**
     * @return Determines how the host
     * quarantine, maintenance mode, or virtual machine migration recommendations
     * made by proactive HA are to be handled. Can be one of `Automated` or
     * `Manual`. Default: `Manual`. &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<String>> proactiveHaAutomationLevel() {
        return Optional.ofNullable(this.proactiveHaAutomationLevel);
    }

    /**
     * Enables Proactive HA. Default: `false`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="proactiveHaEnabled")
    private @Nullable Output<Boolean> proactiveHaEnabled;

    /**
     * @return Enables Proactive HA. Default: `false`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<Boolean>> proactiveHaEnabled() {
        return Optional.ofNullable(this.proactiveHaEnabled);
    }

    /**
     * The configured remediation
     * for moderately degraded hosts. Can be one of `MaintenanceMode` or
     * `QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when
     * `proactive_ha_severe_remediation` is set
     * to `QuarantineMode`. Default: `QuarantineMode`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="proactiveHaModerateRemediation")
    private @Nullable Output<String> proactiveHaModerateRemediation;

    /**
     * @return The configured remediation
     * for moderately degraded hosts. Can be one of `MaintenanceMode` or
     * `QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when
     * `proactive_ha_severe_remediation` is set
     * to `QuarantineMode`. Default: `QuarantineMode`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<String>> proactiveHaModerateRemediation() {
        return Optional.ofNullable(this.proactiveHaModerateRemediation);
    }

    /**
     * The list of IDs for health update
     * providers configured for this cluster.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="proactiveHaProviderIds")
    private @Nullable Output<List<String>> proactiveHaProviderIds;

    /**
     * @return The list of IDs for health update
     * providers configured for this cluster.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<List<String>>> proactiveHaProviderIds() {
        return Optional.ofNullable(this.proactiveHaProviderIds);
    }

    /**
     * The configured remediation for
     * severely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.
     * Note that this cannot be set to `QuarantineMode` when
     * `proactive_ha_moderate_remediation` is
     * set to `MaintenanceMode`. Default: `QuarantineMode`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    @Import(name="proactiveHaSevereRemediation")
    private @Nullable Output<String> proactiveHaSevereRemediation;

    /**
     * @return The configured remediation for
     * severely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.
     * Note that this cannot be set to `QuarantineMode` when
     * `proactive_ha_moderate_remediation` is
     * set to `MaintenanceMode`. Default: `QuarantineMode`.
     * &lt;sup&gt;\*&lt;/sup&gt;
     * 
     */
    public Optional<Output<String>> proactiveHaSevereRemediation() {
        return Optional.ofNullable(this.proactiveHaSevereRemediation);
    }

    /**
     * The managed object ID of the primary
     * resource pool for this cluster. This can be passed directly to the
     * `resource_pool_id`
     * attribute of the
     * `vsphere.VirtualMachine` resource.
     * 
     */
    @Import(name="resourcePoolId")
    private @Nullable Output<String> resourcePoolId;

    /**
     * @return The managed object ID of the primary
     * resource pool for this cluster. This can be passed directly to the
     * `resource_pool_id`
     * attribute of the
     * `vsphere.VirtualMachine` resource.
     * 
     */
    public Optional<Output<String>> resourcePoolId() {
        return Optional.ofNullable(this.resourcePoolId);
    }

    /**
     * The IDs of any tags to attach to this resource.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return The IDs of any tags to attach to this resource.
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * Enables vSAN compression on the
     * cluster.
     * 
     */
    @Import(name="vsanCompressionEnabled")
    private @Nullable Output<Boolean> vsanCompressionEnabled;

    /**
     * @return Enables vSAN compression on the
     * cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanCompressionEnabled() {
        return Optional.ofNullable(this.vsanCompressionEnabled);
    }

    /**
     * Enables vSAN deduplication on the cluster.
     * Cannot be independently set to true. When vSAN deduplication is enabled, vSAN
     * compression must also be enabled.
     * 
     */
    @Import(name="vsanDedupEnabled")
    private @Nullable Output<Boolean> vsanDedupEnabled;

    /**
     * @return Enables vSAN deduplication on the cluster.
     * Cannot be independently set to true. When vSAN deduplication is enabled, vSAN
     * compression must also be enabled.
     * 
     */
    public Optional<Output<Boolean>> vsanDedupEnabled() {
        return Optional.ofNullable(this.vsanDedupEnabled);
    }

    /**
     * Represents the configuration of a host disk
     * group in the cluster.
     * 
     */
    @Import(name="vsanDiskGroups")
    private @Nullable Output<List<ComputeClusterVsanDiskGroupArgs>> vsanDiskGroups;

    /**
     * @return Represents the configuration of a host disk
     * group in the cluster.
     * 
     */
    public Optional<Output<List<ComputeClusterVsanDiskGroupArgs>>> vsanDiskGroups() {
        return Optional.ofNullable(this.vsanDiskGroups);
    }

    /**
     * Enables vSAN data-in-transit
     * encryption on the cluster. Conflicts with `vsan_remote_datastore_ids`, i.e.,
     * vSAN data-in-transit feature cannot be enabled with the vSAN HCI Mesh feature
     * at the same time.
     * 
     */
    @Import(name="vsanDitEncryptionEnabled")
    private @Nullable Output<Boolean> vsanDitEncryptionEnabled;

    /**
     * @return Enables vSAN data-in-transit
     * encryption on the cluster. Conflicts with `vsan_remote_datastore_ids`, i.e.,
     * vSAN data-in-transit feature cannot be enabled with the vSAN HCI Mesh feature
     * at the same time.
     * 
     */
    public Optional<Output<Boolean>> vsanDitEncryptionEnabled() {
        return Optional.ofNullable(this.vsanDitEncryptionEnabled);
    }

    /**
     * Indicates the rekey interval in
     * minutes for data-in-transit encryption. The valid rekey interval is 30 to
     * 10800 (feature defaults to 1440). Conflicts with `vsan_remote_datastore_ids`.
     * 
     */
    @Import(name="vsanDitRekeyInterval")
    private @Nullable Output<Integer> vsanDitRekeyInterval;

    /**
     * @return Indicates the rekey interval in
     * minutes for data-in-transit encryption. The valid rekey interval is 30 to
     * 10800 (feature defaults to 1440). Conflicts with `vsan_remote_datastore_ids`.
     * 
     */
    public Optional<Output<Integer>> vsanDitRekeyInterval() {
        return Optional.ofNullable(this.vsanDitRekeyInterval);
    }

    /**
     * Enables vSAN on the cluster.
     * 
     */
    @Import(name="vsanEnabled")
    private @Nullable Output<Boolean> vsanEnabled;

    /**
     * @return Enables vSAN on the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanEnabled() {
        return Optional.ofNullable(this.vsanEnabled);
    }

    /**
     * Enables network
     * diagnostic mode for vSAN performance service on the cluster.
     * 
     */
    @Import(name="vsanNetworkDiagnosticModeEnabled")
    private @Nullable Output<Boolean> vsanNetworkDiagnosticModeEnabled;

    /**
     * @return Enables network
     * diagnostic mode for vSAN performance service on the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanNetworkDiagnosticModeEnabled() {
        return Optional.ofNullable(this.vsanNetworkDiagnosticModeEnabled);
    }

    /**
     * Enables vSAN performance service on
     * the cluster. Default: `true`.
     * 
     */
    @Import(name="vsanPerformanceEnabled")
    private @Nullable Output<Boolean> vsanPerformanceEnabled;

    /**
     * @return Enables vSAN performance service on
     * the cluster. Default: `true`.
     * 
     */
    public Optional<Output<Boolean>> vsanPerformanceEnabled() {
        return Optional.ofNullable(this.vsanPerformanceEnabled);
    }

    /**
     * The remote vSAN datastore IDs to be
     * mounted to this cluster. Conflicts with `vsan_dit_encryption_enabled` and
     * `vsan_dit_rekey_interval`, i.e., vSAN HCI Mesh feature cannot be enabled with
     * data-in-transit encryption feature at the same time.
     * 
     */
    @Import(name="vsanRemoteDatastoreIds")
    private @Nullable Output<List<String>> vsanRemoteDatastoreIds;

    /**
     * @return The remote vSAN datastore IDs to be
     * mounted to this cluster. Conflicts with `vsan_dit_encryption_enabled` and
     * `vsan_dit_rekey_interval`, i.e., vSAN HCI Mesh feature cannot be enabled with
     * data-in-transit encryption feature at the same time.
     * 
     */
    public Optional<Output<List<String>>> vsanRemoteDatastoreIds() {
        return Optional.ofNullable(this.vsanRemoteDatastoreIds);
    }

    /**
     * Enables vSAN unmap on the cluster.
     * 
     */
    @Import(name="vsanUnmapEnabled")
    private @Nullable Output<Boolean> vsanUnmapEnabled;

    /**
     * @return Enables vSAN unmap on the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanUnmapEnabled() {
        return Optional.ofNullable(this.vsanUnmapEnabled);
    }

    /**
     * Enables verbose mode for vSAN
     * performance service on the cluster.
     * 
     */
    @Import(name="vsanVerboseModeEnabled")
    private @Nullable Output<Boolean> vsanVerboseModeEnabled;

    /**
     * @return Enables verbose mode for vSAN
     * performance service on the cluster.
     * 
     */
    public Optional<Output<Boolean>> vsanVerboseModeEnabled() {
        return Optional.ofNullable(this.vsanVerboseModeEnabled);
    }

    private ComputeClusterState() {}

    private ComputeClusterState(ComputeClusterState $) {
        this.customAttributes = $.customAttributes;
        this.datacenterId = $.datacenterId;
        this.dpmAutomationLevel = $.dpmAutomationLevel;
        this.dpmEnabled = $.dpmEnabled;
        this.dpmThreshold = $.dpmThreshold;
        this.drsAdvancedOptions = $.drsAdvancedOptions;
        this.drsAutomationLevel = $.drsAutomationLevel;
        this.drsEnablePredictiveDrs = $.drsEnablePredictiveDrs;
        this.drsEnableVmOverrides = $.drsEnableVmOverrides;
        this.drsEnabled = $.drsEnabled;
        this.drsMigrationThreshold = $.drsMigrationThreshold;
        this.drsScaleDescendantsShares = $.drsScaleDescendantsShares;
        this.folder = $.folder;
        this.forceEvacuateOnDestroy = $.forceEvacuateOnDestroy;
        this.haAdmissionControlFailoverHostSystemIds = $.haAdmissionControlFailoverHostSystemIds;
        this.haAdmissionControlHostFailureTolerance = $.haAdmissionControlHostFailureTolerance;
        this.haAdmissionControlPerformanceTolerance = $.haAdmissionControlPerformanceTolerance;
        this.haAdmissionControlPolicy = $.haAdmissionControlPolicy;
        this.haAdmissionControlResourcePercentageAutoCompute = $.haAdmissionControlResourcePercentageAutoCompute;
        this.haAdmissionControlResourcePercentageCpu = $.haAdmissionControlResourcePercentageCpu;
        this.haAdmissionControlResourcePercentageMemory = $.haAdmissionControlResourcePercentageMemory;
        this.haAdmissionControlSlotPolicyExplicitCpu = $.haAdmissionControlSlotPolicyExplicitCpu;
        this.haAdmissionControlSlotPolicyExplicitMemory = $.haAdmissionControlSlotPolicyExplicitMemory;
        this.haAdmissionControlSlotPolicyUseExplicitSize = $.haAdmissionControlSlotPolicyUseExplicitSize;
        this.haAdvancedOptions = $.haAdvancedOptions;
        this.haDatastoreApdRecoveryAction = $.haDatastoreApdRecoveryAction;
        this.haDatastoreApdResponse = $.haDatastoreApdResponse;
        this.haDatastoreApdResponseDelay = $.haDatastoreApdResponseDelay;
        this.haDatastorePdlResponse = $.haDatastorePdlResponse;
        this.haEnabled = $.haEnabled;
        this.haHeartbeatDatastoreIds = $.haHeartbeatDatastoreIds;
        this.haHeartbeatDatastorePolicy = $.haHeartbeatDatastorePolicy;
        this.haHostIsolationResponse = $.haHostIsolationResponse;
        this.haHostMonitoring = $.haHostMonitoring;
        this.haVmComponentProtection = $.haVmComponentProtection;
        this.haVmDependencyRestartCondition = $.haVmDependencyRestartCondition;
        this.haVmFailureInterval = $.haVmFailureInterval;
        this.haVmMaximumFailureWindow = $.haVmMaximumFailureWindow;
        this.haVmMaximumResets = $.haVmMaximumResets;
        this.haVmMinimumUptime = $.haVmMinimumUptime;
        this.haVmMonitoring = $.haVmMonitoring;
        this.haVmRestartAdditionalDelay = $.haVmRestartAdditionalDelay;
        this.haVmRestartPriority = $.haVmRestartPriority;
        this.haVmRestartTimeout = $.haVmRestartTimeout;
        this.hostClusterExitTimeout = $.hostClusterExitTimeout;
        this.hostManaged = $.hostManaged;
        this.hostSystemIds = $.hostSystemIds;
        this.name = $.name;
        this.proactiveHaAutomationLevel = $.proactiveHaAutomationLevel;
        this.proactiveHaEnabled = $.proactiveHaEnabled;
        this.proactiveHaModerateRemediation = $.proactiveHaModerateRemediation;
        this.proactiveHaProviderIds = $.proactiveHaProviderIds;
        this.proactiveHaSevereRemediation = $.proactiveHaSevereRemediation;
        this.resourcePoolId = $.resourcePoolId;
        this.tags = $.tags;
        this.vsanCompressionEnabled = $.vsanCompressionEnabled;
        this.vsanDedupEnabled = $.vsanDedupEnabled;
        this.vsanDiskGroups = $.vsanDiskGroups;
        this.vsanDitEncryptionEnabled = $.vsanDitEncryptionEnabled;
        this.vsanDitRekeyInterval = $.vsanDitRekeyInterval;
        this.vsanEnabled = $.vsanEnabled;
        this.vsanNetworkDiagnosticModeEnabled = $.vsanNetworkDiagnosticModeEnabled;
        this.vsanPerformanceEnabled = $.vsanPerformanceEnabled;
        this.vsanRemoteDatastoreIds = $.vsanRemoteDatastoreIds;
        this.vsanUnmapEnabled = $.vsanUnmapEnabled;
        this.vsanVerboseModeEnabled = $.vsanVerboseModeEnabled;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ComputeClusterState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ComputeClusterState $;

        public Builder() {
            $ = new ComputeClusterState();
        }

        public Builder(ComputeClusterState defaults) {
            $ = new ComputeClusterState(Objects.requireNonNull(defaults));
        }

        /**
         * @param customAttributes A map of custom attribute ids to attribute
         * value strings to set for the datastore cluster.
         * 
         * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
         * and require vCenter Server.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(@Nullable Output<Map<String,String>> customAttributes) {
            $.customAttributes = customAttributes;
            return this;
        }

        /**
         * @param customAttributes A map of custom attribute ids to attribute
         * value strings to set for the datastore cluster.
         * 
         * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
         * and require vCenter Server.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(Map<String,String> customAttributes) {
            return customAttributes(Output.of(customAttributes));
        }

        /**
         * @param datacenterId The managed object ID of
         * the datacenter to create the cluster in. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder datacenterId(@Nullable Output<String> datacenterId) {
            $.datacenterId = datacenterId;
            return this;
        }

        /**
         * @param datacenterId The managed object ID of
         * the datacenter to create the cluster in. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder datacenterId(String datacenterId) {
            return datacenterId(Output.of(datacenterId));
        }

        /**
         * @param dpmAutomationLevel The automation level for host power
         * operations in this cluster. Can be one of `manual` or `automated`. Default:
         * `manual`.
         * 
         * @return builder
         * 
         */
        public Builder dpmAutomationLevel(@Nullable Output<String> dpmAutomationLevel) {
            $.dpmAutomationLevel = dpmAutomationLevel;
            return this;
        }

        /**
         * @param dpmAutomationLevel The automation level for host power
         * operations in this cluster. Can be one of `manual` or `automated`. Default:
         * `manual`.
         * 
         * @return builder
         * 
         */
        public Builder dpmAutomationLevel(String dpmAutomationLevel) {
            return dpmAutomationLevel(Output.of(dpmAutomationLevel));
        }

        /**
         * @param dpmEnabled Enable DPM support for DRS in this cluster.
         * Requires `drs_enabled` to be `true` in order to be effective.
         * Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder dpmEnabled(@Nullable Output<Boolean> dpmEnabled) {
            $.dpmEnabled = dpmEnabled;
            return this;
        }

        /**
         * @param dpmEnabled Enable DPM support for DRS in this cluster.
         * Requires `drs_enabled` to be `true` in order to be effective.
         * Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder dpmEnabled(Boolean dpmEnabled) {
            return dpmEnabled(Output.of(dpmEnabled));
        }

        /**
         * @param dpmThreshold A value between `1` and `5` indicating the
         * threshold of load within the cluster that influences host power operations.
         * This affects both power on and power off operations - a lower setting will
         * tolerate more of a surplus/deficit than a higher setting. Default: `3`.
         * 
         * @return builder
         * 
         */
        public Builder dpmThreshold(@Nullable Output<Integer> dpmThreshold) {
            $.dpmThreshold = dpmThreshold;
            return this;
        }

        /**
         * @param dpmThreshold A value between `1` and `5` indicating the
         * threshold of load within the cluster that influences host power operations.
         * This affects both power on and power off operations - a lower setting will
         * tolerate more of a surplus/deficit than a higher setting. Default: `3`.
         * 
         * @return builder
         * 
         */
        public Builder dpmThreshold(Integer dpmThreshold) {
            return dpmThreshold(Output.of(dpmThreshold));
        }

        /**
         * @param drsAdvancedOptions A key/value map that specifies advanced
         * options for DRS and DPM.
         * 
         * @return builder
         * 
         */
        public Builder drsAdvancedOptions(@Nullable Output<Map<String,String>> drsAdvancedOptions) {
            $.drsAdvancedOptions = drsAdvancedOptions;
            return this;
        }

        /**
         * @param drsAdvancedOptions A key/value map that specifies advanced
         * options for DRS and DPM.
         * 
         * @return builder
         * 
         */
        public Builder drsAdvancedOptions(Map<String,String> drsAdvancedOptions) {
            return drsAdvancedOptions(Output.of(drsAdvancedOptions));
        }

        /**
         * @param drsAutomationLevel The default automation level for all
         * virtual machines in this cluster. Can be one of `manual`,
         * `partiallyAutomated`, or `fullyAutomated`. Default: `manual`.
         * 
         * @return builder
         * 
         */
        public Builder drsAutomationLevel(@Nullable Output<String> drsAutomationLevel) {
            $.drsAutomationLevel = drsAutomationLevel;
            return this;
        }

        /**
         * @param drsAutomationLevel The default automation level for all
         * virtual machines in this cluster. Can be one of `manual`,
         * `partiallyAutomated`, or `fullyAutomated`. Default: `manual`.
         * 
         * @return builder
         * 
         */
        public Builder drsAutomationLevel(String drsAutomationLevel) {
            return drsAutomationLevel(Output.of(drsAutomationLevel));
        }

        /**
         * @param drsEnablePredictiveDrs When `true`, enables DRS to use data
         * from [vRealize Operations Manager][ref-vsphere-vrops] to make proactive DRS
         * recommendations. &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder drsEnablePredictiveDrs(@Nullable Output<Boolean> drsEnablePredictiveDrs) {
            $.drsEnablePredictiveDrs = drsEnablePredictiveDrs;
            return this;
        }

        /**
         * @param drsEnablePredictiveDrs When `true`, enables DRS to use data
         * from [vRealize Operations Manager][ref-vsphere-vrops] to make proactive DRS
         * recommendations. &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder drsEnablePredictiveDrs(Boolean drsEnablePredictiveDrs) {
            return drsEnablePredictiveDrs(Output.of(drsEnablePredictiveDrs));
        }

        /**
         * @param drsEnableVmOverrides Allow individual DRS overrides to be
         * set for virtual machines in the cluster. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder drsEnableVmOverrides(@Nullable Output<Boolean> drsEnableVmOverrides) {
            $.drsEnableVmOverrides = drsEnableVmOverrides;
            return this;
        }

        /**
         * @param drsEnableVmOverrides Allow individual DRS overrides to be
         * set for virtual machines in the cluster. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder drsEnableVmOverrides(Boolean drsEnableVmOverrides) {
            return drsEnableVmOverrides(Output.of(drsEnableVmOverrides));
        }

        /**
         * @param drsEnabled Enable DRS for this cluster. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder drsEnabled(@Nullable Output<Boolean> drsEnabled) {
            $.drsEnabled = drsEnabled;
            return this;
        }

        /**
         * @param drsEnabled Enable DRS for this cluster. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder drsEnabled(Boolean drsEnabled) {
            return drsEnabled(Output.of(drsEnabled));
        }

        /**
         * @param drsMigrationThreshold A value between `1` and `5` indicating
         * the threshold of imbalance tolerated between hosts. A lower setting will
         * tolerate more imbalance while a higher setting will tolerate less. Default:
         * `3`.
         * 
         * @return builder
         * 
         */
        public Builder drsMigrationThreshold(@Nullable Output<Integer> drsMigrationThreshold) {
            $.drsMigrationThreshold = drsMigrationThreshold;
            return this;
        }

        /**
         * @param drsMigrationThreshold A value between `1` and `5` indicating
         * the threshold of imbalance tolerated between hosts. A lower setting will
         * tolerate more imbalance while a higher setting will tolerate less. Default:
         * `3`.
         * 
         * @return builder
         * 
         */
        public Builder drsMigrationThreshold(Integer drsMigrationThreshold) {
            return drsMigrationThreshold(Output.of(drsMigrationThreshold));
        }

        /**
         * @param drsScaleDescendantsShares Enable scalable shares for all
         * resource pools in the cluster. Can be one of `disabled` or
         * `scaleCpuAndMemoryShares`. Default: `disabled`.
         * 
         * @return builder
         * 
         */
        public Builder drsScaleDescendantsShares(@Nullable Output<String> drsScaleDescendantsShares) {
            $.drsScaleDescendantsShares = drsScaleDescendantsShares;
            return this;
        }

        /**
         * @param drsScaleDescendantsShares Enable scalable shares for all
         * resource pools in the cluster. Can be one of `disabled` or
         * `scaleCpuAndMemoryShares`. Default: `disabled`.
         * 
         * @return builder
         * 
         */
        public Builder drsScaleDescendantsShares(String drsScaleDescendantsShares) {
            return drsScaleDescendantsShares(Output.of(drsScaleDescendantsShares));
        }

        /**
         * @param folder The relative path to a folder to put this cluster in.
         * This is a path relative to the datacenter you are deploying the cluster to.
         * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
         * The provider will place a cluster named `compute-cluster-test` in a
         * host folder located at `/dc1/host/foo/bar`, with the final inventory path
         * being `/dc1/host/foo/bar/datastore-cluster-test`.
         * 
         * @return builder
         * 
         */
        public Builder folder(@Nullable Output<String> folder) {
            $.folder = folder;
            return this;
        }

        /**
         * @param folder The relative path to a folder to put this cluster in.
         * This is a path relative to the datacenter you are deploying the cluster to.
         * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
         * The provider will place a cluster named `compute-cluster-test` in a
         * host folder located at `/dc1/host/foo/bar`, with the final inventory path
         * being `/dc1/host/foo/bar/datastore-cluster-test`.
         * 
         * @return builder
         * 
         */
        public Builder folder(String folder) {
            return folder(Output.of(folder));
        }

        /**
         * @param forceEvacuateOnDestroy When destroying the resource, setting this to
         * `true` will auto-remove any hosts that are currently a member of the cluster,
         * as if they were removed by taking their entry out of `host_system_ids` (see
         * below. This is an advanced
         * option and should only be used for testing. Default: `false`.
         * 
         * &gt; **NOTE:** Do not set `force_evacuate_on_destroy` in production operation as
         * there are many pitfalls to its use when working with complex cluster
         * configurations. Depending on the virtual machines currently on the cluster, and
         * your DRS and HA settings, the full host evacuation may fail. Instead,
         * incrementally remove hosts from your configuration by adjusting the contents of
         * the `host_system_ids` attribute.
         * 
         * @return builder
         * 
         */
        public Builder forceEvacuateOnDestroy(@Nullable Output<Boolean> forceEvacuateOnDestroy) {
            $.forceEvacuateOnDestroy = forceEvacuateOnDestroy;
            return this;
        }

        /**
         * @param forceEvacuateOnDestroy When destroying the resource, setting this to
         * `true` will auto-remove any hosts that are currently a member of the cluster,
         * as if they were removed by taking their entry out of `host_system_ids` (see
         * below. This is an advanced
         * option and should only be used for testing. Default: `false`.
         * 
         * &gt; **NOTE:** Do not set `force_evacuate_on_destroy` in production operation as
         * there are many pitfalls to its use when working with complex cluster
         * configurations. Depending on the virtual machines currently on the cluster, and
         * your DRS and HA settings, the full host evacuation may fail. Instead,
         * incrementally remove hosts from your configuration by adjusting the contents of
         * the `host_system_ids` attribute.
         * 
         * @return builder
         * 
         */
        public Builder forceEvacuateOnDestroy(Boolean forceEvacuateOnDestroy) {
            return forceEvacuateOnDestroy(Output.of(forceEvacuateOnDestroy));
        }

        /**
         * @param haAdmissionControlFailoverHostSystemIds Defines the
         * managed object IDs of hosts to use as dedicated failover
         * hosts. These hosts are kept as available as possible - admission control will
         * block access to the host, and DRS will ignore the host when making
         * recommendations.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlFailoverHostSystemIds(@Nullable Output<List<String>> haAdmissionControlFailoverHostSystemIds) {
            $.haAdmissionControlFailoverHostSystemIds = haAdmissionControlFailoverHostSystemIds;
            return this;
        }

        /**
         * @param haAdmissionControlFailoverHostSystemIds Defines the
         * managed object IDs of hosts to use as dedicated failover
         * hosts. These hosts are kept as available as possible - admission control will
         * block access to the host, and DRS will ignore the host when making
         * recommendations.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlFailoverHostSystemIds(List<String> haAdmissionControlFailoverHostSystemIds) {
            return haAdmissionControlFailoverHostSystemIds(Output.of(haAdmissionControlFailoverHostSystemIds));
        }

        /**
         * @param haAdmissionControlFailoverHostSystemIds Defines the
         * managed object IDs of hosts to use as dedicated failover
         * hosts. These hosts are kept as available as possible - admission control will
         * block access to the host, and DRS will ignore the host when making
         * recommendations.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlFailoverHostSystemIds(String... haAdmissionControlFailoverHostSystemIds) {
            return haAdmissionControlFailoverHostSystemIds(List.of(haAdmissionControlFailoverHostSystemIds));
        }

        /**
         * @param haAdmissionControlHostFailureTolerance The maximum number
         * of failed hosts that admission control tolerates when making decisions on
         * whether to permit virtual machine operations. The maximum is one less than
         * the number of hosts in the cluster. Default: `1`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlHostFailureTolerance(@Nullable Output<Integer> haAdmissionControlHostFailureTolerance) {
            $.haAdmissionControlHostFailureTolerance = haAdmissionControlHostFailureTolerance;
            return this;
        }

        /**
         * @param haAdmissionControlHostFailureTolerance The maximum number
         * of failed hosts that admission control tolerates when making decisions on
         * whether to permit virtual machine operations. The maximum is one less than
         * the number of hosts in the cluster. Default: `1`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlHostFailureTolerance(Integer haAdmissionControlHostFailureTolerance) {
            return haAdmissionControlHostFailureTolerance(Output.of(haAdmissionControlHostFailureTolerance));
        }

        /**
         * @param haAdmissionControlPerformanceTolerance The percentage of
         * resource reduction that a cluster of virtual machines can tolerate in case of
         * a failover. A value of 0 produces warnings only, whereas a value of 100
         * disables the setting. Default: `100` (disabled).
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlPerformanceTolerance(@Nullable Output<Integer> haAdmissionControlPerformanceTolerance) {
            $.haAdmissionControlPerformanceTolerance = haAdmissionControlPerformanceTolerance;
            return this;
        }

        /**
         * @param haAdmissionControlPerformanceTolerance The percentage of
         * resource reduction that a cluster of virtual machines can tolerate in case of
         * a failover. A value of 0 produces warnings only, whereas a value of 100
         * disables the setting. Default: `100` (disabled).
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlPerformanceTolerance(Integer haAdmissionControlPerformanceTolerance) {
            return haAdmissionControlPerformanceTolerance(Output.of(haAdmissionControlPerformanceTolerance));
        }

        /**
         * @param haAdmissionControlPolicy The type of admission control
         * policy to use with vSphere HA. Can be one of `resourcePercentage`,
         * `slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlPolicy(@Nullable Output<String> haAdmissionControlPolicy) {
            $.haAdmissionControlPolicy = haAdmissionControlPolicy;
            return this;
        }

        /**
         * @param haAdmissionControlPolicy The type of admission control
         * policy to use with vSphere HA. Can be one of `resourcePercentage`,
         * `slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlPolicy(String haAdmissionControlPolicy) {
            return haAdmissionControlPolicy(Output.of(haAdmissionControlPolicy));
        }

        /**
         * @param haAdmissionControlResourcePercentageAutoCompute Automatically determine available resource percentages by subtracting the
         * average number of host resources represented by the
         * `ha_admission_control_host_failure_tolerance`
         * setting from the total amount of resources in the cluster. Disable to supply
         * user-defined values. Default: `true`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageAutoCompute(@Nullable Output<Boolean> haAdmissionControlResourcePercentageAutoCompute) {
            $.haAdmissionControlResourcePercentageAutoCompute = haAdmissionControlResourcePercentageAutoCompute;
            return this;
        }

        /**
         * @param haAdmissionControlResourcePercentageAutoCompute Automatically determine available resource percentages by subtracting the
         * average number of host resources represented by the
         * `ha_admission_control_host_failure_tolerance`
         * setting from the total amount of resources in the cluster. Disable to supply
         * user-defined values. Default: `true`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageAutoCompute(Boolean haAdmissionControlResourcePercentageAutoCompute) {
            return haAdmissionControlResourcePercentageAutoCompute(Output.of(haAdmissionControlResourcePercentageAutoCompute));
        }

        /**
         * @param haAdmissionControlResourcePercentageCpu Controls the
         * user-defined percentage of CPU resources in the cluster to reserve for
         * failover. Default: `100`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageCpu(@Nullable Output<Integer> haAdmissionControlResourcePercentageCpu) {
            $.haAdmissionControlResourcePercentageCpu = haAdmissionControlResourcePercentageCpu;
            return this;
        }

        /**
         * @param haAdmissionControlResourcePercentageCpu Controls the
         * user-defined percentage of CPU resources in the cluster to reserve for
         * failover. Default: `100`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageCpu(Integer haAdmissionControlResourcePercentageCpu) {
            return haAdmissionControlResourcePercentageCpu(Output.of(haAdmissionControlResourcePercentageCpu));
        }

        /**
         * @param haAdmissionControlResourcePercentageMemory Controls the
         * user-defined percentage of memory resources in the cluster to reserve for
         * failover. Default: `100`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageMemory(@Nullable Output<Integer> haAdmissionControlResourcePercentageMemory) {
            $.haAdmissionControlResourcePercentageMemory = haAdmissionControlResourcePercentageMemory;
            return this;
        }

        /**
         * @param haAdmissionControlResourcePercentageMemory Controls the
         * user-defined percentage of memory resources in the cluster to reserve for
         * failover. Default: `100`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlResourcePercentageMemory(Integer haAdmissionControlResourcePercentageMemory) {
            return haAdmissionControlResourcePercentageMemory(Output.of(haAdmissionControlResourcePercentageMemory));
        }

        /**
         * @param haAdmissionControlSlotPolicyExplicitCpu Controls the
         * user-defined CPU slot size, in MHz. Default: `32`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyExplicitCpu(@Nullable Output<Integer> haAdmissionControlSlotPolicyExplicitCpu) {
            $.haAdmissionControlSlotPolicyExplicitCpu = haAdmissionControlSlotPolicyExplicitCpu;
            return this;
        }

        /**
         * @param haAdmissionControlSlotPolicyExplicitCpu Controls the
         * user-defined CPU slot size, in MHz. Default: `32`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyExplicitCpu(Integer haAdmissionControlSlotPolicyExplicitCpu) {
            return haAdmissionControlSlotPolicyExplicitCpu(Output.of(haAdmissionControlSlotPolicyExplicitCpu));
        }

        /**
         * @param haAdmissionControlSlotPolicyExplicitMemory Controls the
         * user-defined memory slot size, in MB. Default: `100`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyExplicitMemory(@Nullable Output<Integer> haAdmissionControlSlotPolicyExplicitMemory) {
            $.haAdmissionControlSlotPolicyExplicitMemory = haAdmissionControlSlotPolicyExplicitMemory;
            return this;
        }

        /**
         * @param haAdmissionControlSlotPolicyExplicitMemory Controls the
         * user-defined memory slot size, in MB. Default: `100`.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyExplicitMemory(Integer haAdmissionControlSlotPolicyExplicitMemory) {
            return haAdmissionControlSlotPolicyExplicitMemory(Output.of(haAdmissionControlSlotPolicyExplicitMemory));
        }

        /**
         * @param haAdmissionControlSlotPolicyUseExplicitSize Controls
         * whether or not you wish to supply explicit values to CPU and memory slot
         * sizes. The default is `false`, which tells vSphere to gather a automatic
         * average based on all powered-on virtual machines currently in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyUseExplicitSize(@Nullable Output<Boolean> haAdmissionControlSlotPolicyUseExplicitSize) {
            $.haAdmissionControlSlotPolicyUseExplicitSize = haAdmissionControlSlotPolicyUseExplicitSize;
            return this;
        }

        /**
         * @param haAdmissionControlSlotPolicyUseExplicitSize Controls
         * whether or not you wish to supply explicit values to CPU and memory slot
         * sizes. The default is `false`, which tells vSphere to gather a automatic
         * average based on all powered-on virtual machines currently in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder haAdmissionControlSlotPolicyUseExplicitSize(Boolean haAdmissionControlSlotPolicyUseExplicitSize) {
            return haAdmissionControlSlotPolicyUseExplicitSize(Output.of(haAdmissionControlSlotPolicyUseExplicitSize));
        }

        /**
         * @param haAdvancedOptions A key/value map that specifies advanced
         * options for vSphere HA.
         * 
         * @return builder
         * 
         */
        public Builder haAdvancedOptions(@Nullable Output<Map<String,String>> haAdvancedOptions) {
            $.haAdvancedOptions = haAdvancedOptions;
            return this;
        }

        /**
         * @param haAdvancedOptions A key/value map that specifies advanced
         * options for vSphere HA.
         * 
         * @return builder
         * 
         */
        public Builder haAdvancedOptions(Map<String,String> haAdvancedOptions) {
            return haAdvancedOptions(Output.of(haAdvancedOptions));
        }

        /**
         * @param haDatastoreApdRecoveryAction Controls the action to take
         * on virtual machines if an APD status on an affected datastore clears in the
         * middle of an APD event. Can be one of `none` or `reset`. Default: `none`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdRecoveryAction(@Nullable Output<String> haDatastoreApdRecoveryAction) {
            $.haDatastoreApdRecoveryAction = haDatastoreApdRecoveryAction;
            return this;
        }

        /**
         * @param haDatastoreApdRecoveryAction Controls the action to take
         * on virtual machines if an APD status on an affected datastore clears in the
         * middle of an APD event. Can be one of `none` or `reset`. Default: `none`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdRecoveryAction(String haDatastoreApdRecoveryAction) {
            return haDatastoreApdRecoveryAction(Output.of(haDatastoreApdRecoveryAction));
        }

        /**
         * @param haDatastoreApdResponse Controls the action to take on
         * virtual machines when the cluster has detected loss to all paths to a
         * relevant datastore. Can be one of `disabled`, `warning`,
         * `restartConservative`, or `restartAggressive`.  Default: `disabled`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdResponse(@Nullable Output<String> haDatastoreApdResponse) {
            $.haDatastoreApdResponse = haDatastoreApdResponse;
            return this;
        }

        /**
         * @param haDatastoreApdResponse Controls the action to take on
         * virtual machines when the cluster has detected loss to all paths to a
         * relevant datastore. Can be one of `disabled`, `warning`,
         * `restartConservative`, or `restartAggressive`.  Default: `disabled`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdResponse(String haDatastoreApdResponse) {
            return haDatastoreApdResponse(Output.of(haDatastoreApdResponse));
        }

        /**
         * @param haDatastoreApdResponseDelay The time, in seconds,
         * to wait after an APD timeout event to run the response action defined in
         * `ha_datastore_apd_response`. Default: `180`
         * seconds (3 minutes). &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdResponseDelay(@Nullable Output<Integer> haDatastoreApdResponseDelay) {
            $.haDatastoreApdResponseDelay = haDatastoreApdResponseDelay;
            return this;
        }

        /**
         * @param haDatastoreApdResponseDelay The time, in seconds,
         * to wait after an APD timeout event to run the response action defined in
         * `ha_datastore_apd_response`. Default: `180`
         * seconds (3 minutes). &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haDatastoreApdResponseDelay(Integer haDatastoreApdResponseDelay) {
            return haDatastoreApdResponseDelay(Output.of(haDatastoreApdResponseDelay));
        }

        /**
         * @param haDatastorePdlResponse Controls the action to take on
         * virtual machines when the cluster has detected a permanent device loss to a
         * relevant datastore. Can be one of `disabled`, `warning`, or
         * `restartAggressive`. Default: `disabled`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haDatastorePdlResponse(@Nullable Output<String> haDatastorePdlResponse) {
            $.haDatastorePdlResponse = haDatastorePdlResponse;
            return this;
        }

        /**
         * @param haDatastorePdlResponse Controls the action to take on
         * virtual machines when the cluster has detected a permanent device loss to a
         * relevant datastore. Can be one of `disabled`, `warning`, or
         * `restartAggressive`. Default: `disabled`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haDatastorePdlResponse(String haDatastorePdlResponse) {
            return haDatastorePdlResponse(Output.of(haDatastorePdlResponse));
        }

        /**
         * @param haEnabled Enable vSphere HA for this cluster. Default:
         * `false`.
         * 
         * @return builder
         * 
         */
        public Builder haEnabled(@Nullable Output<Boolean> haEnabled) {
            $.haEnabled = haEnabled;
            return this;
        }

        /**
         * @param haEnabled Enable vSphere HA for this cluster. Default:
         * `false`.
         * 
         * @return builder
         * 
         */
        public Builder haEnabled(Boolean haEnabled) {
            return haEnabled(Output.of(haEnabled));
        }

        /**
         * @param haHeartbeatDatastoreIds The list of managed object IDs for
         * preferred datastores to use for HA heartbeating. This setting is only useful
         * when `ha_heartbeat_datastore_policy` is set
         * to either `userSelectedDs` or `allFeasibleDsWithUserPreference`.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastoreIds(@Nullable Output<List<String>> haHeartbeatDatastoreIds) {
            $.haHeartbeatDatastoreIds = haHeartbeatDatastoreIds;
            return this;
        }

        /**
         * @param haHeartbeatDatastoreIds The list of managed object IDs for
         * preferred datastores to use for HA heartbeating. This setting is only useful
         * when `ha_heartbeat_datastore_policy` is set
         * to either `userSelectedDs` or `allFeasibleDsWithUserPreference`.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastoreIds(List<String> haHeartbeatDatastoreIds) {
            return haHeartbeatDatastoreIds(Output.of(haHeartbeatDatastoreIds));
        }

        /**
         * @param haHeartbeatDatastoreIds The list of managed object IDs for
         * preferred datastores to use for HA heartbeating. This setting is only useful
         * when `ha_heartbeat_datastore_policy` is set
         * to either `userSelectedDs` or `allFeasibleDsWithUserPreference`.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastoreIds(String... haHeartbeatDatastoreIds) {
            return haHeartbeatDatastoreIds(List.of(haHeartbeatDatastoreIds));
        }

        /**
         * @param haHeartbeatDatastorePolicy The selection policy for HA
         * heartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or
         * `allFeasibleDsWithUserPreference`. Default:
         * `allFeasibleDsWithUserPreference`.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastorePolicy(@Nullable Output<String> haHeartbeatDatastorePolicy) {
            $.haHeartbeatDatastorePolicy = haHeartbeatDatastorePolicy;
            return this;
        }

        /**
         * @param haHeartbeatDatastorePolicy The selection policy for HA
         * heartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or
         * `allFeasibleDsWithUserPreference`. Default:
         * `allFeasibleDsWithUserPreference`.
         * 
         * @return builder
         * 
         */
        public Builder haHeartbeatDatastorePolicy(String haHeartbeatDatastorePolicy) {
            return haHeartbeatDatastorePolicy(Output.of(haHeartbeatDatastorePolicy));
        }

        /**
         * @param haHostIsolationResponse The action to take on virtual
         * machines when a host has detected that it has been isolated from the rest of
         * the cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:
         * `none`.
         * 
         * @return builder
         * 
         */
        public Builder haHostIsolationResponse(@Nullable Output<String> haHostIsolationResponse) {
            $.haHostIsolationResponse = haHostIsolationResponse;
            return this;
        }

        /**
         * @param haHostIsolationResponse The action to take on virtual
         * machines when a host has detected that it has been isolated from the rest of
         * the cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:
         * `none`.
         * 
         * @return builder
         * 
         */
        public Builder haHostIsolationResponse(String haHostIsolationResponse) {
            return haHostIsolationResponse(Output.of(haHostIsolationResponse));
        }

        /**
         * @param haHostMonitoring Global setting that controls whether
         * vSphere HA remediates virtual machines on host failure. Can be one of `enabled`
         * or `disabled`. Default: `enabled`.
         * 
         * @return builder
         * 
         */
        public Builder haHostMonitoring(@Nullable Output<String> haHostMonitoring) {
            $.haHostMonitoring = haHostMonitoring;
            return this;
        }

        /**
         * @param haHostMonitoring Global setting that controls whether
         * vSphere HA remediates virtual machines on host failure. Can be one of `enabled`
         * or `disabled`. Default: `enabled`.
         * 
         * @return builder
         * 
         */
        public Builder haHostMonitoring(String haHostMonitoring) {
            return haHostMonitoring(Output.of(haHostMonitoring));
        }

        /**
         * @param haVmComponentProtection Controls vSphere VM component
         * protection for virtual machines in this cluster. Can be one of `enabled` or
         * `disabled`. Default: `enabled`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haVmComponentProtection(@Nullable Output<String> haVmComponentProtection) {
            $.haVmComponentProtection = haVmComponentProtection;
            return this;
        }

        /**
         * @param haVmComponentProtection Controls vSphere VM component
         * protection for virtual machines in this cluster. Can be one of `enabled` or
         * `disabled`. Default: `enabled`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haVmComponentProtection(String haVmComponentProtection) {
            return haVmComponentProtection(Output.of(haVmComponentProtection));
        }

        /**
         * @param haVmDependencyRestartCondition The condition used to
         * determine whether or not virtual machines in a certain restart priority class
         * are online, allowing HA to move on to restarting virtual machines on the next
         * priority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or
         * `appHbStatusGreen`. The default is `none`, which means that a virtual machine
         * is considered ready immediately after a host is found to start it on.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haVmDependencyRestartCondition(@Nullable Output<String> haVmDependencyRestartCondition) {
            $.haVmDependencyRestartCondition = haVmDependencyRestartCondition;
            return this;
        }

        /**
         * @param haVmDependencyRestartCondition The condition used to
         * determine whether or not virtual machines in a certain restart priority class
         * are online, allowing HA to move on to restarting virtual machines on the next
         * priority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or
         * `appHbStatusGreen`. The default is `none`, which means that a virtual machine
         * is considered ready immediately after a host is found to start it on.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haVmDependencyRestartCondition(String haVmDependencyRestartCondition) {
            return haVmDependencyRestartCondition(Output.of(haVmDependencyRestartCondition));
        }

        /**
         * @param haVmFailureInterval The time interval, in seconds, a heartbeat
         * from a virtual machine is not received within this configured interval,
         * the virtual machine is marked as failed. Default: `30` seconds.
         * 
         * @return builder
         * 
         */
        public Builder haVmFailureInterval(@Nullable Output<Integer> haVmFailureInterval) {
            $.haVmFailureInterval = haVmFailureInterval;
            return this;
        }

        /**
         * @param haVmFailureInterval The time interval, in seconds, a heartbeat
         * from a virtual machine is not received within this configured interval,
         * the virtual machine is marked as failed. Default: `30` seconds.
         * 
         * @return builder
         * 
         */
        public Builder haVmFailureInterval(Integer haVmFailureInterval) {
            return haVmFailureInterval(Output.of(haVmFailureInterval));
        }

        /**
         * @param haVmMaximumFailureWindow The time, in seconds, for the reset window in
         * which `ha_vm_maximum_resets` can operate. When this
         * window expires, no more resets are attempted regardless of the setting
         * configured in `ha_vm_maximum_resets`. `-1` means no window, meaning an
         * unlimited reset time is allotted. Default: `-1` (no window).
         * 
         * @return builder
         * 
         */
        public Builder haVmMaximumFailureWindow(@Nullable Output<Integer> haVmMaximumFailureWindow) {
            $.haVmMaximumFailureWindow = haVmMaximumFailureWindow;
            return this;
        }

        /**
         * @param haVmMaximumFailureWindow The time, in seconds, for the reset window in
         * which `ha_vm_maximum_resets` can operate. When this
         * window expires, no more resets are attempted regardless of the setting
         * configured in `ha_vm_maximum_resets`. `-1` means no window, meaning an
         * unlimited reset time is allotted. Default: `-1` (no window).
         * 
         * @return builder
         * 
         */
        public Builder haVmMaximumFailureWindow(Integer haVmMaximumFailureWindow) {
            return haVmMaximumFailureWindow(Output.of(haVmMaximumFailureWindow));
        }

        /**
         * @param haVmMaximumResets The maximum number of resets that HA will
         * perform to a virtual machine when responding to a failure event. Default: `3`
         * 
         * @return builder
         * 
         */
        public Builder haVmMaximumResets(@Nullable Output<Integer> haVmMaximumResets) {
            $.haVmMaximumResets = haVmMaximumResets;
            return this;
        }

        /**
         * @param haVmMaximumResets The maximum number of resets that HA will
         * perform to a virtual machine when responding to a failure event. Default: `3`
         * 
         * @return builder
         * 
         */
        public Builder haVmMaximumResets(Integer haVmMaximumResets) {
            return haVmMaximumResets(Output.of(haVmMaximumResets));
        }

        /**
         * @param haVmMinimumUptime The time, in seconds, that HA waits after
         * powering on a virtual machine before monitoring for heartbeats. Default:
         * `120` seconds (2 minutes).
         * 
         * @return builder
         * 
         */
        public Builder haVmMinimumUptime(@Nullable Output<Integer> haVmMinimumUptime) {
            $.haVmMinimumUptime = haVmMinimumUptime;
            return this;
        }

        /**
         * @param haVmMinimumUptime The time, in seconds, that HA waits after
         * powering on a virtual machine before monitoring for heartbeats. Default:
         * `120` seconds (2 minutes).
         * 
         * @return builder
         * 
         */
        public Builder haVmMinimumUptime(Integer haVmMinimumUptime) {
            return haVmMinimumUptime(Output.of(haVmMinimumUptime));
        }

        /**
         * @param haVmMonitoring The type of virtual machine monitoring to use
         * when HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,
         * `vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.
         * 
         * @return builder
         * 
         */
        public Builder haVmMonitoring(@Nullable Output<String> haVmMonitoring) {
            $.haVmMonitoring = haVmMonitoring;
            return this;
        }

        /**
         * @param haVmMonitoring The type of virtual machine monitoring to use
         * when HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,
         * `vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.
         * 
         * @return builder
         * 
         */
        public Builder haVmMonitoring(String haVmMonitoring) {
            return haVmMonitoring(Output.of(haVmMonitoring));
        }

        /**
         * @param haVmRestartAdditionalDelay Additional delay, in seconds,
         * after ready condition is met. A VM is considered ready at this point.
         * Default: `0` seconds (no delay). &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartAdditionalDelay(@Nullable Output<Integer> haVmRestartAdditionalDelay) {
            $.haVmRestartAdditionalDelay = haVmRestartAdditionalDelay;
            return this;
        }

        /**
         * @param haVmRestartAdditionalDelay Additional delay, in seconds,
         * after ready condition is met. A VM is considered ready at this point.
         * Default: `0` seconds (no delay). &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartAdditionalDelay(Integer haVmRestartAdditionalDelay) {
            return haVmRestartAdditionalDelay(Output.of(haVmRestartAdditionalDelay));
        }

        /**
         * @param haVmRestartPriority The default restart priority
         * for affected virtual machines when vSphere detects a host failure. Can be one
         * of `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartPriority(@Nullable Output<String> haVmRestartPriority) {
            $.haVmRestartPriority = haVmRestartPriority;
            return this;
        }

        /**
         * @param haVmRestartPriority The default restart priority
         * for affected virtual machines when vSphere detects a host failure. Can be one
         * of `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartPriority(String haVmRestartPriority) {
            return haVmRestartPriority(Output.of(haVmRestartPriority));
        }

        /**
         * @param haVmRestartTimeout The maximum time, in seconds,
         * that vSphere HA will wait for virtual machines in one priority to be ready
         * before proceeding with the next priority. Default: `600` seconds (10 minutes).
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartTimeout(@Nullable Output<Integer> haVmRestartTimeout) {
            $.haVmRestartTimeout = haVmRestartTimeout;
            return this;
        }

        /**
         * @param haVmRestartTimeout The maximum time, in seconds,
         * that vSphere HA will wait for virtual machines in one priority to be ready
         * before proceeding with the next priority. Default: `600` seconds (10 minutes).
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder haVmRestartTimeout(Integer haVmRestartTimeout) {
            return haVmRestartTimeout(Output.of(haVmRestartTimeout));
        }

        /**
         * @param hostClusterExitTimeout The timeout, in seconds, for each host maintenance
         * mode operation when removing hosts from a cluster. Default: `3600` seconds (1 hour).
         * 
         * @return builder
         * 
         */
        public Builder hostClusterExitTimeout(@Nullable Output<Integer> hostClusterExitTimeout) {
            $.hostClusterExitTimeout = hostClusterExitTimeout;
            return this;
        }

        /**
         * @param hostClusterExitTimeout The timeout, in seconds, for each host maintenance
         * mode operation when removing hosts from a cluster. Default: `3600` seconds (1 hour).
         * 
         * @return builder
         * 
         */
        public Builder hostClusterExitTimeout(Integer hostClusterExitTimeout) {
            return hostClusterExitTimeout(Output.of(hostClusterExitTimeout));
        }

        /**
         * @param hostManaged Can be set to `true` if compute cluster
         * membership will be managed through the `host` resource rather than the
         * `compute_cluster` resource. Conflicts with: `host_system_ids`.
         * 
         * @return builder
         * 
         */
        public Builder hostManaged(@Nullable Output<Boolean> hostManaged) {
            $.hostManaged = hostManaged;
            return this;
        }

        /**
         * @param hostManaged Can be set to `true` if compute cluster
         * membership will be managed through the `host` resource rather than the
         * `compute_cluster` resource. Conflicts with: `host_system_ids`.
         * 
         * @return builder
         * 
         */
        public Builder hostManaged(Boolean hostManaged) {
            return hostManaged(Output.of(hostManaged));
        }

        /**
         * @param hostSystemIds The managed object IDs of
         * the hosts to put in the cluster. Conflicts with: `host_managed`.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemIds(@Nullable Output<List<String>> hostSystemIds) {
            $.hostSystemIds = hostSystemIds;
            return this;
        }

        /**
         * @param hostSystemIds The managed object IDs of
         * the hosts to put in the cluster. Conflicts with: `host_managed`.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemIds(List<String> hostSystemIds) {
            return hostSystemIds(Output.of(hostSystemIds));
        }

        /**
         * @param hostSystemIds The managed object IDs of
         * the hosts to put in the cluster. Conflicts with: `host_managed`.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemIds(String... hostSystemIds) {
            return hostSystemIds(List.of(hostSystemIds));
        }

        /**
         * @param name The name of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param proactiveHaAutomationLevel Determines how the host
         * quarantine, maintenance mode, or virtual machine migration recommendations
         * made by proactive HA are to be handled. Can be one of `Automated` or
         * `Manual`. Default: `Manual`. &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaAutomationLevel(@Nullable Output<String> proactiveHaAutomationLevel) {
            $.proactiveHaAutomationLevel = proactiveHaAutomationLevel;
            return this;
        }

        /**
         * @param proactiveHaAutomationLevel Determines how the host
         * quarantine, maintenance mode, or virtual machine migration recommendations
         * made by proactive HA are to be handled. Can be one of `Automated` or
         * `Manual`. Default: `Manual`. &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaAutomationLevel(String proactiveHaAutomationLevel) {
            return proactiveHaAutomationLevel(Output.of(proactiveHaAutomationLevel));
        }

        /**
         * @param proactiveHaEnabled Enables Proactive HA. Default: `false`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaEnabled(@Nullable Output<Boolean> proactiveHaEnabled) {
            $.proactiveHaEnabled = proactiveHaEnabled;
            return this;
        }

        /**
         * @param proactiveHaEnabled Enables Proactive HA. Default: `false`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaEnabled(Boolean proactiveHaEnabled) {
            return proactiveHaEnabled(Output.of(proactiveHaEnabled));
        }

        /**
         * @param proactiveHaModerateRemediation The configured remediation
         * for moderately degraded hosts. Can be one of `MaintenanceMode` or
         * `QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when
         * `proactive_ha_severe_remediation` is set
         * to `QuarantineMode`. Default: `QuarantineMode`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaModerateRemediation(@Nullable Output<String> proactiveHaModerateRemediation) {
            $.proactiveHaModerateRemediation = proactiveHaModerateRemediation;
            return this;
        }

        /**
         * @param proactiveHaModerateRemediation The configured remediation
         * for moderately degraded hosts. Can be one of `MaintenanceMode` or
         * `QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when
         * `proactive_ha_severe_remediation` is set
         * to `QuarantineMode`. Default: `QuarantineMode`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaModerateRemediation(String proactiveHaModerateRemediation) {
            return proactiveHaModerateRemediation(Output.of(proactiveHaModerateRemediation));
        }

        /**
         * @param proactiveHaProviderIds The list of IDs for health update
         * providers configured for this cluster.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaProviderIds(@Nullable Output<List<String>> proactiveHaProviderIds) {
            $.proactiveHaProviderIds = proactiveHaProviderIds;
            return this;
        }

        /**
         * @param proactiveHaProviderIds The list of IDs for health update
         * providers configured for this cluster.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaProviderIds(List<String> proactiveHaProviderIds) {
            return proactiveHaProviderIds(Output.of(proactiveHaProviderIds));
        }

        /**
         * @param proactiveHaProviderIds The list of IDs for health update
         * providers configured for this cluster.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaProviderIds(String... proactiveHaProviderIds) {
            return proactiveHaProviderIds(List.of(proactiveHaProviderIds));
        }

        /**
         * @param proactiveHaSevereRemediation The configured remediation for
         * severely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.
         * Note that this cannot be set to `QuarantineMode` when
         * `proactive_ha_moderate_remediation` is
         * set to `MaintenanceMode`. Default: `QuarantineMode`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaSevereRemediation(@Nullable Output<String> proactiveHaSevereRemediation) {
            $.proactiveHaSevereRemediation = proactiveHaSevereRemediation;
            return this;
        }

        /**
         * @param proactiveHaSevereRemediation The configured remediation for
         * severely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.
         * Note that this cannot be set to `QuarantineMode` when
         * `proactive_ha_moderate_remediation` is
         * set to `MaintenanceMode`. Default: `QuarantineMode`.
         * &lt;sup&gt;\*&lt;/sup&gt;
         * 
         * @return builder
         * 
         */
        public Builder proactiveHaSevereRemediation(String proactiveHaSevereRemediation) {
            return proactiveHaSevereRemediation(Output.of(proactiveHaSevereRemediation));
        }

        /**
         * @param resourcePoolId The managed object ID of the primary
         * resource pool for this cluster. This can be passed directly to the
         * `resource_pool_id`
         * attribute of the
         * `vsphere.VirtualMachine` resource.
         * 
         * @return builder
         * 
         */
        public Builder resourcePoolId(@Nullable Output<String> resourcePoolId) {
            $.resourcePoolId = resourcePoolId;
            return this;
        }

        /**
         * @param resourcePoolId The managed object ID of the primary
         * resource pool for this cluster. This can be passed directly to the
         * `resource_pool_id`
         * attribute of the
         * `vsphere.VirtualMachine` resource.
         * 
         * @return builder
         * 
         */
        public Builder resourcePoolId(String resourcePoolId) {
            return resourcePoolId(Output.of(resourcePoolId));
        }

        /**
         * @param tags The IDs of any tags to attach to this resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags The IDs of any tags to attach to this resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags The IDs of any tags to attach to this resource.
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param vsanCompressionEnabled Enables vSAN compression on the
         * cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanCompressionEnabled(@Nullable Output<Boolean> vsanCompressionEnabled) {
            $.vsanCompressionEnabled = vsanCompressionEnabled;
            return this;
        }

        /**
         * @param vsanCompressionEnabled Enables vSAN compression on the
         * cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanCompressionEnabled(Boolean vsanCompressionEnabled) {
            return vsanCompressionEnabled(Output.of(vsanCompressionEnabled));
        }

        /**
         * @param vsanDedupEnabled Enables vSAN deduplication on the cluster.
         * Cannot be independently set to true. When vSAN deduplication is enabled, vSAN
         * compression must also be enabled.
         * 
         * @return builder
         * 
         */
        public Builder vsanDedupEnabled(@Nullable Output<Boolean> vsanDedupEnabled) {
            $.vsanDedupEnabled = vsanDedupEnabled;
            return this;
        }

        /**
         * @param vsanDedupEnabled Enables vSAN deduplication on the cluster.
         * Cannot be independently set to true. When vSAN deduplication is enabled, vSAN
         * compression must also be enabled.
         * 
         * @return builder
         * 
         */
        public Builder vsanDedupEnabled(Boolean vsanDedupEnabled) {
            return vsanDedupEnabled(Output.of(vsanDedupEnabled));
        }

        /**
         * @param vsanDiskGroups Represents the configuration of a host disk
         * group in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDiskGroups(@Nullable Output<List<ComputeClusterVsanDiskGroupArgs>> vsanDiskGroups) {
            $.vsanDiskGroups = vsanDiskGroups;
            return this;
        }

        /**
         * @param vsanDiskGroups Represents the configuration of a host disk
         * group in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDiskGroups(List<ComputeClusterVsanDiskGroupArgs> vsanDiskGroups) {
            return vsanDiskGroups(Output.of(vsanDiskGroups));
        }

        /**
         * @param vsanDiskGroups Represents the configuration of a host disk
         * group in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanDiskGroups(ComputeClusterVsanDiskGroupArgs... vsanDiskGroups) {
            return vsanDiskGroups(List.of(vsanDiskGroups));
        }

        /**
         * @param vsanDitEncryptionEnabled Enables vSAN data-in-transit
         * encryption on the cluster. Conflicts with `vsan_remote_datastore_ids`, i.e.,
         * vSAN data-in-transit feature cannot be enabled with the vSAN HCI Mesh feature
         * at the same time.
         * 
         * @return builder
         * 
         */
        public Builder vsanDitEncryptionEnabled(@Nullable Output<Boolean> vsanDitEncryptionEnabled) {
            $.vsanDitEncryptionEnabled = vsanDitEncryptionEnabled;
            return this;
        }

        /**
         * @param vsanDitEncryptionEnabled Enables vSAN data-in-transit
         * encryption on the cluster. Conflicts with `vsan_remote_datastore_ids`, i.e.,
         * vSAN data-in-transit feature cannot be enabled with the vSAN HCI Mesh feature
         * at the same time.
         * 
         * @return builder
         * 
         */
        public Builder vsanDitEncryptionEnabled(Boolean vsanDitEncryptionEnabled) {
            return vsanDitEncryptionEnabled(Output.of(vsanDitEncryptionEnabled));
        }

        /**
         * @param vsanDitRekeyInterval Indicates the rekey interval in
         * minutes for data-in-transit encryption. The valid rekey interval is 30 to
         * 10800 (feature defaults to 1440). Conflicts with `vsan_remote_datastore_ids`.
         * 
         * @return builder
         * 
         */
        public Builder vsanDitRekeyInterval(@Nullable Output<Integer> vsanDitRekeyInterval) {
            $.vsanDitRekeyInterval = vsanDitRekeyInterval;
            return this;
        }

        /**
         * @param vsanDitRekeyInterval Indicates the rekey interval in
         * minutes for data-in-transit encryption. The valid rekey interval is 30 to
         * 10800 (feature defaults to 1440). Conflicts with `vsan_remote_datastore_ids`.
         * 
         * @return builder
         * 
         */
        public Builder vsanDitRekeyInterval(Integer vsanDitRekeyInterval) {
            return vsanDitRekeyInterval(Output.of(vsanDitRekeyInterval));
        }

        /**
         * @param vsanEnabled Enables vSAN on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanEnabled(@Nullable Output<Boolean> vsanEnabled) {
            $.vsanEnabled = vsanEnabled;
            return this;
        }

        /**
         * @param vsanEnabled Enables vSAN on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanEnabled(Boolean vsanEnabled) {
            return vsanEnabled(Output.of(vsanEnabled));
        }

        /**
         * @param vsanNetworkDiagnosticModeEnabled Enables network
         * diagnostic mode for vSAN performance service on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanNetworkDiagnosticModeEnabled(@Nullable Output<Boolean> vsanNetworkDiagnosticModeEnabled) {
            $.vsanNetworkDiagnosticModeEnabled = vsanNetworkDiagnosticModeEnabled;
            return this;
        }

        /**
         * @param vsanNetworkDiagnosticModeEnabled Enables network
         * diagnostic mode for vSAN performance service on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanNetworkDiagnosticModeEnabled(Boolean vsanNetworkDiagnosticModeEnabled) {
            return vsanNetworkDiagnosticModeEnabled(Output.of(vsanNetworkDiagnosticModeEnabled));
        }

        /**
         * @param vsanPerformanceEnabled Enables vSAN performance service on
         * the cluster. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder vsanPerformanceEnabled(@Nullable Output<Boolean> vsanPerformanceEnabled) {
            $.vsanPerformanceEnabled = vsanPerformanceEnabled;
            return this;
        }

        /**
         * @param vsanPerformanceEnabled Enables vSAN performance service on
         * the cluster. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder vsanPerformanceEnabled(Boolean vsanPerformanceEnabled) {
            return vsanPerformanceEnabled(Output.of(vsanPerformanceEnabled));
        }

        /**
         * @param vsanRemoteDatastoreIds The remote vSAN datastore IDs to be
         * mounted to this cluster. Conflicts with `vsan_dit_encryption_enabled` and
         * `vsan_dit_rekey_interval`, i.e., vSAN HCI Mesh feature cannot be enabled with
         * data-in-transit encryption feature at the same time.
         * 
         * @return builder
         * 
         */
        public Builder vsanRemoteDatastoreIds(@Nullable Output<List<String>> vsanRemoteDatastoreIds) {
            $.vsanRemoteDatastoreIds = vsanRemoteDatastoreIds;
            return this;
        }

        /**
         * @param vsanRemoteDatastoreIds The remote vSAN datastore IDs to be
         * mounted to this cluster. Conflicts with `vsan_dit_encryption_enabled` and
         * `vsan_dit_rekey_interval`, i.e., vSAN HCI Mesh feature cannot be enabled with
         * data-in-transit encryption feature at the same time.
         * 
         * @return builder
         * 
         */
        public Builder vsanRemoteDatastoreIds(List<String> vsanRemoteDatastoreIds) {
            return vsanRemoteDatastoreIds(Output.of(vsanRemoteDatastoreIds));
        }

        /**
         * @param vsanRemoteDatastoreIds The remote vSAN datastore IDs to be
         * mounted to this cluster. Conflicts with `vsan_dit_encryption_enabled` and
         * `vsan_dit_rekey_interval`, i.e., vSAN HCI Mesh feature cannot be enabled with
         * data-in-transit encryption feature at the same time.
         * 
         * @return builder
         * 
         */
        public Builder vsanRemoteDatastoreIds(String... vsanRemoteDatastoreIds) {
            return vsanRemoteDatastoreIds(List.of(vsanRemoteDatastoreIds));
        }

        /**
         * @param vsanUnmapEnabled Enables vSAN unmap on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanUnmapEnabled(@Nullable Output<Boolean> vsanUnmapEnabled) {
            $.vsanUnmapEnabled = vsanUnmapEnabled;
            return this;
        }

        /**
         * @param vsanUnmapEnabled Enables vSAN unmap on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanUnmapEnabled(Boolean vsanUnmapEnabled) {
            return vsanUnmapEnabled(Output.of(vsanUnmapEnabled));
        }

        /**
         * @param vsanVerboseModeEnabled Enables verbose mode for vSAN
         * performance service on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanVerboseModeEnabled(@Nullable Output<Boolean> vsanVerboseModeEnabled) {
            $.vsanVerboseModeEnabled = vsanVerboseModeEnabled;
            return this;
        }

        /**
         * @param vsanVerboseModeEnabled Enables verbose mode for vSAN
         * performance service on the cluster.
         * 
         * @return builder
         * 
         */
        public Builder vsanVerboseModeEnabled(Boolean vsanVerboseModeEnabled) {
            return vsanVerboseModeEnabled(Output.of(vsanVerboseModeEnabled));
        }

        public ComputeClusterState build() {
            return $;
        }
    }

}
