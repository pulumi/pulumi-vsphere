// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.vsphere.inputs.DistributedPortGroupVlanRangeArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DistributedPortGroupArgs extends com.pulumi.resources.ResourceArgs {

    public static final DistributedPortGroupArgs Empty = new DistributedPortGroupArgs();

    /**
     * List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    @Import(name="activeUplinks")
    private @Nullable Output<List<String>> activeUplinks;

    /**
     * @return List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    public Optional<Output<List<String>>> activeUplinks() {
        return Optional.ofNullable(this.activeUplinks);
    }

    /**
     * Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
     * that of its own.
     * 
     */
    @Import(name="allowForgedTransmits")
    private @Nullable Output<Boolean> allowForgedTransmits;

    /**
     * @return Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
     * that of its own.
     * 
     */
    public Optional<Output<Boolean>> allowForgedTransmits() {
        return Optional.ofNullable(this.allowForgedTransmits);
    }

    /**
     * Controls whether or not the Media Access Control (MAC) address can be changed.
     * 
     */
    @Import(name="allowMacChanges")
    private @Nullable Output<Boolean> allowMacChanges;

    /**
     * @return Controls whether or not the Media Access Control (MAC) address can be changed.
     * 
     */
    public Optional<Output<Boolean>> allowMacChanges() {
        return Optional.ofNullable(this.allowMacChanges);
    }

    /**
     * Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    @Import(name="allowPromiscuous")
    private @Nullable Output<Boolean> allowPromiscuous;

    /**
     * @return Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    public Optional<Output<Boolean>> allowPromiscuous() {
        return Optional.ofNullable(this.allowPromiscuous);
    }

    /**
     * Allows the port group to create additional ports
     * past the limit specified in `number_of_ports` if necessary. Default: `true`.
     * 
     */
    @Import(name="autoExpand")
    private @Nullable Output<Boolean> autoExpand;

    /**
     * @return Allows the port group to create additional ports
     * past the limit specified in `number_of_ports` if necessary. Default: `true`.
     * 
     */
    public Optional<Output<Boolean>> autoExpand() {
        return Optional.ofNullable(this.autoExpand);
    }

    /**
     * Indicates whether to block all ports by default.
     * 
     */
    @Import(name="blockAllPorts")
    private @Nullable Output<Boolean> blockAllPorts;

    /**
     * @return Indicates whether to block all ports by default.
     * 
     */
    public Optional<Output<Boolean>> blockAllPorts() {
        return Optional.ofNullable(this.blockAllPorts);
    }

    /**
     * Allow the port shutdown
     * policy to be overridden on an individual port.
     * 
     */
    @Import(name="blockOverrideAllowed")
    private @Nullable Output<Boolean> blockOverrideAllowed;

    /**
     * @return Allow the port shutdown
     * policy to be overridden on an individual port.
     * 
     */
    public Optional<Output<Boolean>> blockOverrideAllowed() {
        return Optional.ofNullable(this.blockOverrideAllowed);
    }

    /**
     * Enable beacon probing on the ports this policy applies to.
     * 
     */
    @Import(name="checkBeacon")
    private @Nullable Output<Boolean> checkBeacon;

    /**
     * @return Enable beacon probing on the ports this policy applies to.
     * 
     */
    public Optional<Output<Boolean>> checkBeacon() {
        return Optional.ofNullable(this.checkBeacon);
    }

    /**
     * Map of custom attribute ids to attribute
     * value string to set for port group.
     * 
     */
    @Import(name="customAttributes")
    private @Nullable Output<Map<String,String>> customAttributes;

    /**
     * @return Map of custom attribute ids to attribute
     * value string to set for port group.
     * 
     */
    public Optional<Output<Map<String,String>>> customAttributes() {
        return Optional.ofNullable(this.customAttributes);
    }

    /**
     * An optional description for the port group.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return An optional description for the port group.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Allow VMDirectPath Gen2 on the ports this policy applies to.
     * 
     */
    @Import(name="directpathGen2Allowed")
    private @Nullable Output<Boolean> directpathGen2Allowed;

    /**
     * @return Allow VMDirectPath Gen2 on the ports this policy applies to.
     * 
     */
    public Optional<Output<Boolean>> directpathGen2Allowed() {
        return Optional.ofNullable(this.directpathGen2Allowed);
    }

    /**
     * The ID of the VDS to add the
     * port group to. Forces a new resource if changed.
     * 
     */
    @Import(name="distributedVirtualSwitchUuid", required=true)
    private Output<String> distributedVirtualSwitchUuid;

    /**
     * @return The ID of the VDS to add the
     * port group to. Forces a new resource if changed.
     * 
     */
    public Output<String> distributedVirtualSwitchUuid() {
        return this.distributedVirtualSwitchUuid;
    }

    /**
     * The average egress bandwidth in bits per second if egress shaping is enabled on the port.
     * 
     */
    @Import(name="egressShapingAverageBandwidth")
    private @Nullable Output<Integer> egressShapingAverageBandwidth;

    /**
     * @return The average egress bandwidth in bits per second if egress shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> egressShapingAverageBandwidth() {
        return Optional.ofNullable(this.egressShapingAverageBandwidth);
    }

    /**
     * The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
     * 
     */
    @Import(name="egressShapingBurstSize")
    private @Nullable Output<Integer> egressShapingBurstSize;

    /**
     * @return The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> egressShapingBurstSize() {
        return Optional.ofNullable(this.egressShapingBurstSize);
    }

    /**
     * True if the traffic shaper is enabled for egress traffic on the port.
     * 
     */
    @Import(name="egressShapingEnabled")
    private @Nullable Output<Boolean> egressShapingEnabled;

    /**
     * @return True if the traffic shaper is enabled for egress traffic on the port.
     * 
     */
    public Optional<Output<Boolean>> egressShapingEnabled() {
        return Optional.ofNullable(this.egressShapingEnabled);
    }

    /**
     * The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    @Import(name="egressShapingPeakBandwidth")
    private @Nullable Output<Integer> egressShapingPeakBandwidth;

    /**
     * @return The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> egressShapingPeakBandwidth() {
        return Optional.ofNullable(this.egressShapingPeakBandwidth);
    }

    /**
     * If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
     * 
     */
    @Import(name="failback")
    private @Nullable Output<Boolean> failback;

    /**
     * @return If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
     * 
     */
    public Optional<Output<Boolean>> failback() {
        return Optional.ofNullable(this.failback);
    }

    /**
     * The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
     * 
     */
    @Import(name="ingressShapingAverageBandwidth")
    private @Nullable Output<Integer> ingressShapingAverageBandwidth;

    /**
     * @return The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> ingressShapingAverageBandwidth() {
        return Optional.ofNullable(this.ingressShapingAverageBandwidth);
    }

    /**
     * The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
     * 
     */
    @Import(name="ingressShapingBurstSize")
    private @Nullable Output<Integer> ingressShapingBurstSize;

    /**
     * @return The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> ingressShapingBurstSize() {
        return Optional.ofNullable(this.ingressShapingBurstSize);
    }

    /**
     * True if the traffic shaper is enabled for ingress traffic on the port.
     * 
     */
    @Import(name="ingressShapingEnabled")
    private @Nullable Output<Boolean> ingressShapingEnabled;

    /**
     * @return True if the traffic shaper is enabled for ingress traffic on the port.
     * 
     */
    public Optional<Output<Boolean>> ingressShapingEnabled() {
        return Optional.ofNullable(this.ingressShapingEnabled);
    }

    /**
     * The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    @Import(name="ingressShapingPeakBandwidth")
    private @Nullable Output<Integer> ingressShapingPeakBandwidth;

    /**
     * @return The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    public Optional<Output<Integer>> ingressShapingPeakBandwidth() {
        return Optional.ofNullable(this.ingressShapingPeakBandwidth);
    }

    /**
     * Whether or not to enable LACP on all uplink ports.
     * 
     */
    @Import(name="lacpEnabled")
    private @Nullable Output<Boolean> lacpEnabled;

    /**
     * @return Whether or not to enable LACP on all uplink ports.
     * 
     */
    public Optional<Output<Boolean>> lacpEnabled() {
        return Optional.ofNullable(this.lacpEnabled);
    }

    /**
     * The uplink LACP mode to use. Can be one of active or passive.
     * 
     */
    @Import(name="lacpMode")
    private @Nullable Output<String> lacpMode;

    /**
     * @return The uplink LACP mode to use. Can be one of active or passive.
     * 
     */
    public Optional<Output<String>> lacpMode() {
        return Optional.ofNullable(this.lacpMode);
    }

    /**
     * Allow a port in this port group to be
     * moved to another port group while it is connected.
     * 
     */
    @Import(name="livePortMovingAllowed")
    private @Nullable Output<Boolean> livePortMovingAllowed;

    /**
     * @return Allow a port in this port group to be
     * moved to another port group while it is connected.
     * 
     */
    public Optional<Output<Boolean>> livePortMovingAllowed() {
        return Optional.ofNullable(this.livePortMovingAllowed);
    }

    /**
     * The name of the port group.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the port group.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Indicates whether to enable netflow on all ports.
     * 
     */
    @Import(name="netflowEnabled")
    private @Nullable Output<Boolean> netflowEnabled;

    /**
     * @return Indicates whether to enable netflow on all ports.
     * 
     */
    public Optional<Output<Boolean>> netflowEnabled() {
        return Optional.ofNullable(this.netflowEnabled);
    }

    /**
     * Allow the
     * [Netflow policy][netflow-policy] on this port group to be overridden on an
     * individual port.
     * 
     */
    @Import(name="netflowOverrideAllowed")
    private @Nullable Output<Boolean> netflowOverrideAllowed;

    /**
     * @return Allow the
     * [Netflow policy][netflow-policy] on this port group to be overridden on an
     * individual port.
     * 
     */
    public Optional<Output<Boolean>> netflowOverrideAllowed() {
        return Optional.ofNullable(this.netflowOverrideAllowed);
    }

    /**
     * The key of a network resource pool
     * to associate with this port group. The default is `-1`, which implies no
     * association.
     * 
     */
    @Import(name="networkResourcePoolKey")
    private @Nullable Output<String> networkResourcePoolKey;

    /**
     * @return The key of a network resource pool
     * to associate with this port group. The default is `-1`, which implies no
     * association.
     * 
     */
    public Optional<Output<String>> networkResourcePoolKey() {
        return Optional.ofNullable(this.networkResourcePoolKey);
    }

    /**
     * Allow the network
     * resource pool set on this port group to be overridden on an individual port.
     * 
     */
    @Import(name="networkResourcePoolOverrideAllowed")
    private @Nullable Output<Boolean> networkResourcePoolOverrideAllowed;

    /**
     * @return Allow the network
     * resource pool set on this port group to be overridden on an individual port.
     * 
     */
    public Optional<Output<Boolean>> networkResourcePoolOverrideAllowed() {
        return Optional.ofNullable(this.networkResourcePoolOverrideAllowed);
    }

    /**
     * If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
     * 
     */
    @Import(name="notifySwitches")
    private @Nullable Output<Boolean> notifySwitches;

    /**
     * @return If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
     * 
     */
    public Optional<Output<Boolean>> notifySwitches() {
        return Optional.ofNullable(this.notifySwitches);
    }

    /**
     * The number of ports available on this port
     * group. Cannot be decreased below the amount of used ports on the port group.
     * 
     */
    @Import(name="numberOfPorts")
    private @Nullable Output<Integer> numberOfPorts;

    /**
     * @return The number of ports available on this port
     * group. Cannot be decreased below the amount of used ports on the port group.
     * 
     */
    public Optional<Output<Integer>> numberOfPorts() {
        return Optional.ofNullable(this.numberOfPorts);
    }

    /**
     * Reset a port&#39;s settings to the
     * settings defined on this port group policy when the port disconnects.
     * 
     */
    @Import(name="portConfigResetAtDisconnect")
    private @Nullable Output<Boolean> portConfigResetAtDisconnect;

    /**
     * @return Reset a port&#39;s settings to the
     * settings defined on this port group policy when the port disconnects.
     * 
     */
    public Optional<Output<Boolean>> portConfigResetAtDisconnect() {
        return Optional.ofNullable(this.portConfigResetAtDisconnect);
    }

    /**
     * An optional formatting policy for naming of
     * the ports in this port group. See the `portNameFormat` attribute listed
     * [here][ext-vsphere-portname-format] for details on the format syntax.
     * 
     */
    @Import(name="portNameFormat")
    private @Nullable Output<String> portNameFormat;

    /**
     * @return An optional formatting policy for naming of
     * the ports in this port group. See the `portNameFormat` attribute listed
     * [here][ext-vsphere-portname-format] for details on the format syntax.
     * 
     */
    public Optional<Output<String>> portNameFormat() {
        return Optional.ofNullable(this.portNameFormat);
    }

    /**
     * The secondary VLAN ID for this port.
     * 
     */
    @Import(name="portPrivateSecondaryVlanId")
    private @Nullable Output<Integer> portPrivateSecondaryVlanId;

    /**
     * @return The secondary VLAN ID for this port.
     * 
     */
    public Optional<Output<Integer>> portPrivateSecondaryVlanId() {
        return Optional.ofNullable(this.portPrivateSecondaryVlanId);
    }

    /**
     * Allow the
     * [security policy settings][sec-policy-settings] defined in this port group
     * policy to be overridden on an individual port.
     * 
     */
    @Import(name="securityPolicyOverrideAllowed")
    private @Nullable Output<Boolean> securityPolicyOverrideAllowed;

    /**
     * @return Allow the
     * [security policy settings][sec-policy-settings] defined in this port group
     * policy to be overridden on an individual port.
     * 
     */
    public Optional<Output<Boolean>> securityPolicyOverrideAllowed() {
        return Optional.ofNullable(this.securityPolicyOverrideAllowed);
    }

    /**
     * Allow the
     * [traffic shaping options][traffic-shaping-settings] on this port group policy
     * to be overridden on an individual port.
     * 
     */
    @Import(name="shapingOverrideAllowed")
    private @Nullable Output<Boolean> shapingOverrideAllowed;

    /**
     * @return Allow the
     * [traffic shaping options][traffic-shaping-settings] on this port group policy
     * to be overridden on an individual port.
     * 
     */
    public Optional<Output<Boolean>> shapingOverrideAllowed() {
        return Optional.ofNullable(this.shapingOverrideAllowed);
    }

    /**
     * List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    @Import(name="standbyUplinks")
    private @Nullable Output<List<String>> standbyUplinks;

    /**
     * @return List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    public Optional<Output<List<String>>> standbyUplinks() {
        return Optional.ofNullable(this.standbyUplinks);
    }

    /**
     * A list of tag IDs to apply to this object.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return A list of tag IDs to apply to this object.
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
     * failover_explicit, or loadbalance_loadbased.
     * 
     */
    @Import(name="teamingPolicy")
    private @Nullable Output<String> teamingPolicy;

    /**
     * @return The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
     * failover_explicit, or loadbalance_loadbased.
     * 
     */
    public Optional<Output<String>> teamingPolicy() {
        return Optional.ofNullable(this.teamingPolicy);
    }

    /**
     * Allow any traffic filters on
     * this port group to be overridden on an individual port.
     * 
     */
    @Import(name="trafficFilterOverrideAllowed")
    private @Nullable Output<Boolean> trafficFilterOverrideAllowed;

    /**
     * @return Allow any traffic filters on
     * this port group to be overridden on an individual port.
     * 
     */
    public Optional<Output<Boolean>> trafficFilterOverrideAllowed() {
        return Optional.ofNullable(this.trafficFilterOverrideAllowed);
    }

    /**
     * If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
     * forwarded done by the switch.
     * 
     */
    @Import(name="txUplink")
    private @Nullable Output<Boolean> txUplink;

    /**
     * @return If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
     * forwarded done by the switch.
     * 
     */
    public Optional<Output<Boolean>> txUplink() {
        return Optional.ofNullable(this.txUplink);
    }

    /**
     * The port group type. Can be one of `earlyBinding` (static
     * binding) or `ephemeral`. Default: `earlyBinding`.
     * 
     */
    @Import(name="type")
    private @Nullable Output<String> type;

    /**
     * @return The port group type. Can be one of `earlyBinding` (static
     * binding) or `ephemeral`. Default: `earlyBinding`.
     * 
     */
    public Optional<Output<String>> type() {
        return Optional.ofNullable(this.type);
    }

    /**
     * Allow the
     * [uplink teaming options][uplink-teaming-settings] on this port group to be
     * overridden on an individual port.
     * 
     */
    @Import(name="uplinkTeamingOverrideAllowed")
    private @Nullable Output<Boolean> uplinkTeamingOverrideAllowed;

    /**
     * @return Allow the
     * [uplink teaming options][uplink-teaming-settings] on this port group to be
     * overridden on an individual port.
     * 
     */
    public Optional<Output<Boolean>> uplinkTeamingOverrideAllowed() {
        return Optional.ofNullable(this.uplinkTeamingOverrideAllowed);
    }

    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    @Import(name="vlanId")
    private @Nullable Output<Integer> vlanId;

    /**
     * @return The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    public Optional<Output<Integer>> vlanId() {
        return Optional.ofNullable(this.vlanId);
    }

    /**
     * Allow the
     * [VLAN settings][vlan-settings] on this port group to be overridden on an
     * individual port.
     * 
     */
    @Import(name="vlanOverrideAllowed")
    private @Nullable Output<Boolean> vlanOverrideAllowed;

    /**
     * @return Allow the
     * [VLAN settings][vlan-settings] on this port group to be overridden on an
     * individual port.
     * 
     */
    public Optional<Output<Boolean>> vlanOverrideAllowed() {
        return Optional.ofNullable(this.vlanOverrideAllowed);
    }

    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    @Import(name="vlanRanges")
    private @Nullable Output<List<DistributedPortGroupVlanRangeArgs>> vlanRanges;

    /**
     * @return The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    public Optional<Output<List<DistributedPortGroupVlanRangeArgs>>> vlanRanges() {
        return Optional.ofNullable(this.vlanRanges);
    }

    private DistributedPortGroupArgs() {}

    private DistributedPortGroupArgs(DistributedPortGroupArgs $) {
        this.activeUplinks = $.activeUplinks;
        this.allowForgedTransmits = $.allowForgedTransmits;
        this.allowMacChanges = $.allowMacChanges;
        this.allowPromiscuous = $.allowPromiscuous;
        this.autoExpand = $.autoExpand;
        this.blockAllPorts = $.blockAllPorts;
        this.blockOverrideAllowed = $.blockOverrideAllowed;
        this.checkBeacon = $.checkBeacon;
        this.customAttributes = $.customAttributes;
        this.description = $.description;
        this.directpathGen2Allowed = $.directpathGen2Allowed;
        this.distributedVirtualSwitchUuid = $.distributedVirtualSwitchUuid;
        this.egressShapingAverageBandwidth = $.egressShapingAverageBandwidth;
        this.egressShapingBurstSize = $.egressShapingBurstSize;
        this.egressShapingEnabled = $.egressShapingEnabled;
        this.egressShapingPeakBandwidth = $.egressShapingPeakBandwidth;
        this.failback = $.failback;
        this.ingressShapingAverageBandwidth = $.ingressShapingAverageBandwidth;
        this.ingressShapingBurstSize = $.ingressShapingBurstSize;
        this.ingressShapingEnabled = $.ingressShapingEnabled;
        this.ingressShapingPeakBandwidth = $.ingressShapingPeakBandwidth;
        this.lacpEnabled = $.lacpEnabled;
        this.lacpMode = $.lacpMode;
        this.livePortMovingAllowed = $.livePortMovingAllowed;
        this.name = $.name;
        this.netflowEnabled = $.netflowEnabled;
        this.netflowOverrideAllowed = $.netflowOverrideAllowed;
        this.networkResourcePoolKey = $.networkResourcePoolKey;
        this.networkResourcePoolOverrideAllowed = $.networkResourcePoolOverrideAllowed;
        this.notifySwitches = $.notifySwitches;
        this.numberOfPorts = $.numberOfPorts;
        this.portConfigResetAtDisconnect = $.portConfigResetAtDisconnect;
        this.portNameFormat = $.portNameFormat;
        this.portPrivateSecondaryVlanId = $.portPrivateSecondaryVlanId;
        this.securityPolicyOverrideAllowed = $.securityPolicyOverrideAllowed;
        this.shapingOverrideAllowed = $.shapingOverrideAllowed;
        this.standbyUplinks = $.standbyUplinks;
        this.tags = $.tags;
        this.teamingPolicy = $.teamingPolicy;
        this.trafficFilterOverrideAllowed = $.trafficFilterOverrideAllowed;
        this.txUplink = $.txUplink;
        this.type = $.type;
        this.uplinkTeamingOverrideAllowed = $.uplinkTeamingOverrideAllowed;
        this.vlanId = $.vlanId;
        this.vlanOverrideAllowed = $.vlanOverrideAllowed;
        this.vlanRanges = $.vlanRanges;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DistributedPortGroupArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DistributedPortGroupArgs $;

        public Builder() {
            $ = new DistributedPortGroupArgs();
        }

        public Builder(DistributedPortGroupArgs defaults) {
            $ = new DistributedPortGroupArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param activeUplinks List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
         * 
         * @return builder
         * 
         */
        public Builder activeUplinks(@Nullable Output<List<String>> activeUplinks) {
            $.activeUplinks = activeUplinks;
            return this;
        }

        /**
         * @param activeUplinks List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
         * 
         * @return builder
         * 
         */
        public Builder activeUplinks(List<String> activeUplinks) {
            return activeUplinks(Output.of(activeUplinks));
        }

        /**
         * @param activeUplinks List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
         * 
         * @return builder
         * 
         */
        public Builder activeUplinks(String... activeUplinks) {
            return activeUplinks(List.of(activeUplinks));
        }

        /**
         * @param allowForgedTransmits Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
         * that of its own.
         * 
         * @return builder
         * 
         */
        public Builder allowForgedTransmits(@Nullable Output<Boolean> allowForgedTransmits) {
            $.allowForgedTransmits = allowForgedTransmits;
            return this;
        }

        /**
         * @param allowForgedTransmits Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
         * that of its own.
         * 
         * @return builder
         * 
         */
        public Builder allowForgedTransmits(Boolean allowForgedTransmits) {
            return allowForgedTransmits(Output.of(allowForgedTransmits));
        }

        /**
         * @param allowMacChanges Controls whether or not the Media Access Control (MAC) address can be changed.
         * 
         * @return builder
         * 
         */
        public Builder allowMacChanges(@Nullable Output<Boolean> allowMacChanges) {
            $.allowMacChanges = allowMacChanges;
            return this;
        }

        /**
         * @param allowMacChanges Controls whether or not the Media Access Control (MAC) address can be changed.
         * 
         * @return builder
         * 
         */
        public Builder allowMacChanges(Boolean allowMacChanges) {
            return allowMacChanges(Output.of(allowMacChanges));
        }

        /**
         * @param allowPromiscuous Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
         * 
         * @return builder
         * 
         */
        public Builder allowPromiscuous(@Nullable Output<Boolean> allowPromiscuous) {
            $.allowPromiscuous = allowPromiscuous;
            return this;
        }

        /**
         * @param allowPromiscuous Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
         * 
         * @return builder
         * 
         */
        public Builder allowPromiscuous(Boolean allowPromiscuous) {
            return allowPromiscuous(Output.of(allowPromiscuous));
        }

        /**
         * @param autoExpand Allows the port group to create additional ports
         * past the limit specified in `number_of_ports` if necessary. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder autoExpand(@Nullable Output<Boolean> autoExpand) {
            $.autoExpand = autoExpand;
            return this;
        }

        /**
         * @param autoExpand Allows the port group to create additional ports
         * past the limit specified in `number_of_ports` if necessary. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder autoExpand(Boolean autoExpand) {
            return autoExpand(Output.of(autoExpand));
        }

        /**
         * @param blockAllPorts Indicates whether to block all ports by default.
         * 
         * @return builder
         * 
         */
        public Builder blockAllPorts(@Nullable Output<Boolean> blockAllPorts) {
            $.blockAllPorts = blockAllPorts;
            return this;
        }

        /**
         * @param blockAllPorts Indicates whether to block all ports by default.
         * 
         * @return builder
         * 
         */
        public Builder blockAllPorts(Boolean blockAllPorts) {
            return blockAllPorts(Output.of(blockAllPorts));
        }

        /**
         * @param blockOverrideAllowed Allow the port shutdown
         * policy to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder blockOverrideAllowed(@Nullable Output<Boolean> blockOverrideAllowed) {
            $.blockOverrideAllowed = blockOverrideAllowed;
            return this;
        }

        /**
         * @param blockOverrideAllowed Allow the port shutdown
         * policy to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder blockOverrideAllowed(Boolean blockOverrideAllowed) {
            return blockOverrideAllowed(Output.of(blockOverrideAllowed));
        }

        /**
         * @param checkBeacon Enable beacon probing on the ports this policy applies to.
         * 
         * @return builder
         * 
         */
        public Builder checkBeacon(@Nullable Output<Boolean> checkBeacon) {
            $.checkBeacon = checkBeacon;
            return this;
        }

        /**
         * @param checkBeacon Enable beacon probing on the ports this policy applies to.
         * 
         * @return builder
         * 
         */
        public Builder checkBeacon(Boolean checkBeacon) {
            return checkBeacon(Output.of(checkBeacon));
        }

        /**
         * @param customAttributes Map of custom attribute ids to attribute
         * value string to set for port group.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(@Nullable Output<Map<String,String>> customAttributes) {
            $.customAttributes = customAttributes;
            return this;
        }

        /**
         * @param customAttributes Map of custom attribute ids to attribute
         * value string to set for port group.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(Map<String,String> customAttributes) {
            return customAttributes(Output.of(customAttributes));
        }

        /**
         * @param description An optional description for the port group.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description An optional description for the port group.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param directpathGen2Allowed Allow VMDirectPath Gen2 on the ports this policy applies to.
         * 
         * @return builder
         * 
         */
        public Builder directpathGen2Allowed(@Nullable Output<Boolean> directpathGen2Allowed) {
            $.directpathGen2Allowed = directpathGen2Allowed;
            return this;
        }

        /**
         * @param directpathGen2Allowed Allow VMDirectPath Gen2 on the ports this policy applies to.
         * 
         * @return builder
         * 
         */
        public Builder directpathGen2Allowed(Boolean directpathGen2Allowed) {
            return directpathGen2Allowed(Output.of(directpathGen2Allowed));
        }

        /**
         * @param distributedVirtualSwitchUuid The ID of the VDS to add the
         * port group to. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder distributedVirtualSwitchUuid(Output<String> distributedVirtualSwitchUuid) {
            $.distributedVirtualSwitchUuid = distributedVirtualSwitchUuid;
            return this;
        }

        /**
         * @param distributedVirtualSwitchUuid The ID of the VDS to add the
         * port group to. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder distributedVirtualSwitchUuid(String distributedVirtualSwitchUuid) {
            return distributedVirtualSwitchUuid(Output.of(distributedVirtualSwitchUuid));
        }

        /**
         * @param egressShapingAverageBandwidth The average egress bandwidth in bits per second if egress shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingAverageBandwidth(@Nullable Output<Integer> egressShapingAverageBandwidth) {
            $.egressShapingAverageBandwidth = egressShapingAverageBandwidth;
            return this;
        }

        /**
         * @param egressShapingAverageBandwidth The average egress bandwidth in bits per second if egress shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingAverageBandwidth(Integer egressShapingAverageBandwidth) {
            return egressShapingAverageBandwidth(Output.of(egressShapingAverageBandwidth));
        }

        /**
         * @param egressShapingBurstSize The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingBurstSize(@Nullable Output<Integer> egressShapingBurstSize) {
            $.egressShapingBurstSize = egressShapingBurstSize;
            return this;
        }

        /**
         * @param egressShapingBurstSize The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingBurstSize(Integer egressShapingBurstSize) {
            return egressShapingBurstSize(Output.of(egressShapingBurstSize));
        }

        /**
         * @param egressShapingEnabled True if the traffic shaper is enabled for egress traffic on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingEnabled(@Nullable Output<Boolean> egressShapingEnabled) {
            $.egressShapingEnabled = egressShapingEnabled;
            return this;
        }

        /**
         * @param egressShapingEnabled True if the traffic shaper is enabled for egress traffic on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingEnabled(Boolean egressShapingEnabled) {
            return egressShapingEnabled(Output.of(egressShapingEnabled));
        }

        /**
         * @param egressShapingPeakBandwidth The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingPeakBandwidth(@Nullable Output<Integer> egressShapingPeakBandwidth) {
            $.egressShapingPeakBandwidth = egressShapingPeakBandwidth;
            return this;
        }

        /**
         * @param egressShapingPeakBandwidth The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder egressShapingPeakBandwidth(Integer egressShapingPeakBandwidth) {
            return egressShapingPeakBandwidth(Output.of(egressShapingPeakBandwidth));
        }

        /**
         * @param failback If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
         * 
         * @return builder
         * 
         */
        public Builder failback(@Nullable Output<Boolean> failback) {
            $.failback = failback;
            return this;
        }

        /**
         * @param failback If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
         * 
         * @return builder
         * 
         */
        public Builder failback(Boolean failback) {
            return failback(Output.of(failback));
        }

        /**
         * @param ingressShapingAverageBandwidth The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingAverageBandwidth(@Nullable Output<Integer> ingressShapingAverageBandwidth) {
            $.ingressShapingAverageBandwidth = ingressShapingAverageBandwidth;
            return this;
        }

        /**
         * @param ingressShapingAverageBandwidth The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingAverageBandwidth(Integer ingressShapingAverageBandwidth) {
            return ingressShapingAverageBandwidth(Output.of(ingressShapingAverageBandwidth));
        }

        /**
         * @param ingressShapingBurstSize The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingBurstSize(@Nullable Output<Integer> ingressShapingBurstSize) {
            $.ingressShapingBurstSize = ingressShapingBurstSize;
            return this;
        }

        /**
         * @param ingressShapingBurstSize The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingBurstSize(Integer ingressShapingBurstSize) {
            return ingressShapingBurstSize(Output.of(ingressShapingBurstSize));
        }

        /**
         * @param ingressShapingEnabled True if the traffic shaper is enabled for ingress traffic on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingEnabled(@Nullable Output<Boolean> ingressShapingEnabled) {
            $.ingressShapingEnabled = ingressShapingEnabled;
            return this;
        }

        /**
         * @param ingressShapingEnabled True if the traffic shaper is enabled for ingress traffic on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingEnabled(Boolean ingressShapingEnabled) {
            return ingressShapingEnabled(Output.of(ingressShapingEnabled));
        }

        /**
         * @param ingressShapingPeakBandwidth The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingPeakBandwidth(@Nullable Output<Integer> ingressShapingPeakBandwidth) {
            $.ingressShapingPeakBandwidth = ingressShapingPeakBandwidth;
            return this;
        }

        /**
         * @param ingressShapingPeakBandwidth The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
         * 
         * @return builder
         * 
         */
        public Builder ingressShapingPeakBandwidth(Integer ingressShapingPeakBandwidth) {
            return ingressShapingPeakBandwidth(Output.of(ingressShapingPeakBandwidth));
        }

        /**
         * @param lacpEnabled Whether or not to enable LACP on all uplink ports.
         * 
         * @return builder
         * 
         */
        public Builder lacpEnabled(@Nullable Output<Boolean> lacpEnabled) {
            $.lacpEnabled = lacpEnabled;
            return this;
        }

        /**
         * @param lacpEnabled Whether or not to enable LACP on all uplink ports.
         * 
         * @return builder
         * 
         */
        public Builder lacpEnabled(Boolean lacpEnabled) {
            return lacpEnabled(Output.of(lacpEnabled));
        }

        /**
         * @param lacpMode The uplink LACP mode to use. Can be one of active or passive.
         * 
         * @return builder
         * 
         */
        public Builder lacpMode(@Nullable Output<String> lacpMode) {
            $.lacpMode = lacpMode;
            return this;
        }

        /**
         * @param lacpMode The uplink LACP mode to use. Can be one of active or passive.
         * 
         * @return builder
         * 
         */
        public Builder lacpMode(String lacpMode) {
            return lacpMode(Output.of(lacpMode));
        }

        /**
         * @param livePortMovingAllowed Allow a port in this port group to be
         * moved to another port group while it is connected.
         * 
         * @return builder
         * 
         */
        public Builder livePortMovingAllowed(@Nullable Output<Boolean> livePortMovingAllowed) {
            $.livePortMovingAllowed = livePortMovingAllowed;
            return this;
        }

        /**
         * @param livePortMovingAllowed Allow a port in this port group to be
         * moved to another port group while it is connected.
         * 
         * @return builder
         * 
         */
        public Builder livePortMovingAllowed(Boolean livePortMovingAllowed) {
            return livePortMovingAllowed(Output.of(livePortMovingAllowed));
        }

        /**
         * @param name The name of the port group.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the port group.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param netflowEnabled Indicates whether to enable netflow on all ports.
         * 
         * @return builder
         * 
         */
        public Builder netflowEnabled(@Nullable Output<Boolean> netflowEnabled) {
            $.netflowEnabled = netflowEnabled;
            return this;
        }

        /**
         * @param netflowEnabled Indicates whether to enable netflow on all ports.
         * 
         * @return builder
         * 
         */
        public Builder netflowEnabled(Boolean netflowEnabled) {
            return netflowEnabled(Output.of(netflowEnabled));
        }

        /**
         * @param netflowOverrideAllowed Allow the
         * [Netflow policy][netflow-policy] on this port group to be overridden on an
         * individual port.
         * 
         * @return builder
         * 
         */
        public Builder netflowOverrideAllowed(@Nullable Output<Boolean> netflowOverrideAllowed) {
            $.netflowOverrideAllowed = netflowOverrideAllowed;
            return this;
        }

        /**
         * @param netflowOverrideAllowed Allow the
         * [Netflow policy][netflow-policy] on this port group to be overridden on an
         * individual port.
         * 
         * @return builder
         * 
         */
        public Builder netflowOverrideAllowed(Boolean netflowOverrideAllowed) {
            return netflowOverrideAllowed(Output.of(netflowOverrideAllowed));
        }

        /**
         * @param networkResourcePoolKey The key of a network resource pool
         * to associate with this port group. The default is `-1`, which implies no
         * association.
         * 
         * @return builder
         * 
         */
        public Builder networkResourcePoolKey(@Nullable Output<String> networkResourcePoolKey) {
            $.networkResourcePoolKey = networkResourcePoolKey;
            return this;
        }

        /**
         * @param networkResourcePoolKey The key of a network resource pool
         * to associate with this port group. The default is `-1`, which implies no
         * association.
         * 
         * @return builder
         * 
         */
        public Builder networkResourcePoolKey(String networkResourcePoolKey) {
            return networkResourcePoolKey(Output.of(networkResourcePoolKey));
        }

        /**
         * @param networkResourcePoolOverrideAllowed Allow the network
         * resource pool set on this port group to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder networkResourcePoolOverrideAllowed(@Nullable Output<Boolean> networkResourcePoolOverrideAllowed) {
            $.networkResourcePoolOverrideAllowed = networkResourcePoolOverrideAllowed;
            return this;
        }

        /**
         * @param networkResourcePoolOverrideAllowed Allow the network
         * resource pool set on this port group to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder networkResourcePoolOverrideAllowed(Boolean networkResourcePoolOverrideAllowed) {
            return networkResourcePoolOverrideAllowed(Output.of(networkResourcePoolOverrideAllowed));
        }

        /**
         * @param notifySwitches If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
         * 
         * @return builder
         * 
         */
        public Builder notifySwitches(@Nullable Output<Boolean> notifySwitches) {
            $.notifySwitches = notifySwitches;
            return this;
        }

        /**
         * @param notifySwitches If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
         * 
         * @return builder
         * 
         */
        public Builder notifySwitches(Boolean notifySwitches) {
            return notifySwitches(Output.of(notifySwitches));
        }

        /**
         * @param numberOfPorts The number of ports available on this port
         * group. Cannot be decreased below the amount of used ports on the port group.
         * 
         * @return builder
         * 
         */
        public Builder numberOfPorts(@Nullable Output<Integer> numberOfPorts) {
            $.numberOfPorts = numberOfPorts;
            return this;
        }

        /**
         * @param numberOfPorts The number of ports available on this port
         * group. Cannot be decreased below the amount of used ports on the port group.
         * 
         * @return builder
         * 
         */
        public Builder numberOfPorts(Integer numberOfPorts) {
            return numberOfPorts(Output.of(numberOfPorts));
        }

        /**
         * @param portConfigResetAtDisconnect Reset a port&#39;s settings to the
         * settings defined on this port group policy when the port disconnects.
         * 
         * @return builder
         * 
         */
        public Builder portConfigResetAtDisconnect(@Nullable Output<Boolean> portConfigResetAtDisconnect) {
            $.portConfigResetAtDisconnect = portConfigResetAtDisconnect;
            return this;
        }

        /**
         * @param portConfigResetAtDisconnect Reset a port&#39;s settings to the
         * settings defined on this port group policy when the port disconnects.
         * 
         * @return builder
         * 
         */
        public Builder portConfigResetAtDisconnect(Boolean portConfigResetAtDisconnect) {
            return portConfigResetAtDisconnect(Output.of(portConfigResetAtDisconnect));
        }

        /**
         * @param portNameFormat An optional formatting policy for naming of
         * the ports in this port group. See the `portNameFormat` attribute listed
         * [here][ext-vsphere-portname-format] for details on the format syntax.
         * 
         * @return builder
         * 
         */
        public Builder portNameFormat(@Nullable Output<String> portNameFormat) {
            $.portNameFormat = portNameFormat;
            return this;
        }

        /**
         * @param portNameFormat An optional formatting policy for naming of
         * the ports in this port group. See the `portNameFormat` attribute listed
         * [here][ext-vsphere-portname-format] for details on the format syntax.
         * 
         * @return builder
         * 
         */
        public Builder portNameFormat(String portNameFormat) {
            return portNameFormat(Output.of(portNameFormat));
        }

        /**
         * @param portPrivateSecondaryVlanId The secondary VLAN ID for this port.
         * 
         * @return builder
         * 
         */
        public Builder portPrivateSecondaryVlanId(@Nullable Output<Integer> portPrivateSecondaryVlanId) {
            $.portPrivateSecondaryVlanId = portPrivateSecondaryVlanId;
            return this;
        }

        /**
         * @param portPrivateSecondaryVlanId The secondary VLAN ID for this port.
         * 
         * @return builder
         * 
         */
        public Builder portPrivateSecondaryVlanId(Integer portPrivateSecondaryVlanId) {
            return portPrivateSecondaryVlanId(Output.of(portPrivateSecondaryVlanId));
        }

        /**
         * @param securityPolicyOverrideAllowed Allow the
         * [security policy settings][sec-policy-settings] defined in this port group
         * policy to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder securityPolicyOverrideAllowed(@Nullable Output<Boolean> securityPolicyOverrideAllowed) {
            $.securityPolicyOverrideAllowed = securityPolicyOverrideAllowed;
            return this;
        }

        /**
         * @param securityPolicyOverrideAllowed Allow the
         * [security policy settings][sec-policy-settings] defined in this port group
         * policy to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder securityPolicyOverrideAllowed(Boolean securityPolicyOverrideAllowed) {
            return securityPolicyOverrideAllowed(Output.of(securityPolicyOverrideAllowed));
        }

        /**
         * @param shapingOverrideAllowed Allow the
         * [traffic shaping options][traffic-shaping-settings] on this port group policy
         * to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder shapingOverrideAllowed(@Nullable Output<Boolean> shapingOverrideAllowed) {
            $.shapingOverrideAllowed = shapingOverrideAllowed;
            return this;
        }

        /**
         * @param shapingOverrideAllowed Allow the
         * [traffic shaping options][traffic-shaping-settings] on this port group policy
         * to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder shapingOverrideAllowed(Boolean shapingOverrideAllowed) {
            return shapingOverrideAllowed(Output.of(shapingOverrideAllowed));
        }

        /**
         * @param standbyUplinks List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
         * 
         * @return builder
         * 
         */
        public Builder standbyUplinks(@Nullable Output<List<String>> standbyUplinks) {
            $.standbyUplinks = standbyUplinks;
            return this;
        }

        /**
         * @param standbyUplinks List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
         * 
         * @return builder
         * 
         */
        public Builder standbyUplinks(List<String> standbyUplinks) {
            return standbyUplinks(Output.of(standbyUplinks));
        }

        /**
         * @param standbyUplinks List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
         * 
         * @return builder
         * 
         */
        public Builder standbyUplinks(String... standbyUplinks) {
            return standbyUplinks(List.of(standbyUplinks));
        }

        /**
         * @param tags A list of tag IDs to apply to this object.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags A list of tag IDs to apply to this object.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags A list of tag IDs to apply to this object.
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param teamingPolicy The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
         * failover_explicit, or loadbalance_loadbased.
         * 
         * @return builder
         * 
         */
        public Builder teamingPolicy(@Nullable Output<String> teamingPolicy) {
            $.teamingPolicy = teamingPolicy;
            return this;
        }

        /**
         * @param teamingPolicy The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
         * failover_explicit, or loadbalance_loadbased.
         * 
         * @return builder
         * 
         */
        public Builder teamingPolicy(String teamingPolicy) {
            return teamingPolicy(Output.of(teamingPolicy));
        }

        /**
         * @param trafficFilterOverrideAllowed Allow any traffic filters on
         * this port group to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder trafficFilterOverrideAllowed(@Nullable Output<Boolean> trafficFilterOverrideAllowed) {
            $.trafficFilterOverrideAllowed = trafficFilterOverrideAllowed;
            return this;
        }

        /**
         * @param trafficFilterOverrideAllowed Allow any traffic filters on
         * this port group to be overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder trafficFilterOverrideAllowed(Boolean trafficFilterOverrideAllowed) {
            return trafficFilterOverrideAllowed(Output.of(trafficFilterOverrideAllowed));
        }

        /**
         * @param txUplink If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
         * forwarded done by the switch.
         * 
         * @return builder
         * 
         */
        public Builder txUplink(@Nullable Output<Boolean> txUplink) {
            $.txUplink = txUplink;
            return this;
        }

        /**
         * @param txUplink If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
         * forwarded done by the switch.
         * 
         * @return builder
         * 
         */
        public Builder txUplink(Boolean txUplink) {
            return txUplink(Output.of(txUplink));
        }

        /**
         * @param type The port group type. Can be one of `earlyBinding` (static
         * binding) or `ephemeral`. Default: `earlyBinding`.
         * 
         * @return builder
         * 
         */
        public Builder type(@Nullable Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type The port group type. Can be one of `earlyBinding` (static
         * binding) or `ephemeral`. Default: `earlyBinding`.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        /**
         * @param uplinkTeamingOverrideAllowed Allow the
         * [uplink teaming options][uplink-teaming-settings] on this port group to be
         * overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder uplinkTeamingOverrideAllowed(@Nullable Output<Boolean> uplinkTeamingOverrideAllowed) {
            $.uplinkTeamingOverrideAllowed = uplinkTeamingOverrideAllowed;
            return this;
        }

        /**
         * @param uplinkTeamingOverrideAllowed Allow the
         * [uplink teaming options][uplink-teaming-settings] on this port group to be
         * overridden on an individual port.
         * 
         * @return builder
         * 
         */
        public Builder uplinkTeamingOverrideAllowed(Boolean uplinkTeamingOverrideAllowed) {
            return uplinkTeamingOverrideAllowed(Output.of(uplinkTeamingOverrideAllowed));
        }

        /**
         * @param vlanId The VLAN ID for single VLAN mode. 0 denotes no VLAN.
         * 
         * @return builder
         * 
         */
        public Builder vlanId(@Nullable Output<Integer> vlanId) {
            $.vlanId = vlanId;
            return this;
        }

        /**
         * @param vlanId The VLAN ID for single VLAN mode. 0 denotes no VLAN.
         * 
         * @return builder
         * 
         */
        public Builder vlanId(Integer vlanId) {
            return vlanId(Output.of(vlanId));
        }

        /**
         * @param vlanOverrideAllowed Allow the
         * [VLAN settings][vlan-settings] on this port group to be overridden on an
         * individual port.
         * 
         * @return builder
         * 
         */
        public Builder vlanOverrideAllowed(@Nullable Output<Boolean> vlanOverrideAllowed) {
            $.vlanOverrideAllowed = vlanOverrideAllowed;
            return this;
        }

        /**
         * @param vlanOverrideAllowed Allow the
         * [VLAN settings][vlan-settings] on this port group to be overridden on an
         * individual port.
         * 
         * @return builder
         * 
         */
        public Builder vlanOverrideAllowed(Boolean vlanOverrideAllowed) {
            return vlanOverrideAllowed(Output.of(vlanOverrideAllowed));
        }

        /**
         * @param vlanRanges The VLAN ID for single VLAN mode. 0 denotes no VLAN.
         * 
         * @return builder
         * 
         */
        public Builder vlanRanges(@Nullable Output<List<DistributedPortGroupVlanRangeArgs>> vlanRanges) {
            $.vlanRanges = vlanRanges;
            return this;
        }

        /**
         * @param vlanRanges The VLAN ID for single VLAN mode. 0 denotes no VLAN.
         * 
         * @return builder
         * 
         */
        public Builder vlanRanges(List<DistributedPortGroupVlanRangeArgs> vlanRanges) {
            return vlanRanges(Output.of(vlanRanges));
        }

        /**
         * @param vlanRanges The VLAN ID for single VLAN mode. 0 denotes no VLAN.
         * 
         * @return builder
         * 
         */
        public Builder vlanRanges(DistributedPortGroupVlanRangeArgs... vlanRanges) {
            return vlanRanges(List.of(vlanRanges));
        }

        public DistributedPortGroupArgs build() {
            $.distributedVirtualSwitchUuid = Objects.requireNonNull($.distributedVirtualSwitchUuid, "expected parameter 'distributedVirtualSwitchUuid' to be non-null");
            return $;
        }
    }

}
