// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.vsphere.ComputeClusterArgs;
import com.pulumi.vsphere.Utilities;
import com.pulumi.vsphere.inputs.ComputeClusterState;
import com.pulumi.vsphere.outputs.ComputeClusterVsanDiskGroup;
import com.pulumi.vsphere.outputs.ComputeClusterVsanFaultDomain;
import com.pulumi.vsphere.outputs.ComputeClusterVsanStretchedCluster;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

@ResourceType(type="vsphere:index/computeCluster:ComputeCluster")
public class ComputeCluster extends com.pulumi.resources.CustomResource {
    /**
     * A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
     * and require vCenter Server.
     * 
     */
    @Export(name="customAttributes", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> customAttributes;

    /**
     * @return A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
     * and require vCenter Server.
     * 
     */
    public Output<Optional<Map<String,String>>> customAttributes() {
        return Codegen.optional(this.customAttributes);
    }
    /**
     * The managed object ID of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     * 
     */
    @Export(name="datacenterId", refs={String.class}, tree="[0]")
    private Output<String> datacenterId;

    /**
     * @return The managed object ID of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     * 
     */
    public Output<String> datacenterId() {
        return this.datacenterId;
    }
    /**
     * The automation level for host power operations in this cluster. Can be one of manual or automated.
     * 
     */
    @Export(name="dpmAutomationLevel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> dpmAutomationLevel;

    /**
     * @return The automation level for host power operations in this cluster. Can be one of manual or automated.
     * 
     */
    public Output<Optional<String>> dpmAutomationLevel() {
        return Codegen.optional(this.dpmAutomationLevel);
    }
    /**
     * Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual
     * machines in the cluster. Requires that DRS be enabled.
     * 
     */
    @Export(name="dpmEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> dpmEnabled;

    /**
     * @return Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual
     * machines in the cluster. Requires that DRS be enabled.
     * 
     */
    public Output<Optional<Boolean>> dpmEnabled() {
        return Codegen.optional(this.dpmEnabled);
    }
    /**
     * A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This
     * affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher
     * setting.
     * 
     */
    @Export(name="dpmThreshold", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> dpmThreshold;

    /**
     * @return A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This
     * affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher
     * setting.
     * 
     */
    public Output<Optional<Integer>> dpmThreshold() {
        return Codegen.optional(this.dpmThreshold);
    }
    /**
     * Advanced configuration options for DRS and DPM.
     * 
     */
    @Export(name="drsAdvancedOptions", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> drsAdvancedOptions;

    /**
     * @return Advanced configuration options for DRS and DPM.
     * 
     */
    public Output<Optional<Map<String,String>>> drsAdvancedOptions() {
        return Codegen.optional(this.drsAdvancedOptions);
    }
    /**
     * The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or
     * fullyAutomated.
     * 
     */
    @Export(name="drsAutomationLevel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> drsAutomationLevel;

    /**
     * @return The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or
     * fullyAutomated.
     * 
     */
    public Output<Optional<String>> drsAutomationLevel() {
        return Codegen.optional(this.drsAutomationLevel);
    }
    /**
     * When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     * 
     */
    @Export(name="drsEnablePredictiveDrs", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> drsEnablePredictiveDrs;

    /**
     * @return When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     * 
     */
    public Output<Optional<Boolean>> drsEnablePredictiveDrs() {
        return Codegen.optional(this.drsEnablePredictiveDrs);
    }
    /**
     * When true, allows individual VM overrides within this cluster to be set.
     * 
     */
    @Export(name="drsEnableVmOverrides", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> drsEnableVmOverrides;

    /**
     * @return When true, allows individual VM overrides within this cluster to be set.
     * 
     */
    public Output<Optional<Boolean>> drsEnableVmOverrides() {
        return Codegen.optional(this.drsEnableVmOverrides);
    }
    /**
     * Enable DRS for this cluster.
     * 
     */
    @Export(name="drsEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> drsEnabled;

    /**
     * @return Enable DRS for this cluster.
     * 
     */
    public Output<Optional<Boolean>> drsEnabled() {
        return Codegen.optional(this.drsEnabled);
    }
    /**
     * A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate
     * more imbalance while a higher setting will tolerate less.
     * 
     */
    @Export(name="drsMigrationThreshold", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> drsMigrationThreshold;

    /**
     * @return A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate
     * more imbalance while a higher setting will tolerate less.
     * 
     */
    public Output<Optional<Integer>> drsMigrationThreshold() {
        return Codegen.optional(this.drsMigrationThreshold);
    }
    /**
     * Enable scalable shares for all descendants of this cluster.
     * 
     */
    @Export(name="drsScaleDescendantsShares", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> drsScaleDescendantsShares;

    /**
     * @return Enable scalable shares for all descendants of this cluster.
     * 
     */
    public Output<Optional<String>> drsScaleDescendantsShares() {
        return Codegen.optional(this.drsScaleDescendantsShares);
    }
    /**
     * The relative path to a folder to put this cluster in.
     * This is a path relative to the datacenter you are deploying the cluster to.
     * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
     * The provider will place a cluster named `compute-cluster-test` in a
     * host folder located at `/dc1/host/foo/bar`, with the final inventory path
     * being `/dc1/host/foo/bar/datastore-cluster-test`.
     * 
     */
    @Export(name="folder", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> folder;

    /**
     * @return The relative path to a folder to put this cluster in.
     * This is a path relative to the datacenter you are deploying the cluster to.
     * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
     * The provider will place a cluster named `compute-cluster-test` in a
     * host folder located at `/dc1/host/foo/bar`, with the final inventory path
     * being `/dc1/host/foo/bar/datastore-cluster-test`.
     * 
     */
    public Output<Optional<String>> folder() {
        return Codegen.optional(this.folder);
    }
    /**
     * Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists
     * for testing and is not recommended in normal use.
     * 
     */
    @Export(name="forceEvacuateOnDestroy", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> forceEvacuateOnDestroy;

    /**
     * @return Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists
     * for testing and is not recommended in normal use.
     * 
     */
    public Output<Optional<Boolean>> forceEvacuateOnDestroy() {
        return Codegen.optional(this.forceEvacuateOnDestroy);
    }
    /**
     * When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated
     * failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS
     * will ignore the host when making recommendations.
     * 
     */
    @Export(name="haAdmissionControlFailoverHostSystemIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> haAdmissionControlFailoverHostSystemIds;

    /**
     * @return When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated
     * failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS
     * will ignore the host when making recommendations.
     * 
     */
    public Output<Optional<List<String>>> haAdmissionControlFailoverHostSystemIds() {
        return Codegen.optional(this.haAdmissionControlFailoverHostSystemIds);
    }
    /**
     * The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual
     * machine operations. The maximum is one less than the number of hosts in the cluster.
     * 
     */
    @Export(name="haAdmissionControlHostFailureTolerance", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haAdmissionControlHostFailureTolerance;

    /**
     * @return The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual
     * machine operations. The maximum is one less than the number of hosts in the cluster.
     * 
     */
    public Output<Optional<Integer>> haAdmissionControlHostFailureTolerance() {
        return Codegen.optional(this.haAdmissionControlHostFailureTolerance);
    }
    /**
     * The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces
     * warnings only, whereas a value of 100 disables the setting.
     * 
     */
    @Export(name="haAdmissionControlPerformanceTolerance", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haAdmissionControlPerformanceTolerance;

    /**
     * @return The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces
     * warnings only, whereas a value of 100 disables the setting.
     * 
     */
    public Output<Optional<Integer>> haAdmissionControlPerformanceTolerance() {
        return Codegen.optional(this.haAdmissionControlPerformanceTolerance);
    }
    /**
     * The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are
     * permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,
     * slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service
     * issues.
     * 
     */
    @Export(name="haAdmissionControlPolicy", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haAdmissionControlPolicy;

    /**
     * @return The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are
     * permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,
     * slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service
     * issues.
     * 
     */
    public Output<Optional<String>> haAdmissionControlPolicy() {
        return Codegen.optional(this.haAdmissionControlPolicy);
    }
    /**
     * When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by
     * subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting
     * from the total amount of resources in the cluster. Disable to supply user-defined values.
     * 
     */
    @Export(name="haAdmissionControlResourcePercentageAutoCompute", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> haAdmissionControlResourcePercentageAutoCompute;

    /**
     * @return When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by
     * subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting
     * from the total amount of resources in the cluster. Disable to supply user-defined values.
     * 
     */
    public Output<Optional<Boolean>> haAdmissionControlResourcePercentageAutoCompute() {
        return Codegen.optional(this.haAdmissionControlResourcePercentageAutoCompute);
    }
    /**
     * When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in
     * the cluster to reserve for failover.
     * 
     */
    @Export(name="haAdmissionControlResourcePercentageCpu", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haAdmissionControlResourcePercentageCpu;

    /**
     * @return When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in
     * the cluster to reserve for failover.
     * 
     */
    public Output<Optional<Integer>> haAdmissionControlResourcePercentageCpu() {
        return Codegen.optional(this.haAdmissionControlResourcePercentageCpu);
    }
    /**
     * When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in
     * the cluster to reserve for failover.
     * 
     */
    @Export(name="haAdmissionControlResourcePercentageMemory", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haAdmissionControlResourcePercentageMemory;

    /**
     * @return When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in
     * the cluster to reserve for failover.
     * 
     */
    public Output<Optional<Integer>> haAdmissionControlResourcePercentageMemory() {
        return Codegen.optional(this.haAdmissionControlResourcePercentageMemory);
    }
    /**
     * When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     * 
     */
    @Export(name="haAdmissionControlSlotPolicyExplicitCpu", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haAdmissionControlSlotPolicyExplicitCpu;

    /**
     * @return When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     * 
     */
    public Output<Optional<Integer>> haAdmissionControlSlotPolicyExplicitCpu() {
        return Codegen.optional(this.haAdmissionControlSlotPolicyExplicitCpu);
    }
    /**
     * When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.
     * 
     */
    @Export(name="haAdmissionControlSlotPolicyExplicitMemory", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haAdmissionControlSlotPolicyExplicitMemory;

    /**
     * @return When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.
     * 
     */
    public Output<Optional<Integer>> haAdmissionControlSlotPolicyExplicitMemory() {
        return Codegen.optional(this.haAdmissionControlSlotPolicyExplicitMemory);
    }
    /**
     * When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values
     * to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines
     * currently in the cluster.
     * 
     */
    @Export(name="haAdmissionControlSlotPolicyUseExplicitSize", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> haAdmissionControlSlotPolicyUseExplicitSize;

    /**
     * @return When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values
     * to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines
     * currently in the cluster.
     * 
     */
    public Output<Optional<Boolean>> haAdmissionControlSlotPolicyUseExplicitSize() {
        return Codegen.optional(this.haAdmissionControlSlotPolicyUseExplicitSize);
    }
    /**
     * Advanced configuration options for vSphere HA.
     * 
     */
    @Export(name="haAdvancedOptions", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> haAdvancedOptions;

    /**
     * @return Advanced configuration options for vSphere HA.
     * 
     */
    public Output<Optional<Map<String,String>>> haAdvancedOptions() {
        return Codegen.optional(this.haAdvancedOptions);
    }
    /**
     * When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an
     * affected datastore clears in the middle of an APD event. Can be one of none or reset.
     * 
     */
    @Export(name="haDatastoreApdRecoveryAction", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haDatastoreApdRecoveryAction;

    /**
     * @return When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an
     * affected datastore clears in the middle of an APD event. Can be one of none or reset.
     * 
     */
    public Output<Optional<String>> haDatastoreApdRecoveryAction() {
        return Codegen.optional(this.haDatastoreApdRecoveryAction);
    }
    /**
     * When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
     * detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or
     * restartAggressive.
     * 
     */
    @Export(name="haDatastoreApdResponse", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haDatastoreApdResponse;

    /**
     * @return When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
     * detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or
     * restartAggressive.
     * 
     */
    public Output<Optional<String>> haDatastoreApdResponse() {
        return Codegen.optional(this.haDatastoreApdResponse);
    }
    /**
     * When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute
     * the response action defined in ha_datastore_apd_response.
     * 
     */
    @Export(name="haDatastoreApdResponseDelay", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haDatastoreApdResponseDelay;

    /**
     * @return When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute
     * the response action defined in ha_datastore_apd_response.
     * 
     */
    public Output<Optional<Integer>> haDatastoreApdResponseDelay() {
        return Codegen.optional(this.haDatastoreApdResponseDelay);
    }
    /**
     * When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
     * detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     * 
     */
    @Export(name="haDatastorePdlResponse", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haDatastorePdlResponse;

    /**
     * @return When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
     * detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     * 
     */
    public Output<Optional<String>> haDatastorePdlResponse() {
        return Codegen.optional(this.haDatastorePdlResponse);
    }
    /**
     * Enable vSphere HA for this cluster.
     * 
     */
    @Export(name="haEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> haEnabled;

    /**
     * @return Enable vSphere HA for this cluster.
     * 
     */
    public Output<Optional<Boolean>> haEnabled() {
        return Codegen.optional(this.haEnabled);
    }
    /**
     * The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when
     * ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     * 
     */
    @Export(name="haHeartbeatDatastoreIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> haHeartbeatDatastoreIds;

    /**
     * @return The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when
     * ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     * 
     */
    public Output<Optional<List<String>>> haHeartbeatDatastoreIds() {
        return Codegen.optional(this.haHeartbeatDatastoreIds);
    }
    /**
     * The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or
     * allFeasibleDsWithUserPreference.
     * 
     */
    @Export(name="haHeartbeatDatastorePolicy", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haHeartbeatDatastorePolicy;

    /**
     * @return The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or
     * allFeasibleDsWithUserPreference.
     * 
     */
    public Output<Optional<String>> haHeartbeatDatastorePolicy() {
        return Codegen.optional(this.haHeartbeatDatastorePolicy);
    }
    /**
     * The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.
     * Can be one of none, powerOff, or shutdown.
     * 
     */
    @Export(name="haHostIsolationResponse", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haHostIsolationResponse;

    /**
     * @return The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.
     * Can be one of none, powerOff, or shutdown.
     * 
     */
    public Output<Optional<String>> haHostIsolationResponse() {
        return Codegen.optional(this.haHostIsolationResponse);
    }
    /**
     * Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     * 
     */
    @Export(name="haHostMonitoring", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haHostMonitoring;

    /**
     * @return Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     * 
     */
    public Output<Optional<String>> haHostMonitoring() {
        return Codegen.optional(this.haHostMonitoring);
    }
    /**
     * Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to
     * failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     * 
     */
    @Export(name="haVmComponentProtection", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haVmComponentProtection;

    /**
     * @return Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to
     * failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     * 
     */
    public Output<Optional<String>> haVmComponentProtection() {
        return Codegen.optional(this.haVmComponentProtection);
    }
    /**
     * The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move
     * on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     * 
     */
    @Export(name="haVmDependencyRestartCondition", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haVmDependencyRestartCondition;

    /**
     * @return The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move
     * on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     * 
     */
    public Output<Optional<String>> haVmDependencyRestartCondition() {
        return Codegen.optional(this.haVmDependencyRestartCondition);
    }
    /**
     * If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as
     * failed. The value is in seconds.
     * 
     */
    @Export(name="haVmFailureInterval", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haVmFailureInterval;

    /**
     * @return If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as
     * failed. The value is in seconds.
     * 
     */
    public Output<Optional<Integer>> haVmFailureInterval() {
        return Codegen.optional(this.haVmFailureInterval);
    }
    /**
     * The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are
     * attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset
     * time is allotted.
     * 
     */
    @Export(name="haVmMaximumFailureWindow", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haVmMaximumFailureWindow;

    /**
     * @return The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are
     * attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset
     * time is allotted.
     * 
     */
    public Output<Optional<Integer>> haVmMaximumFailureWindow() {
        return Codegen.optional(this.haVmMaximumFailureWindow);
    }
    /**
     * The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     * 
     */
    @Export(name="haVmMaximumResets", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haVmMaximumResets;

    /**
     * @return The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     * 
     */
    public Output<Optional<Integer>> haVmMaximumResets() {
        return Codegen.optional(this.haVmMaximumResets);
    }
    /**
     * The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     * 
     */
    @Export(name="haVmMinimumUptime", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haVmMinimumUptime;

    /**
     * @return The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     * 
     */
    public Output<Optional<Integer>> haVmMinimumUptime() {
        return Codegen.optional(this.haVmMinimumUptime);
    }
    /**
     * The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,
     * vmMonitoringOnly, or vmAndAppMonitoring.
     * 
     */
    @Export(name="haVmMonitoring", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haVmMonitoring;

    /**
     * @return The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,
     * vmMonitoringOnly, or vmAndAppMonitoring.
     * 
     */
    public Output<Optional<String>> haVmMonitoring() {
        return Codegen.optional(this.haVmMonitoring);
    }
    /**
     * Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     * 
     */
    @Export(name="haVmRestartAdditionalDelay", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haVmRestartAdditionalDelay;

    /**
     * @return Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     * 
     */
    public Output<Optional<Integer>> haVmRestartAdditionalDelay() {
        return Codegen.optional(this.haVmRestartAdditionalDelay);
    }
    /**
     * The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,
     * high, or highest.
     * 
     */
    @Export(name="haVmRestartPriority", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> haVmRestartPriority;

    /**
     * @return The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,
     * high, or highest.
     * 
     */
    public Output<Optional<String>> haVmRestartPriority() {
        return Codegen.optional(this.haVmRestartPriority);
    }
    /**
     * The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before
     * proceeding with the next priority.
     * 
     */
    @Export(name="haVmRestartTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> haVmRestartTimeout;

    /**
     * @return The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before
     * proceeding with the next priority.
     * 
     */
    public Output<Optional<Integer>> haVmRestartTimeout() {
        return Codegen.optional(this.haVmRestartTimeout);
    }
    /**
     * The timeout for each host maintenance mode operation when removing hosts from a cluster.
     * 
     */
    @Export(name="hostClusterExitTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> hostClusterExitTimeout;

    /**
     * @return The timeout for each host maintenance mode operation when removing hosts from a cluster.
     * 
     */
    public Output<Optional<Integer>> hostClusterExitTimeout() {
        return Codegen.optional(this.hostClusterExitTimeout);
    }
    /**
     * Must be set if cluster enrollment is managed from host resource.
     * 
     */
    @Export(name="hostManaged", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> hostManaged;

    /**
     * @return Must be set if cluster enrollment is managed from host resource.
     * 
     */
    public Output<Optional<Boolean>> hostManaged() {
        return Codegen.optional(this.hostManaged);
    }
    /**
     * The managed object IDs of the hosts to put in the cluster.
     * 
     */
    @Export(name="hostSystemIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> hostSystemIds;

    /**
     * @return The managed object IDs of the hosts to put in the cluster.
     * 
     */
    public Output<Optional<List<String>>> hostSystemIds() {
        return Codegen.optional(this.hostSystemIds);
    }
    /**
     * The name of the cluster.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the cluster.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     * 
     */
    @Export(name="proactiveHaAutomationLevel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> proactiveHaAutomationLevel;

    /**
     * @return The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     * 
     */
    public Output<Optional<String>> proactiveHaAutomationLevel() {
        return Codegen.optional(this.proactiveHaAutomationLevel);
    }
    /**
     * Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     * 
     */
    @Export(name="proactiveHaEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> proactiveHaEnabled;

    /**
     * @return Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     * 
     */
    public Output<Optional<Boolean>> proactiveHaEnabled() {
        return Codegen.optional(this.proactiveHaEnabled);
    }
    /**
     * The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that
     * this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.
     * 
     */
    @Export(name="proactiveHaModerateRemediation", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> proactiveHaModerateRemediation;

    /**
     * @return The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that
     * this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.
     * 
     */
    public Output<Optional<String>> proactiveHaModerateRemediation() {
        return Codegen.optional(this.proactiveHaModerateRemediation);
    }
    /**
     * The list of IDs for health update providers configured for this cluster.
     * 
     */
    @Export(name="proactiveHaProviderIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> proactiveHaProviderIds;

    /**
     * @return The list of IDs for health update providers configured for this cluster.
     * 
     */
    public Output<Optional<List<String>>> proactiveHaProviderIds() {
        return Codegen.optional(this.proactiveHaProviderIds);
    }
    /**
     * The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this
     * cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.
     * 
     */
    @Export(name="proactiveHaSevereRemediation", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> proactiveHaSevereRemediation;

    /**
     * @return The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this
     * cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.
     * 
     */
    public Output<Optional<String>> proactiveHaSevereRemediation() {
        return Codegen.optional(this.proactiveHaSevereRemediation);
    }
    /**
     * The managed object ID of the primary
     * resource pool for this cluster. This can be passed directly to the
     * `resource_pool_id`
     * attribute of the
     * `vsphere.VirtualMachine` resource.
     * 
     */
    @Export(name="resourcePoolId", refs={String.class}, tree="[0]")
    private Output<String> resourcePoolId;

    /**
     * @return The managed object ID of the primary
     * resource pool for this cluster. This can be passed directly to the
     * `resource_pool_id`
     * attribute of the
     * `vsphere.VirtualMachine` resource.
     * 
     */
    public Output<String> resourcePoolId() {
        return this.resourcePoolId;
    }
    /**
     * The IDs of any tags to attach to this resource.
     * 
     */
    @Export(name="tags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return The IDs of any tags to attach to this resource.
     * 
     */
    public Output<Optional<List<String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * Whether the vSAN compression service is enabled for the cluster.
     * 
     */
    @Export(name="vsanCompressionEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vsanCompressionEnabled;

    /**
     * @return Whether the vSAN compression service is enabled for the cluster.
     * 
     */
    public Output<Optional<Boolean>> vsanCompressionEnabled() {
        return Codegen.optional(this.vsanCompressionEnabled);
    }
    /**
     * Whether the vSAN deduplication service is enabled for the cluster.
     * 
     */
    @Export(name="vsanDedupEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vsanDedupEnabled;

    /**
     * @return Whether the vSAN deduplication service is enabled for the cluster.
     * 
     */
    public Output<Optional<Boolean>> vsanDedupEnabled() {
        return Codegen.optional(this.vsanDedupEnabled);
    }
    /**
     * A list of disk UUIDs to add to the vSAN cluster.
     * 
     */
    @Export(name="vsanDiskGroups", refs={List.class,ComputeClusterVsanDiskGroup.class}, tree="[0,1]")
    private Output<List<ComputeClusterVsanDiskGroup>> vsanDiskGroups;

    /**
     * @return A list of disk UUIDs to add to the vSAN cluster.
     * 
     */
    public Output<List<ComputeClusterVsanDiskGroup>> vsanDiskGroups() {
        return this.vsanDiskGroups;
    }
    /**
     * Whether the vSAN data-in-transit encryption is enabled for the cluster.
     * 
     */
    @Export(name="vsanDitEncryptionEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vsanDitEncryptionEnabled;

    /**
     * @return Whether the vSAN data-in-transit encryption is enabled for the cluster.
     * 
     */
    public Output<Optional<Boolean>> vsanDitEncryptionEnabled() {
        return Codegen.optional(this.vsanDitEncryptionEnabled);
    }
    /**
     * When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     * 
     */
    @Export(name="vsanDitRekeyInterval", refs={Integer.class}, tree="[0]")
    private Output<Integer> vsanDitRekeyInterval;

    /**
     * @return When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     * 
     */
    public Output<Integer> vsanDitRekeyInterval() {
        return this.vsanDitRekeyInterval;
    }
    /**
     * Whether the vSAN service is enabled for the cluster.
     * 
     */
    @Export(name="vsanEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vsanEnabled;

    /**
     * @return Whether the vSAN service is enabled for the cluster.
     * 
     */
    public Output<Optional<Boolean>> vsanEnabled() {
        return Codegen.optional(this.vsanEnabled);
    }
    /**
     * Whether the vSAN ESA service is enabled for the cluster.
     * 
     */
    @Export(name="vsanEsaEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vsanEsaEnabled;

    /**
     * @return Whether the vSAN ESA service is enabled for the cluster.
     * 
     */
    public Output<Optional<Boolean>> vsanEsaEnabled() {
        return Codegen.optional(this.vsanEsaEnabled);
    }
    /**
     * The configuration for vSAN fault domains.
     * 
     */
    @Export(name="vsanFaultDomains", refs={List.class,ComputeClusterVsanFaultDomain.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ComputeClusterVsanFaultDomain>> vsanFaultDomains;

    /**
     * @return The configuration for vSAN fault domains.
     * 
     */
    public Output<Optional<List<ComputeClusterVsanFaultDomain>>> vsanFaultDomains() {
        return Codegen.optional(this.vsanFaultDomains);
    }
    /**
     * Whether the vSAN network diagnostic mode is enabled for the cluster.
     * 
     */
    @Export(name="vsanNetworkDiagnosticModeEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vsanNetworkDiagnosticModeEnabled;

    /**
     * @return Whether the vSAN network diagnostic mode is enabled for the cluster.
     * 
     */
    public Output<Optional<Boolean>> vsanNetworkDiagnosticModeEnabled() {
        return Codegen.optional(this.vsanNetworkDiagnosticModeEnabled);
    }
    /**
     * Whether the vSAN performance service is enabled for the cluster.
     * 
     */
    @Export(name="vsanPerformanceEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vsanPerformanceEnabled;

    /**
     * @return Whether the vSAN performance service is enabled for the cluster.
     * 
     */
    public Output<Optional<Boolean>> vsanPerformanceEnabled() {
        return Codegen.optional(this.vsanPerformanceEnabled);
    }
    /**
     * The managed object IDs of the vSAN datastore to be mounted on the cluster.
     * 
     */
    @Export(name="vsanRemoteDatastoreIds", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> vsanRemoteDatastoreIds;

    /**
     * @return The managed object IDs of the vSAN datastore to be mounted on the cluster.
     * 
     */
    public Output<Optional<List<String>>> vsanRemoteDatastoreIds() {
        return Codegen.optional(this.vsanRemoteDatastoreIds);
    }
    /**
     * The configuration for stretched cluster.
     * 
     */
    @Export(name="vsanStretchedCluster", refs={ComputeClusterVsanStretchedCluster.class}, tree="[0]")
    private Output</* @Nullable */ ComputeClusterVsanStretchedCluster> vsanStretchedCluster;

    /**
     * @return The configuration for stretched cluster.
     * 
     */
    public Output<Optional<ComputeClusterVsanStretchedCluster>> vsanStretchedCluster() {
        return Codegen.optional(this.vsanStretchedCluster);
    }
    /**
     * Whether the vSAN unmap service is enabled for the cluster.
     * 
     */
    @Export(name="vsanUnmapEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vsanUnmapEnabled;

    /**
     * @return Whether the vSAN unmap service is enabled for the cluster.
     * 
     */
    public Output<Optional<Boolean>> vsanUnmapEnabled() {
        return Codegen.optional(this.vsanUnmapEnabled);
    }
    /**
     * Whether the vSAN verbose mode is enabled for the cluster.
     * 
     */
    @Export(name="vsanVerboseModeEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> vsanVerboseModeEnabled;

    /**
     * @return Whether the vSAN verbose mode is enabled for the cluster.
     * 
     */
    public Output<Optional<Boolean>> vsanVerboseModeEnabled() {
        return Codegen.optional(this.vsanVerboseModeEnabled);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ComputeCluster(String name) {
        this(name, ComputeClusterArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ComputeCluster(String name, ComputeClusterArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ComputeCluster(String name, ComputeClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/computeCluster:ComputeCluster", name, args == null ? ComputeClusterArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private ComputeCluster(String name, Output<String> id, @Nullable ComputeClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/computeCluster:ComputeCluster", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ComputeCluster get(String name, Output<String> id, @Nullable ComputeClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ComputeCluster(name, id, state, options);
    }
}
