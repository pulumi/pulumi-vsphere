// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class HostVirtualSwitchArgs extends com.pulumi.resources.ResourceArgs {

    public static final HostVirtualSwitchArgs Empty = new HostVirtualSwitchArgs();

    /**
     * The list of active network adapters used for load
     * balancing.
     * 
     */
    @Import(name="activeNics", required=true)
    private Output<List<String>> activeNics;

    /**
     * @return The list of active network adapters used for load
     * balancing.
     * 
     */
    public Output<List<String>> activeNics() {
        return this.activeNics;
    }

    /**
     * Controls whether or not the virtual
     * network adapter is allowed to send network traffic with a different MAC
     * address than that of its own. Default: `true`.
     * 
     */
    @Import(name="allowForgedTransmits")
    private @Nullable Output<Boolean> allowForgedTransmits;

    /**
     * @return Controls whether or not the virtual
     * network adapter is allowed to send network traffic with a different MAC
     * address than that of its own. Default: `true`.
     * 
     */
    public Optional<Output<Boolean>> allowForgedTransmits() {
        return Optional.ofNullable(this.allowForgedTransmits);
    }

    /**
     * Controls whether or not the Media Access
     * Control (MAC) address can be changed. Default: `true`.
     * 
     */
    @Import(name="allowMacChanges")
    private @Nullable Output<Boolean> allowMacChanges;

    /**
     * @return Controls whether or not the Media Access
     * Control (MAC) address can be changed. Default: `true`.
     * 
     */
    public Optional<Output<Boolean>> allowMacChanges() {
        return Optional.ofNullable(this.allowMacChanges);
    }

    /**
     * Enable promiscuous mode on the network. This
     * flag indicates whether or not all traffic is seen on a given port. Default:
     * `false`.
     * 
     */
    @Import(name="allowPromiscuous")
    private @Nullable Output<Boolean> allowPromiscuous;

    /**
     * @return Enable promiscuous mode on the network. This
     * flag indicates whether or not all traffic is seen on a given port. Default:
     * `false`.
     * 
     */
    public Optional<Output<Boolean>> allowPromiscuous() {
        return Optional.ofNullable(this.allowPromiscuous);
    }

    /**
     * The interval, in seconds, that a NIC beacon
     * packet is sent out. This can be used with `check_beacon` to
     * offer link failure capability beyond link status only. Default: `1`.
     * 
     */
    @Import(name="beaconInterval")
    private @Nullable Output<Integer> beaconInterval;

    /**
     * @return The interval, in seconds, that a NIC beacon
     * packet is sent out. This can be used with `check_beacon` to
     * offer link failure capability beyond link status only. Default: `1`.
     * 
     */
    public Optional<Output<Integer>> beaconInterval() {
        return Optional.ofNullable(this.beaconInterval);
    }

    /**
     * Enable beacon probing - this requires that the
     * `beacon_interval` option has been set in the bridge
     * options. If this is set to `false`, only link status is used to check for
     * failed NICs.  Default: `false`.
     * 
     */
    @Import(name="checkBeacon")
    private @Nullable Output<Boolean> checkBeacon;

    /**
     * @return Enable beacon probing - this requires that the
     * `beacon_interval` option has been set in the bridge
     * options. If this is set to `false`, only link status is used to check for
     * failed NICs.  Default: `false`.
     * 
     */
    public Optional<Output<Boolean>> checkBeacon() {
        return Optional.ofNullable(this.checkBeacon);
    }

    /**
     * If set to `true`, the teaming policy will re-activate
     * failed interfaces higher in precedence when they come back up.  Default:
     * `true`.
     * 
     */
    @Import(name="failback")
    private @Nullable Output<Boolean> failback;

    /**
     * @return If set to `true`, the teaming policy will re-activate
     * failed interfaces higher in precedence when they come back up.  Default:
     * `true`.
     * 
     */
    public Optional<Output<Boolean>> failback() {
        return Optional.ofNullable(this.failback);
    }

    /**
     * The managed object ID of
     * the host to set the virtual switch up on. Forces a new resource if changed.
     * 
     */
    @Import(name="hostSystemId", required=true)
    private Output<String> hostSystemId;

    /**
     * @return The managed object ID of
     * the host to set the virtual switch up on. Forces a new resource if changed.
     * 
     */
    public Output<String> hostSystemId() {
        return this.hostSystemId;
    }

    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic. Default: `listen`.
     * 
     */
    @Import(name="linkDiscoveryOperation")
    private @Nullable Output<String> linkDiscoveryOperation;

    /**
     * @return Whether to `advertise` or `listen`
     * for link discovery traffic. Default: `listen`.
     * 
     */
    public Optional<Output<String>> linkDiscoveryOperation() {
        return Optional.ofNullable(this.linkDiscoveryOperation);
    }

    /**
     * The discovery protocol type.  Valid
     * types are `cpd` and `lldp`. Default: `cdp`.
     * 
     */
    @Import(name="linkDiscoveryProtocol")
    private @Nullable Output<String> linkDiscoveryProtocol;

    /**
     * @return The discovery protocol type.  Valid
     * types are `cpd` and `lldp`. Default: `cdp`.
     * 
     */
    public Optional<Output<String>> linkDiscoveryProtocol() {
        return Optional.ofNullable(this.linkDiscoveryProtocol);
    }

    /**
     * The maximum transmission unit (MTU) for the virtual
     * switch. Default: `1500`.
     * 
     */
    @Import(name="mtu")
    private @Nullable Output<Integer> mtu;

    /**
     * @return The maximum transmission unit (MTU) for the virtual
     * switch. Default: `1500`.
     * 
     */
    public Optional<Output<Integer>> mtu() {
        return Optional.ofNullable(this.mtu);
    }

    /**
     * The name of the virtual switch. Forces a new resource if
     * changed.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the virtual switch. Forces a new resource if
     * changed.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The network interfaces to bind to the bridge.
     * 
     */
    @Import(name="networkAdapters", required=true)
    private Output<List<String>> networkAdapters;

    /**
     * @return The network interfaces to bind to the bridge.
     * 
     */
    public Output<List<String>> networkAdapters() {
        return this.networkAdapters;
    }

    /**
     * If set to `true`, the teaming policy will
     * notify the broadcast network of a NIC failover, triggering cache updates.
     * Default: `true`.
     * 
     */
    @Import(name="notifySwitches")
    private @Nullable Output<Boolean> notifySwitches;

    /**
     * @return If set to `true`, the teaming policy will
     * notify the broadcast network of a NIC failover, triggering cache updates.
     * Default: `true`.
     * 
     */
    public Optional<Output<Boolean>> notifySwitches() {
        return Optional.ofNullable(this.notifySwitches);
    }

    /**
     * The number of ports to create with this
     * virtual switch. Default: `128`.
     * 
     * &gt; **NOTE:** Changing the port count requires a reboot of the host. This provider
     * will not restart the host for you.
     * 
     */
    @Import(name="numberOfPorts")
    private @Nullable Output<Integer> numberOfPorts;

    /**
     * @return The number of ports to create with this
     * virtual switch. Default: `128`.
     * 
     * &gt; **NOTE:** Changing the port count requires a reboot of the host. This provider
     * will not restart the host for you.
     * 
     */
    public Optional<Output<Integer>> numberOfPorts() {
        return Optional.ofNullable(this.numberOfPorts);
    }

    /**
     * The average bandwidth in bits per
     * second if traffic shaping is enabled. Default: `0`
     * 
     */
    @Import(name="shapingAverageBandwidth")
    private @Nullable Output<Integer> shapingAverageBandwidth;

    /**
     * @return The average bandwidth in bits per
     * second if traffic shaping is enabled. Default: `0`
     * 
     */
    public Optional<Output<Integer>> shapingAverageBandwidth() {
        return Optional.ofNullable(this.shapingAverageBandwidth);
    }

    /**
     * The maximum burst size allowed in bytes if
     * shaping is enabled. Default: `0`
     * 
     */
    @Import(name="shapingBurstSize")
    private @Nullable Output<Integer> shapingBurstSize;

    /**
     * @return The maximum burst size allowed in bytes if
     * shaping is enabled. Default: `0`
     * 
     */
    public Optional<Output<Integer>> shapingBurstSize() {
        return Optional.ofNullable(this.shapingBurstSize);
    }

    /**
     * Set to `true` to enable the traffic shaper for
     * ports managed by this virtual switch. Default: `false`.
     * 
     */
    @Import(name="shapingEnabled")
    private @Nullable Output<Boolean> shapingEnabled;

    /**
     * @return Set to `true` to enable the traffic shaper for
     * ports managed by this virtual switch. Default: `false`.
     * 
     */
    public Optional<Output<Boolean>> shapingEnabled() {
        return Optional.ofNullable(this.shapingEnabled);
    }

    /**
     * The peak bandwidth during bursts in
     * bits per second if traffic shaping is enabled. Default: `0`
     * 
     */
    @Import(name="shapingPeakBandwidth")
    private @Nullable Output<Integer> shapingPeakBandwidth;

    /**
     * @return The peak bandwidth during bursts in
     * bits per second if traffic shaping is enabled. Default: `0`
     * 
     */
    public Optional<Output<Integer>> shapingPeakBandwidth() {
        return Optional.ofNullable(this.shapingPeakBandwidth);
    }

    /**
     * The list of standby network adapters used for
     * failover.
     * 
     */
    @Import(name="standbyNics")
    private @Nullable Output<List<String>> standbyNics;

    /**
     * @return The list of standby network adapters used for
     * failover.
     * 
     */
    public Optional<Output<List<String>>> standbyNics() {
        return Optional.ofNullable(this.standbyNics);
    }

    /**
     * The network adapter teaming policy. Can be one
     * of `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
     * `failover_explicit`. Default: `loadbalance_srcid`.
     * 
     */
    @Import(name="teamingPolicy")
    private @Nullable Output<String> teamingPolicy;

    /**
     * @return The network adapter teaming policy. Can be one
     * of `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
     * `failover_explicit`. Default: `loadbalance_srcid`.
     * 
     */
    public Optional<Output<String>> teamingPolicy() {
        return Optional.ofNullable(this.teamingPolicy);
    }

    private HostVirtualSwitchArgs() {}

    private HostVirtualSwitchArgs(HostVirtualSwitchArgs $) {
        this.activeNics = $.activeNics;
        this.allowForgedTransmits = $.allowForgedTransmits;
        this.allowMacChanges = $.allowMacChanges;
        this.allowPromiscuous = $.allowPromiscuous;
        this.beaconInterval = $.beaconInterval;
        this.checkBeacon = $.checkBeacon;
        this.failback = $.failback;
        this.hostSystemId = $.hostSystemId;
        this.linkDiscoveryOperation = $.linkDiscoveryOperation;
        this.linkDiscoveryProtocol = $.linkDiscoveryProtocol;
        this.mtu = $.mtu;
        this.name = $.name;
        this.networkAdapters = $.networkAdapters;
        this.notifySwitches = $.notifySwitches;
        this.numberOfPorts = $.numberOfPorts;
        this.shapingAverageBandwidth = $.shapingAverageBandwidth;
        this.shapingBurstSize = $.shapingBurstSize;
        this.shapingEnabled = $.shapingEnabled;
        this.shapingPeakBandwidth = $.shapingPeakBandwidth;
        this.standbyNics = $.standbyNics;
        this.teamingPolicy = $.teamingPolicy;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(HostVirtualSwitchArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private HostVirtualSwitchArgs $;

        public Builder() {
            $ = new HostVirtualSwitchArgs();
        }

        public Builder(HostVirtualSwitchArgs defaults) {
            $ = new HostVirtualSwitchArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param activeNics The list of active network adapters used for load
         * balancing.
         * 
         * @return builder
         * 
         */
        public Builder activeNics(Output<List<String>> activeNics) {
            $.activeNics = activeNics;
            return this;
        }

        /**
         * @param activeNics The list of active network adapters used for load
         * balancing.
         * 
         * @return builder
         * 
         */
        public Builder activeNics(List<String> activeNics) {
            return activeNics(Output.of(activeNics));
        }

        /**
         * @param activeNics The list of active network adapters used for load
         * balancing.
         * 
         * @return builder
         * 
         */
        public Builder activeNics(String... activeNics) {
            return activeNics(List.of(activeNics));
        }

        /**
         * @param allowForgedTransmits Controls whether or not the virtual
         * network adapter is allowed to send network traffic with a different MAC
         * address than that of its own. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder allowForgedTransmits(@Nullable Output<Boolean> allowForgedTransmits) {
            $.allowForgedTransmits = allowForgedTransmits;
            return this;
        }

        /**
         * @param allowForgedTransmits Controls whether or not the virtual
         * network adapter is allowed to send network traffic with a different MAC
         * address than that of its own. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder allowForgedTransmits(Boolean allowForgedTransmits) {
            return allowForgedTransmits(Output.of(allowForgedTransmits));
        }

        /**
         * @param allowMacChanges Controls whether or not the Media Access
         * Control (MAC) address can be changed. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder allowMacChanges(@Nullable Output<Boolean> allowMacChanges) {
            $.allowMacChanges = allowMacChanges;
            return this;
        }

        /**
         * @param allowMacChanges Controls whether or not the Media Access
         * Control (MAC) address can be changed. Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder allowMacChanges(Boolean allowMacChanges) {
            return allowMacChanges(Output.of(allowMacChanges));
        }

        /**
         * @param allowPromiscuous Enable promiscuous mode on the network. This
         * flag indicates whether or not all traffic is seen on a given port. Default:
         * `false`.
         * 
         * @return builder
         * 
         */
        public Builder allowPromiscuous(@Nullable Output<Boolean> allowPromiscuous) {
            $.allowPromiscuous = allowPromiscuous;
            return this;
        }

        /**
         * @param allowPromiscuous Enable promiscuous mode on the network. This
         * flag indicates whether or not all traffic is seen on a given port. Default:
         * `false`.
         * 
         * @return builder
         * 
         */
        public Builder allowPromiscuous(Boolean allowPromiscuous) {
            return allowPromiscuous(Output.of(allowPromiscuous));
        }

        /**
         * @param beaconInterval The interval, in seconds, that a NIC beacon
         * packet is sent out. This can be used with `check_beacon` to
         * offer link failure capability beyond link status only. Default: `1`.
         * 
         * @return builder
         * 
         */
        public Builder beaconInterval(@Nullable Output<Integer> beaconInterval) {
            $.beaconInterval = beaconInterval;
            return this;
        }

        /**
         * @param beaconInterval The interval, in seconds, that a NIC beacon
         * packet is sent out. This can be used with `check_beacon` to
         * offer link failure capability beyond link status only. Default: `1`.
         * 
         * @return builder
         * 
         */
        public Builder beaconInterval(Integer beaconInterval) {
            return beaconInterval(Output.of(beaconInterval));
        }

        /**
         * @param checkBeacon Enable beacon probing - this requires that the
         * `beacon_interval` option has been set in the bridge
         * options. If this is set to `false`, only link status is used to check for
         * failed NICs.  Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder checkBeacon(@Nullable Output<Boolean> checkBeacon) {
            $.checkBeacon = checkBeacon;
            return this;
        }

        /**
         * @param checkBeacon Enable beacon probing - this requires that the
         * `beacon_interval` option has been set in the bridge
         * options. If this is set to `false`, only link status is used to check for
         * failed NICs.  Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder checkBeacon(Boolean checkBeacon) {
            return checkBeacon(Output.of(checkBeacon));
        }

        /**
         * @param failback If set to `true`, the teaming policy will re-activate
         * failed interfaces higher in precedence when they come back up.  Default:
         * `true`.
         * 
         * @return builder
         * 
         */
        public Builder failback(@Nullable Output<Boolean> failback) {
            $.failback = failback;
            return this;
        }

        /**
         * @param failback If set to `true`, the teaming policy will re-activate
         * failed interfaces higher in precedence when they come back up.  Default:
         * `true`.
         * 
         * @return builder
         * 
         */
        public Builder failback(Boolean failback) {
            return failback(Output.of(failback));
        }

        /**
         * @param hostSystemId The managed object ID of
         * the host to set the virtual switch up on. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemId(Output<String> hostSystemId) {
            $.hostSystemId = hostSystemId;
            return this;
        }

        /**
         * @param hostSystemId The managed object ID of
         * the host to set the virtual switch up on. Forces a new resource if changed.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemId(String hostSystemId) {
            return hostSystemId(Output.of(hostSystemId));
        }

        /**
         * @param linkDiscoveryOperation Whether to `advertise` or `listen`
         * for link discovery traffic. Default: `listen`.
         * 
         * @return builder
         * 
         */
        public Builder linkDiscoveryOperation(@Nullable Output<String> linkDiscoveryOperation) {
            $.linkDiscoveryOperation = linkDiscoveryOperation;
            return this;
        }

        /**
         * @param linkDiscoveryOperation Whether to `advertise` or `listen`
         * for link discovery traffic. Default: `listen`.
         * 
         * @return builder
         * 
         */
        public Builder linkDiscoveryOperation(String linkDiscoveryOperation) {
            return linkDiscoveryOperation(Output.of(linkDiscoveryOperation));
        }

        /**
         * @param linkDiscoveryProtocol The discovery protocol type.  Valid
         * types are `cpd` and `lldp`. Default: `cdp`.
         * 
         * @return builder
         * 
         */
        public Builder linkDiscoveryProtocol(@Nullable Output<String> linkDiscoveryProtocol) {
            $.linkDiscoveryProtocol = linkDiscoveryProtocol;
            return this;
        }

        /**
         * @param linkDiscoveryProtocol The discovery protocol type.  Valid
         * types are `cpd` and `lldp`. Default: `cdp`.
         * 
         * @return builder
         * 
         */
        public Builder linkDiscoveryProtocol(String linkDiscoveryProtocol) {
            return linkDiscoveryProtocol(Output.of(linkDiscoveryProtocol));
        }

        /**
         * @param mtu The maximum transmission unit (MTU) for the virtual
         * switch. Default: `1500`.
         * 
         * @return builder
         * 
         */
        public Builder mtu(@Nullable Output<Integer> mtu) {
            $.mtu = mtu;
            return this;
        }

        /**
         * @param mtu The maximum transmission unit (MTU) for the virtual
         * switch. Default: `1500`.
         * 
         * @return builder
         * 
         */
        public Builder mtu(Integer mtu) {
            return mtu(Output.of(mtu));
        }

        /**
         * @param name The name of the virtual switch. Forces a new resource if
         * changed.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the virtual switch. Forces a new resource if
         * changed.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param networkAdapters The network interfaces to bind to the bridge.
         * 
         * @return builder
         * 
         */
        public Builder networkAdapters(Output<List<String>> networkAdapters) {
            $.networkAdapters = networkAdapters;
            return this;
        }

        /**
         * @param networkAdapters The network interfaces to bind to the bridge.
         * 
         * @return builder
         * 
         */
        public Builder networkAdapters(List<String> networkAdapters) {
            return networkAdapters(Output.of(networkAdapters));
        }

        /**
         * @param networkAdapters The network interfaces to bind to the bridge.
         * 
         * @return builder
         * 
         */
        public Builder networkAdapters(String... networkAdapters) {
            return networkAdapters(List.of(networkAdapters));
        }

        /**
         * @param notifySwitches If set to `true`, the teaming policy will
         * notify the broadcast network of a NIC failover, triggering cache updates.
         * Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder notifySwitches(@Nullable Output<Boolean> notifySwitches) {
            $.notifySwitches = notifySwitches;
            return this;
        }

        /**
         * @param notifySwitches If set to `true`, the teaming policy will
         * notify the broadcast network of a NIC failover, triggering cache updates.
         * Default: `true`.
         * 
         * @return builder
         * 
         */
        public Builder notifySwitches(Boolean notifySwitches) {
            return notifySwitches(Output.of(notifySwitches));
        }

        /**
         * @param numberOfPorts The number of ports to create with this
         * virtual switch. Default: `128`.
         * 
         * &gt; **NOTE:** Changing the port count requires a reboot of the host. This provider
         * will not restart the host for you.
         * 
         * @return builder
         * 
         */
        public Builder numberOfPorts(@Nullable Output<Integer> numberOfPorts) {
            $.numberOfPorts = numberOfPorts;
            return this;
        }

        /**
         * @param numberOfPorts The number of ports to create with this
         * virtual switch. Default: `128`.
         * 
         * &gt; **NOTE:** Changing the port count requires a reboot of the host. This provider
         * will not restart the host for you.
         * 
         * @return builder
         * 
         */
        public Builder numberOfPorts(Integer numberOfPorts) {
            return numberOfPorts(Output.of(numberOfPorts));
        }

        /**
         * @param shapingAverageBandwidth The average bandwidth in bits per
         * second if traffic shaping is enabled. Default: `0`
         * 
         * @return builder
         * 
         */
        public Builder shapingAverageBandwidth(@Nullable Output<Integer> shapingAverageBandwidth) {
            $.shapingAverageBandwidth = shapingAverageBandwidth;
            return this;
        }

        /**
         * @param shapingAverageBandwidth The average bandwidth in bits per
         * second if traffic shaping is enabled. Default: `0`
         * 
         * @return builder
         * 
         */
        public Builder shapingAverageBandwidth(Integer shapingAverageBandwidth) {
            return shapingAverageBandwidth(Output.of(shapingAverageBandwidth));
        }

        /**
         * @param shapingBurstSize The maximum burst size allowed in bytes if
         * shaping is enabled. Default: `0`
         * 
         * @return builder
         * 
         */
        public Builder shapingBurstSize(@Nullable Output<Integer> shapingBurstSize) {
            $.shapingBurstSize = shapingBurstSize;
            return this;
        }

        /**
         * @param shapingBurstSize The maximum burst size allowed in bytes if
         * shaping is enabled. Default: `0`
         * 
         * @return builder
         * 
         */
        public Builder shapingBurstSize(Integer shapingBurstSize) {
            return shapingBurstSize(Output.of(shapingBurstSize));
        }

        /**
         * @param shapingEnabled Set to `true` to enable the traffic shaper for
         * ports managed by this virtual switch. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder shapingEnabled(@Nullable Output<Boolean> shapingEnabled) {
            $.shapingEnabled = shapingEnabled;
            return this;
        }

        /**
         * @param shapingEnabled Set to `true` to enable the traffic shaper for
         * ports managed by this virtual switch. Default: `false`.
         * 
         * @return builder
         * 
         */
        public Builder shapingEnabled(Boolean shapingEnabled) {
            return shapingEnabled(Output.of(shapingEnabled));
        }

        /**
         * @param shapingPeakBandwidth The peak bandwidth during bursts in
         * bits per second if traffic shaping is enabled. Default: `0`
         * 
         * @return builder
         * 
         */
        public Builder shapingPeakBandwidth(@Nullable Output<Integer> shapingPeakBandwidth) {
            $.shapingPeakBandwidth = shapingPeakBandwidth;
            return this;
        }

        /**
         * @param shapingPeakBandwidth The peak bandwidth during bursts in
         * bits per second if traffic shaping is enabled. Default: `0`
         * 
         * @return builder
         * 
         */
        public Builder shapingPeakBandwidth(Integer shapingPeakBandwidth) {
            return shapingPeakBandwidth(Output.of(shapingPeakBandwidth));
        }

        /**
         * @param standbyNics The list of standby network adapters used for
         * failover.
         * 
         * @return builder
         * 
         */
        public Builder standbyNics(@Nullable Output<List<String>> standbyNics) {
            $.standbyNics = standbyNics;
            return this;
        }

        /**
         * @param standbyNics The list of standby network adapters used for
         * failover.
         * 
         * @return builder
         * 
         */
        public Builder standbyNics(List<String> standbyNics) {
            return standbyNics(Output.of(standbyNics));
        }

        /**
         * @param standbyNics The list of standby network adapters used for
         * failover.
         * 
         * @return builder
         * 
         */
        public Builder standbyNics(String... standbyNics) {
            return standbyNics(List.of(standbyNics));
        }

        /**
         * @param teamingPolicy The network adapter teaming policy. Can be one
         * of `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
         * `failover_explicit`. Default: `loadbalance_srcid`.
         * 
         * @return builder
         * 
         */
        public Builder teamingPolicy(@Nullable Output<String> teamingPolicy) {
            $.teamingPolicy = teamingPolicy;
            return this;
        }

        /**
         * @param teamingPolicy The network adapter teaming policy. Can be one
         * of `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
         * `failover_explicit`. Default: `loadbalance_srcid`.
         * 
         * @return builder
         * 
         */
        public Builder teamingPolicy(String teamingPolicy) {
            return teamingPolicy(Output.of(teamingPolicy));
        }

        public HostVirtualSwitchArgs build() {
            $.activeNics = Objects.requireNonNull($.activeNics, "expected parameter 'activeNics' to be non-null");
            $.hostSystemId = Objects.requireNonNull($.hostSystemId, "expected parameter 'hostSystemId' to be non-null");
            $.networkAdapters = Objects.requireNonNull($.networkAdapters, "expected parameter 'networkAdapters' to be non-null");
            return $;
        }
    }

}
