// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.vsphere.inputs.VirtualMachineCdromArgs;
import com.pulumi.vsphere.inputs.VirtualMachineCloneArgs;
import com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;
import com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;
import com.pulumi.vsphere.inputs.VirtualMachineOvfDeployArgs;
import com.pulumi.vsphere.inputs.VirtualMachineVappArgs;
import com.pulumi.vsphere.inputs.VirtualMachineVtpmArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class VirtualMachineArgs extends com.pulumi.resources.ResourceArgs {

    public static final VirtualMachineArgs Empty = new VirtualMachineArgs();

    /**
     * The guest name for the operating system when guest_id is otherGuest or otherGuest64.
     * 
     */
    @Import(name="alternateGuestName")
    private @Nullable Output<String> alternateGuestName;

    /**
     * @return The guest name for the operating system when guest_id is otherGuest or otherGuest64.
     * 
     */
    public Optional<Output<String>> alternateGuestName() {
        return Optional.ofNullable(this.alternateGuestName);
    }

    /**
     * User-provided description of the virtual machine.
     * 
     */
    @Import(name="annotation")
    private @Nullable Output<String> annotation;

    /**
     * @return User-provided description of the virtual machine.
     * 
     */
    public Optional<Output<String>> annotation() {
        return Optional.ofNullable(this.annotation);
    }

    /**
     * The number of milliseconds to wait before starting the boot sequence.
     * 
     */
    @Import(name="bootDelay")
    private @Nullable Output<Integer> bootDelay;

    /**
     * @return The number of milliseconds to wait before starting the boot sequence.
     * 
     */
    public Optional<Output<Integer>> bootDelay() {
        return Optional.ofNullable(this.bootDelay);
    }

    /**
     * The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.
     * 
     */
    @Import(name="bootRetryDelay")
    private @Nullable Output<Integer> bootRetryDelay;

    /**
     * @return The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.
     * 
     */
    public Optional<Output<Integer>> bootRetryDelay() {
        return Optional.ofNullable(this.bootRetryDelay);
    }

    /**
     * If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
     * 
     */
    @Import(name="bootRetryEnabled")
    private @Nullable Output<Boolean> bootRetryEnabled;

    /**
     * @return If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
     * 
     */
    public Optional<Output<Boolean>> bootRetryEnabled() {
        return Optional.ofNullable(this.bootRetryEnabled);
    }

    /**
     * A specification for a CDROM device on this virtual machine.
     * 
     */
    @Import(name="cdroms")
    private @Nullable Output<List<VirtualMachineCdromArgs>> cdroms;

    /**
     * @return A specification for a CDROM device on this virtual machine.
     * 
     */
    public Optional<Output<List<VirtualMachineCdromArgs>>> cdroms() {
        return Optional.ofNullable(this.cdroms);
    }

    /**
     * A specification for cloning a virtual machine from template.
     * 
     */
    @Import(name="clone")
    private @Nullable Output<VirtualMachineCloneArgs> clone;

    /**
     * @return A specification for cloning a virtual machine from template.
     * 
     */
    public Optional<Output<VirtualMachineCloneArgs>> clone_() {
        return Optional.ofNullable(this.clone);
    }

    /**
     * Allow CPUs to be added to this virtual machine while it is running.
     * 
     */
    @Import(name="cpuHotAddEnabled")
    private @Nullable Output<Boolean> cpuHotAddEnabled;

    /**
     * @return Allow CPUs to be added to this virtual machine while it is running.
     * 
     */
    public Optional<Output<Boolean>> cpuHotAddEnabled() {
        return Optional.ofNullable(this.cpuHotAddEnabled);
    }

    /**
     * Allow CPUs to be added to this virtual machine while it is running.
     * 
     */
    @Import(name="cpuHotRemoveEnabled")
    private @Nullable Output<Boolean> cpuHotRemoveEnabled;

    /**
     * @return Allow CPUs to be added to this virtual machine while it is running.
     * 
     */
    public Optional<Output<Boolean>> cpuHotRemoveEnabled() {
        return Optional.ofNullable(this.cpuHotRemoveEnabled);
    }

    /**
     * The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
     * 
     */
    @Import(name="cpuLimit")
    private @Nullable Output<Integer> cpuLimit;

    /**
     * @return The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
     * 
     */
    public Optional<Output<Integer>> cpuLimit() {
        return Optional.ofNullable(this.cpuLimit);
    }

    /**
     * Enable CPU performance counters on this virtual machine.
     * 
     */
    @Import(name="cpuPerformanceCountersEnabled")
    private @Nullable Output<Boolean> cpuPerformanceCountersEnabled;

    /**
     * @return Enable CPU performance counters on this virtual machine.
     * 
     */
    public Optional<Output<Boolean>> cpuPerformanceCountersEnabled() {
        return Optional.ofNullable(this.cpuPerformanceCountersEnabled);
    }

    /**
     * The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
     * 
     */
    @Import(name="cpuReservation")
    private @Nullable Output<Integer> cpuReservation;

    /**
     * @return The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
     * 
     */
    public Optional<Output<Integer>> cpuReservation() {
        return Optional.ofNullable(this.cpuReservation);
    }

    /**
     * The amount of shares to allocate to cpu for a custom share level.
     * 
     */
    @Import(name="cpuShareCount")
    private @Nullable Output<Integer> cpuShareCount;

    /**
     * @return The amount of shares to allocate to cpu for a custom share level.
     * 
     */
    public Optional<Output<Integer>> cpuShareCount() {
        return Optional.ofNullable(this.cpuShareCount);
    }

    /**
     * The allocation level for cpu resources. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="cpuShareLevel")
    private @Nullable Output<String> cpuShareLevel;

    /**
     * @return The allocation level for cpu resources. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> cpuShareLevel() {
        return Optional.ofNullable(this.cpuShareLevel);
    }

    /**
     * A list of custom attributes to set on this resource.
     * 
     */
    @Import(name="customAttributes")
    private @Nullable Output<Map<String,String>> customAttributes;

    /**
     * @return A list of custom attributes to set on this resource.
     * 
     */
    public Optional<Output<Map<String,String>>> customAttributes() {
        return Optional.ofNullable(this.customAttributes);
    }

    /**
     * The ID of the datacenter where the VM is to be created.
     * 
     */
    @Import(name="datacenterId")
    private @Nullable Output<String> datacenterId;

    /**
     * @return The ID of the datacenter where the VM is to be created.
     * 
     */
    public Optional<Output<String>> datacenterId() {
        return Optional.ofNullable(this.datacenterId);
    }

    /**
     * The ID of a datastore cluster to put the virtual machine in.
     * 
     */
    @Import(name="datastoreClusterId")
    private @Nullable Output<String> datastoreClusterId;

    /**
     * @return The ID of a datastore cluster to put the virtual machine in.
     * 
     */
    public Optional<Output<String>> datastoreClusterId() {
        return Optional.ofNullable(this.datastoreClusterId);
    }

    /**
     * The ID of the virtual machine&#39;s datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
     * 
     */
    @Import(name="datastoreId")
    private @Nullable Output<String> datastoreId;

    /**
     * @return The ID of the virtual machine&#39;s datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
     * 
     */
    public Optional<Output<String>> datastoreId() {
        return Optional.ofNullable(this.datastoreId);
    }

    /**
     * A specification for a virtual disk device on this virtual machine.
     * 
     */
    @Import(name="disks")
    private @Nullable Output<List<VirtualMachineDiskArgs>> disks;

    /**
     * @return A specification for a virtual disk device on this virtual machine.
     * 
     */
    public Optional<Output<List<VirtualMachineDiskArgs>>> disks() {
        return Optional.ofNullable(this.disks);
    }

    /**
     * When the boot type set in firmware is efi, this enables EFI secure boot.
     * 
     */
    @Import(name="efiSecureBootEnabled")
    private @Nullable Output<Boolean> efiSecureBootEnabled;

    /**
     * @return When the boot type set in firmware is efi, this enables EFI secure boot.
     * 
     */
    public Optional<Output<Boolean>> efiSecureBootEnabled() {
        return Optional.ofNullable(this.efiSecureBootEnabled);
    }

    /**
     * Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
     * 
     */
    @Import(name="enableDiskUuid")
    private @Nullable Output<Boolean> enableDiskUuid;

    /**
     * @return Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
     * 
     */
    public Optional<Output<Boolean>> enableDiskUuid() {
        return Optional.ofNullable(this.enableDiskUuid);
    }

    /**
     * Enable logging on this virtual machine.
     * 
     */
    @Import(name="enableLogging")
    private @Nullable Output<Boolean> enableLogging;

    /**
     * @return Enable logging on this virtual machine.
     * 
     */
    public Optional<Output<Boolean>> enableLogging() {
        return Optional.ofNullable(this.enableLogging);
    }

    /**
     * The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
     * 
     */
    @Import(name="eptRviMode")
    private @Nullable Output<String> eptRviMode;

    /**
     * @return The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
     * 
     */
    public Optional<Output<String>> eptRviMode() {
        return Optional.ofNullable(this.eptRviMode);
    }

    /**
     * Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
     * 
     */
    @Import(name="extraConfig")
    private @Nullable Output<Map<String,String>> extraConfig;

    /**
     * @return Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
     * 
     */
    public Optional<Output<Map<String,String>>> extraConfig() {
        return Optional.ofNullable(this.extraConfig);
    }

    /**
     * Allow the virtual machine to be rebooted when a change to `extra_config` occurs.
     * 
     */
    @Import(name="extraConfigRebootRequired")
    private @Nullable Output<Boolean> extraConfigRebootRequired;

    /**
     * @return Allow the virtual machine to be rebooted when a change to `extra_config` occurs.
     * 
     */
    public Optional<Output<Boolean>> extraConfigRebootRequired() {
        return Optional.ofNullable(this.extraConfigRebootRequired);
    }

    /**
     * The firmware interface to use on the virtual machine. Can be one of bios or efi.
     * 
     */
    @Import(name="firmware")
    private @Nullable Output<String> firmware;

    /**
     * @return The firmware interface to use on the virtual machine. Can be one of bios or efi.
     * 
     */
    public Optional<Output<String>> firmware() {
        return Optional.ofNullable(this.firmware);
    }

    /**
     * The name of the folder to locate the virtual machine in.
     * 
     */
    @Import(name="folder")
    private @Nullable Output<String> folder;

    /**
     * @return The name of the folder to locate the virtual machine in.
     * 
     */
    public Optional<Output<String>> folder() {
        return Optional.ofNullable(this.folder);
    }

    /**
     * Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
     * 
     */
    @Import(name="forcePowerOff")
    private @Nullable Output<Boolean> forcePowerOff;

    /**
     * @return Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
     * 
     */
    public Optional<Output<Boolean>> forcePowerOff() {
        return Optional.ofNullable(this.forcePowerOff);
    }

    /**
     * The guest ID for the operating system.
     * 
     */
    @Import(name="guestId")
    private @Nullable Output<String> guestId;

    /**
     * @return The guest ID for the operating system.
     * 
     */
    public Optional<Output<String>> guestId() {
        return Optional.ofNullable(this.guestId);
    }

    /**
     * The hardware version for the virtual machine. Allows versions within ranges: 4, 7-11, 13-15, 17-22.
     * 
     */
    @Import(name="hardwareVersion")
    private @Nullable Output<Integer> hardwareVersion;

    /**
     * @return The hardware version for the virtual machine. Allows versions within ranges: 4, 7-11, 13-15, 17-22.
     * 
     */
    public Optional<Output<Integer>> hardwareVersion() {
        return Optional.ofNullable(this.hardwareVersion);
    }

    /**
     * The ID of an optional host system to pin the virtual machine to.
     * 
     */
    @Import(name="hostSystemId")
    private @Nullable Output<String> hostSystemId;

    /**
     * @return The ID of an optional host system to pin the virtual machine to.
     * 
     */
    public Optional<Output<String>> hostSystemId() {
        return Optional.ofNullable(this.hostSystemId);
    }

    /**
     * The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
     * 
     */
    @Import(name="hvMode")
    private @Nullable Output<String> hvMode;

    /**
     * @return The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
     * 
     */
    public Optional<Output<String>> hvMode() {
        return Optional.ofNullable(this.hvMode);
    }

    @Import(name="ideControllerCount")
    private @Nullable Output<Integer> ideControllerCount;

    public Optional<Output<Integer>> ideControllerCount() {
        return Optional.ofNullable(this.ideControllerCount);
    }

    /**
     * List of IP addresses and CIDR networks to ignore while waiting for an IP
     * 
     */
    @Import(name="ignoredGuestIps")
    private @Nullable Output<List<String>> ignoredGuestIps;

    /**
     * @return List of IP addresses and CIDR networks to ignore while waiting for an IP
     * 
     */
    public Optional<Output<List<String>>> ignoredGuestIps() {
        return Optional.ofNullable(this.ignoredGuestIps);
    }

    /**
     * Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
     * 
     */
    @Import(name="latencySensitivity")
    private @Nullable Output<String> latencySensitivity;

    /**
     * @return Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
     * 
     */
    public Optional<Output<String>> latencySensitivity() {
        return Optional.ofNullable(this.latencySensitivity);
    }

    /**
     * The size of the virtual machine&#39;s memory, in MB.
     * 
     */
    @Import(name="memory")
    private @Nullable Output<Integer> memory;

    /**
     * @return The size of the virtual machine&#39;s memory, in MB.
     * 
     */
    public Optional<Output<Integer>> memory() {
        return Optional.ofNullable(this.memory);
    }

    /**
     * Allow memory to be added to this virtual machine while it is running.
     * 
     */
    @Import(name="memoryHotAddEnabled")
    private @Nullable Output<Boolean> memoryHotAddEnabled;

    /**
     * @return Allow memory to be added to this virtual machine while it is running.
     * 
     */
    public Optional<Output<Boolean>> memoryHotAddEnabled() {
        return Optional.ofNullable(this.memoryHotAddEnabled);
    }

    /**
     * The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
     * 
     */
    @Import(name="memoryLimit")
    private @Nullable Output<Integer> memoryLimit;

    /**
     * @return The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
     * 
     */
    public Optional<Output<Integer>> memoryLimit() {
        return Optional.ofNullable(this.memoryLimit);
    }

    /**
     * The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
     * 
     */
    @Import(name="memoryReservation")
    private @Nullable Output<Integer> memoryReservation;

    /**
     * @return The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
     * 
     */
    public Optional<Output<Integer>> memoryReservation() {
        return Optional.ofNullable(this.memoryReservation);
    }

    /**
     * If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine&#39;s memory size;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature may only be enabled if it is currently possible to reserve all of the virtual machine&#39;s memory.
     * 
     */
    @Import(name="memoryReservationLockedToMax")
    private @Nullable Output<Boolean> memoryReservationLockedToMax;

    /**
     * @return If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine&#39;s memory size;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature may only be enabled if it is currently possible to reserve all of the virtual machine&#39;s memory.
     * 
     */
    public Optional<Output<Boolean>> memoryReservationLockedToMax() {
        return Optional.ofNullable(this.memoryReservationLockedToMax);
    }

    /**
     * The amount of shares to allocate to memory for a custom share level.
     * 
     */
    @Import(name="memoryShareCount")
    private @Nullable Output<Integer> memoryShareCount;

    /**
     * @return The amount of shares to allocate to memory for a custom share level.
     * 
     */
    public Optional<Output<Integer>> memoryShareCount() {
        return Optional.ofNullable(this.memoryShareCount);
    }

    /**
     * The allocation level for memory resources. Can be one of high, low, normal, or custom.
     * 
     */
    @Import(name="memoryShareLevel")
    private @Nullable Output<String> memoryShareLevel;

    /**
     * @return The allocation level for memory resources. Can be one of high, low, normal, or custom.
     * 
     */
    public Optional<Output<String>> memoryShareLevel() {
        return Optional.ofNullable(this.memoryShareLevel);
    }

    /**
     * The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
     * 
     */
    @Import(name="migrateWaitTimeout")
    private @Nullable Output<Integer> migrateWaitTimeout;

    /**
     * @return The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
     * 
     */
    public Optional<Output<Integer>> migrateWaitTimeout() {
        return Optional.ofNullable(this.migrateWaitTimeout);
    }

    /**
     * The name of this virtual machine.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of this virtual machine.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
     * 
     */
    @Import(name="nestedHvEnabled")
    private @Nullable Output<Boolean> nestedHvEnabled;

    /**
     * @return Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
     * 
     */
    public Optional<Output<Boolean>> nestedHvEnabled() {
        return Optional.ofNullable(this.nestedHvEnabled);
    }

    /**
     * A specification for a virtual NIC on this virtual machine.
     * 
     */
    @Import(name="networkInterfaces")
    private @Nullable Output<List<VirtualMachineNetworkInterfaceArgs>> networkInterfaces;

    /**
     * @return A specification for a virtual NIC on this virtual machine.
     * 
     */
    public Optional<Output<List<VirtualMachineNetworkInterfaceArgs>>> networkInterfaces() {
        return Optional.ofNullable(this.networkInterfaces);
    }

    /**
     * The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus must be evenly divisible by this value.
     * 
     */
    @Import(name="numCoresPerSocket")
    private @Nullable Output<Integer> numCoresPerSocket;

    /**
     * @return The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus must be evenly divisible by this value.
     * 
     */
    public Optional<Output<Integer>> numCoresPerSocket() {
        return Optional.ofNullable(this.numCoresPerSocket);
    }

    /**
     * The number of virtual processors to assign to this virtual machine.
     * 
     */
    @Import(name="numCpus")
    private @Nullable Output<Integer> numCpus;

    /**
     * @return The number of virtual processors to assign to this virtual machine.
     * 
     */
    public Optional<Output<Integer>> numCpus() {
        return Optional.ofNullable(this.numCpus);
    }

    @Import(name="nvmeControllerCount")
    private @Nullable Output<Integer> nvmeControllerCount;

    public Optional<Output<Integer>> nvmeControllerCount() {
        return Optional.ofNullable(this.nvmeControllerCount);
    }

    /**
     * A specification for deploying a virtual machine from ovf/ova template.
     * 
     */
    @Import(name="ovfDeploy")
    private @Nullable Output<VirtualMachineOvfDeployArgs> ovfDeploy;

    /**
     * @return A specification for deploying a virtual machine from ovf/ova template.
     * 
     */
    public Optional<Output<VirtualMachineOvfDeployArgs>> ovfDeploy() {
        return Optional.ofNullable(this.ovfDeploy);
    }

    /**
     * A list of PCI passthrough devices
     * 
     */
    @Import(name="pciDeviceIds")
    private @Nullable Output<List<String>> pciDeviceIds;

    /**
     * @return A list of PCI passthrough devices
     * 
     */
    public Optional<Output<List<String>>> pciDeviceIds() {
        return Optional.ofNullable(this.pciDeviceIds);
    }

    /**
     * The amount of time, in seconds, that we will be trying to power on a VM
     * 
     */
    @Import(name="poweronTimeout")
    private @Nullable Output<Integer> poweronTimeout;

    /**
     * @return The amount of time, in seconds, that we will be trying to power on a VM
     * 
     */
    public Optional<Output<Integer>> poweronTimeout() {
        return Optional.ofNullable(this.poweronTimeout);
    }

    /**
     * Triggers replacement of resource whenever it changes.
     * 
     */
    @Import(name="replaceTrigger")
    private @Nullable Output<String> replaceTrigger;

    /**
     * @return Triggers replacement of resource whenever it changes.
     * 
     */
    public Optional<Output<String>> replaceTrigger() {
        return Optional.ofNullable(this.replaceTrigger);
    }

    /**
     * The ID of a resource pool to put the virtual machine in.
     * 
     */
    @Import(name="resourcePoolId", required=true)
    private Output<String> resourcePoolId;

    /**
     * @return The ID of a resource pool to put the virtual machine in.
     * 
     */
    public Output<String> resourcePoolId() {
        return this.resourcePoolId;
    }

    /**
     * Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
     * 
     */
    @Import(name="runToolsScriptsAfterPowerOn")
    private @Nullable Output<Boolean> runToolsScriptsAfterPowerOn;

    /**
     * @return Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
     * 
     */
    public Optional<Output<Boolean>> runToolsScriptsAfterPowerOn() {
        return Optional.ofNullable(this.runToolsScriptsAfterPowerOn);
    }

    /**
     * Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
     * 
     */
    @Import(name="runToolsScriptsAfterResume")
    private @Nullable Output<Boolean> runToolsScriptsAfterResume;

    /**
     * @return Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
     * 
     */
    public Optional<Output<Boolean>> runToolsScriptsAfterResume() {
        return Optional.ofNullable(this.runToolsScriptsAfterResume);
    }

    /**
     * Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
     * 
     */
    @Import(name="runToolsScriptsBeforeGuestReboot")
    private @Nullable Output<Boolean> runToolsScriptsBeforeGuestReboot;

    /**
     * @return Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
     * 
     */
    public Optional<Output<Boolean>> runToolsScriptsBeforeGuestReboot() {
        return Optional.ofNullable(this.runToolsScriptsBeforeGuestReboot);
    }

    /**
     * Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
     * 
     */
    @Import(name="runToolsScriptsBeforeGuestShutdown")
    private @Nullable Output<Boolean> runToolsScriptsBeforeGuestShutdown;

    /**
     * @return Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
     * 
     */
    public Optional<Output<Boolean>> runToolsScriptsBeforeGuestShutdown() {
        return Optional.ofNullable(this.runToolsScriptsBeforeGuestShutdown);
    }

    /**
     * Enable the run of scripts before guest operating system standby when VMware Tools is installed.
     * 
     */
    @Import(name="runToolsScriptsBeforeGuestStandby")
    private @Nullable Output<Boolean> runToolsScriptsBeforeGuestStandby;

    /**
     * @return Enable the run of scripts before guest operating system standby when VMware Tools is installed.
     * 
     */
    public Optional<Output<Boolean>> runToolsScriptsBeforeGuestStandby() {
        return Optional.ofNullable(this.runToolsScriptsBeforeGuestStandby);
    }

    @Import(name="sataControllerCount")
    private @Nullable Output<Integer> sataControllerCount;

    public Optional<Output<Integer>> sataControllerCount() {
        return Optional.ofNullable(this.sataControllerCount);
    }

    /**
     * Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
     * 
     */
    @Import(name="scsiBusSharing")
    private @Nullable Output<String> scsiBusSharing;

    /**
     * @return Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
     * 
     */
    public Optional<Output<String>> scsiBusSharing() {
        return Optional.ofNullable(this.scsiBusSharing);
    }

    @Import(name="scsiControllerCount")
    private @Nullable Output<Integer> scsiControllerCount;

    public Optional<Output<Integer>> scsiControllerCount() {
        return Optional.ofNullable(this.scsiControllerCount);
    }

    /**
     * The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
     * 
     */
    @Import(name="scsiType")
    private @Nullable Output<String> scsiType;

    /**
     * @return The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
     * 
     */
    public Optional<Output<String>> scsiType() {
        return Optional.ofNullable(this.scsiType);
    }

    /**
     * The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
     * 
     */
    @Import(name="shutdownWaitTimeout")
    private @Nullable Output<Integer> shutdownWaitTimeout;

    /**
     * @return The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
     * 
     */
    public Optional<Output<Integer>> shutdownWaitTimeout() {
        return Optional.ofNullable(this.shutdownWaitTimeout);
    }

    /**
     * The ID of the storage policy to assign to the virtual machine home directory.
     * 
     */
    @Import(name="storagePolicyId")
    private @Nullable Output<String> storagePolicyId;

    /**
     * @return The ID of the storage policy to assign to the virtual machine home directory.
     * 
     */
    public Optional<Output<String>> storagePolicyId() {
        return Optional.ofNullable(this.storagePolicyId);
    }

    /**
     * The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
     * 
     */
    @Import(name="swapPlacementPolicy")
    private @Nullable Output<String> swapPlacementPolicy;

    /**
     * @return The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
     * 
     */
    public Optional<Output<String>> swapPlacementPolicy() {
        return Optional.ofNullable(this.swapPlacementPolicy);
    }

    /**
     * Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
     * 
     */
    @Import(name="syncTimeWithHost")
    private @Nullable Output<Boolean> syncTimeWithHost;

    /**
     * @return Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
     * 
     */
    public Optional<Output<Boolean>> syncTimeWithHost() {
        return Optional.ofNullable(this.syncTimeWithHost);
    }

    /**
     * Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.
     * 
     */
    @Import(name="syncTimeWithHostPeriodically")
    private @Nullable Output<Boolean> syncTimeWithHostPeriodically;

    /**
     * @return Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.
     * 
     */
    public Optional<Output<Boolean>> syncTimeWithHostPeriodically() {
        return Optional.ofNullable(this.syncTimeWithHostPeriodically);
    }

    /**
     * A list of tag IDs to apply to this object.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return A list of tag IDs to apply to this object.
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.
     * 
     */
    @Import(name="toolsUpgradePolicy")
    private @Nullable Output<String> toolsUpgradePolicy;

    /**
     * @return Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.
     * 
     */
    public Optional<Output<String>> toolsUpgradePolicy() {
        return Optional.ofNullable(this.toolsUpgradePolicy);
    }

    /**
     * vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
     * 
     */
    @Import(name="vapp")
    private @Nullable Output<VirtualMachineVappArgs> vapp;

    /**
     * @return vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
     * 
     */
    public Optional<Output<VirtualMachineVappArgs>> vapp() {
        return Optional.ofNullable(this.vapp);
    }

    /**
     * Flag to specify if Virtualization-based security is enabled for this virtual machine.
     * 
     */
    @Import(name="vbsEnabled")
    private @Nullable Output<Boolean> vbsEnabled;

    /**
     * @return Flag to specify if Virtualization-based security is enabled for this virtual machine.
     * 
     */
    public Optional<Output<Boolean>> vbsEnabled() {
        return Optional.ofNullable(this.vbsEnabled);
    }

    /**
     * A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.
     * 
     */
    @Import(name="vtpm")
    private @Nullable Output<VirtualMachineVtpmArgs> vtpm;

    /**
     * @return A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.
     * 
     */
    public Optional<Output<VirtualMachineVtpmArgs>> vtpm() {
        return Optional.ofNullable(this.vtpm);
    }

    /**
     * Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
     * 
     */
    @Import(name="vvtdEnabled")
    private @Nullable Output<Boolean> vvtdEnabled;

    /**
     * @return Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
     * 
     */
    public Optional<Output<Boolean>> vvtdEnabled() {
        return Optional.ofNullable(this.vvtdEnabled);
    }

    /**
     * The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
     * 
     */
    @Import(name="waitForGuestIpTimeout")
    private @Nullable Output<Integer> waitForGuestIpTimeout;

    /**
     * @return The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
     * 
     */
    public Optional<Output<Integer>> waitForGuestIpTimeout() {
        return Optional.ofNullable(this.waitForGuestIpTimeout);
    }

    /**
     * Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
     * 
     */
    @Import(name="waitForGuestNetRoutable")
    private @Nullable Output<Boolean> waitForGuestNetRoutable;

    /**
     * @return Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
     * 
     */
    public Optional<Output<Boolean>> waitForGuestNetRoutable() {
        return Optional.ofNullable(this.waitForGuestNetRoutable);
    }

    /**
     * The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
     * 
     */
    @Import(name="waitForGuestNetTimeout")
    private @Nullable Output<Integer> waitForGuestNetTimeout;

    /**
     * @return The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
     * 
     */
    public Optional<Output<Integer>> waitForGuestNetTimeout() {
        return Optional.ofNullable(this.waitForGuestNetTimeout);
    }

    private VirtualMachineArgs() {}

    private VirtualMachineArgs(VirtualMachineArgs $) {
        this.alternateGuestName = $.alternateGuestName;
        this.annotation = $.annotation;
        this.bootDelay = $.bootDelay;
        this.bootRetryDelay = $.bootRetryDelay;
        this.bootRetryEnabled = $.bootRetryEnabled;
        this.cdroms = $.cdroms;
        this.clone = $.clone;
        this.cpuHotAddEnabled = $.cpuHotAddEnabled;
        this.cpuHotRemoveEnabled = $.cpuHotRemoveEnabled;
        this.cpuLimit = $.cpuLimit;
        this.cpuPerformanceCountersEnabled = $.cpuPerformanceCountersEnabled;
        this.cpuReservation = $.cpuReservation;
        this.cpuShareCount = $.cpuShareCount;
        this.cpuShareLevel = $.cpuShareLevel;
        this.customAttributes = $.customAttributes;
        this.datacenterId = $.datacenterId;
        this.datastoreClusterId = $.datastoreClusterId;
        this.datastoreId = $.datastoreId;
        this.disks = $.disks;
        this.efiSecureBootEnabled = $.efiSecureBootEnabled;
        this.enableDiskUuid = $.enableDiskUuid;
        this.enableLogging = $.enableLogging;
        this.eptRviMode = $.eptRviMode;
        this.extraConfig = $.extraConfig;
        this.extraConfigRebootRequired = $.extraConfigRebootRequired;
        this.firmware = $.firmware;
        this.folder = $.folder;
        this.forcePowerOff = $.forcePowerOff;
        this.guestId = $.guestId;
        this.hardwareVersion = $.hardwareVersion;
        this.hostSystemId = $.hostSystemId;
        this.hvMode = $.hvMode;
        this.ideControllerCount = $.ideControllerCount;
        this.ignoredGuestIps = $.ignoredGuestIps;
        this.latencySensitivity = $.latencySensitivity;
        this.memory = $.memory;
        this.memoryHotAddEnabled = $.memoryHotAddEnabled;
        this.memoryLimit = $.memoryLimit;
        this.memoryReservation = $.memoryReservation;
        this.memoryReservationLockedToMax = $.memoryReservationLockedToMax;
        this.memoryShareCount = $.memoryShareCount;
        this.memoryShareLevel = $.memoryShareLevel;
        this.migrateWaitTimeout = $.migrateWaitTimeout;
        this.name = $.name;
        this.nestedHvEnabled = $.nestedHvEnabled;
        this.networkInterfaces = $.networkInterfaces;
        this.numCoresPerSocket = $.numCoresPerSocket;
        this.numCpus = $.numCpus;
        this.nvmeControllerCount = $.nvmeControllerCount;
        this.ovfDeploy = $.ovfDeploy;
        this.pciDeviceIds = $.pciDeviceIds;
        this.poweronTimeout = $.poweronTimeout;
        this.replaceTrigger = $.replaceTrigger;
        this.resourcePoolId = $.resourcePoolId;
        this.runToolsScriptsAfterPowerOn = $.runToolsScriptsAfterPowerOn;
        this.runToolsScriptsAfterResume = $.runToolsScriptsAfterResume;
        this.runToolsScriptsBeforeGuestReboot = $.runToolsScriptsBeforeGuestReboot;
        this.runToolsScriptsBeforeGuestShutdown = $.runToolsScriptsBeforeGuestShutdown;
        this.runToolsScriptsBeforeGuestStandby = $.runToolsScriptsBeforeGuestStandby;
        this.sataControllerCount = $.sataControllerCount;
        this.scsiBusSharing = $.scsiBusSharing;
        this.scsiControllerCount = $.scsiControllerCount;
        this.scsiType = $.scsiType;
        this.shutdownWaitTimeout = $.shutdownWaitTimeout;
        this.storagePolicyId = $.storagePolicyId;
        this.swapPlacementPolicy = $.swapPlacementPolicy;
        this.syncTimeWithHost = $.syncTimeWithHost;
        this.syncTimeWithHostPeriodically = $.syncTimeWithHostPeriodically;
        this.tags = $.tags;
        this.toolsUpgradePolicy = $.toolsUpgradePolicy;
        this.vapp = $.vapp;
        this.vbsEnabled = $.vbsEnabled;
        this.vtpm = $.vtpm;
        this.vvtdEnabled = $.vvtdEnabled;
        this.waitForGuestIpTimeout = $.waitForGuestIpTimeout;
        this.waitForGuestNetRoutable = $.waitForGuestNetRoutable;
        this.waitForGuestNetTimeout = $.waitForGuestNetTimeout;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(VirtualMachineArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private VirtualMachineArgs $;

        public Builder() {
            $ = new VirtualMachineArgs();
        }

        public Builder(VirtualMachineArgs defaults) {
            $ = new VirtualMachineArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param alternateGuestName The guest name for the operating system when guest_id is otherGuest or otherGuest64.
         * 
         * @return builder
         * 
         */
        public Builder alternateGuestName(@Nullable Output<String> alternateGuestName) {
            $.alternateGuestName = alternateGuestName;
            return this;
        }

        /**
         * @param alternateGuestName The guest name for the operating system when guest_id is otherGuest or otherGuest64.
         * 
         * @return builder
         * 
         */
        public Builder alternateGuestName(String alternateGuestName) {
            return alternateGuestName(Output.of(alternateGuestName));
        }

        /**
         * @param annotation User-provided description of the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder annotation(@Nullable Output<String> annotation) {
            $.annotation = annotation;
            return this;
        }

        /**
         * @param annotation User-provided description of the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder annotation(String annotation) {
            return annotation(Output.of(annotation));
        }

        /**
         * @param bootDelay The number of milliseconds to wait before starting the boot sequence.
         * 
         * @return builder
         * 
         */
        public Builder bootDelay(@Nullable Output<Integer> bootDelay) {
            $.bootDelay = bootDelay;
            return this;
        }

        /**
         * @param bootDelay The number of milliseconds to wait before starting the boot sequence.
         * 
         * @return builder
         * 
         */
        public Builder bootDelay(Integer bootDelay) {
            return bootDelay(Output.of(bootDelay));
        }

        /**
         * @param bootRetryDelay The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.
         * 
         * @return builder
         * 
         */
        public Builder bootRetryDelay(@Nullable Output<Integer> bootRetryDelay) {
            $.bootRetryDelay = bootRetryDelay;
            return this;
        }

        /**
         * @param bootRetryDelay The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.
         * 
         * @return builder
         * 
         */
        public Builder bootRetryDelay(Integer bootRetryDelay) {
            return bootRetryDelay(Output.of(bootRetryDelay));
        }

        /**
         * @param bootRetryEnabled If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
         * 
         * @return builder
         * 
         */
        public Builder bootRetryEnabled(@Nullable Output<Boolean> bootRetryEnabled) {
            $.bootRetryEnabled = bootRetryEnabled;
            return this;
        }

        /**
         * @param bootRetryEnabled If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
         * 
         * @return builder
         * 
         */
        public Builder bootRetryEnabled(Boolean bootRetryEnabled) {
            return bootRetryEnabled(Output.of(bootRetryEnabled));
        }

        /**
         * @param cdroms A specification for a CDROM device on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder cdroms(@Nullable Output<List<VirtualMachineCdromArgs>> cdroms) {
            $.cdroms = cdroms;
            return this;
        }

        /**
         * @param cdroms A specification for a CDROM device on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder cdroms(List<VirtualMachineCdromArgs> cdroms) {
            return cdroms(Output.of(cdroms));
        }

        /**
         * @param cdroms A specification for a CDROM device on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder cdroms(VirtualMachineCdromArgs... cdroms) {
            return cdroms(List.of(cdroms));
        }

        /**
         * @param clone A specification for cloning a virtual machine from template.
         * 
         * @return builder
         * 
         */
        public Builder clone_(@Nullable Output<VirtualMachineCloneArgs> clone) {
            $.clone = clone;
            return this;
        }

        /**
         * @param clone A specification for cloning a virtual machine from template.
         * 
         * @return builder
         * 
         */
        public Builder clone_(VirtualMachineCloneArgs clone) {
            return clone_(Output.of(clone));
        }

        /**
         * @param cpuHotAddEnabled Allow CPUs to be added to this virtual machine while it is running.
         * 
         * @return builder
         * 
         */
        public Builder cpuHotAddEnabled(@Nullable Output<Boolean> cpuHotAddEnabled) {
            $.cpuHotAddEnabled = cpuHotAddEnabled;
            return this;
        }

        /**
         * @param cpuHotAddEnabled Allow CPUs to be added to this virtual machine while it is running.
         * 
         * @return builder
         * 
         */
        public Builder cpuHotAddEnabled(Boolean cpuHotAddEnabled) {
            return cpuHotAddEnabled(Output.of(cpuHotAddEnabled));
        }

        /**
         * @param cpuHotRemoveEnabled Allow CPUs to be added to this virtual machine while it is running.
         * 
         * @return builder
         * 
         */
        public Builder cpuHotRemoveEnabled(@Nullable Output<Boolean> cpuHotRemoveEnabled) {
            $.cpuHotRemoveEnabled = cpuHotRemoveEnabled;
            return this;
        }

        /**
         * @param cpuHotRemoveEnabled Allow CPUs to be added to this virtual machine while it is running.
         * 
         * @return builder
         * 
         */
        public Builder cpuHotRemoveEnabled(Boolean cpuHotRemoveEnabled) {
            return cpuHotRemoveEnabled(Output.of(cpuHotRemoveEnabled));
        }

        /**
         * @param cpuLimit The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
         * 
         * @return builder
         * 
         */
        public Builder cpuLimit(@Nullable Output<Integer> cpuLimit) {
            $.cpuLimit = cpuLimit;
            return this;
        }

        /**
         * @param cpuLimit The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
         * 
         * @return builder
         * 
         */
        public Builder cpuLimit(Integer cpuLimit) {
            return cpuLimit(Output.of(cpuLimit));
        }

        /**
         * @param cpuPerformanceCountersEnabled Enable CPU performance counters on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder cpuPerformanceCountersEnabled(@Nullable Output<Boolean> cpuPerformanceCountersEnabled) {
            $.cpuPerformanceCountersEnabled = cpuPerformanceCountersEnabled;
            return this;
        }

        /**
         * @param cpuPerformanceCountersEnabled Enable CPU performance counters on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder cpuPerformanceCountersEnabled(Boolean cpuPerformanceCountersEnabled) {
            return cpuPerformanceCountersEnabled(Output.of(cpuPerformanceCountersEnabled));
        }

        /**
         * @param cpuReservation The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
         * 
         * @return builder
         * 
         */
        public Builder cpuReservation(@Nullable Output<Integer> cpuReservation) {
            $.cpuReservation = cpuReservation;
            return this;
        }

        /**
         * @param cpuReservation The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
         * 
         * @return builder
         * 
         */
        public Builder cpuReservation(Integer cpuReservation) {
            return cpuReservation(Output.of(cpuReservation));
        }

        /**
         * @param cpuShareCount The amount of shares to allocate to cpu for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder cpuShareCount(@Nullable Output<Integer> cpuShareCount) {
            $.cpuShareCount = cpuShareCount;
            return this;
        }

        /**
         * @param cpuShareCount The amount of shares to allocate to cpu for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder cpuShareCount(Integer cpuShareCount) {
            return cpuShareCount(Output.of(cpuShareCount));
        }

        /**
         * @param cpuShareLevel The allocation level for cpu resources. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder cpuShareLevel(@Nullable Output<String> cpuShareLevel) {
            $.cpuShareLevel = cpuShareLevel;
            return this;
        }

        /**
         * @param cpuShareLevel The allocation level for cpu resources. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder cpuShareLevel(String cpuShareLevel) {
            return cpuShareLevel(Output.of(cpuShareLevel));
        }

        /**
         * @param customAttributes A list of custom attributes to set on this resource.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(@Nullable Output<Map<String,String>> customAttributes) {
            $.customAttributes = customAttributes;
            return this;
        }

        /**
         * @param customAttributes A list of custom attributes to set on this resource.
         * 
         * @return builder
         * 
         */
        public Builder customAttributes(Map<String,String> customAttributes) {
            return customAttributes(Output.of(customAttributes));
        }

        /**
         * @param datacenterId The ID of the datacenter where the VM is to be created.
         * 
         * @return builder
         * 
         */
        public Builder datacenterId(@Nullable Output<String> datacenterId) {
            $.datacenterId = datacenterId;
            return this;
        }

        /**
         * @param datacenterId The ID of the datacenter where the VM is to be created.
         * 
         * @return builder
         * 
         */
        public Builder datacenterId(String datacenterId) {
            return datacenterId(Output.of(datacenterId));
        }

        /**
         * @param datastoreClusterId The ID of a datastore cluster to put the virtual machine in.
         * 
         * @return builder
         * 
         */
        public Builder datastoreClusterId(@Nullable Output<String> datastoreClusterId) {
            $.datastoreClusterId = datastoreClusterId;
            return this;
        }

        /**
         * @param datastoreClusterId The ID of a datastore cluster to put the virtual machine in.
         * 
         * @return builder
         * 
         */
        public Builder datastoreClusterId(String datastoreClusterId) {
            return datastoreClusterId(Output.of(datastoreClusterId));
        }

        /**
         * @param datastoreId The ID of the virtual machine&#39;s datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
         * 
         * @return builder
         * 
         */
        public Builder datastoreId(@Nullable Output<String> datastoreId) {
            $.datastoreId = datastoreId;
            return this;
        }

        /**
         * @param datastoreId The ID of the virtual machine&#39;s datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
         * 
         * @return builder
         * 
         */
        public Builder datastoreId(String datastoreId) {
            return datastoreId(Output.of(datastoreId));
        }

        /**
         * @param disks A specification for a virtual disk device on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder disks(@Nullable Output<List<VirtualMachineDiskArgs>> disks) {
            $.disks = disks;
            return this;
        }

        /**
         * @param disks A specification for a virtual disk device on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder disks(List<VirtualMachineDiskArgs> disks) {
            return disks(Output.of(disks));
        }

        /**
         * @param disks A specification for a virtual disk device on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder disks(VirtualMachineDiskArgs... disks) {
            return disks(List.of(disks));
        }

        /**
         * @param efiSecureBootEnabled When the boot type set in firmware is efi, this enables EFI secure boot.
         * 
         * @return builder
         * 
         */
        public Builder efiSecureBootEnabled(@Nullable Output<Boolean> efiSecureBootEnabled) {
            $.efiSecureBootEnabled = efiSecureBootEnabled;
            return this;
        }

        /**
         * @param efiSecureBootEnabled When the boot type set in firmware is efi, this enables EFI secure boot.
         * 
         * @return builder
         * 
         */
        public Builder efiSecureBootEnabled(Boolean efiSecureBootEnabled) {
            return efiSecureBootEnabled(Output.of(efiSecureBootEnabled));
        }

        /**
         * @param enableDiskUuid Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
         * 
         * @return builder
         * 
         */
        public Builder enableDiskUuid(@Nullable Output<Boolean> enableDiskUuid) {
            $.enableDiskUuid = enableDiskUuid;
            return this;
        }

        /**
         * @param enableDiskUuid Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
         * 
         * @return builder
         * 
         */
        public Builder enableDiskUuid(Boolean enableDiskUuid) {
            return enableDiskUuid(Output.of(enableDiskUuid));
        }

        /**
         * @param enableLogging Enable logging on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder enableLogging(@Nullable Output<Boolean> enableLogging) {
            $.enableLogging = enableLogging;
            return this;
        }

        /**
         * @param enableLogging Enable logging on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder enableLogging(Boolean enableLogging) {
            return enableLogging(Output.of(enableLogging));
        }

        /**
         * @param eptRviMode The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
         * 
         * @return builder
         * 
         */
        public Builder eptRviMode(@Nullable Output<String> eptRviMode) {
            $.eptRviMode = eptRviMode;
            return this;
        }

        /**
         * @param eptRviMode The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
         * 
         * @return builder
         * 
         */
        public Builder eptRviMode(String eptRviMode) {
            return eptRviMode(Output.of(eptRviMode));
        }

        /**
         * @param extraConfig Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
         * 
         * @return builder
         * 
         */
        public Builder extraConfig(@Nullable Output<Map<String,String>> extraConfig) {
            $.extraConfig = extraConfig;
            return this;
        }

        /**
         * @param extraConfig Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
         * 
         * @return builder
         * 
         */
        public Builder extraConfig(Map<String,String> extraConfig) {
            return extraConfig(Output.of(extraConfig));
        }

        /**
         * @param extraConfigRebootRequired Allow the virtual machine to be rebooted when a change to `extra_config` occurs.
         * 
         * @return builder
         * 
         */
        public Builder extraConfigRebootRequired(@Nullable Output<Boolean> extraConfigRebootRequired) {
            $.extraConfigRebootRequired = extraConfigRebootRequired;
            return this;
        }

        /**
         * @param extraConfigRebootRequired Allow the virtual machine to be rebooted when a change to `extra_config` occurs.
         * 
         * @return builder
         * 
         */
        public Builder extraConfigRebootRequired(Boolean extraConfigRebootRequired) {
            return extraConfigRebootRequired(Output.of(extraConfigRebootRequired));
        }

        /**
         * @param firmware The firmware interface to use on the virtual machine. Can be one of bios or efi.
         * 
         * @return builder
         * 
         */
        public Builder firmware(@Nullable Output<String> firmware) {
            $.firmware = firmware;
            return this;
        }

        /**
         * @param firmware The firmware interface to use on the virtual machine. Can be one of bios or efi.
         * 
         * @return builder
         * 
         */
        public Builder firmware(String firmware) {
            return firmware(Output.of(firmware));
        }

        /**
         * @param folder The name of the folder to locate the virtual machine in.
         * 
         * @return builder
         * 
         */
        public Builder folder(@Nullable Output<String> folder) {
            $.folder = folder;
            return this;
        }

        /**
         * @param folder The name of the folder to locate the virtual machine in.
         * 
         * @return builder
         * 
         */
        public Builder folder(String folder) {
            return folder(Output.of(folder));
        }

        /**
         * @param forcePowerOff Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
         * 
         * @return builder
         * 
         */
        public Builder forcePowerOff(@Nullable Output<Boolean> forcePowerOff) {
            $.forcePowerOff = forcePowerOff;
            return this;
        }

        /**
         * @param forcePowerOff Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
         * 
         * @return builder
         * 
         */
        public Builder forcePowerOff(Boolean forcePowerOff) {
            return forcePowerOff(Output.of(forcePowerOff));
        }

        /**
         * @param guestId The guest ID for the operating system.
         * 
         * @return builder
         * 
         */
        public Builder guestId(@Nullable Output<String> guestId) {
            $.guestId = guestId;
            return this;
        }

        /**
         * @param guestId The guest ID for the operating system.
         * 
         * @return builder
         * 
         */
        public Builder guestId(String guestId) {
            return guestId(Output.of(guestId));
        }

        /**
         * @param hardwareVersion The hardware version for the virtual machine. Allows versions within ranges: 4, 7-11, 13-15, 17-22.
         * 
         * @return builder
         * 
         */
        public Builder hardwareVersion(@Nullable Output<Integer> hardwareVersion) {
            $.hardwareVersion = hardwareVersion;
            return this;
        }

        /**
         * @param hardwareVersion The hardware version for the virtual machine. Allows versions within ranges: 4, 7-11, 13-15, 17-22.
         * 
         * @return builder
         * 
         */
        public Builder hardwareVersion(Integer hardwareVersion) {
            return hardwareVersion(Output.of(hardwareVersion));
        }

        /**
         * @param hostSystemId The ID of an optional host system to pin the virtual machine to.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemId(@Nullable Output<String> hostSystemId) {
            $.hostSystemId = hostSystemId;
            return this;
        }

        /**
         * @param hostSystemId The ID of an optional host system to pin the virtual machine to.
         * 
         * @return builder
         * 
         */
        public Builder hostSystemId(String hostSystemId) {
            return hostSystemId(Output.of(hostSystemId));
        }

        /**
         * @param hvMode The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
         * 
         * @return builder
         * 
         */
        public Builder hvMode(@Nullable Output<String> hvMode) {
            $.hvMode = hvMode;
            return this;
        }

        /**
         * @param hvMode The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
         * 
         * @return builder
         * 
         */
        public Builder hvMode(String hvMode) {
            return hvMode(Output.of(hvMode));
        }

        public Builder ideControllerCount(@Nullable Output<Integer> ideControllerCount) {
            $.ideControllerCount = ideControllerCount;
            return this;
        }

        public Builder ideControllerCount(Integer ideControllerCount) {
            return ideControllerCount(Output.of(ideControllerCount));
        }

        /**
         * @param ignoredGuestIps List of IP addresses and CIDR networks to ignore while waiting for an IP
         * 
         * @return builder
         * 
         */
        public Builder ignoredGuestIps(@Nullable Output<List<String>> ignoredGuestIps) {
            $.ignoredGuestIps = ignoredGuestIps;
            return this;
        }

        /**
         * @param ignoredGuestIps List of IP addresses and CIDR networks to ignore while waiting for an IP
         * 
         * @return builder
         * 
         */
        public Builder ignoredGuestIps(List<String> ignoredGuestIps) {
            return ignoredGuestIps(Output.of(ignoredGuestIps));
        }

        /**
         * @param ignoredGuestIps List of IP addresses and CIDR networks to ignore while waiting for an IP
         * 
         * @return builder
         * 
         */
        public Builder ignoredGuestIps(String... ignoredGuestIps) {
            return ignoredGuestIps(List.of(ignoredGuestIps));
        }

        /**
         * @param latencySensitivity Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
         * 
         * @return builder
         * 
         */
        public Builder latencySensitivity(@Nullable Output<String> latencySensitivity) {
            $.latencySensitivity = latencySensitivity;
            return this;
        }

        /**
         * @param latencySensitivity Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
         * 
         * @return builder
         * 
         */
        public Builder latencySensitivity(String latencySensitivity) {
            return latencySensitivity(Output.of(latencySensitivity));
        }

        /**
         * @param memory The size of the virtual machine&#39;s memory, in MB.
         * 
         * @return builder
         * 
         */
        public Builder memory(@Nullable Output<Integer> memory) {
            $.memory = memory;
            return this;
        }

        /**
         * @param memory The size of the virtual machine&#39;s memory, in MB.
         * 
         * @return builder
         * 
         */
        public Builder memory(Integer memory) {
            return memory(Output.of(memory));
        }

        /**
         * @param memoryHotAddEnabled Allow memory to be added to this virtual machine while it is running.
         * 
         * @return builder
         * 
         */
        public Builder memoryHotAddEnabled(@Nullable Output<Boolean> memoryHotAddEnabled) {
            $.memoryHotAddEnabled = memoryHotAddEnabled;
            return this;
        }

        /**
         * @param memoryHotAddEnabled Allow memory to be added to this virtual machine while it is running.
         * 
         * @return builder
         * 
         */
        public Builder memoryHotAddEnabled(Boolean memoryHotAddEnabled) {
            return memoryHotAddEnabled(Output.of(memoryHotAddEnabled));
        }

        /**
         * @param memoryLimit The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
         * 
         * @return builder
         * 
         */
        public Builder memoryLimit(@Nullable Output<Integer> memoryLimit) {
            $.memoryLimit = memoryLimit;
            return this;
        }

        /**
         * @param memoryLimit The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
         * 
         * @return builder
         * 
         */
        public Builder memoryLimit(Integer memoryLimit) {
            return memoryLimit(Output.of(memoryLimit));
        }

        /**
         * @param memoryReservation The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
         * 
         * @return builder
         * 
         */
        public Builder memoryReservation(@Nullable Output<Integer> memoryReservation) {
            $.memoryReservation = memoryReservation;
            return this;
        }

        /**
         * @param memoryReservation The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
         * 
         * @return builder
         * 
         */
        public Builder memoryReservation(Integer memoryReservation) {
            return memoryReservation(Output.of(memoryReservation));
        }

        /**
         * @param memoryReservationLockedToMax If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine&#39;s memory size;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature may only be enabled if it is currently possible to reserve all of the virtual machine&#39;s memory.
         * 
         * @return builder
         * 
         */
        public Builder memoryReservationLockedToMax(@Nullable Output<Boolean> memoryReservationLockedToMax) {
            $.memoryReservationLockedToMax = memoryReservationLockedToMax;
            return this;
        }

        /**
         * @param memoryReservationLockedToMax If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine&#39;s memory size;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature may only be enabled if it is currently possible to reserve all of the virtual machine&#39;s memory.
         * 
         * @return builder
         * 
         */
        public Builder memoryReservationLockedToMax(Boolean memoryReservationLockedToMax) {
            return memoryReservationLockedToMax(Output.of(memoryReservationLockedToMax));
        }

        /**
         * @param memoryShareCount The amount of shares to allocate to memory for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder memoryShareCount(@Nullable Output<Integer> memoryShareCount) {
            $.memoryShareCount = memoryShareCount;
            return this;
        }

        /**
         * @param memoryShareCount The amount of shares to allocate to memory for a custom share level.
         * 
         * @return builder
         * 
         */
        public Builder memoryShareCount(Integer memoryShareCount) {
            return memoryShareCount(Output.of(memoryShareCount));
        }

        /**
         * @param memoryShareLevel The allocation level for memory resources. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder memoryShareLevel(@Nullable Output<String> memoryShareLevel) {
            $.memoryShareLevel = memoryShareLevel;
            return this;
        }

        /**
         * @param memoryShareLevel The allocation level for memory resources. Can be one of high, low, normal, or custom.
         * 
         * @return builder
         * 
         */
        public Builder memoryShareLevel(String memoryShareLevel) {
            return memoryShareLevel(Output.of(memoryShareLevel));
        }

        /**
         * @param migrateWaitTimeout The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
         * 
         * @return builder
         * 
         */
        public Builder migrateWaitTimeout(@Nullable Output<Integer> migrateWaitTimeout) {
            $.migrateWaitTimeout = migrateWaitTimeout;
            return this;
        }

        /**
         * @param migrateWaitTimeout The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
         * 
         * @return builder
         * 
         */
        public Builder migrateWaitTimeout(Integer migrateWaitTimeout) {
            return migrateWaitTimeout(Output.of(migrateWaitTimeout));
        }

        /**
         * @param name The name of this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param nestedHvEnabled Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
         * 
         * @return builder
         * 
         */
        public Builder nestedHvEnabled(@Nullable Output<Boolean> nestedHvEnabled) {
            $.nestedHvEnabled = nestedHvEnabled;
            return this;
        }

        /**
         * @param nestedHvEnabled Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
         * 
         * @return builder
         * 
         */
        public Builder nestedHvEnabled(Boolean nestedHvEnabled) {
            return nestedHvEnabled(Output.of(nestedHvEnabled));
        }

        /**
         * @param networkInterfaces A specification for a virtual NIC on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder networkInterfaces(@Nullable Output<List<VirtualMachineNetworkInterfaceArgs>> networkInterfaces) {
            $.networkInterfaces = networkInterfaces;
            return this;
        }

        /**
         * @param networkInterfaces A specification for a virtual NIC on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder networkInterfaces(List<VirtualMachineNetworkInterfaceArgs> networkInterfaces) {
            return networkInterfaces(Output.of(networkInterfaces));
        }

        /**
         * @param networkInterfaces A specification for a virtual NIC on this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder networkInterfaces(VirtualMachineNetworkInterfaceArgs... networkInterfaces) {
            return networkInterfaces(List.of(networkInterfaces));
        }

        /**
         * @param numCoresPerSocket The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus must be evenly divisible by this value.
         * 
         * @return builder
         * 
         */
        public Builder numCoresPerSocket(@Nullable Output<Integer> numCoresPerSocket) {
            $.numCoresPerSocket = numCoresPerSocket;
            return this;
        }

        /**
         * @param numCoresPerSocket The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus must be evenly divisible by this value.
         * 
         * @return builder
         * 
         */
        public Builder numCoresPerSocket(Integer numCoresPerSocket) {
            return numCoresPerSocket(Output.of(numCoresPerSocket));
        }

        /**
         * @param numCpus The number of virtual processors to assign to this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder numCpus(@Nullable Output<Integer> numCpus) {
            $.numCpus = numCpus;
            return this;
        }

        /**
         * @param numCpus The number of virtual processors to assign to this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder numCpus(Integer numCpus) {
            return numCpus(Output.of(numCpus));
        }

        public Builder nvmeControllerCount(@Nullable Output<Integer> nvmeControllerCount) {
            $.nvmeControllerCount = nvmeControllerCount;
            return this;
        }

        public Builder nvmeControllerCount(Integer nvmeControllerCount) {
            return nvmeControllerCount(Output.of(nvmeControllerCount));
        }

        /**
         * @param ovfDeploy A specification for deploying a virtual machine from ovf/ova template.
         * 
         * @return builder
         * 
         */
        public Builder ovfDeploy(@Nullable Output<VirtualMachineOvfDeployArgs> ovfDeploy) {
            $.ovfDeploy = ovfDeploy;
            return this;
        }

        /**
         * @param ovfDeploy A specification for deploying a virtual machine from ovf/ova template.
         * 
         * @return builder
         * 
         */
        public Builder ovfDeploy(VirtualMachineOvfDeployArgs ovfDeploy) {
            return ovfDeploy(Output.of(ovfDeploy));
        }

        /**
         * @param pciDeviceIds A list of PCI passthrough devices
         * 
         * @return builder
         * 
         */
        public Builder pciDeviceIds(@Nullable Output<List<String>> pciDeviceIds) {
            $.pciDeviceIds = pciDeviceIds;
            return this;
        }

        /**
         * @param pciDeviceIds A list of PCI passthrough devices
         * 
         * @return builder
         * 
         */
        public Builder pciDeviceIds(List<String> pciDeviceIds) {
            return pciDeviceIds(Output.of(pciDeviceIds));
        }

        /**
         * @param pciDeviceIds A list of PCI passthrough devices
         * 
         * @return builder
         * 
         */
        public Builder pciDeviceIds(String... pciDeviceIds) {
            return pciDeviceIds(List.of(pciDeviceIds));
        }

        /**
         * @param poweronTimeout The amount of time, in seconds, that we will be trying to power on a VM
         * 
         * @return builder
         * 
         */
        public Builder poweronTimeout(@Nullable Output<Integer> poweronTimeout) {
            $.poweronTimeout = poweronTimeout;
            return this;
        }

        /**
         * @param poweronTimeout The amount of time, in seconds, that we will be trying to power on a VM
         * 
         * @return builder
         * 
         */
        public Builder poweronTimeout(Integer poweronTimeout) {
            return poweronTimeout(Output.of(poweronTimeout));
        }

        /**
         * @param replaceTrigger Triggers replacement of resource whenever it changes.
         * 
         * @return builder
         * 
         */
        public Builder replaceTrigger(@Nullable Output<String> replaceTrigger) {
            $.replaceTrigger = replaceTrigger;
            return this;
        }

        /**
         * @param replaceTrigger Triggers replacement of resource whenever it changes.
         * 
         * @return builder
         * 
         */
        public Builder replaceTrigger(String replaceTrigger) {
            return replaceTrigger(Output.of(replaceTrigger));
        }

        /**
         * @param resourcePoolId The ID of a resource pool to put the virtual machine in.
         * 
         * @return builder
         * 
         */
        public Builder resourcePoolId(Output<String> resourcePoolId) {
            $.resourcePoolId = resourcePoolId;
            return this;
        }

        /**
         * @param resourcePoolId The ID of a resource pool to put the virtual machine in.
         * 
         * @return builder
         * 
         */
        public Builder resourcePoolId(String resourcePoolId) {
            return resourcePoolId(Output.of(resourcePoolId));
        }

        /**
         * @param runToolsScriptsAfterPowerOn Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsAfterPowerOn(@Nullable Output<Boolean> runToolsScriptsAfterPowerOn) {
            $.runToolsScriptsAfterPowerOn = runToolsScriptsAfterPowerOn;
            return this;
        }

        /**
         * @param runToolsScriptsAfterPowerOn Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsAfterPowerOn(Boolean runToolsScriptsAfterPowerOn) {
            return runToolsScriptsAfterPowerOn(Output.of(runToolsScriptsAfterPowerOn));
        }

        /**
         * @param runToolsScriptsAfterResume Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsAfterResume(@Nullable Output<Boolean> runToolsScriptsAfterResume) {
            $.runToolsScriptsAfterResume = runToolsScriptsAfterResume;
            return this;
        }

        /**
         * @param runToolsScriptsAfterResume Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsAfterResume(Boolean runToolsScriptsAfterResume) {
            return runToolsScriptsAfterResume(Output.of(runToolsScriptsAfterResume));
        }

        /**
         * @param runToolsScriptsBeforeGuestReboot Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsBeforeGuestReboot(@Nullable Output<Boolean> runToolsScriptsBeforeGuestReboot) {
            $.runToolsScriptsBeforeGuestReboot = runToolsScriptsBeforeGuestReboot;
            return this;
        }

        /**
         * @param runToolsScriptsBeforeGuestReboot Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsBeforeGuestReboot(Boolean runToolsScriptsBeforeGuestReboot) {
            return runToolsScriptsBeforeGuestReboot(Output.of(runToolsScriptsBeforeGuestReboot));
        }

        /**
         * @param runToolsScriptsBeforeGuestShutdown Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsBeforeGuestShutdown(@Nullable Output<Boolean> runToolsScriptsBeforeGuestShutdown) {
            $.runToolsScriptsBeforeGuestShutdown = runToolsScriptsBeforeGuestShutdown;
            return this;
        }

        /**
         * @param runToolsScriptsBeforeGuestShutdown Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsBeforeGuestShutdown(Boolean runToolsScriptsBeforeGuestShutdown) {
            return runToolsScriptsBeforeGuestShutdown(Output.of(runToolsScriptsBeforeGuestShutdown));
        }

        /**
         * @param runToolsScriptsBeforeGuestStandby Enable the run of scripts before guest operating system standby when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsBeforeGuestStandby(@Nullable Output<Boolean> runToolsScriptsBeforeGuestStandby) {
            $.runToolsScriptsBeforeGuestStandby = runToolsScriptsBeforeGuestStandby;
            return this;
        }

        /**
         * @param runToolsScriptsBeforeGuestStandby Enable the run of scripts before guest operating system standby when VMware Tools is installed.
         * 
         * @return builder
         * 
         */
        public Builder runToolsScriptsBeforeGuestStandby(Boolean runToolsScriptsBeforeGuestStandby) {
            return runToolsScriptsBeforeGuestStandby(Output.of(runToolsScriptsBeforeGuestStandby));
        }

        public Builder sataControllerCount(@Nullable Output<Integer> sataControllerCount) {
            $.sataControllerCount = sataControllerCount;
            return this;
        }

        public Builder sataControllerCount(Integer sataControllerCount) {
            return sataControllerCount(Output.of(sataControllerCount));
        }

        /**
         * @param scsiBusSharing Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
         * 
         * @return builder
         * 
         */
        public Builder scsiBusSharing(@Nullable Output<String> scsiBusSharing) {
            $.scsiBusSharing = scsiBusSharing;
            return this;
        }

        /**
         * @param scsiBusSharing Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
         * 
         * @return builder
         * 
         */
        public Builder scsiBusSharing(String scsiBusSharing) {
            return scsiBusSharing(Output.of(scsiBusSharing));
        }

        public Builder scsiControllerCount(@Nullable Output<Integer> scsiControllerCount) {
            $.scsiControllerCount = scsiControllerCount;
            return this;
        }

        public Builder scsiControllerCount(Integer scsiControllerCount) {
            return scsiControllerCount(Output.of(scsiControllerCount));
        }

        /**
         * @param scsiType The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
         * 
         * @return builder
         * 
         */
        public Builder scsiType(@Nullable Output<String> scsiType) {
            $.scsiType = scsiType;
            return this;
        }

        /**
         * @param scsiType The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
         * 
         * @return builder
         * 
         */
        public Builder scsiType(String scsiType) {
            return scsiType(Output.of(scsiType));
        }

        /**
         * @param shutdownWaitTimeout The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder shutdownWaitTimeout(@Nullable Output<Integer> shutdownWaitTimeout) {
            $.shutdownWaitTimeout = shutdownWaitTimeout;
            return this;
        }

        /**
         * @param shutdownWaitTimeout The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder shutdownWaitTimeout(Integer shutdownWaitTimeout) {
            return shutdownWaitTimeout(Output.of(shutdownWaitTimeout));
        }

        /**
         * @param storagePolicyId The ID of the storage policy to assign to the virtual machine home directory.
         * 
         * @return builder
         * 
         */
        public Builder storagePolicyId(@Nullable Output<String> storagePolicyId) {
            $.storagePolicyId = storagePolicyId;
            return this;
        }

        /**
         * @param storagePolicyId The ID of the storage policy to assign to the virtual machine home directory.
         * 
         * @return builder
         * 
         */
        public Builder storagePolicyId(String storagePolicyId) {
            return storagePolicyId(Output.of(storagePolicyId));
        }

        /**
         * @param swapPlacementPolicy The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
         * 
         * @return builder
         * 
         */
        public Builder swapPlacementPolicy(@Nullable Output<String> swapPlacementPolicy) {
            $.swapPlacementPolicy = swapPlacementPolicy;
            return this;
        }

        /**
         * @param swapPlacementPolicy The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
         * 
         * @return builder
         * 
         */
        public Builder swapPlacementPolicy(String swapPlacementPolicy) {
            return swapPlacementPolicy(Output.of(swapPlacementPolicy));
        }

        /**
         * @param syncTimeWithHost Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
         * 
         * @return builder
         * 
         */
        public Builder syncTimeWithHost(@Nullable Output<Boolean> syncTimeWithHost) {
            $.syncTimeWithHost = syncTimeWithHost;
            return this;
        }

        /**
         * @param syncTimeWithHost Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
         * 
         * @return builder
         * 
         */
        public Builder syncTimeWithHost(Boolean syncTimeWithHost) {
            return syncTimeWithHost(Output.of(syncTimeWithHost));
        }

        /**
         * @param syncTimeWithHostPeriodically Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.
         * 
         * @return builder
         * 
         */
        public Builder syncTimeWithHostPeriodically(@Nullable Output<Boolean> syncTimeWithHostPeriodically) {
            $.syncTimeWithHostPeriodically = syncTimeWithHostPeriodically;
            return this;
        }

        /**
         * @param syncTimeWithHostPeriodically Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.
         * 
         * @return builder
         * 
         */
        public Builder syncTimeWithHostPeriodically(Boolean syncTimeWithHostPeriodically) {
            return syncTimeWithHostPeriodically(Output.of(syncTimeWithHostPeriodically));
        }

        /**
         * @param tags A list of tag IDs to apply to this object.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags A list of tag IDs to apply to this object.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags A list of tag IDs to apply to this object.
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param toolsUpgradePolicy Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.
         * 
         * @return builder
         * 
         */
        public Builder toolsUpgradePolicy(@Nullable Output<String> toolsUpgradePolicy) {
            $.toolsUpgradePolicy = toolsUpgradePolicy;
            return this;
        }

        /**
         * @param toolsUpgradePolicy Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.
         * 
         * @return builder
         * 
         */
        public Builder toolsUpgradePolicy(String toolsUpgradePolicy) {
            return toolsUpgradePolicy(Output.of(toolsUpgradePolicy));
        }

        /**
         * @param vapp vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
         * 
         * @return builder
         * 
         */
        public Builder vapp(@Nullable Output<VirtualMachineVappArgs> vapp) {
            $.vapp = vapp;
            return this;
        }

        /**
         * @param vapp vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
         * 
         * @return builder
         * 
         */
        public Builder vapp(VirtualMachineVappArgs vapp) {
            return vapp(Output.of(vapp));
        }

        /**
         * @param vbsEnabled Flag to specify if Virtualization-based security is enabled for this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder vbsEnabled(@Nullable Output<Boolean> vbsEnabled) {
            $.vbsEnabled = vbsEnabled;
            return this;
        }

        /**
         * @param vbsEnabled Flag to specify if Virtualization-based security is enabled for this virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder vbsEnabled(Boolean vbsEnabled) {
            return vbsEnabled(Output.of(vbsEnabled));
        }

        /**
         * @param vtpm A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder vtpm(@Nullable Output<VirtualMachineVtpmArgs> vtpm) {
            $.vtpm = vtpm;
            return this;
        }

        /**
         * @param vtpm A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.
         * 
         * @return builder
         * 
         */
        public Builder vtpm(VirtualMachineVtpmArgs vtpm) {
            return vtpm(Output.of(vtpm));
        }

        /**
         * @param vvtdEnabled Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
         * 
         * @return builder
         * 
         */
        public Builder vvtdEnabled(@Nullable Output<Boolean> vvtdEnabled) {
            $.vvtdEnabled = vvtdEnabled;
            return this;
        }

        /**
         * @param vvtdEnabled Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
         * 
         * @return builder
         * 
         */
        public Builder vvtdEnabled(Boolean vvtdEnabled) {
            return vvtdEnabled(Output.of(vvtdEnabled));
        }

        /**
         * @param waitForGuestIpTimeout The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
         * 
         * @return builder
         * 
         */
        public Builder waitForGuestIpTimeout(@Nullable Output<Integer> waitForGuestIpTimeout) {
            $.waitForGuestIpTimeout = waitForGuestIpTimeout;
            return this;
        }

        /**
         * @param waitForGuestIpTimeout The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
         * 
         * @return builder
         * 
         */
        public Builder waitForGuestIpTimeout(Integer waitForGuestIpTimeout) {
            return waitForGuestIpTimeout(Output.of(waitForGuestIpTimeout));
        }

        /**
         * @param waitForGuestNetRoutable Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
         * 
         * @return builder
         * 
         */
        public Builder waitForGuestNetRoutable(@Nullable Output<Boolean> waitForGuestNetRoutable) {
            $.waitForGuestNetRoutable = waitForGuestNetRoutable;
            return this;
        }

        /**
         * @param waitForGuestNetRoutable Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
         * 
         * @return builder
         * 
         */
        public Builder waitForGuestNetRoutable(Boolean waitForGuestNetRoutable) {
            return waitForGuestNetRoutable(Output.of(waitForGuestNetRoutable));
        }

        /**
         * @param waitForGuestNetTimeout The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
         * 
         * @return builder
         * 
         */
        public Builder waitForGuestNetTimeout(@Nullable Output<Integer> waitForGuestNetTimeout) {
            $.waitForGuestNetTimeout = waitForGuestNetTimeout;
            return this;
        }

        /**
         * @param waitForGuestNetTimeout The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
         * 
         * @return builder
         * 
         */
        public Builder waitForGuestNetTimeout(Integer waitForGuestNetTimeout) {
            return waitForGuestNetTimeout(Output.of(waitForGuestNetTimeout));
        }

        public VirtualMachineArgs build() {
            if ($.resourcePoolId == null) {
                throw new MissingRequiredPropertyException("VirtualMachineArgs", "resourcePoolId");
            }
            return $;
        }
    }

}
