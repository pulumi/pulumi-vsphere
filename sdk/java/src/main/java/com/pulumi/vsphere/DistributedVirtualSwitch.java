// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
import com.pulumi.vsphere.Utilities;
import com.pulumi.vsphere.inputs.DistributedVirtualSwitchState;
import com.pulumi.vsphere.outputs.DistributedVirtualSwitchHost;
import com.pulumi.vsphere.outputs.DistributedVirtualSwitchPvlanMapping;
import com.pulumi.vsphere.outputs.DistributedVirtualSwitchVlanRange;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

@ResourceType(type="vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch")
public class DistributedVirtualSwitch extends com.pulumi.resources.CustomResource {
    /**
     * A list of active uplinks to be used in load
     * balancing. These uplinks need to match the definitions in the
     * `uplinks` VDS argument. See
     * here for more details.
     * 
     */
    @Export(name="activeUplinks", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> activeUplinks;

    /**
     * @return A list of active uplinks to be used in load
     * balancing. These uplinks need to match the definitions in the
     * `uplinks` VDS argument. See
     * here for more details.
     * 
     */
    public Output<List<String>> activeUplinks() {
        return this.activeUplinks;
    }
    /**
     * Controls whether or not a virtual
     * network adapter is allowed to send network traffic with a different MAC
     * address than that of its own.
     * 
     */
    @Export(name="allowForgedTransmits", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowForgedTransmits;

    /**
     * @return Controls whether or not a virtual
     * network adapter is allowed to send network traffic with a different MAC
     * address than that of its own.
     * 
     */
    public Output<Boolean> allowForgedTransmits() {
        return this.allowForgedTransmits;
    }
    /**
     * Controls whether or not the Media Access
     * Control (MAC) address can be changed.
     * 
     */
    @Export(name="allowMacChanges", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowMacChanges;

    /**
     * @return Controls whether or not the Media Access
     * Control (MAC) address can be changed.
     * 
     */
    public Output<Boolean> allowMacChanges() {
        return this.allowMacChanges;
    }
    /**
     * Enable promiscuous mode on the network. This
     * flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    @Export(name="allowPromiscuous", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowPromiscuous;

    /**
     * @return Enable promiscuous mode on the network. This
     * flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    public Output<Boolean> allowPromiscuous() {
        return this.allowPromiscuous;
    }
    /**
     * The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    @Export(name="backupnfcMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> backupnfcMaximumMbit;

    /**
     * @return The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> backupnfcMaximumMbit() {
        return this.backupnfcMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    @Export(name="backupnfcReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> backupnfcReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> backupnfcReservationMbit() {
        return this.backupnfcReservationMbit;
    }
    /**
     * The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     * 
     */
    @Export(name="backupnfcShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> backupnfcShareCount;

    /**
     * @return The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     * 
     */
    public Output<Integer> backupnfcShareCount() {
        return this.backupnfcShareCount;
    }
    /**
     * The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="backupnfcShareLevel", refs={String.class}, tree="[0]")
    private Output<String> backupnfcShareLevel;

    /**
     * @return The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> backupnfcShareLevel() {
        return this.backupnfcShareLevel;
    }
    /**
     * Shuts down all ports in the port groups that
     * this policy applies to, effectively blocking all network access to connected
     * virtual devices.
     * 
     */
    @Export(name="blockAllPorts", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> blockAllPorts;

    /**
     * @return Shuts down all ports in the port groups that
     * this policy applies to, effectively blocking all network access to connected
     * virtual devices.
     * 
     */
    public Output<Boolean> blockAllPorts() {
        return this.blockAllPorts;
    }
    /**
     * Enables beacon probing as an additional measure
     * to detect NIC failure.
     * 
     * &gt; **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon
     * probing.
     * 
     */
    @Export(name="checkBeacon", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> checkBeacon;

    /**
     * @return Enables beacon probing as an additional measure
     * to detect NIC failure.
     * 
     * &gt; **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon
     * probing.
     * 
     */
    public Output<Boolean> checkBeacon() {
        return this.checkBeacon;
    }
    /**
     * The current version of the VDS configuration, incremented
     * by subsequent updates to the VDS.
     * 
     */
    @Export(name="configVersion", refs={String.class}, tree="[0]")
    private Output<String> configVersion;

    /**
     * @return The current version of the VDS configuration, incremented
     * by subsequent updates to the VDS.
     * 
     */
    public Output<String> configVersion() {
        return this.configVersion;
    }
    /**
     * The detailed contact information for the person
     * who is responsible for the VDS.
     * 
     */
    @Export(name="contactDetail", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> contactDetail;

    /**
     * @return The detailed contact information for the person
     * who is responsible for the VDS.
     * 
     */
    public Output<Optional<String>> contactDetail() {
        return Codegen.optional(this.contactDetail);
    }
    /**
     * The name of the person who is responsible for the
     * VDS.
     * 
     */
    @Export(name="contactName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> contactName;

    /**
     * @return The name of the person who is responsible for the
     * VDS.
     * 
     */
    public Output<Optional<String>> contactName() {
        return Codegen.optional(this.contactName);
    }
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for VDS.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
     * and requires vCenter Server.
     * 
     */
    @Export(name="customAttributes", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> customAttributes;

    /**
     * @return Map of custom attribute ids to attribute
     * value strings to set for VDS.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
     * and requires vCenter Server.
     * 
     */
    public Output<Optional<Map<String,String>>> customAttributes() {
        return Codegen.optional(this.customAttributes);
    }
    /**
     * The ID of the datacenter where the VDS will be
     * created. Forces a new resource if changed.
     * 
     */
    @Export(name="datacenterId", refs={String.class}, tree="[0]")
    private Output<String> datacenterId;

    /**
     * @return The ID of the datacenter where the VDS will be
     * created. Forces a new resource if changed.
     * 
     */
    public Output<String> datacenterId() {
        return this.datacenterId;
    }
    /**
     * A detailed description for the VDS.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return A detailed description for the VDS.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Allow VMDirectPath Gen2 for the ports
     * for which this policy applies to.
     * 
     */
    @Export(name="directpathGen2Allowed", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> directpathGen2Allowed;

    /**
     * @return Allow VMDirectPath Gen2 for the ports
     * for which this policy applies to.
     * 
     */
    public Output<Boolean> directpathGen2Allowed() {
        return this.directpathGen2Allowed;
    }
    /**
     * The average bandwidth in bits
     * per second if egress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="egressShapingAverageBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> egressShapingAverageBandwidth;

    /**
     * @return The average bandwidth in bits
     * per second if egress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> egressShapingAverageBandwidth() {
        return this.egressShapingAverageBandwidth;
    }
    /**
     * The maximum burst size allowed in
     * bytes if egress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="egressShapingBurstSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> egressShapingBurstSize;

    /**
     * @return The maximum burst size allowed in
     * bytes if egress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> egressShapingBurstSize() {
        return this.egressShapingBurstSize;
    }
    /**
     * `true` if the traffic shaper is enabled
     * on the port for egress traffic.
     * 
     */
    @Export(name="egressShapingEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> egressShapingEnabled;

    /**
     * @return `true` if the traffic shaper is enabled
     * on the port for egress traffic.
     * 
     */
    public Output<Boolean> egressShapingEnabled() {
        return this.egressShapingEnabled;
    }
    /**
     * The peak bandwidth during bursts
     * in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="egressShapingPeakBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> egressShapingPeakBandwidth;

    /**
     * @return The peak bandwidth during bursts
     * in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> egressShapingPeakBandwidth() {
        return this.egressShapingPeakBandwidth;
    }
    /**
     * If `true`, the teaming policy will re-activate failed
     * uplinks higher in precedence when they come back up.
     * 
     */
    @Export(name="failback", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> failback;

    /**
     * @return If `true`, the teaming policy will re-activate failed
     * uplinks higher in precedence when they come back up.
     * 
     */
    public Output<Boolean> failback() {
        return this.failback;
    }
    /**
     * The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    @Export(name="faulttoleranceMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> faulttoleranceMaximumMbit;

    /**
     * @return The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> faulttoleranceMaximumMbit() {
        return this.faulttoleranceMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    @Export(name="faulttoleranceReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> faulttoleranceReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> faulttoleranceReservationMbit() {
        return this.faulttoleranceReservationMbit;
    }
    /**
     * The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     * 
     */
    @Export(name="faulttoleranceShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> faulttoleranceShareCount;

    /**
     * @return The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     * 
     */
    public Output<Integer> faulttoleranceShareCount() {
        return this.faulttoleranceShareCount;
    }
    /**
     * The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="faulttoleranceShareLevel", refs={String.class}, tree="[0]")
    private Output<String> faulttoleranceShareLevel;

    /**
     * @return The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> faulttoleranceShareLevel() {
        return this.faulttoleranceShareLevel;
    }
    /**
     * The folder in which to create the VDS.
     * Forces a new resource if changed.
     * 
     */
    @Export(name="folder", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> folder;

    /**
     * @return The folder in which to create the VDS.
     * Forces a new resource if changed.
     * 
     */
    public Output<Optional<String>> folder() {
        return Codegen.optional(this.folder);
    }
    /**
     * The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     * 
     */
    @Export(name="hbrMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> hbrMaximumMbit;

    /**
     * @return The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> hbrMaximumMbit() {
        return this.hbrMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     * 
     */
    @Export(name="hbrReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> hbrReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> hbrReservationMbit() {
        return this.hbrReservationMbit;
    }
    /**
     * The amount of shares to allocate to the hbr traffic class for a custom share level.
     * 
     */
    @Export(name="hbrShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> hbrShareCount;

    /**
     * @return The amount of shares to allocate to the hbr traffic class for a custom share level.
     * 
     */
    public Output<Integer> hbrShareCount() {
        return this.hbrShareCount;
    }
    /**
     * The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="hbrShareLevel", refs={String.class}, tree="[0]")
    private Output<String> hbrShareLevel;

    /**
     * @return The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> hbrShareLevel() {
        return this.hbrShareLevel;
    }
    /**
     * Use the `host` block to declare a host specification. The
     * options are:
     * 
     */
    @Export(name="hosts", refs={List.class,DistributedVirtualSwitchHost.class}, tree="[0,1]")
    private Output</* @Nullable */ List<DistributedVirtualSwitchHost>> hosts;

    /**
     * @return Use the `host` block to declare a host specification. The
     * options are:
     * 
     */
    public Output<Optional<List<DistributedVirtualSwitchHost>>> hosts() {
        return Codegen.optional(this.hosts);
    }
    /**
     * Whether to ignore existing PVLAN
     * mappings not managed by this resource. Defaults to false.
     * 
     */
    @Export(name="ignoreOtherPvlanMappings", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ignoreOtherPvlanMappings;

    /**
     * @return Whether to ignore existing PVLAN
     * mappings not managed by this resource. Defaults to false.
     * 
     */
    public Output<Optional<Boolean>> ignoreOtherPvlanMappings() {
        return Codegen.optional(this.ignoreOtherPvlanMappings);
    }
    /**
     * The average bandwidth in
     * bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="ingressShapingAverageBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> ingressShapingAverageBandwidth;

    /**
     * @return The average bandwidth in
     * bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> ingressShapingAverageBandwidth() {
        return this.ingressShapingAverageBandwidth;
    }
    /**
     * The maximum burst size allowed in
     * bytes if ingress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="ingressShapingBurstSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> ingressShapingBurstSize;

    /**
     * @return The maximum burst size allowed in
     * bytes if ingress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> ingressShapingBurstSize() {
        return this.ingressShapingBurstSize;
    }
    /**
     * `true` if the traffic shaper is
     * enabled on the port for ingress traffic.
     * 
     */
    @Export(name="ingressShapingEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> ingressShapingEnabled;

    /**
     * @return `true` if the traffic shaper is
     * enabled on the port for ingress traffic.
     * 
     */
    public Output<Boolean> ingressShapingEnabled() {
        return this.ingressShapingEnabled;
    }
    /**
     * The peak bandwidth during
     * bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="ingressShapingPeakBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> ingressShapingPeakBandwidth;

    /**
     * @return The peak bandwidth during
     * bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> ingressShapingPeakBandwidth() {
        return this.ingressShapingPeakBandwidth;
    }
    /**
     * An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments.
     * 
     */
    @Export(name="ipv4Address", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4Address;

    /**
     * @return An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments.
     * 
     */
    public Output<Optional<String>> ipv4Address() {
        return Codegen.optional(this.ipv4Address);
    }
    /**
     * The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    @Export(name="iscsiMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> iscsiMaximumMbit;

    /**
     * @return The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> iscsiMaximumMbit() {
        return this.iscsiMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    @Export(name="iscsiReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> iscsiReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> iscsiReservationMbit() {
        return this.iscsiReservationMbit;
    }
    /**
     * The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     * 
     */
    @Export(name="iscsiShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> iscsiShareCount;

    /**
     * @return The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     * 
     */
    public Output<Integer> iscsiShareCount() {
        return this.iscsiShareCount;
    }
    /**
     * The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="iscsiShareLevel", refs={String.class}, tree="[0]")
    private Output<String> iscsiShareLevel;

    /**
     * @return The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> iscsiShareLevel() {
        return this.iscsiShareLevel;
    }
    /**
     * The Link Aggregation Control Protocol group
     * version to use with the VDS. Possible values are `singleLag` and
     * `multipleLag`.
     * 
     */
    @Export(name="lacpApiVersion", refs={String.class}, tree="[0]")
    private Output<String> lacpApiVersion;

    /**
     * @return The Link Aggregation Control Protocol group
     * version to use with the VDS. Possible values are `singleLag` and
     * `multipleLag`.
     * 
     */
    public Output<String> lacpApiVersion() {
        return this.lacpApiVersion;
    }
    /**
     * Enables LACP for the ports that this policy
     * applies to.
     * 
     */
    @Export(name="lacpEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> lacpEnabled;

    /**
     * @return Enables LACP for the ports that this policy
     * applies to.
     * 
     */
    public Output<Boolean> lacpEnabled() {
        return this.lacpEnabled;
    }
    /**
     * The LACP mode. Can be one of `active` or `passive`.
     * 
     */
    @Export(name="lacpMode", refs={String.class}, tree="[0]")
    private Output<String> lacpMode;

    /**
     * @return The LACP mode. Can be one of `active` or `passive`.
     * 
     */
    public Output<String> lacpMode() {
        return this.lacpMode;
    }
    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic.
     * 
     */
    @Export(name="linkDiscoveryOperation", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> linkDiscoveryOperation;

    /**
     * @return Whether to `advertise` or `listen`
     * for link discovery traffic.
     * 
     */
    public Output<Optional<String>> linkDiscoveryOperation() {
        return Codegen.optional(this.linkDiscoveryOperation);
    }
    /**
     * The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     * 
     */
    @Export(name="linkDiscoveryProtocol", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> linkDiscoveryProtocol;

    /**
     * @return The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     * 
     */
    public Output<Optional<String>> linkDiscoveryProtocol() {
        return Codegen.optional(this.linkDiscoveryProtocol);
    }
    /**
     * The maximum allowed usage for the management traffic class, in Mbits/sec.
     * 
     */
    @Export(name="managementMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> managementMaximumMbit;

    /**
     * @return The maximum allowed usage for the management traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> managementMaximumMbit() {
        return this.managementMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     * 
     */
    @Export(name="managementReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> managementReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> managementReservationMbit() {
        return this.managementReservationMbit;
    }
    /**
     * The amount of shares to allocate to the management traffic class for a custom share level.
     * 
     */
    @Export(name="managementShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> managementShareCount;

    /**
     * @return The amount of shares to allocate to the management traffic class for a custom share level.
     * 
     */
    public Output<Integer> managementShareCount() {
        return this.managementShareCount;
    }
    /**
     * The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="managementShareLevel", refs={String.class}, tree="[0]")
    private Output<String> managementShareLevel;

    /**
     * @return The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> managementShareLevel() {
        return this.managementShareLevel;
    }
    /**
     * The maximum transmission unit (MTU) for the VDS.
     * 
     */
    @Export(name="maxMtu", refs={Integer.class}, tree="[0]")
    private Output<Integer> maxMtu;

    /**
     * @return The maximum transmission unit (MTU) for the VDS.
     * 
     */
    public Output<Integer> maxMtu() {
        return this.maxMtu;
    }
    /**
     * The multicast filtering mode to use
     * with the VDS. Can be one of `legacyFiltering` or `snooping`.
     * 
     */
    @Export(name="multicastFilteringMode", refs={String.class}, tree="[0]")
    private Output<String> multicastFilteringMode;

    /**
     * @return The multicast filtering mode to use
     * with the VDS. Can be one of `legacyFiltering` or `snooping`.
     * 
     */
    public Output<String> multicastFilteringMode() {
        return this.multicastFilteringMode;
    }
    /**
     * The name of the VDS.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the VDS.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The number of seconds after which
     * active flows are forced to be exported to the collector. Allowed range is
     * `60` to `3600`. Default: `60`.
     * 
     */
    @Export(name="netflowActiveFlowTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowActiveFlowTimeout;

    /**
     * @return The number of seconds after which
     * active flows are forced to be exported to the collector. Allowed range is
     * `60` to `3600`. Default: `60`.
     * 
     */
    public Output<Optional<Integer>> netflowActiveFlowTimeout() {
        return Codegen.optional(this.netflowActiveFlowTimeout);
    }
    /**
     * IP address for the Netflow
     * collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
     * Must be set before Netflow can be enabled.
     * 
     */
    @Export(name="netflowCollectorIpAddress", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> netflowCollectorIpAddress;

    /**
     * @return IP address for the Netflow
     * collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
     * Must be set before Netflow can be enabled.
     * 
     */
    public Output<Optional<String>> netflowCollectorIpAddress() {
        return Codegen.optional(this.netflowCollectorIpAddress);
    }
    /**
     * Port for the Netflow collector. This
     * must be set before Netflow can be enabled.
     * 
     */
    @Export(name="netflowCollectorPort", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowCollectorPort;

    /**
     * @return Port for the Netflow collector. This
     * must be set before Netflow can be enabled.
     * 
     */
    public Output<Optional<Integer>> netflowCollectorPort() {
        return Codegen.optional(this.netflowCollectorPort);
    }
    /**
     * Enables Netflow on all ports that this policy
     * applies to.
     * 
     */
    @Export(name="netflowEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> netflowEnabled;

    /**
     * @return Enables Netflow on all ports that this policy
     * applies to.
     * 
     */
    public Output<Boolean> netflowEnabled() {
        return this.netflowEnabled;
    }
    /**
     * The number of seconds after which
     * idle flows are forced to be exported to the collector. Allowed range is `10`
     * to `600`. Default: `15`.
     * 
     */
    @Export(name="netflowIdleFlowTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowIdleFlowTimeout;

    /**
     * @return The number of seconds after which
     * idle flows are forced to be exported to the collector. Allowed range is `10`
     * to `600`. Default: `15`.
     * 
     */
    public Output<Optional<Integer>> netflowIdleFlowTimeout() {
        return Codegen.optional(this.netflowIdleFlowTimeout);
    }
    /**
     * Whether to limit analysis to
     * traffic that has both source and destination served by the same host.
     * Default: `false`.
     * 
     */
    @Export(name="netflowInternalFlowsOnly", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> netflowInternalFlowsOnly;

    /**
     * @return Whether to limit analysis to
     * traffic that has both source and destination served by the same host.
     * Default: `false`.
     * 
     */
    public Output<Optional<Boolean>> netflowInternalFlowsOnly() {
        return Codegen.optional(this.netflowInternalFlowsOnly);
    }
    /**
     * The observation domain ID for
     * the Netflow collector.
     * 
     */
    @Export(name="netflowObservationDomainId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowObservationDomainId;

    /**
     * @return The observation domain ID for
     * the Netflow collector.
     * 
     */
    public Output<Optional<Integer>> netflowObservationDomainId() {
        return Codegen.optional(this.netflowObservationDomainId);
    }
    /**
     * The ratio of total number of packets to
     * the number of packets analyzed. The default is `0`, which indicates that the
     * VDS should analyze all packets. The maximum value is `1000`, which
     * indicates an analysis rate of 0.001%!
     * (MISSING)
     * 
     */
    @Export(name="netflowSamplingRate", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowSamplingRate;

    /**
     * @return The ratio of total number of packets to
     * the number of packets analyzed. The default is `0`, which indicates that the
     * VDS should analyze all packets. The maximum value is `1000`, which
     * indicates an analysis rate of 0.001%!
     * (MISSING)
     * 
     */
    public Output<Optional<Integer>> netflowSamplingRate() {
        return Codegen.optional(this.netflowSamplingRate);
    }
    /**
     * Set to `true` to enable
     * network I/O control. Default: `false`.
     * 
     */
    @Export(name="networkResourceControlEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> networkResourceControlEnabled;

    /**
     * @return Set to `true` to enable
     * network I/O control. Default: `false`.
     * 
     */
    public Output<Optional<Boolean>> networkResourceControlEnabled() {
        return Codegen.optional(this.networkResourceControlEnabled);
    }
    /**
     * The version of network I/O
     * control to use. Can be one of `version2` or `version3`. Default: `version2`.
     * 
     */
    @Export(name="networkResourceControlVersion", refs={String.class}, tree="[0]")
    private Output<String> networkResourceControlVersion;

    /**
     * @return The version of network I/O
     * control to use. Can be one of `version2` or `version3`. Default: `version2`.
     * 
     */
    public Output<String> networkResourceControlVersion() {
        return this.networkResourceControlVersion;
    }
    /**
     * The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     * 
     */
    @Export(name="nfsMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> nfsMaximumMbit;

    /**
     * @return The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> nfsMaximumMbit() {
        return this.nfsMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     * 
     */
    @Export(name="nfsReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> nfsReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> nfsReservationMbit() {
        return this.nfsReservationMbit;
    }
    /**
     * The amount of shares to allocate to the nfs traffic class for a custom share level.
     * 
     */
    @Export(name="nfsShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> nfsShareCount;

    /**
     * @return The amount of shares to allocate to the nfs traffic class for a custom share level.
     * 
     */
    public Output<Integer> nfsShareCount() {
        return this.nfsShareCount;
    }
    /**
     * The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="nfsShareLevel", refs={String.class}, tree="[0]")
    private Output<String> nfsShareLevel;

    /**
     * @return The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> nfsShareLevel() {
        return this.nfsShareLevel;
    }
    /**
     * If `true`, the teaming policy will notify the
     * broadcast network of an uplink failover, triggering cache updates.
     * 
     */
    @Export(name="notifySwitches", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> notifySwitches;

    /**
     * @return If `true`, the teaming policy will notify the
     * broadcast network of an uplink failover, triggering cache updates.
     * 
     */
    public Output<Boolean> notifySwitches() {
        return this.notifySwitches;
    }
    /**
     * Used to define a secondary VLAN
     * ID when using private VLANs.
     * 
     */
    @Export(name="portPrivateSecondaryVlanId", refs={Integer.class}, tree="[0]")
    private Output<Integer> portPrivateSecondaryVlanId;

    /**
     * @return Used to define a secondary VLAN
     * ID when using private VLANs.
     * 
     */
    public Output<Integer> portPrivateSecondaryVlanId() {
        return this.portPrivateSecondaryVlanId;
    }
    /**
     * Use the `pvlan_mapping` block to declare a
     * private VLAN mapping. The options are:
     * 
     */
    @Export(name="pvlanMappings", refs={List.class,DistributedVirtualSwitchPvlanMapping.class}, tree="[0,1]")
    private Output</* @Nullable */ List<DistributedVirtualSwitchPvlanMapping>> pvlanMappings;

    /**
     * @return Use the `pvlan_mapping` block to declare a
     * private VLAN mapping. The options are:
     * 
     */
    public Output<Optional<List<DistributedVirtualSwitchPvlanMapping>>> pvlanMappings() {
        return Codegen.optional(this.pvlanMappings);
    }
    /**
     * A list of standby uplinks to be used in
     * failover. These uplinks need to match the definitions in the
     * `uplinks` VDS argument. See
     * here for more details.
     * 
     */
    @Export(name="standbyUplinks", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> standbyUplinks;

    /**
     * @return A list of standby uplinks to be used in
     * failover. These uplinks need to match the definitions in the
     * `uplinks` VDS argument. See
     * here for more details.
     * 
     */
    public Output<List<String>> standbyUplinks() {
        return this.standbyUplinks;
    }
    /**
     * The IDs of any tags to attach to this resource.
     * 
     * &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
     * 
     */
    @Export(name="tags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return The IDs of any tags to attach to this resource.
     * 
     * &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
     * 
     */
    public Output<Optional<List<String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * The uplink teaming policy. Can be one of
     * `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,
     * `failover_explicit`, or `loadbalance_loadbased`.
     * 
     */
    @Export(name="teamingPolicy", refs={String.class}, tree="[0]")
    private Output<String> teamingPolicy;

    /**
     * @return The uplink teaming policy. Can be one of
     * `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,
     * `failover_explicit`, or `loadbalance_loadbased`.
     * 
     */
    public Output<String> teamingPolicy() {
        return this.teamingPolicy;
    }
    /**
     * Forward all traffic transmitted by ports for which
     * this policy applies to its VDS uplinks.
     * 
     */
    @Export(name="txUplink", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> txUplink;

    /**
     * @return Forward all traffic transmitted by ports for which
     * this policy applies to its VDS uplinks.
     * 
     */
    public Output<Boolean> txUplink() {
        return this.txUplink;
    }
    /**
     * A list of strings that uniquely identifies the names
     * of the uplinks on the VDS across hosts. The number of items in this list
     * controls the number of uplinks that exist on the VDS, in addition to the
     * names. See here for an example on how to
     * use this option.
     * 
     */
    @Export(name="uplinks", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> uplinks;

    /**
     * @return A list of strings that uniquely identifies the names
     * of the uplinks on the VDS across hosts. The number of items in this list
     * controls the number of uplinks that exist on the VDS, in addition to the
     * names. See here for an example on how to
     * use this option.
     * 
     */
    public Output<List<String>> uplinks() {
        return this.uplinks;
    }
    /**
     * The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vdpMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vdpMaximumMbit;

    /**
     * @return The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vdpMaximumMbit() {
        return this.vdpMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vdpReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vdpReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vdpReservationMbit() {
        return this.vdpReservationMbit;
    }
    /**
     * The amount of shares to allocate to the vdp traffic class for a custom share level.
     * 
     */
    @Export(name="vdpShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> vdpShareCount;

    /**
     * @return The amount of shares to allocate to the vdp traffic class for a custom share level.
     * 
     */
    public Output<Integer> vdpShareCount() {
        return this.vdpShareCount;
    }
    /**
     * The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="vdpShareLevel", refs={String.class}, tree="[0]")
    private Output<String> vdpShareLevel;

    /**
     * @return The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> vdpShareLevel() {
        return this.vdpShareLevel;
    }
    /**
     * The version of the VDS. BY default, a VDS is created
     * at the latest version supported by the vSphere version if not specified.
     * A VDS can be upgraded to a newer version, but can not be downgraded.
     * 
     */
    @Export(name="version", refs={String.class}, tree="[0]")
    private Output<String> version;

    /**
     * @return The version of the VDS. BY default, a VDS is created
     * at the latest version supported by the vSphere version if not specified.
     * A VDS can be upgraded to a newer version, but can not be downgraded.
     * 
     */
    public Output<String> version() {
        return this.version;
    }
    /**
     * The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    @Export(name="virtualmachineMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> virtualmachineMaximumMbit;

    /**
     * @return The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> virtualmachineMaximumMbit() {
        return this.virtualmachineMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    @Export(name="virtualmachineReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> virtualmachineReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> virtualmachineReservationMbit() {
        return this.virtualmachineReservationMbit;
    }
    /**
     * The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     * 
     */
    @Export(name="virtualmachineShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> virtualmachineShareCount;

    /**
     * @return The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     * 
     */
    public Output<Integer> virtualmachineShareCount() {
        return this.virtualmachineShareCount;
    }
    /**
     * The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="virtualmachineShareLevel", refs={String.class}, tree="[0]")
    private Output<String> virtualmachineShareLevel;

    /**
     * @return The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> virtualmachineShareLevel() {
        return this.virtualmachineShareLevel;
    }
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    @Export(name="vlanId", refs={Integer.class}, tree="[0]")
    private Output<Integer> vlanId;

    /**
     * @return The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    public Output<Integer> vlanId() {
        return this.vlanId;
    }
    /**
     * Used to denote VLAN trunking. Use the `min_vlan`
     * and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
     * `vlan_range` definitions are allowed, but they must not overlap. Example
     * below:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vsphere.DistributedVirtualSwitch;
     * import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
     * import com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var vds = new DistributedVirtualSwitch(&#34;vds&#34;, DistributedVirtualSwitchArgs.builder()        
     *             .vlanRanges(            
     *                 DistributedVirtualSwitchVlanRangeArgs.builder()
     *                     .maxVlan(199)
     *                     .minVlan(100)
     *                     .build(),
     *                 DistributedVirtualSwitchVlanRangeArgs.builder()
     *                     .maxVlan(399)
     *                     .minVlan(300)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    @Export(name="vlanRanges", refs={List.class,DistributedVirtualSwitchVlanRange.class}, tree="[0,1]")
    private Output<List<DistributedVirtualSwitchVlanRange>> vlanRanges;

    /**
     * @return Used to denote VLAN trunking. Use the `min_vlan`
     * and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
     * `vlan_range` definitions are allowed, but they must not overlap. Example
     * below:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.vsphere.DistributedVirtualSwitch;
     * import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
     * import com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var vds = new DistributedVirtualSwitch(&#34;vds&#34;, DistributedVirtualSwitchArgs.builder()        
     *             .vlanRanges(            
     *                 DistributedVirtualSwitchVlanRangeArgs.builder()
     *                     .maxVlan(199)
     *                     .minVlan(100)
     *                     .build(),
     *                 DistributedVirtualSwitchVlanRangeArgs.builder()
     *                     .maxVlan(399)
     *                     .minVlan(300)
     *                     .build())
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public Output<List<DistributedVirtualSwitchVlanRange>> vlanRanges() {
        return this.vlanRanges;
    }
    /**
     * The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vmotionMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vmotionMaximumMbit;

    /**
     * @return The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vmotionMaximumMbit() {
        return this.vmotionMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vmotionReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vmotionReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vmotionReservationMbit() {
        return this.vmotionReservationMbit;
    }
    /**
     * The amount of shares to allocate to the vmotion traffic class for a custom share level.
     * 
     */
    @Export(name="vmotionShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> vmotionShareCount;

    /**
     * @return The amount of shares to allocate to the vmotion traffic class for a custom share level.
     * 
     */
    public Output<Integer> vmotionShareCount() {
        return this.vmotionShareCount;
    }
    /**
     * The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="vmotionShareLevel", refs={String.class}, tree="[0]")
    private Output<String> vmotionShareLevel;

    /**
     * @return The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> vmotionShareLevel() {
        return this.vmotionShareLevel;
    }
    /**
     * The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vsanMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vsanMaximumMbit;

    /**
     * @return The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vsanMaximumMbit() {
        return this.vsanMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vsanReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vsanReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vsanReservationMbit() {
        return this.vsanReservationMbit;
    }
    /**
     * The amount of shares to allocate to the vsan traffic class for a custom share level.
     * 
     */
    @Export(name="vsanShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> vsanShareCount;

    /**
     * @return The amount of shares to allocate to the vsan traffic class for a custom share level.
     * 
     */
    public Output<Integer> vsanShareCount() {
        return this.vsanShareCount;
    }
    /**
     * The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="vsanShareLevel", refs={String.class}, tree="[0]")
    private Output<String> vsanShareLevel;

    /**
     * @return The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> vsanShareLevel() {
        return this.vsanShareLevel;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public DistributedVirtualSwitch(String name) {
        this(name, DistributedVirtualSwitchArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public DistributedVirtualSwitch(String name, DistributedVirtualSwitchArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public DistributedVirtualSwitch(String name, DistributedVirtualSwitchArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, args == null ? DistributedVirtualSwitchArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private DistributedVirtualSwitch(String name, Output<String> id, @Nullable DistributedVirtualSwitchState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static DistributedVirtualSwitch get(String name, Output<String> id, @Nullable DistributedVirtualSwitchState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new DistributedVirtualSwitch(name, id, state, options);
    }
}
