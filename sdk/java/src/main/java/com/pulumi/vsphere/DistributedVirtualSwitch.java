// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.vsphere;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
import com.pulumi.vsphere.Utilities;
import com.pulumi.vsphere.inputs.DistributedVirtualSwitchState;
import com.pulumi.vsphere.outputs.DistributedVirtualSwitchHost;
import com.pulumi.vsphere.outputs.DistributedVirtualSwitchPvlanMapping;
import com.pulumi.vsphere.outputs.DistributedVirtualSwitchVlanRange;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * The `vsphere.DistributedVirtualSwitch` resource can be used to manage vSphere
 * Distributed Switches (VDS).
 * 
 * An essential component of a distributed, scalable vSphere infrastructure, the
 * VDS provides centralized management and monitoring of the networking
 * configuration for all the hosts that are associated with the switch.
 * In addition to adding distributed port groups
 * (see the `vsphere.DistributedPortGroup` resource)
 * that can be used as networks for virtual machines, a VDS can be configured to
 * perform advanced high availability, traffic shaping, network monitoring, etc.
 * 
 * For an overview on vSphere networking concepts, see
 * [this page][ref-vsphere-net-concepts].
 * 
 * For more information on the VDS, see [this page][ref-vsphere-vds].
 * 
 * [ref-vsphere-net-concepts]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches/dvport-groups.html
 * [ref-vsphere-vds]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches.html
 * 
 * &gt; **NOTE:** This resource requires vCenter and is not available on
 * direct ESXi host connections.
 * 
 * ## Example Usage
 * 
 * The following example below demonstrates a &#34;standard&#34; example of configuring a
 * VDS in a 3-node vSphere datacenter named `dc1`, across 4 NICs with two being
 * used as active, and two being used as passive. Note that the NIC failover order
 * propagates to any port groups configured on this VDS and can be overridden.
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ### Uplink name and count control
 * 
 * The following abridged example below demonstrates how you can manage the number
 * of uplinks, and the name of the uplinks via the `uplinks` parameter.
 * 
 * Note that if you change the uplink naming and count after creating the VDS, you
 * may need to explicitly specify `active_uplinks` and `standby_uplinks` as these
 * values are saved to state after creation, regardless of being
 * specified in config, and will drift if not modified, causing errors.
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.vsphere.DistributedVirtualSwitch;
 * import com.pulumi.vsphere.DistributedVirtualSwitchArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var vds = new DistributedVirtualSwitch("vds", DistributedVirtualSwitchArgs.builder()
 *             .name("vds-01")
 *             .datacenterId(datacenter.id())
 *             .uplinks(            
 *                 "uplink1",
 *                 "uplink2")
 *             .activeUplinks("uplink1")
 *             .standbyUplinks("uplink2")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * &gt; **NOTE:** The default uplink names when a VDS is created are `uplink1`
 * through to `uplink4`, however this default is not guaranteed to be stable and
 * you are encouraged to set your own.
 * 
 * ## Import
 * 
 * An existing VDS can be imported into this resource via the path
 * 
 * to the VDS, via the following command:
 * 
 * [docs-import]: https://developer.hashicorp.com/terraform/cli/import
 * 
 * ```sh
 * $ pulumi import vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch vds /dc-01/network/vds-01
 * ```
 * 
 * The above would import the VDS named `vds-01` that is located in the `dc-01`
 * 
 * datacenter.
 * 
 */
@ResourceType(type="vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch")
public class DistributedVirtualSwitch extends com.pulumi.resources.CustomResource {
    /**
     * List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    @Export(name="activeUplinks", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> activeUplinks;

    /**
     * @return List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    public Output<List<String>> activeUplinks() {
        return this.activeUplinks;
    }
    /**
     * Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
     * 
     */
    @Export(name="allowForgedTransmits", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowForgedTransmits;

    /**
     * @return Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
     * 
     */
    public Output<Boolean> allowForgedTransmits() {
        return this.allowForgedTransmits;
    }
    /**
     * Controls whether or not the Media Access Control (MAC) address can be changed.
     * 
     */
    @Export(name="allowMacChanges", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowMacChanges;

    /**
     * @return Controls whether or not the Media Access Control (MAC) address can be changed.
     * 
     */
    public Output<Boolean> allowMacChanges() {
        return this.allowMacChanges;
    }
    /**
     * Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    @Export(name="allowPromiscuous", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> allowPromiscuous;

    /**
     * @return Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
     * 
     */
    public Output<Boolean> allowPromiscuous() {
        return this.allowPromiscuous;
    }
    /**
     * The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    @Export(name="backupnfcMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> backupnfcMaximumMbit;

    /**
     * @return The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> backupnfcMaximumMbit() {
        return this.backupnfcMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    @Export(name="backupnfcReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> backupnfcReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> backupnfcReservationMbit() {
        return this.backupnfcReservationMbit;
    }
    /**
     * The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     * 
     */
    @Export(name="backupnfcShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> backupnfcShareCount;

    /**
     * @return The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     * 
     */
    public Output<Integer> backupnfcShareCount() {
        return this.backupnfcShareCount;
    }
    /**
     * The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="backupnfcShareLevel", refs={String.class}, tree="[0]")
    private Output<String> backupnfcShareLevel;

    /**
     * @return The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> backupnfcShareLevel() {
        return this.backupnfcShareLevel;
    }
    /**
     * Indicates whether to block all ports by default.
     * 
     */
    @Export(name="blockAllPorts", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> blockAllPorts;

    /**
     * @return Indicates whether to block all ports by default.
     * 
     */
    public Output<Boolean> blockAllPorts() {
        return this.blockAllPorts;
    }
    /**
     * Enable beacon probing on the ports this policy applies to.
     * 
     */
    @Export(name="checkBeacon", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> checkBeacon;

    /**
     * @return Enable beacon probing on the ports this policy applies to.
     * 
     */
    public Output<Boolean> checkBeacon() {
        return this.checkBeacon;
    }
    /**
     * The current version of the VDS configuration, incremented
     * by subsequent updates to the VDS.
     * 
     */
    @Export(name="configVersion", refs={String.class}, tree="[0]")
    private Output<String> configVersion;

    /**
     * @return The current version of the VDS configuration, incremented
     * by subsequent updates to the VDS.
     * 
     */
    public Output<String> configVersion() {
        return this.configVersion;
    }
    /**
     * The detailed contact information for the person
     * who is responsible for the VDS.
     * 
     */
    @Export(name="contactDetail", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> contactDetail;

    /**
     * @return The detailed contact information for the person
     * who is responsible for the VDS.
     * 
     */
    public Output<Optional<String>> contactDetail() {
        return Codegen.optional(this.contactDetail);
    }
    /**
     * The name of the person who is responsible for the
     * VDS.
     * 
     */
    @Export(name="contactName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> contactName;

    /**
     * @return The name of the person who is responsible for the
     * VDS.
     * 
     */
    public Output<Optional<String>> contactName() {
        return Codegen.optional(this.contactName);
    }
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for VDS.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
     * and requires vCenter Server.
     * 
     */
    @Export(name="customAttributes", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> customAttributes;

    /**
     * @return Map of custom attribute ids to attribute
     * value strings to set for VDS.
     * 
     * &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
     * and requires vCenter Server.
     * 
     */
    public Output<Optional<Map<String,String>>> customAttributes() {
        return Codegen.optional(this.customAttributes);
    }
    /**
     * The ID of the datacenter where the VDS will be
     * created. Forces a new resource if changed.
     * 
     */
    @Export(name="datacenterId", refs={String.class}, tree="[0]")
    private Output<String> datacenterId;

    /**
     * @return The ID of the datacenter where the VDS will be
     * created. Forces a new resource if changed.
     * 
     */
    public Output<String> datacenterId() {
        return this.datacenterId;
    }
    /**
     * A detailed description for the VDS.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return A detailed description for the VDS.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Allow VMDirectPath Gen2 on the ports this policy applies to.
     * 
     */
    @Export(name="directpathGen2Allowed", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> directpathGen2Allowed;

    /**
     * @return Allow VMDirectPath Gen2 on the ports this policy applies to.
     * 
     */
    public Output<Boolean> directpathGen2Allowed() {
        return this.directpathGen2Allowed;
    }
    /**
     * The average egress bandwidth in bits per second if egress shaping is enabled on the port.
     * 
     */
    @Export(name="egressShapingAverageBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> egressShapingAverageBandwidth;

    /**
     * @return The average egress bandwidth in bits per second if egress shaping is enabled on the port.
     * 
     */
    public Output<Integer> egressShapingAverageBandwidth() {
        return this.egressShapingAverageBandwidth;
    }
    /**
     * The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
     * 
     */
    @Export(name="egressShapingBurstSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> egressShapingBurstSize;

    /**
     * @return The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
     * 
     */
    public Output<Integer> egressShapingBurstSize() {
        return this.egressShapingBurstSize;
    }
    /**
     * True if the traffic shaper is enabled for egress traffic on the port.
     * 
     */
    @Export(name="egressShapingEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> egressShapingEnabled;

    /**
     * @return True if the traffic shaper is enabled for egress traffic on the port.
     * 
     */
    public Output<Boolean> egressShapingEnabled() {
        return this.egressShapingEnabled;
    }
    /**
     * The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="egressShapingPeakBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> egressShapingPeakBandwidth;

    /**
     * @return The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> egressShapingPeakBandwidth() {
        return this.egressShapingPeakBandwidth;
    }
    /**
     * If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
     * 
     */
    @Export(name="failback", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> failback;

    /**
     * @return If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
     * 
     */
    public Output<Boolean> failback() {
        return this.failback;
    }
    /**
     * The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    @Export(name="faulttoleranceMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> faulttoleranceMaximumMbit;

    /**
     * @return The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> faulttoleranceMaximumMbit() {
        return this.faulttoleranceMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    @Export(name="faulttoleranceReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> faulttoleranceReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> faulttoleranceReservationMbit() {
        return this.faulttoleranceReservationMbit;
    }
    /**
     * The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     * 
     */
    @Export(name="faulttoleranceShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> faulttoleranceShareCount;

    /**
     * @return The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     * 
     */
    public Output<Integer> faulttoleranceShareCount() {
        return this.faulttoleranceShareCount;
    }
    /**
     * The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="faulttoleranceShareLevel", refs={String.class}, tree="[0]")
    private Output<String> faulttoleranceShareLevel;

    /**
     * @return The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> faulttoleranceShareLevel() {
        return this.faulttoleranceShareLevel;
    }
    /**
     * The folder in which to create the VDS.
     * Forces a new resource if changed.
     * 
     */
    @Export(name="folder", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> folder;

    /**
     * @return The folder in which to create the VDS.
     * Forces a new resource if changed.
     * 
     */
    public Output<Optional<String>> folder() {
        return Codegen.optional(this.folder);
    }
    /**
     * The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     * 
     */
    @Export(name="hbrMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> hbrMaximumMbit;

    /**
     * @return The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> hbrMaximumMbit() {
        return this.hbrMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     * 
     */
    @Export(name="hbrReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> hbrReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> hbrReservationMbit() {
        return this.hbrReservationMbit;
    }
    /**
     * The amount of shares to allocate to the hbr traffic class for a custom share level.
     * 
     */
    @Export(name="hbrShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> hbrShareCount;

    /**
     * @return The amount of shares to allocate to the hbr traffic class for a custom share level.
     * 
     */
    public Output<Integer> hbrShareCount() {
        return this.hbrShareCount;
    }
    /**
     * The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="hbrShareLevel", refs={String.class}, tree="[0]")
    private Output<String> hbrShareLevel;

    /**
     * @return The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> hbrShareLevel() {
        return this.hbrShareLevel;
    }
    /**
     * A host member specification.
     * 
     */
    @Export(name="hosts", refs={List.class,DistributedVirtualSwitchHost.class}, tree="[0,1]")
    private Output</* @Nullable */ List<DistributedVirtualSwitchHost>> hosts;

    /**
     * @return A host member specification.
     * 
     */
    public Output<Optional<List<DistributedVirtualSwitchHost>>> hosts() {
        return Codegen.optional(this.hosts);
    }
    /**
     * Whether to ignore existing PVLAN mappings not managed by this resource.
     * 
     */
    @Export(name="ignoreOtherPvlanMappings", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ignoreOtherPvlanMappings;

    /**
     * @return Whether to ignore existing PVLAN mappings not managed by this resource.
     * 
     */
    public Output<Optional<Boolean>> ignoreOtherPvlanMappings() {
        return Codegen.optional(this.ignoreOtherPvlanMappings);
    }
    /**
     * The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
     * 
     */
    @Export(name="ingressShapingAverageBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> ingressShapingAverageBandwidth;

    /**
     * @return The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
     * 
     */
    public Output<Integer> ingressShapingAverageBandwidth() {
        return this.ingressShapingAverageBandwidth;
    }
    /**
     * The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
     * 
     */
    @Export(name="ingressShapingBurstSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> ingressShapingBurstSize;

    /**
     * @return The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
     * 
     */
    public Output<Integer> ingressShapingBurstSize() {
        return this.ingressShapingBurstSize;
    }
    /**
     * True if the traffic shaper is enabled for ingress traffic on the port.
     * 
     */
    @Export(name="ingressShapingEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> ingressShapingEnabled;

    /**
     * @return True if the traffic shaper is enabled for ingress traffic on the port.
     * 
     */
    public Output<Boolean> ingressShapingEnabled() {
        return this.ingressShapingEnabled;
    }
    /**
     * The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    @Export(name="ingressShapingPeakBandwidth", refs={Integer.class}, tree="[0]")
    private Output<Integer> ingressShapingPeakBandwidth;

    /**
     * @return The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
     * 
     */
    public Output<Integer> ingressShapingPeakBandwidth() {
        return this.ingressShapingPeakBandwidth;
    }
    /**
     * An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments.
     * 
     */
    @Export(name="ipv4Address", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4Address;

    /**
     * @return An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments.
     * 
     */
    public Output<Optional<String>> ipv4Address() {
        return Codegen.optional(this.ipv4Address);
    }
    /**
     * The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    @Export(name="iscsiMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> iscsiMaximumMbit;

    /**
     * @return The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> iscsiMaximumMbit() {
        return this.iscsiMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    @Export(name="iscsiReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> iscsiReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> iscsiReservationMbit() {
        return this.iscsiReservationMbit;
    }
    /**
     * The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     * 
     */
    @Export(name="iscsiShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> iscsiShareCount;

    /**
     * @return The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     * 
     */
    public Output<Integer> iscsiShareCount() {
        return this.iscsiShareCount;
    }
    /**
     * The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="iscsiShareLevel", refs={String.class}, tree="[0]")
    private Output<String> iscsiShareLevel;

    /**
     * @return The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> iscsiShareLevel() {
        return this.iscsiShareLevel;
    }
    /**
     * The Link Aggregation Control Protocol group
     * version to use with the VDS. Possible values are `singleLag` and
     * `multipleLag`.
     * 
     */
    @Export(name="lacpApiVersion", refs={String.class}, tree="[0]")
    private Output<String> lacpApiVersion;

    /**
     * @return The Link Aggregation Control Protocol group
     * version to use with the VDS. Possible values are `singleLag` and
     * `multipleLag`.
     * 
     */
    public Output<String> lacpApiVersion() {
        return this.lacpApiVersion;
    }
    /**
     * Whether or not to enable LACP on all uplink ports.
     * 
     */
    @Export(name="lacpEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> lacpEnabled;

    /**
     * @return Whether or not to enable LACP on all uplink ports.
     * 
     */
    public Output<Boolean> lacpEnabled() {
        return this.lacpEnabled;
    }
    /**
     * The uplink LACP mode to use. Can be one of active or passive.
     * 
     */
    @Export(name="lacpMode", refs={String.class}, tree="[0]")
    private Output<String> lacpMode;

    /**
     * @return The uplink LACP mode to use. Can be one of active or passive.
     * 
     */
    public Output<String> lacpMode() {
        return this.lacpMode;
    }
    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic.
     * 
     */
    @Export(name="linkDiscoveryOperation", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> linkDiscoveryOperation;

    /**
     * @return Whether to `advertise` or `listen`
     * for link discovery traffic.
     * 
     */
    public Output<Optional<String>> linkDiscoveryOperation() {
        return Codegen.optional(this.linkDiscoveryOperation);
    }
    /**
     * The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     * 
     */
    @Export(name="linkDiscoveryProtocol", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> linkDiscoveryProtocol;

    /**
     * @return The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     * 
     */
    public Output<Optional<String>> linkDiscoveryProtocol() {
        return Codegen.optional(this.linkDiscoveryProtocol);
    }
    /**
     * The maximum allowed usage for the management traffic class, in Mbits/sec.
     * 
     */
    @Export(name="managementMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> managementMaximumMbit;

    /**
     * @return The maximum allowed usage for the management traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> managementMaximumMbit() {
        return this.managementMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     * 
     */
    @Export(name="managementReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> managementReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> managementReservationMbit() {
        return this.managementReservationMbit;
    }
    /**
     * The amount of shares to allocate to the management traffic class for a custom share level.
     * 
     */
    @Export(name="managementShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> managementShareCount;

    /**
     * @return The amount of shares to allocate to the management traffic class for a custom share level.
     * 
     */
    public Output<Integer> managementShareCount() {
        return this.managementShareCount;
    }
    /**
     * The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="managementShareLevel", refs={String.class}, tree="[0]")
    private Output<String> managementShareLevel;

    /**
     * @return The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> managementShareLevel() {
        return this.managementShareLevel;
    }
    /**
     * The maximum transmission unit (MTU) for the VDS.
     * 
     */
    @Export(name="maxMtu", refs={Integer.class}, tree="[0]")
    private Output<Integer> maxMtu;

    /**
     * @return The maximum transmission unit (MTU) for the VDS.
     * 
     */
    public Output<Integer> maxMtu() {
        return this.maxMtu;
    }
    /**
     * The multicast filtering mode to use
     * with the VDS. Can be one of `legacyFiltering` or `snooping`.
     * 
     */
    @Export(name="multicastFilteringMode", refs={String.class}, tree="[0]")
    private Output<String> multicastFilteringMode;

    /**
     * @return The multicast filtering mode to use
     * with the VDS. Can be one of `legacyFiltering` or `snooping`.
     * 
     */
    public Output<String> multicastFilteringMode() {
        return this.multicastFilteringMode;
    }
    /**
     * The name of the VDS.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the VDS.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The number of seconds after which active flows are forced to be exported to the collector.
     * 
     */
    @Export(name="netflowActiveFlowTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowActiveFlowTimeout;

    /**
     * @return The number of seconds after which active flows are forced to be exported to the collector.
     * 
     */
    public Output<Optional<Integer>> netflowActiveFlowTimeout() {
        return Codegen.optional(this.netflowActiveFlowTimeout);
    }
    /**
     * IP address for the netflow collector, using IPv4 or IPv6.
     * 
     */
    @Export(name="netflowCollectorIpAddress", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> netflowCollectorIpAddress;

    /**
     * @return IP address for the netflow collector, using IPv4 or IPv6.
     * 
     */
    public Output<Optional<String>> netflowCollectorIpAddress() {
        return Codegen.optional(this.netflowCollectorIpAddress);
    }
    /**
     * The port for the netflow collector.
     * 
     */
    @Export(name="netflowCollectorPort", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowCollectorPort;

    /**
     * @return The port for the netflow collector.
     * 
     */
    public Output<Optional<Integer>> netflowCollectorPort() {
        return Codegen.optional(this.netflowCollectorPort);
    }
    /**
     * Indicates whether to enable netflow on all ports.
     * 
     */
    @Export(name="netflowEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> netflowEnabled;

    /**
     * @return Indicates whether to enable netflow on all ports.
     * 
     */
    public Output<Boolean> netflowEnabled() {
        return this.netflowEnabled;
    }
    /**
     * The number of seconds after which idle flows are forced to be exported to the collector.
     * 
     */
    @Export(name="netflowIdleFlowTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowIdleFlowTimeout;

    /**
     * @return The number of seconds after which idle flows are forced to be exported to the collector.
     * 
     */
    public Output<Optional<Integer>> netflowIdleFlowTimeout() {
        return Codegen.optional(this.netflowIdleFlowTimeout);
    }
    /**
     * Whether to limit analysis to traffic that has both source and destination served by the same host.
     * 
     */
    @Export(name="netflowInternalFlowsOnly", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> netflowInternalFlowsOnly;

    /**
     * @return Whether to limit analysis to traffic that has both source and destination served by the same host.
     * 
     */
    public Output<Optional<Boolean>> netflowInternalFlowsOnly() {
        return Codegen.optional(this.netflowInternalFlowsOnly);
    }
    /**
     * The observation Domain ID for the netflow collector.
     * 
     */
    @Export(name="netflowObservationDomainId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowObservationDomainId;

    /**
     * @return The observation Domain ID for the netflow collector.
     * 
     */
    public Output<Optional<Integer>> netflowObservationDomainId() {
        return Codegen.optional(this.netflowObservationDomainId);
    }
    /**
     * The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed.
     * 
     */
    @Export(name="netflowSamplingRate", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> netflowSamplingRate;

    /**
     * @return The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed.
     * 
     */
    public Output<Optional<Integer>> netflowSamplingRate() {
        return Codegen.optional(this.netflowSamplingRate);
    }
    /**
     * Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
     * 
     */
    @Export(name="networkResourceControlEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> networkResourceControlEnabled;

    /**
     * @return Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
     * 
     */
    public Output<Optional<Boolean>> networkResourceControlEnabled() {
        return Codegen.optional(this.networkResourceControlEnabled);
    }
    /**
     * The network I/O control version to use. Can be one of version2 or version3.
     * 
     */
    @Export(name="networkResourceControlVersion", refs={String.class}, tree="[0]")
    private Output<String> networkResourceControlVersion;

    /**
     * @return The network I/O control version to use. Can be one of version2 or version3.
     * 
     */
    public Output<String> networkResourceControlVersion() {
        return this.networkResourceControlVersion;
    }
    /**
     * The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     * 
     */
    @Export(name="nfsMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> nfsMaximumMbit;

    /**
     * @return The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> nfsMaximumMbit() {
        return this.nfsMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     * 
     */
    @Export(name="nfsReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> nfsReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> nfsReservationMbit() {
        return this.nfsReservationMbit;
    }
    /**
     * The amount of shares to allocate to the nfs traffic class for a custom share level.
     * 
     */
    @Export(name="nfsShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> nfsShareCount;

    /**
     * @return The amount of shares to allocate to the nfs traffic class for a custom share level.
     * 
     */
    public Output<Integer> nfsShareCount() {
        return this.nfsShareCount;
    }
    /**
     * The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="nfsShareLevel", refs={String.class}, tree="[0]")
    private Output<String> nfsShareLevel;

    /**
     * @return The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> nfsShareLevel() {
        return this.nfsShareLevel;
    }
    /**
     * If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
     * 
     */
    @Export(name="notifySwitches", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> notifySwitches;

    /**
     * @return If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
     * 
     */
    public Output<Boolean> notifySwitches() {
        return this.notifySwitches;
    }
    /**
     * The secondary VLAN ID for this port.
     * 
     */
    @Export(name="portPrivateSecondaryVlanId", refs={Integer.class}, tree="[0]")
    private Output<Integer> portPrivateSecondaryVlanId;

    /**
     * @return The secondary VLAN ID for this port.
     * 
     */
    public Output<Integer> portPrivateSecondaryVlanId() {
        return this.portPrivateSecondaryVlanId;
    }
    /**
     * A private VLAN (PVLAN) mapping.
     * 
     */
    @Export(name="pvlanMappings", refs={List.class,DistributedVirtualSwitchPvlanMapping.class}, tree="[0,1]")
    private Output</* @Nullable */ List<DistributedVirtualSwitchPvlanMapping>> pvlanMappings;

    /**
     * @return A private VLAN (PVLAN) mapping.
     * 
     */
    public Output<Optional<List<DistributedVirtualSwitchPvlanMapping>>> pvlanMappings() {
        return Codegen.optional(this.pvlanMappings);
    }
    /**
     * List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    @Export(name="standbyUplinks", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> standbyUplinks;

    /**
     * @return List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     * 
     */
    public Output<List<String>> standbyUplinks() {
        return this.standbyUplinks;
    }
    /**
     * The IDs of any tags to attach to this resource.
     * 
     */
    @Export(name="tags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return The IDs of any tags to attach to this resource.
     * 
     */
    public Output<Optional<List<String>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
     * 
     */
    @Export(name="teamingPolicy", refs={String.class}, tree="[0]")
    private Output<String> teamingPolicy;

    /**
     * @return The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
     * 
     */
    public Output<String> teamingPolicy() {
        return this.teamingPolicy;
    }
    /**
     * If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
     * 
     */
    @Export(name="txUplink", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> txUplink;

    /**
     * @return If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
     * 
     */
    public Output<Boolean> txUplink() {
        return this.txUplink;
    }
    /**
     * A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.
     * 
     */
    @Export(name="uplinks", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> uplinks;

    /**
     * @return A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.
     * 
     */
    public Output<List<String>> uplinks() {
        return this.uplinks;
    }
    /**
     * The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vdpMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vdpMaximumMbit;

    /**
     * @return The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vdpMaximumMbit() {
        return this.vdpMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vdpReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vdpReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vdpReservationMbit() {
        return this.vdpReservationMbit;
    }
    /**
     * The amount of shares to allocate to the vdp traffic class for a custom share level.
     * 
     */
    @Export(name="vdpShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> vdpShareCount;

    /**
     * @return The amount of shares to allocate to the vdp traffic class for a custom share level.
     * 
     */
    public Output<Integer> vdpShareCount() {
        return this.vdpShareCount;
    }
    /**
     * The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="vdpShareLevel", refs={String.class}, tree="[0]")
    private Output<String> vdpShareLevel;

    /**
     * @return The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> vdpShareLevel() {
        return this.vdpShareLevel;
    }
    /**
     * The version of the VDS. By default, a VDS is created
     * at the latest version supported by the vSphere version if not specified.
     * A VDS can be upgraded to a newer version, but can not be downgraded.
     * 
     */
    @Export(name="version", refs={String.class}, tree="[0]")
    private Output<String> version;

    /**
     * @return The version of the VDS. By default, a VDS is created
     * at the latest version supported by the vSphere version if not specified.
     * A VDS can be upgraded to a newer version, but can not be downgraded.
     * 
     */
    public Output<String> version() {
        return this.version;
    }
    /**
     * The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    @Export(name="virtualmachineMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> virtualmachineMaximumMbit;

    /**
     * @return The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> virtualmachineMaximumMbit() {
        return this.virtualmachineMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    @Export(name="virtualmachineReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> virtualmachineReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> virtualmachineReservationMbit() {
        return this.virtualmachineReservationMbit;
    }
    /**
     * The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     * 
     */
    @Export(name="virtualmachineShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> virtualmachineShareCount;

    /**
     * @return The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     * 
     */
    public Output<Integer> virtualmachineShareCount() {
        return this.virtualmachineShareCount;
    }
    /**
     * The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="virtualmachineShareLevel", refs={String.class}, tree="[0]")
    private Output<String> virtualmachineShareLevel;

    /**
     * @return The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> virtualmachineShareLevel() {
        return this.virtualmachineShareLevel;
    }
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    @Export(name="vlanId", refs={Integer.class}, tree="[0]")
    private Output<Integer> vlanId;

    /**
     * @return The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    public Output<Integer> vlanId() {
        return this.vlanId;
    }
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    @Export(name="vlanRanges", refs={List.class,DistributedVirtualSwitchVlanRange.class}, tree="[0,1]")
    private Output<List<DistributedVirtualSwitchVlanRange>> vlanRanges;

    /**
     * @return The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     * 
     */
    public Output<List<DistributedVirtualSwitchVlanRange>> vlanRanges() {
        return this.vlanRanges;
    }
    /**
     * The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vmotionMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vmotionMaximumMbit;

    /**
     * @return The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vmotionMaximumMbit() {
        return this.vmotionMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vmotionReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vmotionReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vmotionReservationMbit() {
        return this.vmotionReservationMbit;
    }
    /**
     * The amount of shares to allocate to the vmotion traffic class for a custom share level.
     * 
     */
    @Export(name="vmotionShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> vmotionShareCount;

    /**
     * @return The amount of shares to allocate to the vmotion traffic class for a custom share level.
     * 
     */
    public Output<Integer> vmotionShareCount() {
        return this.vmotionShareCount;
    }
    /**
     * The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="vmotionShareLevel", refs={String.class}, tree="[0]")
    private Output<String> vmotionShareLevel;

    /**
     * @return The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> vmotionShareLevel() {
        return this.vmotionShareLevel;
    }
    /**
     * The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vsanMaximumMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vsanMaximumMbit;

    /**
     * @return The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vsanMaximumMbit() {
        return this.vsanMaximumMbit;
    }
    /**
     * The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     * 
     */
    @Export(name="vsanReservationMbit", refs={Integer.class}, tree="[0]")
    private Output<Integer> vsanReservationMbit;

    /**
     * @return The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     * 
     */
    public Output<Integer> vsanReservationMbit() {
        return this.vsanReservationMbit;
    }
    /**
     * The amount of shares to allocate to the vsan traffic class for a custom share level.
     * 
     */
    @Export(name="vsanShareCount", refs={Integer.class}, tree="[0]")
    private Output<Integer> vsanShareCount;

    /**
     * @return The amount of shares to allocate to the vsan traffic class for a custom share level.
     * 
     */
    public Output<Integer> vsanShareCount() {
        return this.vsanShareCount;
    }
    /**
     * The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    @Export(name="vsanShareLevel", refs={String.class}, tree="[0]")
    private Output<String> vsanShareLevel;

    /**
     * @return The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     * 
     */
    public Output<String> vsanShareLevel() {
        return this.vsanShareLevel;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public DistributedVirtualSwitch(java.lang.String name) {
        this(name, DistributedVirtualSwitchArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public DistributedVirtualSwitch(java.lang.String name, DistributedVirtualSwitchArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public DistributedVirtualSwitch(java.lang.String name, DistributedVirtualSwitchArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private DistributedVirtualSwitch(java.lang.String name, Output<java.lang.String> id, @Nullable DistributedVirtualSwitchState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, state, makeResourceOptions(options, id), false);
    }

    private static DistributedVirtualSwitchArgs makeArgs(DistributedVirtualSwitchArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? DistributedVirtualSwitchArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static DistributedVirtualSwitch get(java.lang.String name, Output<java.lang.String> id, @Nullable DistributedVirtualSwitchState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new DistributedVirtualSwitch(name, id, state, options);
    }
}
