// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.VSphere
{
    /// <summary>
    /// The `vsphere..DistributedVirtualSwitch` resource can be used to manage VMware
    /// Distributed Virtual Switches.
    /// 
    /// An essential component of a distributed, scalable VMware datacenter, the
    /// vSphere Distributed Virtual Switch (DVS) provides centralized management and
    /// monitoring of the networking configuration of all the hosts that are associated
    /// with the switch. In addition to adding port groups (see the
    /// [`vsphere..DistributedPortGroup`][distributed-port-group] resource) that can
    /// be used as networks for virtual machines, a DVS can be configured to perform
    /// advanced high availability, traffic shaping, network monitoring, and more.
    /// 
    /// For an overview on vSphere networking concepts, see [this
    /// page][ref-vsphere-net-concepts]. For more information on vSphere DVS, see [this
    /// page][ref-vsphere-dvs].
    /// 
    /// [distributed-port-group]: /docs/providers/vsphere/r/distributed_port_group.html
    /// [ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html
    /// [ref-vsphere-dvs]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-375B45C7-684C-4C51-BA3C-70E48DFABF04.html
    /// 
    /// &gt; **NOTE:** This resource requires vCenter and is not available on direct ESXi
    /// connections.
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-vsphere/blob/master/website/docs/r/distributed_virtual_switch.html.markdown.
    /// </summary>
    public partial class DistributedVirtualSwitch : Pulumi.CustomResource
    {
        /// <summary>
        /// A list of active uplinks to be used in load
        /// balancing. These uplinks need to match the definitions in the
        /// `uplinks` DVS argument. See
        /// here for more details.
        /// </summary>
        [Output("activeUplinks")]
        public Output<ImmutableArray<string>> ActiveUplinks { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not a virtual
        /// network adapter is allowed to send network traffic with a different MAC
        /// address than that of its own.
        /// </summary>
        [Output("allowForgedTransmits")]
        public Output<bool> AllowForgedTransmits { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the Media Access
        /// Control (MAC) address can be changed.
        /// </summary>
        [Output("allowMacChanges")]
        public Output<bool> AllowMacChanges { get; private set; } = null!;

        /// <summary>
        /// Enable promiscuous mode on the network. This
        /// flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Output("allowPromiscuous")]
        public Output<bool> AllowPromiscuous { get; private set; } = null!;

        /// <summary>
        /// Shuts down all ports in the port groups that
        /// this policy applies to, effectively blocking all network access to connected
        /// virtual devices.
        /// </summary>
        [Output("blockAllPorts")]
        public Output<bool> BlockAllPorts { get; private set; } = null!;

        /// <summary>
        /// Enables beacon probing as an additional measure
        /// to detect NIC failure.
        /// </summary>
        [Output("checkBeacon")]
        public Output<bool> CheckBeacon { get; private set; } = null!;

        /// <summary>
        /// The version string of the configuration that this spec is trying to change.
        /// </summary>
        [Output("configVersion")]
        public Output<string> ConfigVersion { get; private set; } = null!;

        /// <summary>
        /// The detailed contact information for the person
        /// who is responsible for the DVS.
        /// </summary>
        [Output("contactDetail")]
        public Output<string?> ContactDetail { get; private set; } = null!;

        /// <summary>
        /// The name of the person who is responsible for the
        /// DVS.
        /// </summary>
        [Output("contactName")]
        public Output<string?> ContactName { get; private set; } = null!;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for virtual switch. See
        /// [here][docs-setting-custom-attributes] for a reference on how to set values
        /// for custom attributes.
        /// </summary>
        [Output("customAttributes")]
        public Output<ImmutableDictionary<string, string>?> CustomAttributes { get; private set; } = null!;

        /// <summary>
        /// The ID of the datacenter where the distributed
        /// virtual switch will be created. Forces a new resource if changed.
        /// </summary>
        [Output("datacenterId")]
        public Output<string> DatacenterId { get; private set; } = null!;

        /// <summary>
        /// A detailed description for the DVS.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Allow VMDirectPath Gen2 for the ports
        /// for which this policy applies to.
        /// </summary>
        [Output("directpathGen2Allowed")]
        public Output<bool> DirectpathGen2Allowed { get; private set; } = null!;

        /// <summary>
        /// The average bandwidth in bits
        /// per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingAverageBandwidth")]
        public Output<int> EgressShapingAverageBandwidth { get; private set; } = null!;

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if egress traffic shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingBurstSize")]
        public Output<int> EgressShapingBurstSize { get; private set; } = null!;

        /// <summary>
        /// `true` if the traffic shaper is enabled
        /// on the port for egress traffic.
        /// </summary>
        [Output("egressShapingEnabled")]
        public Output<bool> EgressShapingEnabled { get; private set; } = null!;

        /// <summary>
        /// The peak bandwidth during bursts
        /// in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingPeakBandwidth")]
        public Output<int> EgressShapingPeakBandwidth { get; private set; } = null!;

        /// <summary>
        /// If `true`, the teaming policy will re-activate failed
        /// uplinks higher in precedence when they come back up.
        /// </summary>
        [Output("failback")]
        public Output<bool> Failback { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Output("faulttoleranceMaximumMbit")]
        public Output<int> FaulttoleranceMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Output("faulttoleranceReservationMbit")]
        public Output<int> FaulttoleranceReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        /// </summary>
        [Output("faulttoleranceShareCount")]
        public Output<int> FaulttoleranceShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("faulttoleranceShareLevel")]
        public Output<string> FaulttoleranceShareLevel { get; private set; } = null!;

        /// <summary>
        /// The folder to create the DVS in. Forces a new resource
        /// if changed.
        /// </summary>
        [Output("folder")]
        public Output<string?> Folder { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Output("hbrMaximumMbit")]
        public Output<int> HbrMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Output("hbrReservationMbit")]
        public Output<int> HbrReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the hbr traffic class for a custom share level.
        /// </summary>
        [Output("hbrShareCount")]
        public Output<int> HbrShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("hbrShareLevel")]
        public Output<string> HbrShareLevel { get; private set; } = null!;

        /// <summary>
        /// Use the `host` block to declare a host specification. The
        /// options are:
        /// </summary>
        [Output("hosts")]
        public Output<ImmutableArray<Outputs.DistributedVirtualSwitchHosts>> Hosts { get; private set; } = null!;

        /// <summary>
        /// The average bandwidth in
        /// bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingAverageBandwidth")]
        public Output<int> IngressShapingAverageBandwidth { get; private set; } = null!;

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingBurstSize")]
        public Output<int> IngressShapingBurstSize { get; private set; } = null!;

        /// <summary>
        /// `true` if the traffic shaper is
        /// enabled on the port for ingress traffic.
        /// </summary>
        [Output("ingressShapingEnabled")]
        public Output<bool> IngressShapingEnabled { get; private set; } = null!;

        /// <summary>
        /// The peak bandwidth during
        /// bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingPeakBandwidth")]
        public Output<int> IngressShapingPeakBandwidth { get; private set; } = null!;

        /// <summary>
        /// An IPv4 address to identify the switch. This is
        /// mostly useful when used with the Netflow arguments found
        /// below.
        /// </summary>
        [Output("ipv4Address")]
        public Output<string?> Ipv4Address { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Output("iscsiMaximumMbit")]
        public Output<int> IscsiMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Output("iscsiReservationMbit")]
        public Output<int> IscsiReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        /// </summary>
        [Output("iscsiShareCount")]
        public Output<int> IscsiShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("iscsiShareLevel")]
        public Output<string> IscsiShareLevel { get; private set; } = null!;

        /// <summary>
        /// The Link Aggregation Control Protocol group
        /// version to use with the switch. Possible values are `singleLag` and
        /// `multipleLag`.
        /// </summary>
        [Output("lacpApiVersion")]
        public Output<string> LacpApiVersion { get; private set; } = null!;

        /// <summary>
        /// Enables LACP for the ports that this policy
        /// applies to.
        /// </summary>
        [Output("lacpEnabled")]
        public Output<bool> LacpEnabled { get; private set; } = null!;

        /// <summary>
        /// The LACP mode. Can be one of `active` or `passive`.
        /// </summary>
        [Output("lacpMode")]
        public Output<string> LacpMode { get; private set; } = null!;

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic.
        /// </summary>
        [Output("linkDiscoveryOperation")]
        public Output<string?> LinkDiscoveryOperation { get; private set; } = null!;

        /// <summary>
        /// The discovery protocol type. Valid
        /// types are `cdp` and `lldp`.
        /// </summary>
        [Output("linkDiscoveryProtocol")]
        public Output<string?> LinkDiscoveryProtocol { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the management traffic class, in Mbits/sec.
        /// </summary>
        [Output("managementMaximumMbit")]
        public Output<int> ManagementMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        /// </summary>
        [Output("managementReservationMbit")]
        public Output<int> ManagementReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the management traffic class for a custom share level.
        /// </summary>
        [Output("managementShareCount")]
        public Output<int> ManagementShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("managementShareLevel")]
        public Output<string> ManagementShareLevel { get; private set; } = null!;

        /// <summary>
        /// The maximum transmission unit (MTU) for the virtual
        /// switch.
        /// </summary>
        [Output("maxMtu")]
        public Output<int> MaxMtu { get; private set; } = null!;

        /// <summary>
        /// The multicast filtering mode to use
        /// with the switch. Can be one of `legacyFiltering` or `snooping`.
        /// </summary>
        [Output("multicastFilteringMode")]
        public Output<string> MulticastFilteringMode { get; private set; } = null!;

        /// <summary>
        /// The name of the distributed virtual switch.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The number of seconds after which
        /// active flows are forced to be exported to the collector. Allowed range is
        /// `60` to `3600`. Default: `60`.
        /// </summary>
        [Output("netflowActiveFlowTimeout")]
        public Output<int?> NetflowActiveFlowTimeout { get; private set; } = null!;

        /// <summary>
        /// IP address for the Netflow
        /// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
        /// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
        /// </summary>
        [Output("netflowCollectorIpAddress")]
        public Output<string?> NetflowCollectorIpAddress { get; private set; } = null!;

        /// <summary>
        /// Port for the Netflow collector. This
        /// must be set before Netflow can be enabled.
        /// </summary>
        [Output("netflowCollectorPort")]
        public Output<int?> NetflowCollectorPort { get; private set; } = null!;

        /// <summary>
        /// Enables Netflow on all ports that this policy
        /// applies to.
        /// </summary>
        [Output("netflowEnabled")]
        public Output<bool> NetflowEnabled { get; private set; } = null!;

        /// <summary>
        /// The number of seconds after which
        /// idle flows are forced to be exported to the collector. Allowed range is `10`
        /// to `600`. Default: `15`.
        /// </summary>
        [Output("netflowIdleFlowTimeout")]
        public Output<int?> NetflowIdleFlowTimeout { get; private set; } = null!;

        /// <summary>
        /// Whether to limit analysis to
        /// traffic that has both source and destination served by the same host.
        /// Default: `false`.
        /// </summary>
        [Output("netflowInternalFlowsOnly")]
        public Output<bool?> NetflowInternalFlowsOnly { get; private set; } = null!;

        /// <summary>
        /// The observation domain ID for
        /// the Netflow collector.
        /// </summary>
        [Output("netflowObservationDomainId")]
        public Output<int?> NetflowObservationDomainId { get; private set; } = null!;

        /// <summary>
        /// The ratio of total number of packets to
        /// the number of packets analyzed. The default is `0`, which indicates that the
        /// switch should analyze all packets. The maximum value is `1000`, which
        /// indicates an analysis rate of 0.001%.
        /// </summary>
        [Output("netflowSamplingRate")]
        public Output<int?> NetflowSamplingRate { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to enable
        /// network I/O control. Default: `false`.
        /// </summary>
        [Output("networkResourceControlEnabled")]
        public Output<bool?> NetworkResourceControlEnabled { get; private set; } = null!;

        /// <summary>
        /// The version of network I/O
        /// control to use. Can be one of `version2` or `version3`. Default: `version2`.
        /// </summary>
        [Output("networkResourceControlVersion")]
        public Output<string> NetworkResourceControlVersion { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Output("nfsMaximumMbit")]
        public Output<int> NfsMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Output("nfsReservationMbit")]
        public Output<int> NfsReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the nfs traffic class for a custom share level.
        /// </summary>
        [Output("nfsShareCount")]
        public Output<int> NfsShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("nfsShareLevel")]
        public Output<string> NfsShareLevel { get; private set; } = null!;

        /// <summary>
        /// If `true`, the teaming policy will notify the
        /// broadcast network of an uplink failover, triggering cache updates.
        /// </summary>
        [Output("notifySwitches")]
        public Output<bool> NotifySwitches { get; private set; } = null!;

        /// <summary>
        /// Used to define a secondary VLAN
        /// ID when using private VLANs.
        /// </summary>
        [Output("portPrivateSecondaryVlanId")]
        public Output<int> PortPrivateSecondaryVlanId { get; private set; } = null!;

        /// <summary>
        /// A list of standby uplinks to be used in
        /// failover. These uplinks need to match the definitions in the
        /// `uplinks` DVS argument. See
        /// here for more details.
        /// </summary>
        [Output("standbyUplinks")]
        public Output<ImmutableArray<string>> StandbyUplinks { get; private set; } = null!;

        /// <summary>
        /// The IDs of any tags to attach to this resource. See
        /// [here][docs-applying-tags] for a reference on how to apply tags.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// The uplink teaming policy. Can be one of
        /// `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
        /// `failover_explicit`.
        /// </summary>
        [Output("teamingPolicy")]
        public Output<string> TeamingPolicy { get; private set; } = null!;

        /// <summary>
        /// Forward all traffic transmitted by ports for which
        /// this policy applies to its DVS uplinks.
        /// </summary>
        [Output("txUplink")]
        public Output<bool> TxUplink { get; private set; } = null!;

        /// <summary>
        /// A list of strings that uniquely identifies the names
        /// of the uplinks on the DVS across hosts. The number of items in this list
        /// controls the number of uplinks that exist on the DVS, in addition to the
        /// names.  See here for an example on how to
        /// use this option.
        /// </summary>
        [Output("uplinks")]
        public Output<ImmutableArray<string>> Uplinks { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Output("vdpMaximumMbit")]
        public Output<int> VdpMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Output("vdpReservationMbit")]
        public Output<int> VdpReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the vdp traffic class for a custom share level.
        /// </summary>
        [Output("vdpShareCount")]
        public Output<int> VdpShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("vdpShareLevel")]
        public Output<string> VdpShareLevel { get; private set; } = null!;

        /// <summary>
        /// - The version of the DVS to create. The default is to
        /// create the DVS at the latest version supported by the version of vSphere
        /// being used. A DVS can be upgraded to another version, but cannot be
        /// downgraded.
        /// </summary>
        [Output("version")]
        public Output<string> Version { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Output("virtualmachineMaximumMbit")]
        public Output<int> VirtualmachineMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Output("virtualmachineReservationMbit")]
        public Output<int> VirtualmachineReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        /// </summary>
        [Output("virtualmachineShareCount")]
        public Output<int> VirtualmachineShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("virtualmachineShareLevel")]
        public Output<string> VirtualmachineShareLevel { get; private set; } = null!;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Output("vlanId")]
        public Output<int> VlanId { get; private set; } = null!;

        /// <summary>
        /// Used to denote VLAN trunking. Use the `min_vlan`
        /// and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
        /// `vlan_range` definitions are allowed, but they must not overlap. Example
        /// below:
        /// </summary>
        [Output("vlanRanges")]
        public Output<ImmutableArray<Outputs.DistributedVirtualSwitchVlanRanges>> VlanRanges { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Output("vmotionMaximumMbit")]
        public Output<int> VmotionMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Output("vmotionReservationMbit")]
        public Output<int> VmotionReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the vmotion traffic class for a custom share level.
        /// </summary>
        [Output("vmotionShareCount")]
        public Output<int> VmotionShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("vmotionShareLevel")]
        public Output<string> VmotionShareLevel { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Output("vsanMaximumMbit")]
        public Output<int> VsanMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Output("vsanReservationMbit")]
        public Output<int> VsanReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the vsan traffic class for a custom share level.
        /// </summary>
        [Output("vsanShareCount")]
        public Output<int> VsanShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("vsanShareLevel")]
        public Output<string> VsanShareLevel { get; private set; } = null!;


        /// <summary>
        /// Create a DistributedVirtualSwitch resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public DistributedVirtualSwitch(string name, DistributedVirtualSwitchArgs args, CustomResourceOptions? options = null)
            : base("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private DistributedVirtualSwitch(string name, Input<string> id, DistributedVirtualSwitchState? state = null, CustomResourceOptions? options = null)
            : base("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing DistributedVirtualSwitch resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static DistributedVirtualSwitch Get(string name, Input<string> id, DistributedVirtualSwitchState? state = null, CustomResourceOptions? options = null)
        {
            return new DistributedVirtualSwitch(name, id, state, options);
        }
    }

    public sealed class DistributedVirtualSwitchArgs : Pulumi.ResourceArgs
    {
        [Input("activeUplinks")]
        private InputList<string>? _activeUplinks;

        /// <summary>
        /// A list of active uplinks to be used in load
        /// balancing. These uplinks need to match the definitions in the
        /// `uplinks` DVS argument. See
        /// here for more details.
        /// </summary>
        public InputList<string> ActiveUplinks
        {
            get => _activeUplinks ?? (_activeUplinks = new InputList<string>());
            set => _activeUplinks = value;
        }

        /// <summary>
        /// Controls whether or not a virtual
        /// network adapter is allowed to send network traffic with a different MAC
        /// address than that of its own.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access
        /// Control (MAC) address can be changed.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This
        /// flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// Shuts down all ports in the port groups that
        /// this policy applies to, effectively blocking all network access to connected
        /// virtual devices.
        /// </summary>
        [Input("blockAllPorts")]
        public Input<bool>? BlockAllPorts { get; set; }

        /// <summary>
        /// Enables beacon probing as an additional measure
        /// to detect NIC failure.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        /// <summary>
        /// The detailed contact information for the person
        /// who is responsible for the DVS.
        /// </summary>
        [Input("contactDetail")]
        public Input<string>? ContactDetail { get; set; }

        /// <summary>
        /// The name of the person who is responsible for the
        /// DVS.
        /// </summary>
        [Input("contactName")]
        public Input<string>? ContactName { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for virtual switch. See
        /// [here][docs-setting-custom-attributes] for a reference on how to set values
        /// for custom attributes.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The ID of the datacenter where the distributed
        /// virtual switch will be created. Forces a new resource if changed.
        /// </summary>
        [Input("datacenterId", required: true)]
        public Input<string> DatacenterId { get; set; } = null!;

        /// <summary>
        /// A detailed description for the DVS.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Allow VMDirectPath Gen2 for the ports
        /// for which this policy applies to.
        /// </summary>
        [Input("directpathGen2Allowed")]
        public Input<bool>? DirectpathGen2Allowed { get; set; }

        /// <summary>
        /// The average bandwidth in bits
        /// per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingAverageBandwidth")]
        public Input<int>? EgressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingBurstSize")]
        public Input<int>? EgressShapingBurstSize { get; set; }

        /// <summary>
        /// `true` if the traffic shaper is enabled
        /// on the port for egress traffic.
        /// </summary>
        [Input("egressShapingEnabled")]
        public Input<bool>? EgressShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during bursts
        /// in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingPeakBandwidth")]
        public Input<int>? EgressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// If `true`, the teaming policy will re-activate failed
        /// uplinks higher in precedence when they come back up.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceMaximumMbit")]
        public Input<int>? FaulttoleranceMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceReservationMbit")]
        public Input<int>? FaulttoleranceReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        /// </summary>
        [Input("faulttoleranceShareCount")]
        public Input<int>? FaulttoleranceShareCount { get; set; }

        /// <summary>
        /// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("faulttoleranceShareLevel")]
        public Input<string>? FaulttoleranceShareLevel { get; set; }

        /// <summary>
        /// The folder to create the DVS in. Forces a new resource
        /// if changed.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrMaximumMbit")]
        public Input<int>? HbrMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrReservationMbit")]
        public Input<int>? HbrReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the hbr traffic class for a custom share level.
        /// </summary>
        [Input("hbrShareCount")]
        public Input<int>? HbrShareCount { get; set; }

        /// <summary>
        /// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("hbrShareLevel")]
        public Input<string>? HbrShareLevel { get; set; }

        [Input("hosts")]
        private InputList<Inputs.DistributedVirtualSwitchHostsArgs>? _hosts;

        /// <summary>
        /// Use the `host` block to declare a host specification. The
        /// options are:
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchHostsArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.DistributedVirtualSwitchHostsArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// The average bandwidth in
        /// bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingAverageBandwidth")]
        public Input<int>? IngressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingBurstSize")]
        public Input<int>? IngressShapingBurstSize { get; set; }

        /// <summary>
        /// `true` if the traffic shaper is
        /// enabled on the port for ingress traffic.
        /// </summary>
        [Input("ingressShapingEnabled")]
        public Input<bool>? IngressShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during
        /// bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingPeakBandwidth")]
        public Input<int>? IngressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// An IPv4 address to identify the switch. This is
        /// mostly useful when used with the Netflow arguments found
        /// below.
        /// </summary>
        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        /// <summary>
        /// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiMaximumMbit")]
        public Input<int>? IscsiMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiReservationMbit")]
        public Input<int>? IscsiReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        /// </summary>
        [Input("iscsiShareCount")]
        public Input<int>? IscsiShareCount { get; set; }

        /// <summary>
        /// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("iscsiShareLevel")]
        public Input<string>? IscsiShareLevel { get; set; }

        /// <summary>
        /// The Link Aggregation Control Protocol group
        /// version to use with the switch. Possible values are `singleLag` and
        /// `multipleLag`.
        /// </summary>
        [Input("lacpApiVersion")]
        public Input<string>? LacpApiVersion { get; set; }

        /// <summary>
        /// Enables LACP for the ports that this policy
        /// applies to.
        /// </summary>
        [Input("lacpEnabled")]
        public Input<bool>? LacpEnabled { get; set; }

        /// <summary>
        /// The LACP mode. Can be one of `active` or `passive`.
        /// </summary>
        [Input("lacpMode")]
        public Input<string>? LacpMode { get; set; }

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic.
        /// </summary>
        [Input("linkDiscoveryOperation")]
        public Input<string>? LinkDiscoveryOperation { get; set; }

        /// <summary>
        /// The discovery protocol type. Valid
        /// types are `cdp` and `lldp`.
        /// </summary>
        [Input("linkDiscoveryProtocol")]
        public Input<string>? LinkDiscoveryProtocol { get; set; }

        /// <summary>
        /// The maximum allowed usage for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementMaximumMbit")]
        public Input<int>? ManagementMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementReservationMbit")]
        public Input<int>? ManagementReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the management traffic class for a custom share level.
        /// </summary>
        [Input("managementShareCount")]
        public Input<int>? ManagementShareCount { get; set; }

        /// <summary>
        /// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("managementShareLevel")]
        public Input<string>? ManagementShareLevel { get; set; }

        /// <summary>
        /// The maximum transmission unit (MTU) for the virtual
        /// switch.
        /// </summary>
        [Input("maxMtu")]
        public Input<int>? MaxMtu { get; set; }

        /// <summary>
        /// The multicast filtering mode to use
        /// with the switch. Can be one of `legacyFiltering` or `snooping`.
        /// </summary>
        [Input("multicastFilteringMode")]
        public Input<string>? MulticastFilteringMode { get; set; }

        /// <summary>
        /// The name of the distributed virtual switch.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The number of seconds after which
        /// active flows are forced to be exported to the collector. Allowed range is
        /// `60` to `3600`. Default: `60`.
        /// </summary>
        [Input("netflowActiveFlowTimeout")]
        public Input<int>? NetflowActiveFlowTimeout { get; set; }

        /// <summary>
        /// IP address for the Netflow
        /// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
        /// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
        /// </summary>
        [Input("netflowCollectorIpAddress")]
        public Input<string>? NetflowCollectorIpAddress { get; set; }

        /// <summary>
        /// Port for the Netflow collector. This
        /// must be set before Netflow can be enabled.
        /// </summary>
        [Input("netflowCollectorPort")]
        public Input<int>? NetflowCollectorPort { get; set; }

        /// <summary>
        /// Enables Netflow on all ports that this policy
        /// applies to.
        /// </summary>
        [Input("netflowEnabled")]
        public Input<bool>? NetflowEnabled { get; set; }

        /// <summary>
        /// The number of seconds after which
        /// idle flows are forced to be exported to the collector. Allowed range is `10`
        /// to `600`. Default: `15`.
        /// </summary>
        [Input("netflowIdleFlowTimeout")]
        public Input<int>? NetflowIdleFlowTimeout { get; set; }

        /// <summary>
        /// Whether to limit analysis to
        /// traffic that has both source and destination served by the same host.
        /// Default: `false`.
        /// </summary>
        [Input("netflowInternalFlowsOnly")]
        public Input<bool>? NetflowInternalFlowsOnly { get; set; }

        /// <summary>
        /// The observation domain ID for
        /// the Netflow collector.
        /// </summary>
        [Input("netflowObservationDomainId")]
        public Input<int>? NetflowObservationDomainId { get; set; }

        /// <summary>
        /// The ratio of total number of packets to
        /// the number of packets analyzed. The default is `0`, which indicates that the
        /// switch should analyze all packets. The maximum value is `1000`, which
        /// indicates an analysis rate of 0.001%.
        /// </summary>
        [Input("netflowSamplingRate")]
        public Input<int>? NetflowSamplingRate { get; set; }

        /// <summary>
        /// Set to `true` to enable
        /// network I/O control. Default: `false`.
        /// </summary>
        [Input("networkResourceControlEnabled")]
        public Input<bool>? NetworkResourceControlEnabled { get; set; }

        /// <summary>
        /// The version of network I/O
        /// control to use. Can be one of `version2` or `version3`. Default: `version2`.
        /// </summary>
        [Input("networkResourceControlVersion")]
        public Input<string>? NetworkResourceControlVersion { get; set; }

        /// <summary>
        /// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsMaximumMbit")]
        public Input<int>? NfsMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsReservationMbit")]
        public Input<int>? NfsReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the nfs traffic class for a custom share level.
        /// </summary>
        [Input("nfsShareCount")]
        public Input<int>? NfsShareCount { get; set; }

        /// <summary>
        /// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("nfsShareLevel")]
        public Input<string>? NfsShareLevel { get; set; }

        /// <summary>
        /// If `true`, the teaming policy will notify the
        /// broadcast network of an uplink failover, triggering cache updates.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// Used to define a secondary VLAN
        /// ID when using private VLANs.
        /// </summary>
        [Input("portPrivateSecondaryVlanId")]
        public Input<int>? PortPrivateSecondaryVlanId { get; set; }

        [Input("standbyUplinks")]
        private InputList<string>? _standbyUplinks;

        /// <summary>
        /// A list of standby uplinks to be used in
        /// failover. These uplinks need to match the definitions in the
        /// `uplinks` DVS argument. See
        /// here for more details.
        /// </summary>
        public InputList<string> StandbyUplinks
        {
            get => _standbyUplinks ?? (_standbyUplinks = new InputList<string>());
            set => _standbyUplinks = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource. See
        /// [here][docs-applying-tags] for a reference on how to apply tags.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The uplink teaming policy. Can be one of
        /// `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
        /// `failover_explicit`.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        /// <summary>
        /// Forward all traffic transmitted by ports for which
        /// this policy applies to its DVS uplinks.
        /// </summary>
        [Input("txUplink")]
        public Input<bool>? TxUplink { get; set; }

        [Input("uplinks")]
        private InputList<string>? _uplinks;

        /// <summary>
        /// A list of strings that uniquely identifies the names
        /// of the uplinks on the DVS across hosts. The number of items in this list
        /// controls the number of uplinks that exist on the DVS, in addition to the
        /// names.  See here for an example on how to
        /// use this option.
        /// </summary>
        public InputList<string> Uplinks
        {
            get => _uplinks ?? (_uplinks = new InputList<string>());
            set => _uplinks = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpMaximumMbit")]
        public Input<int>? VdpMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpReservationMbit")]
        public Input<int>? VdpReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vdp traffic class for a custom share level.
        /// </summary>
        [Input("vdpShareCount")]
        public Input<int>? VdpShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vdpShareLevel")]
        public Input<string>? VdpShareLevel { get; set; }

        /// <summary>
        /// - The version of the DVS to create. The default is to
        /// create the DVS at the latest version supported by the version of vSphere
        /// being used. A DVS can be upgraded to another version, but cannot be
        /// downgraded.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        /// <summary>
        /// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineMaximumMbit")]
        public Input<int>? VirtualmachineMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineReservationMbit")]
        public Input<int>? VirtualmachineReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        /// </summary>
        [Input("virtualmachineShareCount")]
        public Input<int>? VirtualmachineShareCount { get; set; }

        /// <summary>
        /// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("virtualmachineShareLevel")]
        public Input<string>? VirtualmachineShareLevel { get; set; }

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Input("vlanId")]
        public Input<int>? VlanId { get; set; }

        [Input("vlanRanges")]
        private InputList<Inputs.DistributedVirtualSwitchVlanRangesArgs>? _vlanRanges;

        /// <summary>
        /// Used to denote VLAN trunking. Use the `min_vlan`
        /// and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
        /// `vlan_range` definitions are allowed, but they must not overlap. Example
        /// below:
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchVlanRangesArgs> VlanRanges
        {
            get => _vlanRanges ?? (_vlanRanges = new InputList<Inputs.DistributedVirtualSwitchVlanRangesArgs>());
            set => _vlanRanges = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionMaximumMbit")]
        public Input<int>? VmotionMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionReservationMbit")]
        public Input<int>? VmotionReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vmotion traffic class for a custom share level.
        /// </summary>
        [Input("vmotionShareCount")]
        public Input<int>? VmotionShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vmotionShareLevel")]
        public Input<string>? VmotionShareLevel { get; set; }

        /// <summary>
        /// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanMaximumMbit")]
        public Input<int>? VsanMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanReservationMbit")]
        public Input<int>? VsanReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vsan traffic class for a custom share level.
        /// </summary>
        [Input("vsanShareCount")]
        public Input<int>? VsanShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vsanShareLevel")]
        public Input<string>? VsanShareLevel { get; set; }

        public DistributedVirtualSwitchArgs()
        {
        }
    }

    public sealed class DistributedVirtualSwitchState : Pulumi.ResourceArgs
    {
        [Input("activeUplinks")]
        private InputList<string>? _activeUplinks;

        /// <summary>
        /// A list of active uplinks to be used in load
        /// balancing. These uplinks need to match the definitions in the
        /// `uplinks` DVS argument. See
        /// here for more details.
        /// </summary>
        public InputList<string> ActiveUplinks
        {
            get => _activeUplinks ?? (_activeUplinks = new InputList<string>());
            set => _activeUplinks = value;
        }

        /// <summary>
        /// Controls whether or not a virtual
        /// network adapter is allowed to send network traffic with a different MAC
        /// address than that of its own.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access
        /// Control (MAC) address can be changed.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This
        /// flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// Shuts down all ports in the port groups that
        /// this policy applies to, effectively blocking all network access to connected
        /// virtual devices.
        /// </summary>
        [Input("blockAllPorts")]
        public Input<bool>? BlockAllPorts { get; set; }

        /// <summary>
        /// Enables beacon probing as an additional measure
        /// to detect NIC failure.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        /// <summary>
        /// The version string of the configuration that this spec is trying to change.
        /// </summary>
        [Input("configVersion")]
        public Input<string>? ConfigVersion { get; set; }

        /// <summary>
        /// The detailed contact information for the person
        /// who is responsible for the DVS.
        /// </summary>
        [Input("contactDetail")]
        public Input<string>? ContactDetail { get; set; }

        /// <summary>
        /// The name of the person who is responsible for the
        /// DVS.
        /// </summary>
        [Input("contactName")]
        public Input<string>? ContactName { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for virtual switch. See
        /// [here][docs-setting-custom-attributes] for a reference on how to set values
        /// for custom attributes.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The ID of the datacenter where the distributed
        /// virtual switch will be created. Forces a new resource if changed.
        /// </summary>
        [Input("datacenterId")]
        public Input<string>? DatacenterId { get; set; }

        /// <summary>
        /// A detailed description for the DVS.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Allow VMDirectPath Gen2 for the ports
        /// for which this policy applies to.
        /// </summary>
        [Input("directpathGen2Allowed")]
        public Input<bool>? DirectpathGen2Allowed { get; set; }

        /// <summary>
        /// The average bandwidth in bits
        /// per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingAverageBandwidth")]
        public Input<int>? EgressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingBurstSize")]
        public Input<int>? EgressShapingBurstSize { get; set; }

        /// <summary>
        /// `true` if the traffic shaper is enabled
        /// on the port for egress traffic.
        /// </summary>
        [Input("egressShapingEnabled")]
        public Input<bool>? EgressShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during bursts
        /// in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingPeakBandwidth")]
        public Input<int>? EgressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// If `true`, the teaming policy will re-activate failed
        /// uplinks higher in precedence when they come back up.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceMaximumMbit")]
        public Input<int>? FaulttoleranceMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceReservationMbit")]
        public Input<int>? FaulttoleranceReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        /// </summary>
        [Input("faulttoleranceShareCount")]
        public Input<int>? FaulttoleranceShareCount { get; set; }

        /// <summary>
        /// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("faulttoleranceShareLevel")]
        public Input<string>? FaulttoleranceShareLevel { get; set; }

        /// <summary>
        /// The folder to create the DVS in. Forces a new resource
        /// if changed.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrMaximumMbit")]
        public Input<int>? HbrMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrReservationMbit")]
        public Input<int>? HbrReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the hbr traffic class for a custom share level.
        /// </summary>
        [Input("hbrShareCount")]
        public Input<int>? HbrShareCount { get; set; }

        /// <summary>
        /// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("hbrShareLevel")]
        public Input<string>? HbrShareLevel { get; set; }

        [Input("hosts")]
        private InputList<Inputs.DistributedVirtualSwitchHostsGetArgs>? _hosts;

        /// <summary>
        /// Use the `host` block to declare a host specification. The
        /// options are:
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchHostsGetArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.DistributedVirtualSwitchHostsGetArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// The average bandwidth in
        /// bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingAverageBandwidth")]
        public Input<int>? IngressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingBurstSize")]
        public Input<int>? IngressShapingBurstSize { get; set; }

        /// <summary>
        /// `true` if the traffic shaper is
        /// enabled on the port for ingress traffic.
        /// </summary>
        [Input("ingressShapingEnabled")]
        public Input<bool>? IngressShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during
        /// bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingPeakBandwidth")]
        public Input<int>? IngressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// An IPv4 address to identify the switch. This is
        /// mostly useful when used with the Netflow arguments found
        /// below.
        /// </summary>
        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        /// <summary>
        /// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiMaximumMbit")]
        public Input<int>? IscsiMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiReservationMbit")]
        public Input<int>? IscsiReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        /// </summary>
        [Input("iscsiShareCount")]
        public Input<int>? IscsiShareCount { get; set; }

        /// <summary>
        /// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("iscsiShareLevel")]
        public Input<string>? IscsiShareLevel { get; set; }

        /// <summary>
        /// The Link Aggregation Control Protocol group
        /// version to use with the switch. Possible values are `singleLag` and
        /// `multipleLag`.
        /// </summary>
        [Input("lacpApiVersion")]
        public Input<string>? LacpApiVersion { get; set; }

        /// <summary>
        /// Enables LACP for the ports that this policy
        /// applies to.
        /// </summary>
        [Input("lacpEnabled")]
        public Input<bool>? LacpEnabled { get; set; }

        /// <summary>
        /// The LACP mode. Can be one of `active` or `passive`.
        /// </summary>
        [Input("lacpMode")]
        public Input<string>? LacpMode { get; set; }

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic.
        /// </summary>
        [Input("linkDiscoveryOperation")]
        public Input<string>? LinkDiscoveryOperation { get; set; }

        /// <summary>
        /// The discovery protocol type. Valid
        /// types are `cdp` and `lldp`.
        /// </summary>
        [Input("linkDiscoveryProtocol")]
        public Input<string>? LinkDiscoveryProtocol { get; set; }

        /// <summary>
        /// The maximum allowed usage for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementMaximumMbit")]
        public Input<int>? ManagementMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementReservationMbit")]
        public Input<int>? ManagementReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the management traffic class for a custom share level.
        /// </summary>
        [Input("managementShareCount")]
        public Input<int>? ManagementShareCount { get; set; }

        /// <summary>
        /// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("managementShareLevel")]
        public Input<string>? ManagementShareLevel { get; set; }

        /// <summary>
        /// The maximum transmission unit (MTU) for the virtual
        /// switch.
        /// </summary>
        [Input("maxMtu")]
        public Input<int>? MaxMtu { get; set; }

        /// <summary>
        /// The multicast filtering mode to use
        /// with the switch. Can be one of `legacyFiltering` or `snooping`.
        /// </summary>
        [Input("multicastFilteringMode")]
        public Input<string>? MulticastFilteringMode { get; set; }

        /// <summary>
        /// The name of the distributed virtual switch.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The number of seconds after which
        /// active flows are forced to be exported to the collector. Allowed range is
        /// `60` to `3600`. Default: `60`.
        /// </summary>
        [Input("netflowActiveFlowTimeout")]
        public Input<int>? NetflowActiveFlowTimeout { get; set; }

        /// <summary>
        /// IP address for the Netflow
        /// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
        /// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
        /// </summary>
        [Input("netflowCollectorIpAddress")]
        public Input<string>? NetflowCollectorIpAddress { get; set; }

        /// <summary>
        /// Port for the Netflow collector. This
        /// must be set before Netflow can be enabled.
        /// </summary>
        [Input("netflowCollectorPort")]
        public Input<int>? NetflowCollectorPort { get; set; }

        /// <summary>
        /// Enables Netflow on all ports that this policy
        /// applies to.
        /// </summary>
        [Input("netflowEnabled")]
        public Input<bool>? NetflowEnabled { get; set; }

        /// <summary>
        /// The number of seconds after which
        /// idle flows are forced to be exported to the collector. Allowed range is `10`
        /// to `600`. Default: `15`.
        /// </summary>
        [Input("netflowIdleFlowTimeout")]
        public Input<int>? NetflowIdleFlowTimeout { get; set; }

        /// <summary>
        /// Whether to limit analysis to
        /// traffic that has both source and destination served by the same host.
        /// Default: `false`.
        /// </summary>
        [Input("netflowInternalFlowsOnly")]
        public Input<bool>? NetflowInternalFlowsOnly { get; set; }

        /// <summary>
        /// The observation domain ID for
        /// the Netflow collector.
        /// </summary>
        [Input("netflowObservationDomainId")]
        public Input<int>? NetflowObservationDomainId { get; set; }

        /// <summary>
        /// The ratio of total number of packets to
        /// the number of packets analyzed. The default is `0`, which indicates that the
        /// switch should analyze all packets. The maximum value is `1000`, which
        /// indicates an analysis rate of 0.001%.
        /// </summary>
        [Input("netflowSamplingRate")]
        public Input<int>? NetflowSamplingRate { get; set; }

        /// <summary>
        /// Set to `true` to enable
        /// network I/O control. Default: `false`.
        /// </summary>
        [Input("networkResourceControlEnabled")]
        public Input<bool>? NetworkResourceControlEnabled { get; set; }

        /// <summary>
        /// The version of network I/O
        /// control to use. Can be one of `version2` or `version3`. Default: `version2`.
        /// </summary>
        [Input("networkResourceControlVersion")]
        public Input<string>? NetworkResourceControlVersion { get; set; }

        /// <summary>
        /// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsMaximumMbit")]
        public Input<int>? NfsMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsReservationMbit")]
        public Input<int>? NfsReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the nfs traffic class for a custom share level.
        /// </summary>
        [Input("nfsShareCount")]
        public Input<int>? NfsShareCount { get; set; }

        /// <summary>
        /// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("nfsShareLevel")]
        public Input<string>? NfsShareLevel { get; set; }

        /// <summary>
        /// If `true`, the teaming policy will notify the
        /// broadcast network of an uplink failover, triggering cache updates.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// Used to define a secondary VLAN
        /// ID when using private VLANs.
        /// </summary>
        [Input("portPrivateSecondaryVlanId")]
        public Input<int>? PortPrivateSecondaryVlanId { get; set; }

        [Input("standbyUplinks")]
        private InputList<string>? _standbyUplinks;

        /// <summary>
        /// A list of standby uplinks to be used in
        /// failover. These uplinks need to match the definitions in the
        /// `uplinks` DVS argument. See
        /// here for more details.
        /// </summary>
        public InputList<string> StandbyUplinks
        {
            get => _standbyUplinks ?? (_standbyUplinks = new InputList<string>());
            set => _standbyUplinks = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource. See
        /// [here][docs-applying-tags] for a reference on how to apply tags.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The uplink teaming policy. Can be one of
        /// `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
        /// `failover_explicit`.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        /// <summary>
        /// Forward all traffic transmitted by ports for which
        /// this policy applies to its DVS uplinks.
        /// </summary>
        [Input("txUplink")]
        public Input<bool>? TxUplink { get; set; }

        [Input("uplinks")]
        private InputList<string>? _uplinks;

        /// <summary>
        /// A list of strings that uniquely identifies the names
        /// of the uplinks on the DVS across hosts. The number of items in this list
        /// controls the number of uplinks that exist on the DVS, in addition to the
        /// names.  See here for an example on how to
        /// use this option.
        /// </summary>
        public InputList<string> Uplinks
        {
            get => _uplinks ?? (_uplinks = new InputList<string>());
            set => _uplinks = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpMaximumMbit")]
        public Input<int>? VdpMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpReservationMbit")]
        public Input<int>? VdpReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vdp traffic class for a custom share level.
        /// </summary>
        [Input("vdpShareCount")]
        public Input<int>? VdpShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vdpShareLevel")]
        public Input<string>? VdpShareLevel { get; set; }

        /// <summary>
        /// - The version of the DVS to create. The default is to
        /// create the DVS at the latest version supported by the version of vSphere
        /// being used. A DVS can be upgraded to another version, but cannot be
        /// downgraded.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        /// <summary>
        /// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineMaximumMbit")]
        public Input<int>? VirtualmachineMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineReservationMbit")]
        public Input<int>? VirtualmachineReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        /// </summary>
        [Input("virtualmachineShareCount")]
        public Input<int>? VirtualmachineShareCount { get; set; }

        /// <summary>
        /// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("virtualmachineShareLevel")]
        public Input<string>? VirtualmachineShareLevel { get; set; }

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Input("vlanId")]
        public Input<int>? VlanId { get; set; }

        [Input("vlanRanges")]
        private InputList<Inputs.DistributedVirtualSwitchVlanRangesGetArgs>? _vlanRanges;

        /// <summary>
        /// Used to denote VLAN trunking. Use the `min_vlan`
        /// and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
        /// `vlan_range` definitions are allowed, but they must not overlap. Example
        /// below:
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchVlanRangesGetArgs> VlanRanges
        {
            get => _vlanRanges ?? (_vlanRanges = new InputList<Inputs.DistributedVirtualSwitchVlanRangesGetArgs>());
            set => _vlanRanges = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionMaximumMbit")]
        public Input<int>? VmotionMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionReservationMbit")]
        public Input<int>? VmotionReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vmotion traffic class for a custom share level.
        /// </summary>
        [Input("vmotionShareCount")]
        public Input<int>? VmotionShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vmotionShareLevel")]
        public Input<string>? VmotionShareLevel { get; set; }

        /// <summary>
        /// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanMaximumMbit")]
        public Input<int>? VsanMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanReservationMbit")]
        public Input<int>? VsanReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vsan traffic class for a custom share level.
        /// </summary>
        [Input("vsanShareCount")]
        public Input<int>? VsanShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vsanShareLevel")]
        public Input<string>? VsanShareLevel { get; set; }

        public DistributedVirtualSwitchState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class DistributedVirtualSwitchHostsArgs : Pulumi.ResourceArgs
    {
        [Input("devices", required: true)]
        private InputList<string>? _devices;

        /// <summary>
        /// The list of NIC devices to map to uplinks on the DVS,
        /// added in order they are specified.
        /// </summary>
        public InputList<string> Devices
        {
            get => _devices ?? (_devices = new InputList<string>());
            set => _devices = value;
        }

        /// <summary>
        /// The host system ID of the host to add to the
        /// DVS.
        /// </summary>
        [Input("hostSystemId", required: true)]
        public Input<string> HostSystemId { get; set; } = null!;

        public DistributedVirtualSwitchHostsArgs()
        {
        }
    }

    public sealed class DistributedVirtualSwitchHostsGetArgs : Pulumi.ResourceArgs
    {
        [Input("devices", required: true)]
        private InputList<string>? _devices;

        /// <summary>
        /// The list of NIC devices to map to uplinks on the DVS,
        /// added in order they are specified.
        /// </summary>
        public InputList<string> Devices
        {
            get => _devices ?? (_devices = new InputList<string>());
            set => _devices = value;
        }

        /// <summary>
        /// The host system ID of the host to add to the
        /// DVS.
        /// </summary>
        [Input("hostSystemId", required: true)]
        public Input<string> HostSystemId { get; set; } = null!;

        public DistributedVirtualSwitchHostsGetArgs()
        {
        }
    }

    public sealed class DistributedVirtualSwitchVlanRangesArgs : Pulumi.ResourceArgs
    {
        [Input("maxVlan", required: true)]
        public Input<int> MaxVlan { get; set; } = null!;

        [Input("minVlan", required: true)]
        public Input<int> MinVlan { get; set; } = null!;

        public DistributedVirtualSwitchVlanRangesArgs()
        {
        }
    }

    public sealed class DistributedVirtualSwitchVlanRangesGetArgs : Pulumi.ResourceArgs
    {
        [Input("maxVlan", required: true)]
        public Input<int> MaxVlan { get; set; } = null!;

        [Input("minVlan", required: true)]
        public Input<int> MinVlan { get; set; } = null!;

        public DistributedVirtualSwitchVlanRangesGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class DistributedVirtualSwitchHosts
    {
        /// <summary>
        /// The list of NIC devices to map to uplinks on the DVS,
        /// added in order they are specified.
        /// </summary>
        public readonly ImmutableArray<string> Devices;
        /// <summary>
        /// The host system ID of the host to add to the
        /// DVS.
        /// </summary>
        public readonly string HostSystemId;

        [OutputConstructor]
        private DistributedVirtualSwitchHosts(
            ImmutableArray<string> devices,
            string hostSystemId)
        {
            Devices = devices;
            HostSystemId = hostSystemId;
        }
    }

    [OutputType]
    public sealed class DistributedVirtualSwitchVlanRanges
    {
        public readonly int MaxVlan;
        public readonly int MinVlan;

        [OutputConstructor]
        private DistributedVirtualSwitchVlanRanges(
            int maxVlan,
            int minVlan)
        {
            MaxVlan = maxVlan;
            MinVlan = minVlan;
        }
    }
    }
}
