// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.VSphere
{
    /// <summary>
    /// The `vsphere.DistributedVirtualSwitch` resource can be used to manage vSphere
    /// Distributed Switches (VDS).
    /// 
    /// An essential component of a distributed, scalable vSphere infrastructure, the
    /// VDS provides centralized management and monitoring of the networking
    /// configuration for all the hosts that are associated with the switch.
    /// In addition to adding distributed port groups
    /// (see the `vsphere.DistributedPortGroup` resource)
    /// that can be used as networks for virtual machines, a VDS can be configured to
    /// perform advanced high availability, traffic shaping, network monitoring, etc.
    /// 
    /// For an overview on vSphere networking concepts, see
    /// [this page][ref-vsphere-net-concepts].
    /// 
    /// For more information on the VDS, see [this page][ref-vsphere-vds].
    /// 
    /// [ref-vsphere-net-concepts]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches/dvport-groups.html
    /// [ref-vsphere-vds]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches.html
    /// 
    /// &gt; **NOTE:** This resource requires vCenter and is not available on
    /// direct ESXi host connections.
    /// 
    /// ### Uplink name and count control
    /// 
    /// The following abridged example below demonstrates how you can manage the number
    /// of uplinks, and the name of the uplinks via the `uplinks` parameter.
    /// 
    /// Note that if you change the uplink naming and count after creating the VDS, you
    /// may need to explicitly specify `active_uplinks` and `standby_uplinks` as these
    /// values are saved to state after creation, regardless of being
    /// specified in config, and will drift if not modified, causing errors.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using VSphere = Pulumi.VSphere;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var vds = new VSphere.DistributedVirtualSwitch("vds", new()
    ///     {
    ///         Name = "vds-01",
    ///         DatacenterId = datacenter.Id,
    ///         Uplinks = new[]
    ///         {
    ///             "uplink1",
    ///             "uplink2",
    ///         },
    ///         ActiveUplinks = new[]
    ///         {
    ///             "uplink1",
    ///         },
    ///         StandbyUplinks = new[]
    ///         {
    ///             "uplink2",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// &gt; **NOTE:** The default uplink names when a VDS is created are `uplink1`
    /// through to `uplink4`, however this default is not guaranteed to be stable and
    /// you are encouraged to set your own.
    /// 
    /// ## Import
    /// 
    /// An existing VDS can be imported into this resource via the path
    /// 
    /// to the VDS, via the following command:
    /// 
    /// [docs-import]: https://developer.hashicorp.com/terraform/cli/import
    /// 
    /// ```sh
    /// $ pulumi import vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch vds /dc-01/network/vds-01
    /// ```
    /// 
    /// The above would import the VDS named `vds-01` that is located in the `dc-01`
    /// 
    /// datacenter.
    /// </summary>
    [VSphereResourceType("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch")]
    public partial class DistributedVirtualSwitch : global::Pulumi.CustomResource
    {
        /// <summary>
        /// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        [Output("activeUplinks")]
        public Output<ImmutableArray<string>> ActiveUplinks { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
        /// that of its own.
        /// </summary>
        [Output("allowForgedTransmits")]
        public Output<bool> AllowForgedTransmits { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the Media Access Control (MAC) address can be changed.
        /// </summary>
        [Output("allowMacChanges")]
        public Output<bool> AllowMacChanges { get; private set; } = null!;

        /// <summary>
        /// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Output("allowPromiscuous")]
        public Output<bool> AllowPromiscuous { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Output("backupnfcMaximumMbit")]
        public Output<int> BackupnfcMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Output("backupnfcReservationMbit")]
        public Output<int> BackupnfcReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
        /// </summary>
        [Output("backupnfcShareCount")]
        public Output<int> BackupnfcShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("backupnfcShareLevel")]
        public Output<string> BackupnfcShareLevel { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to block all ports by default.
        /// </summary>
        [Output("blockAllPorts")]
        public Output<bool> BlockAllPorts { get; private set; } = null!;

        /// <summary>
        /// Enable beacon probing on the ports this policy applies to.
        /// </summary>
        [Output("checkBeacon")]
        public Output<bool> CheckBeacon { get; private set; } = null!;

        /// <summary>
        /// The current version of the VDS configuration, incremented
        /// by subsequent updates to the VDS.
        /// </summary>
        [Output("configVersion")]
        public Output<string> ConfigVersion { get; private set; } = null!;

        /// <summary>
        /// The detailed contact information for the person
        /// who is responsible for the VDS.
        /// </summary>
        [Output("contactDetail")]
        public Output<string?> ContactDetail { get; private set; } = null!;

        /// <summary>
        /// The name of the person who is responsible for the
        /// VDS.
        /// </summary>
        [Output("contactName")]
        public Output<string?> ContactName { get; private set; } = null!;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for VDS.
        /// 
        /// &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
        /// and requires vCenter Server.
        /// </summary>
        [Output("customAttributes")]
        public Output<ImmutableDictionary<string, string>?> CustomAttributes { get; private set; } = null!;

        /// <summary>
        /// The ID of the datacenter where the VDS will be
        /// created. Forces a new resource if changed.
        /// </summary>
        [Output("datacenterId")]
        public Output<string> DatacenterId { get; private set; } = null!;

        /// <summary>
        /// A detailed description for the VDS.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Allow VMDirectPath Gen2 on the ports this policy applies to.
        /// </summary>
        [Output("directpathGen2Allowed")]
        public Output<bool> DirectpathGen2Allowed { get; private set; } = null!;

        /// <summary>
        /// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingAverageBandwidth")]
        public Output<int> EgressShapingAverageBandwidth { get; private set; } = null!;

        /// <summary>
        /// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingBurstSize")]
        public Output<int> EgressShapingBurstSize { get; private set; } = null!;

        /// <summary>
        /// True if the traffic shaper is enabled for egress traffic on the port.
        /// </summary>
        [Output("egressShapingEnabled")]
        public Output<bool> EgressShapingEnabled { get; private set; } = null!;

        /// <summary>
        /// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingPeakBandwidth")]
        public Output<int> EgressShapingPeakBandwidth { get; private set; } = null!;

        /// <summary>
        /// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
        /// </summary>
        [Output("failback")]
        public Output<bool> Failback { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Output("faulttoleranceMaximumMbit")]
        public Output<int> FaulttoleranceMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Output("faulttoleranceReservationMbit")]
        public Output<int> FaulttoleranceReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        /// </summary>
        [Output("faulttoleranceShareCount")]
        public Output<int> FaulttoleranceShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("faulttoleranceShareLevel")]
        public Output<string> FaulttoleranceShareLevel { get; private set; } = null!;

        /// <summary>
        /// The folder in which to create the VDS.
        /// Forces a new resource if changed.
        /// </summary>
        [Output("folder")]
        public Output<string?> Folder { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Output("hbrMaximumMbit")]
        public Output<int> HbrMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Output("hbrReservationMbit")]
        public Output<int> HbrReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the hbr traffic class for a custom share level.
        /// </summary>
        [Output("hbrShareCount")]
        public Output<int> HbrShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("hbrShareLevel")]
        public Output<string> HbrShareLevel { get; private set; } = null!;

        /// <summary>
        /// A host member specification.
        /// </summary>
        [Output("hosts")]
        public Output<ImmutableArray<Outputs.DistributedVirtualSwitchHost>> Hosts { get; private set; } = null!;

        /// <summary>
        /// Whether to ignore existing PVLAN mappings not managed by this resource.
        /// </summary>
        [Output("ignoreOtherPvlanMappings")]
        public Output<bool?> IgnoreOtherPvlanMappings { get; private set; } = null!;

        /// <summary>
        /// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingAverageBandwidth")]
        public Output<int> IngressShapingAverageBandwidth { get; private set; } = null!;

        /// <summary>
        /// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingBurstSize")]
        public Output<int> IngressShapingBurstSize { get; private set; } = null!;

        /// <summary>
        /// True if the traffic shaper is enabled for ingress traffic on the port.
        /// </summary>
        [Output("ingressShapingEnabled")]
        public Output<bool> IngressShapingEnabled { get; private set; } = null!;

        /// <summary>
        /// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingPeakBandwidth")]
        public Output<int> IngressShapingPeakBandwidth { get; private set; } = null!;

        /// <summary>
        /// An IPv4 address to identify the switch. This is
        /// mostly useful when used with the Netflow arguments.
        /// </summary>
        [Output("ipv4Address")]
        public Output<string?> Ipv4Address { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Output("iscsiMaximumMbit")]
        public Output<int> IscsiMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Output("iscsiReservationMbit")]
        public Output<int> IscsiReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        /// </summary>
        [Output("iscsiShareCount")]
        public Output<int> IscsiShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("iscsiShareLevel")]
        public Output<string> IscsiShareLevel { get; private set; } = null!;

        /// <summary>
        /// The Link Aggregation Control Protocol group
        /// version to use with the VDS. Possible values are `singleLag` and
        /// `multipleLag`.
        /// </summary>
        [Output("lacpApiVersion")]
        public Output<string> LacpApiVersion { get; private set; } = null!;

        /// <summary>
        /// Whether or not to enable LACP on all uplink ports.
        /// </summary>
        [Output("lacpEnabled")]
        public Output<bool> LacpEnabled { get; private set; } = null!;

        /// <summary>
        /// The uplink LACP mode to use. Can be one of active or passive.
        /// </summary>
        [Output("lacpMode")]
        public Output<string> LacpMode { get; private set; } = null!;

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic.
        /// </summary>
        [Output("linkDiscoveryOperation")]
        public Output<string?> LinkDiscoveryOperation { get; private set; } = null!;

        /// <summary>
        /// The discovery protocol type. Valid
        /// types are `cdp` and `lldp`.
        /// </summary>
        [Output("linkDiscoveryProtocol")]
        public Output<string?> LinkDiscoveryProtocol { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the management traffic class, in Mbits/sec.
        /// </summary>
        [Output("managementMaximumMbit")]
        public Output<int> ManagementMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        /// </summary>
        [Output("managementReservationMbit")]
        public Output<int> ManagementReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the management traffic class for a custom share level.
        /// </summary>
        [Output("managementShareCount")]
        public Output<int> ManagementShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("managementShareLevel")]
        public Output<string> ManagementShareLevel { get; private set; } = null!;

        /// <summary>
        /// The maximum transmission unit (MTU) for the VDS.
        /// </summary>
        [Output("maxMtu")]
        public Output<int> MaxMtu { get; private set; } = null!;

        /// <summary>
        /// The multicast filtering mode to use
        /// with the VDS. Can be one of `legacyFiltering` or `snooping`.
        /// </summary>
        [Output("multicastFilteringMode")]
        public Output<string> MulticastFilteringMode { get; private set; } = null!;

        /// <summary>
        /// The name of the VDS.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The number of seconds after which active flows are forced to be exported to the collector.
        /// </summary>
        [Output("netflowActiveFlowTimeout")]
        public Output<int?> NetflowActiveFlowTimeout { get; private set; } = null!;

        /// <summary>
        /// IP address for the netflow collector, using IPv4 or IPv6.
        /// </summary>
        [Output("netflowCollectorIpAddress")]
        public Output<string?> NetflowCollectorIpAddress { get; private set; } = null!;

        /// <summary>
        /// The port for the netflow collector.
        /// </summary>
        [Output("netflowCollectorPort")]
        public Output<int?> NetflowCollectorPort { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to enable netflow on all ports.
        /// </summary>
        [Output("netflowEnabled")]
        public Output<bool> NetflowEnabled { get; private set; } = null!;

        /// <summary>
        /// The number of seconds after which idle flows are forced to be exported to the collector.
        /// </summary>
        [Output("netflowIdleFlowTimeout")]
        public Output<int?> NetflowIdleFlowTimeout { get; private set; } = null!;

        /// <summary>
        /// Whether to limit analysis to traffic that has both source and destination served by the same host.
        /// </summary>
        [Output("netflowInternalFlowsOnly")]
        public Output<bool?> NetflowInternalFlowsOnly { get; private set; } = null!;

        /// <summary>
        /// The observation Domain ID for the netflow collector.
        /// </summary>
        [Output("netflowObservationDomainId")]
        public Output<int?> NetflowObservationDomainId { get; private set; } = null!;

        /// <summary>
        /// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all
        /// packets are analyzed.
        /// </summary>
        [Output("netflowSamplingRate")]
        public Output<int?> NetflowSamplingRate { get; private set; } = null!;

        /// <summary>
        /// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
        /// </summary>
        [Output("networkResourceControlEnabled")]
        public Output<bool?> NetworkResourceControlEnabled { get; private set; } = null!;

        /// <summary>
        /// The network I/O control version to use. Can be one of version2 or version3.
        /// </summary>
        [Output("networkResourceControlVersion")]
        public Output<string> NetworkResourceControlVersion { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Output("nfsMaximumMbit")]
        public Output<int> NfsMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Output("nfsReservationMbit")]
        public Output<int> NfsReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the nfs traffic class for a custom share level.
        /// </summary>
        [Output("nfsShareCount")]
        public Output<int> NfsShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("nfsShareLevel")]
        public Output<string> NfsShareLevel { get; private set; } = null!;

        /// <summary>
        /// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
        /// </summary>
        [Output("notifySwitches")]
        public Output<bool> NotifySwitches { get; private set; } = null!;

        /// <summary>
        /// The secondary VLAN ID for this port.
        /// </summary>
        [Output("portPrivateSecondaryVlanId")]
        public Output<int> PortPrivateSecondaryVlanId { get; private set; } = null!;

        /// <summary>
        /// A private VLAN (PVLAN) mapping.
        /// </summary>
        [Output("pvlanMappings")]
        public Output<ImmutableArray<Outputs.DistributedVirtualSwitchPvlanMapping>> PvlanMappings { get; private set; } = null!;

        /// <summary>
        /// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        [Output("standbyUplinks")]
        public Output<ImmutableArray<string>> StandbyUplinks { get; private set; } = null!;

        /// <summary>
        /// The IDs of any tags to attach to this resource.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
        /// failover_explicit, or loadbalance_loadbased.
        /// </summary>
        [Output("teamingPolicy")]
        public Output<string> TeamingPolicy { get; private set; } = null!;

        /// <summary>
        /// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
        /// forwarded done by the switch.
        /// </summary>
        [Output("txUplink")]
        public Output<bool> TxUplink { get; private set; } = null!;

        /// <summary>
        /// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS
        /// across hosts.
        /// </summary>
        [Output("uplinks")]
        public Output<ImmutableArray<string>> Uplinks { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Output("vdpMaximumMbit")]
        public Output<int> VdpMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Output("vdpReservationMbit")]
        public Output<int> VdpReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the vdp traffic class for a custom share level.
        /// </summary>
        [Output("vdpShareCount")]
        public Output<int> VdpShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("vdpShareLevel")]
        public Output<string> VdpShareLevel { get; private set; } = null!;

        /// <summary>
        /// The version of the VDS. BY default, a VDS is created
        /// at the latest version supported by the vSphere version if not specified.
        /// A VDS can be upgraded to a newer version, but can not be downgraded.
        /// </summary>
        [Output("version")]
        public Output<string> Version { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Output("virtualmachineMaximumMbit")]
        public Output<int> VirtualmachineMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Output("virtualmachineReservationMbit")]
        public Output<int> VirtualmachineReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        /// </summary>
        [Output("virtualmachineShareCount")]
        public Output<int> VirtualmachineShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("virtualmachineShareLevel")]
        public Output<string> VirtualmachineShareLevel { get; private set; } = null!;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Output("vlanId")]
        public Output<int> VlanId { get; private set; } = null!;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Output("vlanRanges")]
        public Output<ImmutableArray<Outputs.DistributedVirtualSwitchVlanRange>> VlanRanges { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Output("vmotionMaximumMbit")]
        public Output<int> VmotionMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Output("vmotionReservationMbit")]
        public Output<int> VmotionReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the vmotion traffic class for a custom share level.
        /// </summary>
        [Output("vmotionShareCount")]
        public Output<int> VmotionShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("vmotionShareLevel")]
        public Output<string> VmotionShareLevel { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Output("vsanMaximumMbit")]
        public Output<int> VsanMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Output("vsanReservationMbit")]
        public Output<int> VsanReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the vsan traffic class for a custom share level.
        /// </summary>
        [Output("vsanShareCount")]
        public Output<int> VsanShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("vsanShareLevel")]
        public Output<string> VsanShareLevel { get; private set; } = null!;


        /// <summary>
        /// Create a DistributedVirtualSwitch resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public DistributedVirtualSwitch(string name, DistributedVirtualSwitchArgs args, CustomResourceOptions? options = null)
            : base("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, args ?? new DistributedVirtualSwitchArgs(), MakeResourceOptions(options, ""))
        {
        }

        private DistributedVirtualSwitch(string name, Input<string> id, DistributedVirtualSwitchState? state = null, CustomResourceOptions? options = null)
            : base("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing DistributedVirtualSwitch resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static DistributedVirtualSwitch Get(string name, Input<string> id, DistributedVirtualSwitchState? state = null, CustomResourceOptions? options = null)
        {
            return new DistributedVirtualSwitch(name, id, state, options);
        }
    }

    public sealed class DistributedVirtualSwitchArgs : global::Pulumi.ResourceArgs
    {
        [Input("activeUplinks")]
        private InputList<string>? _activeUplinks;

        /// <summary>
        /// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        public InputList<string> ActiveUplinks
        {
            get => _activeUplinks ?? (_activeUplinks = new InputList<string>());
            set => _activeUplinks = value;
        }

        /// <summary>
        /// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
        /// that of its own.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access Control (MAC) address can be changed.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Input("backupnfcMaximumMbit")]
        public Input<int>? BackupnfcMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Input("backupnfcReservationMbit")]
        public Input<int>? BackupnfcReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
        /// </summary>
        [Input("backupnfcShareCount")]
        public Input<int>? BackupnfcShareCount { get; set; }

        /// <summary>
        /// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("backupnfcShareLevel")]
        public Input<string>? BackupnfcShareLevel { get; set; }

        /// <summary>
        /// Indicates whether to block all ports by default.
        /// </summary>
        [Input("blockAllPorts")]
        public Input<bool>? BlockAllPorts { get; set; }

        /// <summary>
        /// Enable beacon probing on the ports this policy applies to.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        /// <summary>
        /// The detailed contact information for the person
        /// who is responsible for the VDS.
        /// </summary>
        [Input("contactDetail")]
        public Input<string>? ContactDetail { get; set; }

        /// <summary>
        /// The name of the person who is responsible for the
        /// VDS.
        /// </summary>
        [Input("contactName")]
        public Input<string>? ContactName { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for VDS.
        /// 
        /// &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
        /// and requires vCenter Server.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The ID of the datacenter where the VDS will be
        /// created. Forces a new resource if changed.
        /// </summary>
        [Input("datacenterId", required: true)]
        public Input<string> DatacenterId { get; set; } = null!;

        /// <summary>
        /// A detailed description for the VDS.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Allow VMDirectPath Gen2 on the ports this policy applies to.
        /// </summary>
        [Input("directpathGen2Allowed")]
        public Input<bool>? DirectpathGen2Allowed { get; set; }

        /// <summary>
        /// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingAverageBandwidth")]
        public Input<int>? EgressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingBurstSize")]
        public Input<int>? EgressShapingBurstSize { get; set; }

        /// <summary>
        /// True if the traffic shaper is enabled for egress traffic on the port.
        /// </summary>
        [Input("egressShapingEnabled")]
        public Input<bool>? EgressShapingEnabled { get; set; }

        /// <summary>
        /// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingPeakBandwidth")]
        public Input<int>? EgressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceMaximumMbit")]
        public Input<int>? FaulttoleranceMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceReservationMbit")]
        public Input<int>? FaulttoleranceReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        /// </summary>
        [Input("faulttoleranceShareCount")]
        public Input<int>? FaulttoleranceShareCount { get; set; }

        /// <summary>
        /// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("faulttoleranceShareLevel")]
        public Input<string>? FaulttoleranceShareLevel { get; set; }

        /// <summary>
        /// The folder in which to create the VDS.
        /// Forces a new resource if changed.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrMaximumMbit")]
        public Input<int>? HbrMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrReservationMbit")]
        public Input<int>? HbrReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the hbr traffic class for a custom share level.
        /// </summary>
        [Input("hbrShareCount")]
        public Input<int>? HbrShareCount { get; set; }

        /// <summary>
        /// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("hbrShareLevel")]
        public Input<string>? HbrShareLevel { get; set; }

        [Input("hosts")]
        private InputList<Inputs.DistributedVirtualSwitchHostArgs>? _hosts;

        /// <summary>
        /// A host member specification.
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchHostArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.DistributedVirtualSwitchHostArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// Whether to ignore existing PVLAN mappings not managed by this resource.
        /// </summary>
        [Input("ignoreOtherPvlanMappings")]
        public Input<bool>? IgnoreOtherPvlanMappings { get; set; }

        /// <summary>
        /// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingAverageBandwidth")]
        public Input<int>? IngressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingBurstSize")]
        public Input<int>? IngressShapingBurstSize { get; set; }

        /// <summary>
        /// True if the traffic shaper is enabled for ingress traffic on the port.
        /// </summary>
        [Input("ingressShapingEnabled")]
        public Input<bool>? IngressShapingEnabled { get; set; }

        /// <summary>
        /// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingPeakBandwidth")]
        public Input<int>? IngressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// An IPv4 address to identify the switch. This is
        /// mostly useful when used with the Netflow arguments.
        /// </summary>
        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        /// <summary>
        /// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiMaximumMbit")]
        public Input<int>? IscsiMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiReservationMbit")]
        public Input<int>? IscsiReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        /// </summary>
        [Input("iscsiShareCount")]
        public Input<int>? IscsiShareCount { get; set; }

        /// <summary>
        /// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("iscsiShareLevel")]
        public Input<string>? IscsiShareLevel { get; set; }

        /// <summary>
        /// The Link Aggregation Control Protocol group
        /// version to use with the VDS. Possible values are `singleLag` and
        /// `multipleLag`.
        /// </summary>
        [Input("lacpApiVersion")]
        public Input<string>? LacpApiVersion { get; set; }

        /// <summary>
        /// Whether or not to enable LACP on all uplink ports.
        /// </summary>
        [Input("lacpEnabled")]
        public Input<bool>? LacpEnabled { get; set; }

        /// <summary>
        /// The uplink LACP mode to use. Can be one of active or passive.
        /// </summary>
        [Input("lacpMode")]
        public Input<string>? LacpMode { get; set; }

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic.
        /// </summary>
        [Input("linkDiscoveryOperation")]
        public Input<string>? LinkDiscoveryOperation { get; set; }

        /// <summary>
        /// The discovery protocol type. Valid
        /// types are `cdp` and `lldp`.
        /// </summary>
        [Input("linkDiscoveryProtocol")]
        public Input<string>? LinkDiscoveryProtocol { get; set; }

        /// <summary>
        /// The maximum allowed usage for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementMaximumMbit")]
        public Input<int>? ManagementMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementReservationMbit")]
        public Input<int>? ManagementReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the management traffic class for a custom share level.
        /// </summary>
        [Input("managementShareCount")]
        public Input<int>? ManagementShareCount { get; set; }

        /// <summary>
        /// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("managementShareLevel")]
        public Input<string>? ManagementShareLevel { get; set; }

        /// <summary>
        /// The maximum transmission unit (MTU) for the VDS.
        /// </summary>
        [Input("maxMtu")]
        public Input<int>? MaxMtu { get; set; }

        /// <summary>
        /// The multicast filtering mode to use
        /// with the VDS. Can be one of `legacyFiltering` or `snooping`.
        /// </summary>
        [Input("multicastFilteringMode")]
        public Input<string>? MulticastFilteringMode { get; set; }

        /// <summary>
        /// The name of the VDS.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The number of seconds after which active flows are forced to be exported to the collector.
        /// </summary>
        [Input("netflowActiveFlowTimeout")]
        public Input<int>? NetflowActiveFlowTimeout { get; set; }

        /// <summary>
        /// IP address for the netflow collector, using IPv4 or IPv6.
        /// </summary>
        [Input("netflowCollectorIpAddress")]
        public Input<string>? NetflowCollectorIpAddress { get; set; }

        /// <summary>
        /// The port for the netflow collector.
        /// </summary>
        [Input("netflowCollectorPort")]
        public Input<int>? NetflowCollectorPort { get; set; }

        /// <summary>
        /// Indicates whether to enable netflow on all ports.
        /// </summary>
        [Input("netflowEnabled")]
        public Input<bool>? NetflowEnabled { get; set; }

        /// <summary>
        /// The number of seconds after which idle flows are forced to be exported to the collector.
        /// </summary>
        [Input("netflowIdleFlowTimeout")]
        public Input<int>? NetflowIdleFlowTimeout { get; set; }

        /// <summary>
        /// Whether to limit analysis to traffic that has both source and destination served by the same host.
        /// </summary>
        [Input("netflowInternalFlowsOnly")]
        public Input<bool>? NetflowInternalFlowsOnly { get; set; }

        /// <summary>
        /// The observation Domain ID for the netflow collector.
        /// </summary>
        [Input("netflowObservationDomainId")]
        public Input<int>? NetflowObservationDomainId { get; set; }

        /// <summary>
        /// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all
        /// packets are analyzed.
        /// </summary>
        [Input("netflowSamplingRate")]
        public Input<int>? NetflowSamplingRate { get; set; }

        /// <summary>
        /// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
        /// </summary>
        [Input("networkResourceControlEnabled")]
        public Input<bool>? NetworkResourceControlEnabled { get; set; }

        /// <summary>
        /// The network I/O control version to use. Can be one of version2 or version3.
        /// </summary>
        [Input("networkResourceControlVersion")]
        public Input<string>? NetworkResourceControlVersion { get; set; }

        /// <summary>
        /// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsMaximumMbit")]
        public Input<int>? NfsMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsReservationMbit")]
        public Input<int>? NfsReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the nfs traffic class for a custom share level.
        /// </summary>
        [Input("nfsShareCount")]
        public Input<int>? NfsShareCount { get; set; }

        /// <summary>
        /// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("nfsShareLevel")]
        public Input<string>? NfsShareLevel { get; set; }

        /// <summary>
        /// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// The secondary VLAN ID for this port.
        /// </summary>
        [Input("portPrivateSecondaryVlanId")]
        public Input<int>? PortPrivateSecondaryVlanId { get; set; }

        [Input("pvlanMappings")]
        private InputList<Inputs.DistributedVirtualSwitchPvlanMappingArgs>? _pvlanMappings;

        /// <summary>
        /// A private VLAN (PVLAN) mapping.
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchPvlanMappingArgs> PvlanMappings
        {
            get => _pvlanMappings ?? (_pvlanMappings = new InputList<Inputs.DistributedVirtualSwitchPvlanMappingArgs>());
            set => _pvlanMappings = value;
        }

        [Input("standbyUplinks")]
        private InputList<string>? _standbyUplinks;

        /// <summary>
        /// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        public InputList<string> StandbyUplinks
        {
            get => _standbyUplinks ?? (_standbyUplinks = new InputList<string>());
            set => _standbyUplinks = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
        /// failover_explicit, or loadbalance_loadbased.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        /// <summary>
        /// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
        /// forwarded done by the switch.
        /// </summary>
        [Input("txUplink")]
        public Input<bool>? TxUplink { get; set; }

        [Input("uplinks")]
        private InputList<string>? _uplinks;

        /// <summary>
        /// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS
        /// across hosts.
        /// </summary>
        public InputList<string> Uplinks
        {
            get => _uplinks ?? (_uplinks = new InputList<string>());
            set => _uplinks = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpMaximumMbit")]
        public Input<int>? VdpMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpReservationMbit")]
        public Input<int>? VdpReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vdp traffic class for a custom share level.
        /// </summary>
        [Input("vdpShareCount")]
        public Input<int>? VdpShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vdpShareLevel")]
        public Input<string>? VdpShareLevel { get; set; }

        /// <summary>
        /// The version of the VDS. BY default, a VDS is created
        /// at the latest version supported by the vSphere version if not specified.
        /// A VDS can be upgraded to a newer version, but can not be downgraded.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        /// <summary>
        /// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineMaximumMbit")]
        public Input<int>? VirtualmachineMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineReservationMbit")]
        public Input<int>? VirtualmachineReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        /// </summary>
        [Input("virtualmachineShareCount")]
        public Input<int>? VirtualmachineShareCount { get; set; }

        /// <summary>
        /// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("virtualmachineShareLevel")]
        public Input<string>? VirtualmachineShareLevel { get; set; }

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Input("vlanId")]
        public Input<int>? VlanId { get; set; }

        [Input("vlanRanges")]
        private InputList<Inputs.DistributedVirtualSwitchVlanRangeArgs>? _vlanRanges;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchVlanRangeArgs> VlanRanges
        {
            get => _vlanRanges ?? (_vlanRanges = new InputList<Inputs.DistributedVirtualSwitchVlanRangeArgs>());
            set => _vlanRanges = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionMaximumMbit")]
        public Input<int>? VmotionMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionReservationMbit")]
        public Input<int>? VmotionReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vmotion traffic class for a custom share level.
        /// </summary>
        [Input("vmotionShareCount")]
        public Input<int>? VmotionShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vmotionShareLevel")]
        public Input<string>? VmotionShareLevel { get; set; }

        /// <summary>
        /// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanMaximumMbit")]
        public Input<int>? VsanMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanReservationMbit")]
        public Input<int>? VsanReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vsan traffic class for a custom share level.
        /// </summary>
        [Input("vsanShareCount")]
        public Input<int>? VsanShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vsanShareLevel")]
        public Input<string>? VsanShareLevel { get; set; }

        public DistributedVirtualSwitchArgs()
        {
        }
        public static new DistributedVirtualSwitchArgs Empty => new DistributedVirtualSwitchArgs();
    }

    public sealed class DistributedVirtualSwitchState : global::Pulumi.ResourceArgs
    {
        [Input("activeUplinks")]
        private InputList<string>? _activeUplinks;

        /// <summary>
        /// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        public InputList<string> ActiveUplinks
        {
            get => _activeUplinks ?? (_activeUplinks = new InputList<string>());
            set => _activeUplinks = value;
        }

        /// <summary>
        /// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
        /// that of its own.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access Control (MAC) address can be changed.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Input("backupnfcMaximumMbit")]
        public Input<int>? BackupnfcMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Input("backupnfcReservationMbit")]
        public Input<int>? BackupnfcReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
        /// </summary>
        [Input("backupnfcShareCount")]
        public Input<int>? BackupnfcShareCount { get; set; }

        /// <summary>
        /// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("backupnfcShareLevel")]
        public Input<string>? BackupnfcShareLevel { get; set; }

        /// <summary>
        /// Indicates whether to block all ports by default.
        /// </summary>
        [Input("blockAllPorts")]
        public Input<bool>? BlockAllPorts { get; set; }

        /// <summary>
        /// Enable beacon probing on the ports this policy applies to.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        /// <summary>
        /// The current version of the VDS configuration, incremented
        /// by subsequent updates to the VDS.
        /// </summary>
        [Input("configVersion")]
        public Input<string>? ConfigVersion { get; set; }

        /// <summary>
        /// The detailed contact information for the person
        /// who is responsible for the VDS.
        /// </summary>
        [Input("contactDetail")]
        public Input<string>? ContactDetail { get; set; }

        /// <summary>
        /// The name of the person who is responsible for the
        /// VDS.
        /// </summary>
        [Input("contactName")]
        public Input<string>? ContactName { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for VDS.
        /// 
        /// &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
        /// and requires vCenter Server.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The ID of the datacenter where the VDS will be
        /// created. Forces a new resource if changed.
        /// </summary>
        [Input("datacenterId")]
        public Input<string>? DatacenterId { get; set; }

        /// <summary>
        /// A detailed description for the VDS.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Allow VMDirectPath Gen2 on the ports this policy applies to.
        /// </summary>
        [Input("directpathGen2Allowed")]
        public Input<bool>? DirectpathGen2Allowed { get; set; }

        /// <summary>
        /// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingAverageBandwidth")]
        public Input<int>? EgressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingBurstSize")]
        public Input<int>? EgressShapingBurstSize { get; set; }

        /// <summary>
        /// True if the traffic shaper is enabled for egress traffic on the port.
        /// </summary>
        [Input("egressShapingEnabled")]
        public Input<bool>? EgressShapingEnabled { get; set; }

        /// <summary>
        /// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingPeakBandwidth")]
        public Input<int>? EgressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceMaximumMbit")]
        public Input<int>? FaulttoleranceMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceReservationMbit")]
        public Input<int>? FaulttoleranceReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        /// </summary>
        [Input("faulttoleranceShareCount")]
        public Input<int>? FaulttoleranceShareCount { get; set; }

        /// <summary>
        /// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("faulttoleranceShareLevel")]
        public Input<string>? FaulttoleranceShareLevel { get; set; }

        /// <summary>
        /// The folder in which to create the VDS.
        /// Forces a new resource if changed.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrMaximumMbit")]
        public Input<int>? HbrMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrReservationMbit")]
        public Input<int>? HbrReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the hbr traffic class for a custom share level.
        /// </summary>
        [Input("hbrShareCount")]
        public Input<int>? HbrShareCount { get; set; }

        /// <summary>
        /// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("hbrShareLevel")]
        public Input<string>? HbrShareLevel { get; set; }

        [Input("hosts")]
        private InputList<Inputs.DistributedVirtualSwitchHostGetArgs>? _hosts;

        /// <summary>
        /// A host member specification.
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchHostGetArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.DistributedVirtualSwitchHostGetArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// Whether to ignore existing PVLAN mappings not managed by this resource.
        /// </summary>
        [Input("ignoreOtherPvlanMappings")]
        public Input<bool>? IgnoreOtherPvlanMappings { get; set; }

        /// <summary>
        /// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingAverageBandwidth")]
        public Input<int>? IngressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingBurstSize")]
        public Input<int>? IngressShapingBurstSize { get; set; }

        /// <summary>
        /// True if the traffic shaper is enabled for ingress traffic on the port.
        /// </summary>
        [Input("ingressShapingEnabled")]
        public Input<bool>? IngressShapingEnabled { get; set; }

        /// <summary>
        /// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingPeakBandwidth")]
        public Input<int>? IngressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// An IPv4 address to identify the switch. This is
        /// mostly useful when used with the Netflow arguments.
        /// </summary>
        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        /// <summary>
        /// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiMaximumMbit")]
        public Input<int>? IscsiMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiReservationMbit")]
        public Input<int>? IscsiReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        /// </summary>
        [Input("iscsiShareCount")]
        public Input<int>? IscsiShareCount { get; set; }

        /// <summary>
        /// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("iscsiShareLevel")]
        public Input<string>? IscsiShareLevel { get; set; }

        /// <summary>
        /// The Link Aggregation Control Protocol group
        /// version to use with the VDS. Possible values are `singleLag` and
        /// `multipleLag`.
        /// </summary>
        [Input("lacpApiVersion")]
        public Input<string>? LacpApiVersion { get; set; }

        /// <summary>
        /// Whether or not to enable LACP on all uplink ports.
        /// </summary>
        [Input("lacpEnabled")]
        public Input<bool>? LacpEnabled { get; set; }

        /// <summary>
        /// The uplink LACP mode to use. Can be one of active or passive.
        /// </summary>
        [Input("lacpMode")]
        public Input<string>? LacpMode { get; set; }

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic.
        /// </summary>
        [Input("linkDiscoveryOperation")]
        public Input<string>? LinkDiscoveryOperation { get; set; }

        /// <summary>
        /// The discovery protocol type. Valid
        /// types are `cdp` and `lldp`.
        /// </summary>
        [Input("linkDiscoveryProtocol")]
        public Input<string>? LinkDiscoveryProtocol { get; set; }

        /// <summary>
        /// The maximum allowed usage for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementMaximumMbit")]
        public Input<int>? ManagementMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementReservationMbit")]
        public Input<int>? ManagementReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the management traffic class for a custom share level.
        /// </summary>
        [Input("managementShareCount")]
        public Input<int>? ManagementShareCount { get; set; }

        /// <summary>
        /// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("managementShareLevel")]
        public Input<string>? ManagementShareLevel { get; set; }

        /// <summary>
        /// The maximum transmission unit (MTU) for the VDS.
        /// </summary>
        [Input("maxMtu")]
        public Input<int>? MaxMtu { get; set; }

        /// <summary>
        /// The multicast filtering mode to use
        /// with the VDS. Can be one of `legacyFiltering` or `snooping`.
        /// </summary>
        [Input("multicastFilteringMode")]
        public Input<string>? MulticastFilteringMode { get; set; }

        /// <summary>
        /// The name of the VDS.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The number of seconds after which active flows are forced to be exported to the collector.
        /// </summary>
        [Input("netflowActiveFlowTimeout")]
        public Input<int>? NetflowActiveFlowTimeout { get; set; }

        /// <summary>
        /// IP address for the netflow collector, using IPv4 or IPv6.
        /// </summary>
        [Input("netflowCollectorIpAddress")]
        public Input<string>? NetflowCollectorIpAddress { get; set; }

        /// <summary>
        /// The port for the netflow collector.
        /// </summary>
        [Input("netflowCollectorPort")]
        public Input<int>? NetflowCollectorPort { get; set; }

        /// <summary>
        /// Indicates whether to enable netflow on all ports.
        /// </summary>
        [Input("netflowEnabled")]
        public Input<bool>? NetflowEnabled { get; set; }

        /// <summary>
        /// The number of seconds after which idle flows are forced to be exported to the collector.
        /// </summary>
        [Input("netflowIdleFlowTimeout")]
        public Input<int>? NetflowIdleFlowTimeout { get; set; }

        /// <summary>
        /// Whether to limit analysis to traffic that has both source and destination served by the same host.
        /// </summary>
        [Input("netflowInternalFlowsOnly")]
        public Input<bool>? NetflowInternalFlowsOnly { get; set; }

        /// <summary>
        /// The observation Domain ID for the netflow collector.
        /// </summary>
        [Input("netflowObservationDomainId")]
        public Input<int>? NetflowObservationDomainId { get; set; }

        /// <summary>
        /// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all
        /// packets are analyzed.
        /// </summary>
        [Input("netflowSamplingRate")]
        public Input<int>? NetflowSamplingRate { get; set; }

        /// <summary>
        /// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
        /// </summary>
        [Input("networkResourceControlEnabled")]
        public Input<bool>? NetworkResourceControlEnabled { get; set; }

        /// <summary>
        /// The network I/O control version to use. Can be one of version2 or version3.
        /// </summary>
        [Input("networkResourceControlVersion")]
        public Input<string>? NetworkResourceControlVersion { get; set; }

        /// <summary>
        /// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsMaximumMbit")]
        public Input<int>? NfsMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsReservationMbit")]
        public Input<int>? NfsReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the nfs traffic class for a custom share level.
        /// </summary>
        [Input("nfsShareCount")]
        public Input<int>? NfsShareCount { get; set; }

        /// <summary>
        /// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("nfsShareLevel")]
        public Input<string>? NfsShareLevel { get; set; }

        /// <summary>
        /// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// The secondary VLAN ID for this port.
        /// </summary>
        [Input("portPrivateSecondaryVlanId")]
        public Input<int>? PortPrivateSecondaryVlanId { get; set; }

        [Input("pvlanMappings")]
        private InputList<Inputs.DistributedVirtualSwitchPvlanMappingGetArgs>? _pvlanMappings;

        /// <summary>
        /// A private VLAN (PVLAN) mapping.
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchPvlanMappingGetArgs> PvlanMappings
        {
            get => _pvlanMappings ?? (_pvlanMappings = new InputList<Inputs.DistributedVirtualSwitchPvlanMappingGetArgs>());
            set => _pvlanMappings = value;
        }

        [Input("standbyUplinks")]
        private InputList<string>? _standbyUplinks;

        /// <summary>
        /// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        public InputList<string> StandbyUplinks
        {
            get => _standbyUplinks ?? (_standbyUplinks = new InputList<string>());
            set => _standbyUplinks = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
        /// failover_explicit, or loadbalance_loadbased.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        /// <summary>
        /// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
        /// forwarded done by the switch.
        /// </summary>
        [Input("txUplink")]
        public Input<bool>? TxUplink { get; set; }

        [Input("uplinks")]
        private InputList<string>? _uplinks;

        /// <summary>
        /// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS
        /// across hosts.
        /// </summary>
        public InputList<string> Uplinks
        {
            get => _uplinks ?? (_uplinks = new InputList<string>());
            set => _uplinks = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpMaximumMbit")]
        public Input<int>? VdpMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpReservationMbit")]
        public Input<int>? VdpReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vdp traffic class for a custom share level.
        /// </summary>
        [Input("vdpShareCount")]
        public Input<int>? VdpShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vdpShareLevel")]
        public Input<string>? VdpShareLevel { get; set; }

        /// <summary>
        /// The version of the VDS. BY default, a VDS is created
        /// at the latest version supported by the vSphere version if not specified.
        /// A VDS can be upgraded to a newer version, but can not be downgraded.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        /// <summary>
        /// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineMaximumMbit")]
        public Input<int>? VirtualmachineMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineReservationMbit")]
        public Input<int>? VirtualmachineReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        /// </summary>
        [Input("virtualmachineShareCount")]
        public Input<int>? VirtualmachineShareCount { get; set; }

        /// <summary>
        /// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("virtualmachineShareLevel")]
        public Input<string>? VirtualmachineShareLevel { get; set; }

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Input("vlanId")]
        public Input<int>? VlanId { get; set; }

        [Input("vlanRanges")]
        private InputList<Inputs.DistributedVirtualSwitchVlanRangeGetArgs>? _vlanRanges;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchVlanRangeGetArgs> VlanRanges
        {
            get => _vlanRanges ?? (_vlanRanges = new InputList<Inputs.DistributedVirtualSwitchVlanRangeGetArgs>());
            set => _vlanRanges = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionMaximumMbit")]
        public Input<int>? VmotionMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionReservationMbit")]
        public Input<int>? VmotionReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vmotion traffic class for a custom share level.
        /// </summary>
        [Input("vmotionShareCount")]
        public Input<int>? VmotionShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vmotionShareLevel")]
        public Input<string>? VmotionShareLevel { get; set; }

        /// <summary>
        /// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanMaximumMbit")]
        public Input<int>? VsanMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanReservationMbit")]
        public Input<int>? VsanReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vsan traffic class for a custom share level.
        /// </summary>
        [Input("vsanShareCount")]
        public Input<int>? VsanShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vsanShareLevel")]
        public Input<string>? VsanShareLevel { get; set; }

        public DistributedVirtualSwitchState()
        {
        }
        public static new DistributedVirtualSwitchState Empty => new DistributedVirtualSwitchState();
    }
}
