// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.VSphere
{
    [VSphereResourceType("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch")]
    public partial class DistributedVirtualSwitch : global::Pulumi.CustomResource
    {
        /// <summary>
        /// A list of active uplinks to be used in load
        /// balancing. These uplinks need to match the definitions in the
        /// `uplinks` VDS argument. See
        /// here for more details.
        /// </summary>
        [Output("activeUplinks")]
        public Output<ImmutableArray<string>> ActiveUplinks { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not a virtual
        /// network adapter is allowed to send network traffic with a different MAC
        /// address than that of its own.
        /// </summary>
        [Output("allowForgedTransmits")]
        public Output<bool> AllowForgedTransmits { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the Media Access
        /// Control (MAC) address can be changed.
        /// </summary>
        [Output("allowMacChanges")]
        public Output<bool> AllowMacChanges { get; private set; } = null!;

        /// <summary>
        /// Enable promiscuous mode on the network. This
        /// flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Output("allowPromiscuous")]
        public Output<bool> AllowPromiscuous { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Output("backupnfcMaximumMbit")]
        public Output<int> BackupnfcMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Output("backupnfcReservationMbit")]
        public Output<int> BackupnfcReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
        /// </summary>
        [Output("backupnfcShareCount")]
        public Output<int> BackupnfcShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("backupnfcShareLevel")]
        public Output<string> BackupnfcShareLevel { get; private set; } = null!;

        /// <summary>
        /// Shuts down all ports in the port groups that
        /// this policy applies to, effectively blocking all network access to connected
        /// virtual devices.
        /// </summary>
        [Output("blockAllPorts")]
        public Output<bool> BlockAllPorts { get; private set; } = null!;

        /// <summary>
        /// Enables beacon probing as an additional measure
        /// to detect NIC failure.
        /// 
        /// &gt; **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon
        /// probing.
        /// </summary>
        [Output("checkBeacon")]
        public Output<bool> CheckBeacon { get; private set; } = null!;

        /// <summary>
        /// The current version of the VDS configuration, incremented
        /// by subsequent updates to the VDS.
        /// </summary>
        [Output("configVersion")]
        public Output<string> ConfigVersion { get; private set; } = null!;

        /// <summary>
        /// The detailed contact information for the person
        /// who is responsible for the VDS.
        /// </summary>
        [Output("contactDetail")]
        public Output<string?> ContactDetail { get; private set; } = null!;

        /// <summary>
        /// The name of the person who is responsible for the
        /// VDS.
        /// </summary>
        [Output("contactName")]
        public Output<string?> ContactName { get; private set; } = null!;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for VDS.
        /// 
        /// &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
        /// and requires vCenter Server.
        /// </summary>
        [Output("customAttributes")]
        public Output<ImmutableDictionary<string, string>?> CustomAttributes { get; private set; } = null!;

        /// <summary>
        /// The ID of the datacenter where the VDS will be
        /// created. Forces a new resource if changed.
        /// </summary>
        [Output("datacenterId")]
        public Output<string> DatacenterId { get; private set; } = null!;

        /// <summary>
        /// A detailed description for the VDS.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Allow VMDirectPath Gen2 for the ports
        /// for which this policy applies to.
        /// </summary>
        [Output("directpathGen2Allowed")]
        public Output<bool> DirectpathGen2Allowed { get; private set; } = null!;

        /// <summary>
        /// The average bandwidth in bits
        /// per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingAverageBandwidth")]
        public Output<int> EgressShapingAverageBandwidth { get; private set; } = null!;

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if egress traffic shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingBurstSize")]
        public Output<int> EgressShapingBurstSize { get; private set; } = null!;

        /// <summary>
        /// `true` if the traffic shaper is enabled
        /// on the port for egress traffic.
        /// </summary>
        [Output("egressShapingEnabled")]
        public Output<bool> EgressShapingEnabled { get; private set; } = null!;

        /// <summary>
        /// The peak bandwidth during bursts
        /// in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingPeakBandwidth")]
        public Output<int> EgressShapingPeakBandwidth { get; private set; } = null!;

        /// <summary>
        /// If `true`, the teaming policy will re-activate failed
        /// uplinks higher in precedence when they come back up.
        /// </summary>
        [Output("failback")]
        public Output<bool> Failback { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Output("faulttoleranceMaximumMbit")]
        public Output<int> FaulttoleranceMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Output("faulttoleranceReservationMbit")]
        public Output<int> FaulttoleranceReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        /// </summary>
        [Output("faulttoleranceShareCount")]
        public Output<int> FaulttoleranceShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("faulttoleranceShareLevel")]
        public Output<string> FaulttoleranceShareLevel { get; private set; } = null!;

        /// <summary>
        /// The folder in which to create the VDS.
        /// Forces a new resource if changed.
        /// </summary>
        [Output("folder")]
        public Output<string?> Folder { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Output("hbrMaximumMbit")]
        public Output<int> HbrMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Output("hbrReservationMbit")]
        public Output<int> HbrReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the hbr traffic class for a custom share level.
        /// </summary>
        [Output("hbrShareCount")]
        public Output<int> HbrShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("hbrShareLevel")]
        public Output<string> HbrShareLevel { get; private set; } = null!;

        /// <summary>
        /// Use the `host` block to declare a host specification. The
        /// options are:
        /// </summary>
        [Output("hosts")]
        public Output<ImmutableArray<Outputs.DistributedVirtualSwitchHost>> Hosts { get; private set; } = null!;

        /// <summary>
        /// Whether to ignore existing PVLAN
        /// mappings not managed by this resource. Defaults to false.
        /// </summary>
        [Output("ignoreOtherPvlanMappings")]
        public Output<bool?> IgnoreOtherPvlanMappings { get; private set; } = null!;

        /// <summary>
        /// The average bandwidth in
        /// bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingAverageBandwidth")]
        public Output<int> IngressShapingAverageBandwidth { get; private set; } = null!;

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingBurstSize")]
        public Output<int> IngressShapingBurstSize { get; private set; } = null!;

        /// <summary>
        /// `true` if the traffic shaper is
        /// enabled on the port for ingress traffic.
        /// </summary>
        [Output("ingressShapingEnabled")]
        public Output<bool> IngressShapingEnabled { get; private set; } = null!;

        /// <summary>
        /// The peak bandwidth during
        /// bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingPeakBandwidth")]
        public Output<int> IngressShapingPeakBandwidth { get; private set; } = null!;

        /// <summary>
        /// An IPv4 address to identify the switch. This is
        /// mostly useful when used with the Netflow arguments.
        /// </summary>
        [Output("ipv4Address")]
        public Output<string?> Ipv4Address { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Output("iscsiMaximumMbit")]
        public Output<int> IscsiMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Output("iscsiReservationMbit")]
        public Output<int> IscsiReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        /// </summary>
        [Output("iscsiShareCount")]
        public Output<int> IscsiShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("iscsiShareLevel")]
        public Output<string> IscsiShareLevel { get; private set; } = null!;

        /// <summary>
        /// The Link Aggregation Control Protocol group
        /// version to use with the VDS. Possible values are `singleLag` and
        /// `multipleLag`.
        /// </summary>
        [Output("lacpApiVersion")]
        public Output<string> LacpApiVersion { get; private set; } = null!;

        /// <summary>
        /// Enables LACP for the ports that this policy
        /// applies to.
        /// </summary>
        [Output("lacpEnabled")]
        public Output<bool> LacpEnabled { get; private set; } = null!;

        /// <summary>
        /// The LACP mode. Can be one of `active` or `passive`.
        /// </summary>
        [Output("lacpMode")]
        public Output<string> LacpMode { get; private set; } = null!;

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic.
        /// </summary>
        [Output("linkDiscoveryOperation")]
        public Output<string?> LinkDiscoveryOperation { get; private set; } = null!;

        /// <summary>
        /// The discovery protocol type. Valid
        /// types are `cdp` and `lldp`.
        /// </summary>
        [Output("linkDiscoveryProtocol")]
        public Output<string?> LinkDiscoveryProtocol { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the management traffic class, in Mbits/sec.
        /// </summary>
        [Output("managementMaximumMbit")]
        public Output<int> ManagementMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        /// </summary>
        [Output("managementReservationMbit")]
        public Output<int> ManagementReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the management traffic class for a custom share level.
        /// </summary>
        [Output("managementShareCount")]
        public Output<int> ManagementShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("managementShareLevel")]
        public Output<string> ManagementShareLevel { get; private set; } = null!;

        /// <summary>
        /// The maximum transmission unit (MTU) for the VDS.
        /// </summary>
        [Output("maxMtu")]
        public Output<int> MaxMtu { get; private set; } = null!;

        /// <summary>
        /// The multicast filtering mode to use
        /// with the VDS. Can be one of `legacyFiltering` or `snooping`.
        /// </summary>
        [Output("multicastFilteringMode")]
        public Output<string> MulticastFilteringMode { get; private set; } = null!;

        /// <summary>
        /// The name of the VDS.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The number of seconds after which
        /// active flows are forced to be exported to the collector. Allowed range is
        /// `60` to `3600`. Default: `60`.
        /// </summary>
        [Output("netflowActiveFlowTimeout")]
        public Output<int?> NetflowActiveFlowTimeout { get; private set; } = null!;

        /// <summary>
        /// IP address for the Netflow
        /// collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
        /// Must be set before Netflow can be enabled.
        /// </summary>
        [Output("netflowCollectorIpAddress")]
        public Output<string?> NetflowCollectorIpAddress { get; private set; } = null!;

        /// <summary>
        /// Port for the Netflow collector. This
        /// must be set before Netflow can be enabled.
        /// </summary>
        [Output("netflowCollectorPort")]
        public Output<int?> NetflowCollectorPort { get; private set; } = null!;

        /// <summary>
        /// Enables Netflow on all ports that this policy
        /// applies to.
        /// </summary>
        [Output("netflowEnabled")]
        public Output<bool> NetflowEnabled { get; private set; } = null!;

        /// <summary>
        /// The number of seconds after which
        /// idle flows are forced to be exported to the collector. Allowed range is `10`
        /// to `600`. Default: `15`.
        /// </summary>
        [Output("netflowIdleFlowTimeout")]
        public Output<int?> NetflowIdleFlowTimeout { get; private set; } = null!;

        /// <summary>
        /// Whether to limit analysis to
        /// traffic that has both source and destination served by the same host.
        /// Default: `false`.
        /// </summary>
        [Output("netflowInternalFlowsOnly")]
        public Output<bool?> NetflowInternalFlowsOnly { get; private set; } = null!;

        /// <summary>
        /// The observation domain ID for
        /// the Netflow collector.
        /// </summary>
        [Output("netflowObservationDomainId")]
        public Output<int?> NetflowObservationDomainId { get; private set; } = null!;

        /// <summary>
        /// The ratio of total number of packets to
        /// the number of packets analyzed. The default is `0`, which indicates that the
        /// VDS should analyze all packets. The maximum value is `1000`, which
        /// indicates an analysis rate of 0.001%.
        /// </summary>
        [Output("netflowSamplingRate")]
        public Output<int?> NetflowSamplingRate { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to enable
        /// network I/O control. Default: `false`.
        /// </summary>
        [Output("networkResourceControlEnabled")]
        public Output<bool?> NetworkResourceControlEnabled { get; private set; } = null!;

        /// <summary>
        /// The version of network I/O
        /// control to use. Can be one of `version2` or `version3`. Default: `version2`.
        /// </summary>
        [Output("networkResourceControlVersion")]
        public Output<string> NetworkResourceControlVersion { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Output("nfsMaximumMbit")]
        public Output<int> NfsMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Output("nfsReservationMbit")]
        public Output<int> NfsReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the nfs traffic class for a custom share level.
        /// </summary>
        [Output("nfsShareCount")]
        public Output<int> NfsShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("nfsShareLevel")]
        public Output<string> NfsShareLevel { get; private set; } = null!;

        /// <summary>
        /// If `true`, the teaming policy will notify the
        /// broadcast network of an uplink failover, triggering cache updates.
        /// </summary>
        [Output("notifySwitches")]
        public Output<bool> NotifySwitches { get; private set; } = null!;

        /// <summary>
        /// Used to define a secondary VLAN
        /// ID when using private VLANs.
        /// </summary>
        [Output("portPrivateSecondaryVlanId")]
        public Output<int> PortPrivateSecondaryVlanId { get; private set; } = null!;

        /// <summary>
        /// Use the `pvlan_mapping` block to declare a
        /// private VLAN mapping. The options are:
        /// </summary>
        [Output("pvlanMappings")]
        public Output<ImmutableArray<Outputs.DistributedVirtualSwitchPvlanMapping>> PvlanMappings { get; private set; } = null!;

        /// <summary>
        /// A list of standby uplinks to be used in
        /// failover. These uplinks need to match the definitions in the
        /// `uplinks` VDS argument. See
        /// here for more details.
        /// </summary>
        [Output("standbyUplinks")]
        public Output<ImmutableArray<string>> StandbyUplinks { get; private set; } = null!;

        /// <summary>
        /// The IDs of any tags to attach to this resource.
        /// 
        /// &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// The uplink teaming policy. Can be one of
        /// `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,
        /// `failover_explicit`, or `loadbalance_loadbased`.
        /// </summary>
        [Output("teamingPolicy")]
        public Output<string> TeamingPolicy { get; private set; } = null!;

        /// <summary>
        /// Forward all traffic transmitted by ports for which
        /// this policy applies to its VDS uplinks.
        /// </summary>
        [Output("txUplink")]
        public Output<bool> TxUplink { get; private set; } = null!;

        /// <summary>
        /// A list of strings that uniquely identifies the names
        /// of the uplinks on the VDS across hosts. The number of items in this list
        /// controls the number of uplinks that exist on the VDS, in addition to the
        /// names. See here for an example on how to
        /// use this option.
        /// </summary>
        [Output("uplinks")]
        public Output<ImmutableArray<string>> Uplinks { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Output("vdpMaximumMbit")]
        public Output<int> VdpMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Output("vdpReservationMbit")]
        public Output<int> VdpReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the vdp traffic class for a custom share level.
        /// </summary>
        [Output("vdpShareCount")]
        public Output<int> VdpShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("vdpShareLevel")]
        public Output<string> VdpShareLevel { get; private set; } = null!;

        /// <summary>
        /// The version of the VDS. BY default, a VDS is created
        /// at the latest version supported by the vSphere version if not specified.
        /// A VDS can be upgraded to a newer version, but can not be downgraded.
        /// </summary>
        [Output("version")]
        public Output<string> Version { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Output("virtualmachineMaximumMbit")]
        public Output<int> VirtualmachineMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Output("virtualmachineReservationMbit")]
        public Output<int> VirtualmachineReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        /// </summary>
        [Output("virtualmachineShareCount")]
        public Output<int> VirtualmachineShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("virtualmachineShareLevel")]
        public Output<string> VirtualmachineShareLevel { get; private set; } = null!;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Output("vlanId")]
        public Output<int> VlanId { get; private set; } = null!;

        /// <summary>
        /// Used to denote VLAN trunking. Use the `min_vlan`
        /// and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
        /// `vlan_range` definitions are allowed, but they must not overlap. Example
        /// below:
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using VSphere = Pulumi.VSphere;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var vds = new VSphere.DistributedVirtualSwitch("vds", new()
        ///     {
        ///         VlanRanges = new[]
        ///         {
        ///             new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs
        ///             {
        ///                 MaxVlan = 199,
        ///                 MinVlan = 100,
        ///             },
        ///             new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs
        ///             {
        ///                 MaxVlan = 399,
        ///                 MinVlan = 300,
        ///             },
        ///         },
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        [Output("vlanRanges")]
        public Output<ImmutableArray<Outputs.DistributedVirtualSwitchVlanRange>> VlanRanges { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Output("vmotionMaximumMbit")]
        public Output<int> VmotionMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Output("vmotionReservationMbit")]
        public Output<int> VmotionReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the vmotion traffic class for a custom share level.
        /// </summary>
        [Output("vmotionShareCount")]
        public Output<int> VmotionShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("vmotionShareLevel")]
        public Output<string> VmotionShareLevel { get; private set; } = null!;

        /// <summary>
        /// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Output("vsanMaximumMbit")]
        public Output<int> VsanMaximumMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Output("vsanReservationMbit")]
        public Output<int> VsanReservationMbit { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to the vsan traffic class for a custom share level.
        /// </summary>
        [Output("vsanShareCount")]
        public Output<int> VsanShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("vsanShareLevel")]
        public Output<string> VsanShareLevel { get; private set; } = null!;


        /// <summary>
        /// Create a DistributedVirtualSwitch resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public DistributedVirtualSwitch(string name, DistributedVirtualSwitchArgs args, CustomResourceOptions? options = null)
            : base("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, args ?? new DistributedVirtualSwitchArgs(), MakeResourceOptions(options, ""))
        {
        }

        private DistributedVirtualSwitch(string name, Input<string> id, DistributedVirtualSwitchState? state = null, CustomResourceOptions? options = null)
            : base("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing DistributedVirtualSwitch resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static DistributedVirtualSwitch Get(string name, Input<string> id, DistributedVirtualSwitchState? state = null, CustomResourceOptions? options = null)
        {
            return new DistributedVirtualSwitch(name, id, state, options);
        }
    }

    public sealed class DistributedVirtualSwitchArgs : global::Pulumi.ResourceArgs
    {
        [Input("activeUplinks")]
        private InputList<string>? _activeUplinks;

        /// <summary>
        /// A list of active uplinks to be used in load
        /// balancing. These uplinks need to match the definitions in the
        /// `uplinks` VDS argument. See
        /// here for more details.
        /// </summary>
        public InputList<string> ActiveUplinks
        {
            get => _activeUplinks ?? (_activeUplinks = new InputList<string>());
            set => _activeUplinks = value;
        }

        /// <summary>
        /// Controls whether or not a virtual
        /// network adapter is allowed to send network traffic with a different MAC
        /// address than that of its own.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access
        /// Control (MAC) address can be changed.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This
        /// flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Input("backupnfcMaximumMbit")]
        public Input<int>? BackupnfcMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Input("backupnfcReservationMbit")]
        public Input<int>? BackupnfcReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
        /// </summary>
        [Input("backupnfcShareCount")]
        public Input<int>? BackupnfcShareCount { get; set; }

        /// <summary>
        /// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("backupnfcShareLevel")]
        public Input<string>? BackupnfcShareLevel { get; set; }

        /// <summary>
        /// Shuts down all ports in the port groups that
        /// this policy applies to, effectively blocking all network access to connected
        /// virtual devices.
        /// </summary>
        [Input("blockAllPorts")]
        public Input<bool>? BlockAllPorts { get; set; }

        /// <summary>
        /// Enables beacon probing as an additional measure
        /// to detect NIC failure.
        /// 
        /// &gt; **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon
        /// probing.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        /// <summary>
        /// The detailed contact information for the person
        /// who is responsible for the VDS.
        /// </summary>
        [Input("contactDetail")]
        public Input<string>? ContactDetail { get; set; }

        /// <summary>
        /// The name of the person who is responsible for the
        /// VDS.
        /// </summary>
        [Input("contactName")]
        public Input<string>? ContactName { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for VDS.
        /// 
        /// &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
        /// and requires vCenter Server.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The ID of the datacenter where the VDS will be
        /// created. Forces a new resource if changed.
        /// </summary>
        [Input("datacenterId", required: true)]
        public Input<string> DatacenterId { get; set; } = null!;

        /// <summary>
        /// A detailed description for the VDS.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Allow VMDirectPath Gen2 for the ports
        /// for which this policy applies to.
        /// </summary>
        [Input("directpathGen2Allowed")]
        public Input<bool>? DirectpathGen2Allowed { get; set; }

        /// <summary>
        /// The average bandwidth in bits
        /// per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingAverageBandwidth")]
        public Input<int>? EgressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingBurstSize")]
        public Input<int>? EgressShapingBurstSize { get; set; }

        /// <summary>
        /// `true` if the traffic shaper is enabled
        /// on the port for egress traffic.
        /// </summary>
        [Input("egressShapingEnabled")]
        public Input<bool>? EgressShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during bursts
        /// in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingPeakBandwidth")]
        public Input<int>? EgressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// If `true`, the teaming policy will re-activate failed
        /// uplinks higher in precedence when they come back up.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceMaximumMbit")]
        public Input<int>? FaulttoleranceMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceReservationMbit")]
        public Input<int>? FaulttoleranceReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        /// </summary>
        [Input("faulttoleranceShareCount")]
        public Input<int>? FaulttoleranceShareCount { get; set; }

        /// <summary>
        /// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("faulttoleranceShareLevel")]
        public Input<string>? FaulttoleranceShareLevel { get; set; }

        /// <summary>
        /// The folder in which to create the VDS.
        /// Forces a new resource if changed.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrMaximumMbit")]
        public Input<int>? HbrMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrReservationMbit")]
        public Input<int>? HbrReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the hbr traffic class for a custom share level.
        /// </summary>
        [Input("hbrShareCount")]
        public Input<int>? HbrShareCount { get; set; }

        /// <summary>
        /// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("hbrShareLevel")]
        public Input<string>? HbrShareLevel { get; set; }

        [Input("hosts")]
        private InputList<Inputs.DistributedVirtualSwitchHostArgs>? _hosts;

        /// <summary>
        /// Use the `host` block to declare a host specification. The
        /// options are:
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchHostArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.DistributedVirtualSwitchHostArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// Whether to ignore existing PVLAN
        /// mappings not managed by this resource. Defaults to false.
        /// </summary>
        [Input("ignoreOtherPvlanMappings")]
        public Input<bool>? IgnoreOtherPvlanMappings { get; set; }

        /// <summary>
        /// The average bandwidth in
        /// bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingAverageBandwidth")]
        public Input<int>? IngressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingBurstSize")]
        public Input<int>? IngressShapingBurstSize { get; set; }

        /// <summary>
        /// `true` if the traffic shaper is
        /// enabled on the port for ingress traffic.
        /// </summary>
        [Input("ingressShapingEnabled")]
        public Input<bool>? IngressShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during
        /// bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingPeakBandwidth")]
        public Input<int>? IngressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// An IPv4 address to identify the switch. This is
        /// mostly useful when used with the Netflow arguments.
        /// </summary>
        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        /// <summary>
        /// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiMaximumMbit")]
        public Input<int>? IscsiMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiReservationMbit")]
        public Input<int>? IscsiReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        /// </summary>
        [Input("iscsiShareCount")]
        public Input<int>? IscsiShareCount { get; set; }

        /// <summary>
        /// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("iscsiShareLevel")]
        public Input<string>? IscsiShareLevel { get; set; }

        /// <summary>
        /// The Link Aggregation Control Protocol group
        /// version to use with the VDS. Possible values are `singleLag` and
        /// `multipleLag`.
        /// </summary>
        [Input("lacpApiVersion")]
        public Input<string>? LacpApiVersion { get; set; }

        /// <summary>
        /// Enables LACP for the ports that this policy
        /// applies to.
        /// </summary>
        [Input("lacpEnabled")]
        public Input<bool>? LacpEnabled { get; set; }

        /// <summary>
        /// The LACP mode. Can be one of `active` or `passive`.
        /// </summary>
        [Input("lacpMode")]
        public Input<string>? LacpMode { get; set; }

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic.
        /// </summary>
        [Input("linkDiscoveryOperation")]
        public Input<string>? LinkDiscoveryOperation { get; set; }

        /// <summary>
        /// The discovery protocol type. Valid
        /// types are `cdp` and `lldp`.
        /// </summary>
        [Input("linkDiscoveryProtocol")]
        public Input<string>? LinkDiscoveryProtocol { get; set; }

        /// <summary>
        /// The maximum allowed usage for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementMaximumMbit")]
        public Input<int>? ManagementMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementReservationMbit")]
        public Input<int>? ManagementReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the management traffic class for a custom share level.
        /// </summary>
        [Input("managementShareCount")]
        public Input<int>? ManagementShareCount { get; set; }

        /// <summary>
        /// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("managementShareLevel")]
        public Input<string>? ManagementShareLevel { get; set; }

        /// <summary>
        /// The maximum transmission unit (MTU) for the VDS.
        /// </summary>
        [Input("maxMtu")]
        public Input<int>? MaxMtu { get; set; }

        /// <summary>
        /// The multicast filtering mode to use
        /// with the VDS. Can be one of `legacyFiltering` or `snooping`.
        /// </summary>
        [Input("multicastFilteringMode")]
        public Input<string>? MulticastFilteringMode { get; set; }

        /// <summary>
        /// The name of the VDS.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The number of seconds after which
        /// active flows are forced to be exported to the collector. Allowed range is
        /// `60` to `3600`. Default: `60`.
        /// </summary>
        [Input("netflowActiveFlowTimeout")]
        public Input<int>? NetflowActiveFlowTimeout { get; set; }

        /// <summary>
        /// IP address for the Netflow
        /// collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
        /// Must be set before Netflow can be enabled.
        /// </summary>
        [Input("netflowCollectorIpAddress")]
        public Input<string>? NetflowCollectorIpAddress { get; set; }

        /// <summary>
        /// Port for the Netflow collector. This
        /// must be set before Netflow can be enabled.
        /// </summary>
        [Input("netflowCollectorPort")]
        public Input<int>? NetflowCollectorPort { get; set; }

        /// <summary>
        /// Enables Netflow on all ports that this policy
        /// applies to.
        /// </summary>
        [Input("netflowEnabled")]
        public Input<bool>? NetflowEnabled { get; set; }

        /// <summary>
        /// The number of seconds after which
        /// idle flows are forced to be exported to the collector. Allowed range is `10`
        /// to `600`. Default: `15`.
        /// </summary>
        [Input("netflowIdleFlowTimeout")]
        public Input<int>? NetflowIdleFlowTimeout { get; set; }

        /// <summary>
        /// Whether to limit analysis to
        /// traffic that has both source and destination served by the same host.
        /// Default: `false`.
        /// </summary>
        [Input("netflowInternalFlowsOnly")]
        public Input<bool>? NetflowInternalFlowsOnly { get; set; }

        /// <summary>
        /// The observation domain ID for
        /// the Netflow collector.
        /// </summary>
        [Input("netflowObservationDomainId")]
        public Input<int>? NetflowObservationDomainId { get; set; }

        /// <summary>
        /// The ratio of total number of packets to
        /// the number of packets analyzed. The default is `0`, which indicates that the
        /// VDS should analyze all packets. The maximum value is `1000`, which
        /// indicates an analysis rate of 0.001%.
        /// </summary>
        [Input("netflowSamplingRate")]
        public Input<int>? NetflowSamplingRate { get; set; }

        /// <summary>
        /// Set to `true` to enable
        /// network I/O control. Default: `false`.
        /// </summary>
        [Input("networkResourceControlEnabled")]
        public Input<bool>? NetworkResourceControlEnabled { get; set; }

        /// <summary>
        /// The version of network I/O
        /// control to use. Can be one of `version2` or `version3`. Default: `version2`.
        /// </summary>
        [Input("networkResourceControlVersion")]
        public Input<string>? NetworkResourceControlVersion { get; set; }

        /// <summary>
        /// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsMaximumMbit")]
        public Input<int>? NfsMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsReservationMbit")]
        public Input<int>? NfsReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the nfs traffic class for a custom share level.
        /// </summary>
        [Input("nfsShareCount")]
        public Input<int>? NfsShareCount { get; set; }

        /// <summary>
        /// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("nfsShareLevel")]
        public Input<string>? NfsShareLevel { get; set; }

        /// <summary>
        /// If `true`, the teaming policy will notify the
        /// broadcast network of an uplink failover, triggering cache updates.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// Used to define a secondary VLAN
        /// ID when using private VLANs.
        /// </summary>
        [Input("portPrivateSecondaryVlanId")]
        public Input<int>? PortPrivateSecondaryVlanId { get; set; }

        [Input("pvlanMappings")]
        private InputList<Inputs.DistributedVirtualSwitchPvlanMappingArgs>? _pvlanMappings;

        /// <summary>
        /// Use the `pvlan_mapping` block to declare a
        /// private VLAN mapping. The options are:
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchPvlanMappingArgs> PvlanMappings
        {
            get => _pvlanMappings ?? (_pvlanMappings = new InputList<Inputs.DistributedVirtualSwitchPvlanMappingArgs>());
            set => _pvlanMappings = value;
        }

        [Input("standbyUplinks")]
        private InputList<string>? _standbyUplinks;

        /// <summary>
        /// A list of standby uplinks to be used in
        /// failover. These uplinks need to match the definitions in the
        /// `uplinks` VDS argument. See
        /// here for more details.
        /// </summary>
        public InputList<string> StandbyUplinks
        {
            get => _standbyUplinks ?? (_standbyUplinks = new InputList<string>());
            set => _standbyUplinks = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource.
        /// 
        /// &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The uplink teaming policy. Can be one of
        /// `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,
        /// `failover_explicit`, or `loadbalance_loadbased`.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        /// <summary>
        /// Forward all traffic transmitted by ports for which
        /// this policy applies to its VDS uplinks.
        /// </summary>
        [Input("txUplink")]
        public Input<bool>? TxUplink { get; set; }

        [Input("uplinks")]
        private InputList<string>? _uplinks;

        /// <summary>
        /// A list of strings that uniquely identifies the names
        /// of the uplinks on the VDS across hosts. The number of items in this list
        /// controls the number of uplinks that exist on the VDS, in addition to the
        /// names. See here for an example on how to
        /// use this option.
        /// </summary>
        public InputList<string> Uplinks
        {
            get => _uplinks ?? (_uplinks = new InputList<string>());
            set => _uplinks = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpMaximumMbit")]
        public Input<int>? VdpMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpReservationMbit")]
        public Input<int>? VdpReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vdp traffic class for a custom share level.
        /// </summary>
        [Input("vdpShareCount")]
        public Input<int>? VdpShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vdpShareLevel")]
        public Input<string>? VdpShareLevel { get; set; }

        /// <summary>
        /// The version of the VDS. BY default, a VDS is created
        /// at the latest version supported by the vSphere version if not specified.
        /// A VDS can be upgraded to a newer version, but can not be downgraded.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        /// <summary>
        /// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineMaximumMbit")]
        public Input<int>? VirtualmachineMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineReservationMbit")]
        public Input<int>? VirtualmachineReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        /// </summary>
        [Input("virtualmachineShareCount")]
        public Input<int>? VirtualmachineShareCount { get; set; }

        /// <summary>
        /// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("virtualmachineShareLevel")]
        public Input<string>? VirtualmachineShareLevel { get; set; }

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Input("vlanId")]
        public Input<int>? VlanId { get; set; }

        [Input("vlanRanges")]
        private InputList<Inputs.DistributedVirtualSwitchVlanRangeArgs>? _vlanRanges;

        /// <summary>
        /// Used to denote VLAN trunking. Use the `min_vlan`
        /// and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
        /// `vlan_range` definitions are allowed, but they must not overlap. Example
        /// below:
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using VSphere = Pulumi.VSphere;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var vds = new VSphere.DistributedVirtualSwitch("vds", new()
        ///     {
        ///         VlanRanges = new[]
        ///         {
        ///             new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs
        ///             {
        ///                 MaxVlan = 199,
        ///                 MinVlan = 100,
        ///             },
        ///             new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs
        ///             {
        ///                 MaxVlan = 399,
        ///                 MinVlan = 300,
        ///             },
        ///         },
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchVlanRangeArgs> VlanRanges
        {
            get => _vlanRanges ?? (_vlanRanges = new InputList<Inputs.DistributedVirtualSwitchVlanRangeArgs>());
            set => _vlanRanges = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionMaximumMbit")]
        public Input<int>? VmotionMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionReservationMbit")]
        public Input<int>? VmotionReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vmotion traffic class for a custom share level.
        /// </summary>
        [Input("vmotionShareCount")]
        public Input<int>? VmotionShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vmotionShareLevel")]
        public Input<string>? VmotionShareLevel { get; set; }

        /// <summary>
        /// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanMaximumMbit")]
        public Input<int>? VsanMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanReservationMbit")]
        public Input<int>? VsanReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vsan traffic class for a custom share level.
        /// </summary>
        [Input("vsanShareCount")]
        public Input<int>? VsanShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vsanShareLevel")]
        public Input<string>? VsanShareLevel { get; set; }

        public DistributedVirtualSwitchArgs()
        {
        }
        public static new DistributedVirtualSwitchArgs Empty => new DistributedVirtualSwitchArgs();
    }

    public sealed class DistributedVirtualSwitchState : global::Pulumi.ResourceArgs
    {
        [Input("activeUplinks")]
        private InputList<string>? _activeUplinks;

        /// <summary>
        /// A list of active uplinks to be used in load
        /// balancing. These uplinks need to match the definitions in the
        /// `uplinks` VDS argument. See
        /// here for more details.
        /// </summary>
        public InputList<string> ActiveUplinks
        {
            get => _activeUplinks ?? (_activeUplinks = new InputList<string>());
            set => _activeUplinks = value;
        }

        /// <summary>
        /// Controls whether or not a virtual
        /// network adapter is allowed to send network traffic with a different MAC
        /// address than that of its own.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access
        /// Control (MAC) address can be changed.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This
        /// flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Input("backupnfcMaximumMbit")]
        public Input<int>? BackupnfcMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
        /// </summary>
        [Input("backupnfcReservationMbit")]
        public Input<int>? BackupnfcReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
        /// </summary>
        [Input("backupnfcShareCount")]
        public Input<int>? BackupnfcShareCount { get; set; }

        /// <summary>
        /// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("backupnfcShareLevel")]
        public Input<string>? BackupnfcShareLevel { get; set; }

        /// <summary>
        /// Shuts down all ports in the port groups that
        /// this policy applies to, effectively blocking all network access to connected
        /// virtual devices.
        /// </summary>
        [Input("blockAllPorts")]
        public Input<bool>? BlockAllPorts { get; set; }

        /// <summary>
        /// Enables beacon probing as an additional measure
        /// to detect NIC failure.
        /// 
        /// &gt; **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon
        /// probing.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        /// <summary>
        /// The current version of the VDS configuration, incremented
        /// by subsequent updates to the VDS.
        /// </summary>
        [Input("configVersion")]
        public Input<string>? ConfigVersion { get; set; }

        /// <summary>
        /// The detailed contact information for the person
        /// who is responsible for the VDS.
        /// </summary>
        [Input("contactDetail")]
        public Input<string>? ContactDetail { get; set; }

        /// <summary>
        /// The name of the person who is responsible for the
        /// VDS.
        /// </summary>
        [Input("contactName")]
        public Input<string>? ContactName { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for VDS.
        /// 
        /// &gt; **NOTE:** Custom attributes are unsupported on direct ESXi host connections
        /// and requires vCenter Server.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The ID of the datacenter where the VDS will be
        /// created. Forces a new resource if changed.
        /// </summary>
        [Input("datacenterId")]
        public Input<string>? DatacenterId { get; set; }

        /// <summary>
        /// A detailed description for the VDS.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Allow VMDirectPath Gen2 for the ports
        /// for which this policy applies to.
        /// </summary>
        [Input("directpathGen2Allowed")]
        public Input<bool>? DirectpathGen2Allowed { get; set; }

        /// <summary>
        /// The average bandwidth in bits
        /// per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingAverageBandwidth")]
        public Input<int>? EgressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingBurstSize")]
        public Input<int>? EgressShapingBurstSize { get; set; }

        /// <summary>
        /// `true` if the traffic shaper is enabled
        /// on the port for egress traffic.
        /// </summary>
        [Input("egressShapingEnabled")]
        public Input<bool>? EgressShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during bursts
        /// in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingPeakBandwidth")]
        public Input<int>? EgressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// If `true`, the teaming policy will re-activate failed
        /// uplinks higher in precedence when they come back up.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceMaximumMbit")]
        public Input<int>? FaulttoleranceMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        /// </summary>
        [Input("faulttoleranceReservationMbit")]
        public Input<int>? FaulttoleranceReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        /// </summary>
        [Input("faulttoleranceShareCount")]
        public Input<int>? FaulttoleranceShareCount { get; set; }

        /// <summary>
        /// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("faulttoleranceShareLevel")]
        public Input<string>? FaulttoleranceShareLevel { get; set; }

        /// <summary>
        /// The folder in which to create the VDS.
        /// Forces a new resource if changed.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrMaximumMbit")]
        public Input<int>? HbrMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        /// </summary>
        [Input("hbrReservationMbit")]
        public Input<int>? HbrReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the hbr traffic class for a custom share level.
        /// </summary>
        [Input("hbrShareCount")]
        public Input<int>? HbrShareCount { get; set; }

        /// <summary>
        /// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("hbrShareLevel")]
        public Input<string>? HbrShareLevel { get; set; }

        [Input("hosts")]
        private InputList<Inputs.DistributedVirtualSwitchHostGetArgs>? _hosts;

        /// <summary>
        /// Use the `host` block to declare a host specification. The
        /// options are:
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchHostGetArgs> Hosts
        {
            get => _hosts ?? (_hosts = new InputList<Inputs.DistributedVirtualSwitchHostGetArgs>());
            set => _hosts = value;
        }

        /// <summary>
        /// Whether to ignore existing PVLAN
        /// mappings not managed by this resource. Defaults to false.
        /// </summary>
        [Input("ignoreOtherPvlanMappings")]
        public Input<bool>? IgnoreOtherPvlanMappings { get; set; }

        /// <summary>
        /// The average bandwidth in
        /// bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingAverageBandwidth")]
        public Input<int>? IngressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in
        /// bytes if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingBurstSize")]
        public Input<int>? IngressShapingBurstSize { get; set; }

        /// <summary>
        /// `true` if the traffic shaper is
        /// enabled on the port for ingress traffic.
        /// </summary>
        [Input("ingressShapingEnabled")]
        public Input<bool>? IngressShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during
        /// bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingPeakBandwidth")]
        public Input<int>? IngressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// An IPv4 address to identify the switch. This is
        /// mostly useful when used with the Netflow arguments.
        /// </summary>
        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        /// <summary>
        /// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiMaximumMbit")]
        public Input<int>? IscsiMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        /// </summary>
        [Input("iscsiReservationMbit")]
        public Input<int>? IscsiReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        /// </summary>
        [Input("iscsiShareCount")]
        public Input<int>? IscsiShareCount { get; set; }

        /// <summary>
        /// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("iscsiShareLevel")]
        public Input<string>? IscsiShareLevel { get; set; }

        /// <summary>
        /// The Link Aggregation Control Protocol group
        /// version to use with the VDS. Possible values are `singleLag` and
        /// `multipleLag`.
        /// </summary>
        [Input("lacpApiVersion")]
        public Input<string>? LacpApiVersion { get; set; }

        /// <summary>
        /// Enables LACP for the ports that this policy
        /// applies to.
        /// </summary>
        [Input("lacpEnabled")]
        public Input<bool>? LacpEnabled { get; set; }

        /// <summary>
        /// The LACP mode. Can be one of `active` or `passive`.
        /// </summary>
        [Input("lacpMode")]
        public Input<string>? LacpMode { get; set; }

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic.
        /// </summary>
        [Input("linkDiscoveryOperation")]
        public Input<string>? LinkDiscoveryOperation { get; set; }

        /// <summary>
        /// The discovery protocol type. Valid
        /// types are `cdp` and `lldp`.
        /// </summary>
        [Input("linkDiscoveryProtocol")]
        public Input<string>? LinkDiscoveryProtocol { get; set; }

        /// <summary>
        /// The maximum allowed usage for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementMaximumMbit")]
        public Input<int>? ManagementMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        /// </summary>
        [Input("managementReservationMbit")]
        public Input<int>? ManagementReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the management traffic class for a custom share level.
        /// </summary>
        [Input("managementShareCount")]
        public Input<int>? ManagementShareCount { get; set; }

        /// <summary>
        /// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("managementShareLevel")]
        public Input<string>? ManagementShareLevel { get; set; }

        /// <summary>
        /// The maximum transmission unit (MTU) for the VDS.
        /// </summary>
        [Input("maxMtu")]
        public Input<int>? MaxMtu { get; set; }

        /// <summary>
        /// The multicast filtering mode to use
        /// with the VDS. Can be one of `legacyFiltering` or `snooping`.
        /// </summary>
        [Input("multicastFilteringMode")]
        public Input<string>? MulticastFilteringMode { get; set; }

        /// <summary>
        /// The name of the VDS.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The number of seconds after which
        /// active flows are forced to be exported to the collector. Allowed range is
        /// `60` to `3600`. Default: `60`.
        /// </summary>
        [Input("netflowActiveFlowTimeout")]
        public Input<int>? NetflowActiveFlowTimeout { get; set; }

        /// <summary>
        /// IP address for the Netflow
        /// collector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.
        /// Must be set before Netflow can be enabled.
        /// </summary>
        [Input("netflowCollectorIpAddress")]
        public Input<string>? NetflowCollectorIpAddress { get; set; }

        /// <summary>
        /// Port for the Netflow collector. This
        /// must be set before Netflow can be enabled.
        /// </summary>
        [Input("netflowCollectorPort")]
        public Input<int>? NetflowCollectorPort { get; set; }

        /// <summary>
        /// Enables Netflow on all ports that this policy
        /// applies to.
        /// </summary>
        [Input("netflowEnabled")]
        public Input<bool>? NetflowEnabled { get; set; }

        /// <summary>
        /// The number of seconds after which
        /// idle flows are forced to be exported to the collector. Allowed range is `10`
        /// to `600`. Default: `15`.
        /// </summary>
        [Input("netflowIdleFlowTimeout")]
        public Input<int>? NetflowIdleFlowTimeout { get; set; }

        /// <summary>
        /// Whether to limit analysis to
        /// traffic that has both source and destination served by the same host.
        /// Default: `false`.
        /// </summary>
        [Input("netflowInternalFlowsOnly")]
        public Input<bool>? NetflowInternalFlowsOnly { get; set; }

        /// <summary>
        /// The observation domain ID for
        /// the Netflow collector.
        /// </summary>
        [Input("netflowObservationDomainId")]
        public Input<int>? NetflowObservationDomainId { get; set; }

        /// <summary>
        /// The ratio of total number of packets to
        /// the number of packets analyzed. The default is `0`, which indicates that the
        /// VDS should analyze all packets. The maximum value is `1000`, which
        /// indicates an analysis rate of 0.001%.
        /// </summary>
        [Input("netflowSamplingRate")]
        public Input<int>? NetflowSamplingRate { get; set; }

        /// <summary>
        /// Set to `true` to enable
        /// network I/O control. Default: `false`.
        /// </summary>
        [Input("networkResourceControlEnabled")]
        public Input<bool>? NetworkResourceControlEnabled { get; set; }

        /// <summary>
        /// The version of network I/O
        /// control to use. Can be one of `version2` or `version3`. Default: `version2`.
        /// </summary>
        [Input("networkResourceControlVersion")]
        public Input<string>? NetworkResourceControlVersion { get; set; }

        /// <summary>
        /// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsMaximumMbit")]
        public Input<int>? NfsMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        /// </summary>
        [Input("nfsReservationMbit")]
        public Input<int>? NfsReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the nfs traffic class for a custom share level.
        /// </summary>
        [Input("nfsShareCount")]
        public Input<int>? NfsShareCount { get; set; }

        /// <summary>
        /// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("nfsShareLevel")]
        public Input<string>? NfsShareLevel { get; set; }

        /// <summary>
        /// If `true`, the teaming policy will notify the
        /// broadcast network of an uplink failover, triggering cache updates.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// Used to define a secondary VLAN
        /// ID when using private VLANs.
        /// </summary>
        [Input("portPrivateSecondaryVlanId")]
        public Input<int>? PortPrivateSecondaryVlanId { get; set; }

        [Input("pvlanMappings")]
        private InputList<Inputs.DistributedVirtualSwitchPvlanMappingGetArgs>? _pvlanMappings;

        /// <summary>
        /// Use the `pvlan_mapping` block to declare a
        /// private VLAN mapping. The options are:
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchPvlanMappingGetArgs> PvlanMappings
        {
            get => _pvlanMappings ?? (_pvlanMappings = new InputList<Inputs.DistributedVirtualSwitchPvlanMappingGetArgs>());
            set => _pvlanMappings = value;
        }

        [Input("standbyUplinks")]
        private InputList<string>? _standbyUplinks;

        /// <summary>
        /// A list of standby uplinks to be used in
        /// failover. These uplinks need to match the definitions in the
        /// `uplinks` VDS argument. See
        /// here for more details.
        /// </summary>
        public InputList<string> StandbyUplinks
        {
            get => _standbyUplinks ?? (_standbyUplinks = new InputList<string>());
            set => _standbyUplinks = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource.
        /// 
        /// &gt; **NOTE:** Tagging support requires vCenter Server 6.0 or higher.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The uplink teaming policy. Can be one of
        /// `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,
        /// `failover_explicit`, or `loadbalance_loadbased`.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        /// <summary>
        /// Forward all traffic transmitted by ports for which
        /// this policy applies to its VDS uplinks.
        /// </summary>
        [Input("txUplink")]
        public Input<bool>? TxUplink { get; set; }

        [Input("uplinks")]
        private InputList<string>? _uplinks;

        /// <summary>
        /// A list of strings that uniquely identifies the names
        /// of the uplinks on the VDS across hosts. The number of items in this list
        /// controls the number of uplinks that exist on the VDS, in addition to the
        /// names. See here for an example on how to
        /// use this option.
        /// </summary>
        public InputList<string> Uplinks
        {
            get => _uplinks ?? (_uplinks = new InputList<string>());
            set => _uplinks = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpMaximumMbit")]
        public Input<int>? VdpMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        /// </summary>
        [Input("vdpReservationMbit")]
        public Input<int>? VdpReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vdp traffic class for a custom share level.
        /// </summary>
        [Input("vdpShareCount")]
        public Input<int>? VdpShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vdpShareLevel")]
        public Input<string>? VdpShareLevel { get; set; }

        /// <summary>
        /// The version of the VDS. BY default, a VDS is created
        /// at the latest version supported by the vSphere version if not specified.
        /// A VDS can be upgraded to a newer version, but can not be downgraded.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        /// <summary>
        /// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineMaximumMbit")]
        public Input<int>? VirtualmachineMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        /// </summary>
        [Input("virtualmachineReservationMbit")]
        public Input<int>? VirtualmachineReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        /// </summary>
        [Input("virtualmachineShareCount")]
        public Input<int>? VirtualmachineShareCount { get; set; }

        /// <summary>
        /// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("virtualmachineShareLevel")]
        public Input<string>? VirtualmachineShareLevel { get; set; }

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Input("vlanId")]
        public Input<int>? VlanId { get; set; }

        [Input("vlanRanges")]
        private InputList<Inputs.DistributedVirtualSwitchVlanRangeGetArgs>? _vlanRanges;

        /// <summary>
        /// Used to denote VLAN trunking. Use the `min_vlan`
        /// and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
        /// `vlan_range` definitions are allowed, but they must not overlap. Example
        /// below:
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using System.Linq;
        /// using Pulumi;
        /// using VSphere = Pulumi.VSphere;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var vds = new VSphere.DistributedVirtualSwitch("vds", new()
        ///     {
        ///         VlanRanges = new[]
        ///         {
        ///             new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs
        ///             {
        ///                 MaxVlan = 199,
        ///                 MinVlan = 100,
        ///             },
        ///             new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs
        ///             {
        ///                 MaxVlan = 399,
        ///                 MinVlan = 300,
        ///             },
        ///         },
        ///     });
        /// 
        /// });
        /// ```
        /// </summary>
        public InputList<Inputs.DistributedVirtualSwitchVlanRangeGetArgs> VlanRanges
        {
            get => _vlanRanges ?? (_vlanRanges = new InputList<Inputs.DistributedVirtualSwitchVlanRangeGetArgs>());
            set => _vlanRanges = value;
        }

        /// <summary>
        /// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionMaximumMbit")]
        public Input<int>? VmotionMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        /// </summary>
        [Input("vmotionReservationMbit")]
        public Input<int>? VmotionReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vmotion traffic class for a custom share level.
        /// </summary>
        [Input("vmotionShareCount")]
        public Input<int>? VmotionShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vmotionShareLevel")]
        public Input<string>? VmotionShareLevel { get; set; }

        /// <summary>
        /// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanMaximumMbit")]
        public Input<int>? VsanMaximumMbit { get; set; }

        /// <summary>
        /// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        /// </summary>
        [Input("vsanReservationMbit")]
        public Input<int>? VsanReservationMbit { get; set; }

        /// <summary>
        /// The amount of shares to allocate to the vsan traffic class for a custom share level.
        /// </summary>
        [Input("vsanShareCount")]
        public Input<int>? VsanShareCount { get; set; }

        /// <summary>
        /// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("vsanShareLevel")]
        public Input<string>? VsanShareLevel { get; set; }

        public DistributedVirtualSwitchState()
        {
        }
        public static new DistributedVirtualSwitchState Empty => new DistributedVirtualSwitchState();
    }
}
