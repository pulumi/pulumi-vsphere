// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Vsphere
{
    /// <summary>
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-vsphere/blob/master/website/docs/r/virtual_machine.html.markdown.
    /// </summary>
    public partial class VirtualMachine : Pulumi.CustomResource
    {
        /// <summary>
        /// The guest name for the operating system
        /// when `guest_id` is `other` or `other-64`.
        /// </summary>
        [Output("alternateGuestName")]
        public Output<string?> AlternateGuestName { get; private set; } = null!;

        /// <summary>
        /// A user-provided description of the virtual machine.
        /// The default is no annotation.
        /// </summary>
        [Output("annotation")]
        public Output<string?> Annotation { get; private set; } = null!;

        /// <summary>
        /// The number of milliseconds to wait before starting
        /// the boot sequence. The default is no delay.
        /// </summary>
        [Output("bootDelay")]
        public Output<int?> BootDelay { get; private set; } = null!;

        /// <summary>
        /// The number of milliseconds to wait before
        /// retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
        /// Default: `10000` (10 seconds).
        /// </summary>
        [Output("bootRetryDelay")]
        public Output<int?> BootRetryDelay { get; private set; } = null!;

        /// <summary>
        /// If set to true, a virtual machine that
        /// fails to boot will try again after the delay defined in `boot_retry_delay`.
        /// Default: `false`.
        /// </summary>
        [Output("bootRetryEnabled")]
        public Output<bool?> BootRetryEnabled { get; private set; } = null!;

        /// <summary>
        /// A specification for a CDROM device on this virtual
        /// machine. See CDROM options below.
        /// </summary>
        [Output("cdrom")]
        public Output<Outputs.VirtualMachineCdrom?> Cdrom { get; private set; } = null!;

        /// <summary>
        /// A unique identifier for a given version of the last
        /// configuration applied, such the timestamp of the last update to the
        /// configuration.
        /// </summary>
        [Output("changeVersion")]
        public Output<string> ChangeVersion { get; private set; } = null!;

        /// <summary>
        /// When specified, the VM will be created as a clone of a
        /// specified template. Optional customization options can be submitted as well.
        /// See creating a virtual machine from a
        /// template for more details.
        /// </summary>
        [Output("clone")]
        public Output<Outputs.VirtualMachineClone?> Clone { get; private set; } = null!;

        /// <summary>
        /// Allow CPUs to be added to this virtual
        /// machine while it is running.
        /// </summary>
        [Output("cpuHotAddEnabled")]
        public Output<bool?> CpuHotAddEnabled { get; private set; } = null!;

        /// <summary>
        /// Allow CPUs to be removed to this
        /// virtual machine while it is running.
        /// </summary>
        [Output("cpuHotRemoveEnabled")]
        public Output<bool?> CpuHotRemoveEnabled { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of CPU (in MHz) that this virtual
        /// machine can consume, regardless of available resources. The default is no
        /// limit.
        /// </summary>
        [Output("cpuLimit")]
        public Output<int?> CpuLimit { get; private set; } = null!;

        /// <summary>
        /// Enable CPU performance
        /// counters on this virtual machine. Default: `false`.
        /// </summary>
        [Output("cpuPerformanceCountersEnabled")]
        public Output<bool?> CpuPerformanceCountersEnabled { get; private set; } = null!;

        /// <summary>
        /// The amount of CPU (in MHz) that this virtual
        /// machine is guaranteed. The default is no reservation.
        /// </summary>
        [Output("cpuReservation")]
        public Output<int?> CpuReservation { get; private set; } = null!;

        /// <summary>
        /// The number of CPU shares allocated to the
        /// virtual machine when the `cpu_share_level` is `custom`.
        /// </summary>
        [Output("cpuShareCount")]
        public Output<int> CpuShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for CPU resources. Can be
        /// one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
        /// </summary>
        [Output("cpuShareLevel")]
        public Output<string?> CpuShareLevel { get; private set; } = null!;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for virtual machine. See
        /// [here][docs-setting-custom-attributes] for a reference on how to set values
        /// for custom attributes.
        /// </summary>
        [Output("customAttributes")]
        public Output<ImmutableDictionary<string, object>?> CustomAttributes { get; private set; } = null!;

        /// <summary>
        /// The [managed object reference
        /// ID][docs-about-morefs] of the datastore cluster ID to use. This setting
        /// applies to entire virtual machine and implies that you wish to use Storage
        /// DRS with this virtual machine. See the section on virtual machine
        /// migration for details on changing this value.
        /// </summary>
        [Output("datastoreClusterId")]
        public Output<string?> DatastoreClusterId { get; private set; } = null!;

        /// <summary>
        /// The datastore ID that the ISO is located in.
        /// Requried for using a datastore ISO. Conflicts with `client_device`.
        /// </summary>
        [Output("datastoreId")]
        public Output<string> DatastoreId { get; private set; } = null!;

        /// <summary>
        /// The IP address selected by Terraform to be used for the provisioner.
        /// </summary>
        [Output("defaultIpAddress")]
        public Output<string> DefaultIpAddress { get; private set; } = null!;

        /// <summary>
        /// A specification for a virtual disk device on this virtual
        /// machine. See disk options below.
        /// </summary>
        [Output("disks")]
        public Output<ImmutableArray<Outputs.VirtualMachineDisks>> Disks { get; private set; } = null!;

        /// <summary>
        /// When the `firmware` type is set to is
        /// `efi`, this enables EFI secure boot. Default: `false`.
        /// </summary>
        [Output("efiSecureBootEnabled")]
        public Output<bool?> EfiSecureBootEnabled { get; private set; } = null!;

        /// <summary>
        /// Expose the UUIDs of attached virtual disks to
        /// the virtual machine, allowing access to them in the guest. Default: `false`.
        /// </summary>
        [Output("enableDiskUuid")]
        public Output<bool?> EnableDiskUuid { get; private set; } = null!;

        /// <summary>
        /// Enable logging of virtual machine events to a
        /// log file stored in the virtual machine directory. Default: `false`.
        /// </summary>
        [Output("enableLogging")]
        public Output<bool?> EnableLogging { get; private set; } = null!;

        /// <summary>
        /// The EPT/RVI (hardware memory virtualization)
        /// setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
        /// Default: `automatic`.
        /// </summary>
        [Output("eptRviMode")]
        public Output<string?> EptRviMode { get; private set; } = null!;

        /// <summary>
        /// Extra configuration data for this virtual
        /// machine. Can be used to supply advanced parameters not normally in
        /// configuration, such as instance metadata.
        /// </summary>
        [Output("extraConfig")]
        public Output<ImmutableDictionary<string, object>?> ExtraConfig { get; private set; } = null!;

        /// <summary>
        /// The firmware interface to use on the virtual machine.
        /// Can be one of `bios` or `EFI`. Default: `bios`.
        /// </summary>
        [Output("firmware")]
        public Output<string?> Firmware { get; private set; } = null!;

        /// <summary>
        /// The path to the folder to put this virtual machine in,
        /// relative to the datacenter that the resource pool is in.
        /// </summary>
        [Output("folder")]
        public Output<string?> Folder { get; private set; } = null!;

        /// <summary>
        /// If a guest shutdown failed or timed out while
        /// updating or destroying (see
        /// `shutdown_wait_timeout`), force the power-off of
        /// the virtual machine. Default: `true`.
        /// </summary>
        [Output("forcePowerOff")]
        public Output<bool?> ForcePowerOff { get; private set; } = null!;

        /// <summary>
        /// The guest ID for the operating system type. For a
        /// full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
        /// </summary>
        [Output("guestId")]
        public Output<string?> GuestId { get; private set; } = null!;

        /// <summary>
        /// The current list of IP addresses on this machine,
        /// including the value of `default_ip_address`. If VMware tools is not running
        /// on the virtual machine, or if the VM is powered off, this list will be empty.
        /// * `moid`: The [managed object reference ID][docs-about-morefs] of the created
        /// virtual machine.
        /// </summary>
        [Output("guestIpAddresses")]
        public Output<ImmutableArray<string>> GuestIpAddresses { get; private set; } = null!;

        /// <summary>
        /// An optional [managed object reference
        /// ID][docs-about-morefs] of a host to put this virtual machine on. See the
        /// section on virtual machine migration for
        /// details on changing this value. If a `host_system_id` is not supplied,
        /// vSphere will select a host in the resource pool to place the virtual machine,
        /// according to any defaults or DRS policies in place.
        /// </summary>
        [Output("hostSystemId")]
        public Output<string> HostSystemId { get; private set; } = null!;

        /// <summary>
        /// The (non-nested) hardware virtualization setting for
        /// this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
        /// `hvAuto`.
        /// </summary>
        [Output("hvMode")]
        public Output<string?> HvMode { get; private set; } = null!;

        /// <summary>
        /// List of IP addresses to ignore while waiting
        /// for an available IP address using either of the waiters. Any IP addresses in
        /// this list will be ignored if they show up so that the waiter will continue to
        /// wait for a real IP address. Default: [].
        /// </summary>
        [Output("ignoredGuestIps")]
        public Output<ImmutableArray<string>> IgnoredGuestIps { get; private set; } = null!;

        /// <summary>
        /// This is flagged if the virtual machine has been imported, or the
        /// state has been migrated from a previous version of the resource. It
        /// influences the behavior of the first post-import apply operation. See the
        /// section on importing below.
        /// </summary>
        [Output("imported")]
        public Output<bool> Imported { get; private set; } = null!;

        /// <summary>
        /// Controls the scheduling delay of the
        /// virtual machine. Use a higher sensitivity for applications that require lower
        /// latency, such as VOIP, media player applications, or applications that
        /// require frequent access to mouse or keyboard devices. Can be one of `low`,
        /// `normal`, `medium`, or `high`.
        /// </summary>
        [Output("latencySensitivity")]
        public Output<string?> LatencySensitivity { get; private set; } = null!;

        /// <summary>
        /// The size of the virtual machine's memory, in MB.
        /// Default: `1024` (1 GB).
        /// </summary>
        [Output("memory")]
        public Output<int?> Memory { get; private set; } = null!;

        /// <summary>
        /// Allow memory to be added to this
        /// virtual machine while it is running.
        /// </summary>
        [Output("memoryHotAddEnabled")]
        public Output<bool?> MemoryHotAddEnabled { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of memory (in MB) that this
        /// virtual machine can consume, regardless of available resources. The default
        /// is no limit.
        /// </summary>
        [Output("memoryLimit")]
        public Output<int?> MemoryLimit { get; private set; } = null!;

        /// <summary>
        /// The amount of memory (in MB) that this
        /// virtual machine is guaranteed. The default is no reservation.
        /// </summary>
        [Output("memoryReservation")]
        public Output<int?> MemoryReservation { get; private set; } = null!;

        /// <summary>
        /// The number of memory shares allocated to
        /// the virtual machine when the `memory_share_level` is `custom`.
        /// </summary>
        [Output("memoryShareCount")]
        public Output<int> MemoryShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for memory resources.
        /// Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
        /// </summary>
        [Output("memoryShareLevel")]
        public Output<string?> MemoryShareLevel { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in minutes, to wait
        /// for a virtual machine migration to complete before failing. Default: 10
        /// minutes. Also see the section on virtual machine
        /// migration.
        /// </summary>
        [Output("migrateWaitTimeout")]
        public Output<int?> MigrateWaitTimeout { get; private set; } = null!;

        /// <summary>
        /// The machine object ID from VMWare
        /// </summary>
        [Output("moid")]
        public Output<string> Moid { get; private set; } = null!;

        /// <summary>
        /// An alias for both `label` and `path`, the latter when
        /// using `attach`. Required if not using `label`.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Enable nested hardware virtualization on
        /// this virtual machine, facilitating nested virtualization in the guest.
        /// Default: `false`.
        /// </summary>
        [Output("nestedHvEnabled")]
        public Output<bool?> NestedHvEnabled { get; private set; } = null!;

        /// <summary>
        /// A specification for a virtual NIC on this
        /// virtual machine. See network interface options
        /// below.
        /// </summary>
        [Output("networkInterfaces")]
        public Output<ImmutableArray<Outputs.VirtualMachineNetworkInterfaces>> NetworkInterfaces { get; private set; } = null!;

        /// <summary>
        /// The number of cores per socket in this
        /// virtual machine. The number of vCPUs on the virtual machine will be
        /// `num_cpus` divided by `num_cores_per_socket`. If specified, the value
        /// supplied to `num_cpus` must be evenly divisible by this value. Default: `1`.
        /// </summary>
        [Output("numCoresPerSocket")]
        public Output<int?> NumCoresPerSocket { get; private set; } = null!;

        /// <summary>
        /// The total number of virtual processor cores to assign
        /// to this virtual machine. Default: `1`.
        /// </summary>
        [Output("numCpus")]
        public Output<int?> NumCpus { get; private set; } = null!;

        /// <summary>
        /// Value internal to Terraform used to determine if a configuration set change requires a reboot.
        /// </summary>
        [Output("rebootRequired")]
        public Output<bool> RebootRequired { get; private set; } = null!;

        /// <summary>
        /// The [managed object reference
        /// ID][docs-about-morefs] of the resource pool to put this virtual machine in.
        /// See the section on virtual machine migration
        /// for details on changing this value.
        /// </summary>
        [Output("resourcePoolId")]
        public Output<string> ResourcePoolId { get; private set; } = null!;

        /// <summary>
        /// Enable the execution of
        /// post-power-on scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Output("runToolsScriptsAfterPowerOn")]
        public Output<bool?> RunToolsScriptsAfterPowerOn { get; private set; } = null!;

        /// <summary>
        /// Enable the execution of
        /// post-resume scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Output("runToolsScriptsAfterResume")]
        public Output<bool?> RunToolsScriptsAfterResume { get; private set; } = null!;

        /// <summary>
        /// Enable the execution of
        /// pre-reboot scripts when VMware tools is installed. Default: `false`.
        /// </summary>
        [Output("runToolsScriptsBeforeGuestReboot")]
        public Output<bool?> RunToolsScriptsBeforeGuestReboot { get; private set; } = null!;

        /// <summary>
        /// Enable the execution
        /// of pre-shutdown scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Output("runToolsScriptsBeforeGuestShutdown")]
        public Output<bool?> RunToolsScriptsBeforeGuestShutdown { get; private set; } = null!;

        /// <summary>
        /// Enable the execution of
        /// pre-standby scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Output("runToolsScriptsBeforeGuestStandby")]
        public Output<bool?> RunToolsScriptsBeforeGuestStandby { get; private set; } = null!;

        /// <summary>
        /// Mode for sharing the SCSI bus. The modes are
        /// physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
        /// </summary>
        [Output("scsiBusSharing")]
        public Output<string?> ScsiBusSharing { get; private set; } = null!;

        /// <summary>
        /// The number of SCSI controllers that Terraform manages on this virtual machine. This directly affects the
        /// amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this
        /// value does not remove controllers.
        /// </summary>
        [Output("scsiControllerCount")]
        public Output<int?> ScsiControllerCount { get; private set; } = null!;

        /// <summary>
        /// The type of SCSI bus this virtual machine will have.
        /// Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
        /// pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
        /// </summary>
        [Output("scsiType")]
        public Output<string?> ScsiType { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in minutes, to wait
        /// for a graceful guest shutdown when making necessary updates to the virtual
        /// machine. If `force_power_off` is set to true, the VM will be force powered-off
        /// after this timeout, otherwise an error is returned. Default: 3 minutes.
        /// </summary>
        [Output("shutdownWaitTimeout")]
        public Output<int?> ShutdownWaitTimeout { get; private set; } = null!;

        /// <summary>
        /// The swap file placement policy for this
        /// virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
        /// Default: `inherit`.
        /// </summary>
        [Output("swapPlacementPolicy")]
        public Output<string?> SwapPlacementPolicy { get; private set; } = null!;

        /// <summary>
        /// Enable guest clock synchronization with
        /// the host. Requires VMware tools to be installed. Default: `false`.
        /// </summary>
        [Output("syncTimeWithHost")]
        public Output<bool?> SyncTimeWithHost { get; private set; } = null!;

        /// <summary>
        /// The IDs of any tags to attach to this resource. See
        /// [here][docs-applying-tags] for a reference on how to apply tags.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// The UUID of the virtual disk's VMDK file. This is used to track the
        /// virtual disk on the virtual machine.
        /// </summary>
        [Output("uuid")]
        public Output<string> Uuid { get; private set; } = null!;

        /// <summary>
        /// Optional vApp configuration. The only sub-key available
        /// is `properties`, which is a key/value map of properties for virtual machines
        /// imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
        /// configuration for
        /// more details.
        /// </summary>
        [Output("vapp")]
        public Output<Outputs.VirtualMachineVapp?> Vapp { get; private set; } = null!;

        /// <summary>
        /// Computed value which is only valid for cloned virtual
        /// machines. A list of vApp transport methods supported by the source virtual
        /// machine or template.
        /// </summary>
        [Output("vappTransports")]
        public Output<ImmutableArray<string>> VappTransports { get; private set; } = null!;

        /// <summary>
        /// The state of VMware tools in the guest. This will
        /// determine the proper course of action for some device operations.
        /// </summary>
        [Output("vmwareToolsStatus")]
        public Output<string> VmwareToolsStatus { get; private set; } = null!;

        /// <summary>
        /// The path of the virtual machine's configuration file in the VM's
        /// datastore.
        /// </summary>
        [Output("vmxPath")]
        public Output<string> VmxPath { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in minutes, to
        /// wait for an available guest IP address on this virtual machine. This should
        /// only be used if your version of VMware Tools does not allow the
        /// `wait_for_guest_net_timeout` waiter to be
        /// used. A value less than 1 disables the waiter. Default: 0.
        /// </summary>
        [Output("waitForGuestIpTimeout")]
        public Output<int?> WaitForGuestIpTimeout { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the guest
        /// network waiter waits for a routable address. When `false`, the waiter does
        /// not wait for a default gateway, nor are IP addresses checked against any
        /// discovered default gateways as part of its success criteria. This property is
        /// ignored if the `wait_for_guest_ip_timeout`
        /// waiter is used. Default: `true`.
        /// </summary>
        [Output("waitForGuestNetRoutable")]
        public Output<bool?> WaitForGuestNetRoutable { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in minutes, to
        /// wait for an available IP address on this virtual machine's NICs. Older
        /// versions of VMware Tools do not populate this property. In those cases, this
        /// waiter can be disabled and the
        /// `wait_for_guest_ip_timeout` waiter can be used
        /// instead. A value less than 1 disables the waiter. Default: 5 minutes.
        /// </summary>
        [Output("waitForGuestNetTimeout")]
        public Output<int?> WaitForGuestNetTimeout { get; private set; } = null!;


        /// <summary>
        /// Create a VirtualMachine resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public VirtualMachine(string name, VirtualMachineArgs args, CustomResourceOptions? options = null)
            : base("vsphere:index/virtualMachine:VirtualMachine", name, args, MakeResourceOptions(options, ""))
        {
        }

        private VirtualMachine(string name, Input<string> id, VirtualMachineState? state = null, CustomResourceOptions? options = null)
            : base("vsphere:index/virtualMachine:VirtualMachine", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing VirtualMachine resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static VirtualMachine Get(string name, Input<string> id, VirtualMachineState? state = null, CustomResourceOptions? options = null)
        {
            return new VirtualMachine(name, id, state, options);
        }
    }

    public sealed class VirtualMachineArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The guest name for the operating system
        /// when `guest_id` is `other` or `other-64`.
        /// </summary>
        [Input("alternateGuestName")]
        public Input<string>? AlternateGuestName { get; set; }

        /// <summary>
        /// A user-provided description of the virtual machine.
        /// The default is no annotation.
        /// </summary>
        [Input("annotation")]
        public Input<string>? Annotation { get; set; }

        /// <summary>
        /// The number of milliseconds to wait before starting
        /// the boot sequence. The default is no delay.
        /// </summary>
        [Input("bootDelay")]
        public Input<int>? BootDelay { get; set; }

        /// <summary>
        /// The number of milliseconds to wait before
        /// retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
        /// Default: `10000` (10 seconds).
        /// </summary>
        [Input("bootRetryDelay")]
        public Input<int>? BootRetryDelay { get; set; }

        /// <summary>
        /// If set to true, a virtual machine that
        /// fails to boot will try again after the delay defined in `boot_retry_delay`.
        /// Default: `false`.
        /// </summary>
        [Input("bootRetryEnabled")]
        public Input<bool>? BootRetryEnabled { get; set; }

        /// <summary>
        /// A specification for a CDROM device on this virtual
        /// machine. See CDROM options below.
        /// </summary>
        [Input("cdrom")]
        public Input<Inputs.VirtualMachineCdromArgs>? Cdrom { get; set; }

        /// <summary>
        /// When specified, the VM will be created as a clone of a
        /// specified template. Optional customization options can be submitted as well.
        /// See creating a virtual machine from a
        /// template for more details.
        /// </summary>
        [Input("clone")]
        public Input<Inputs.VirtualMachineCloneArgs>? Clone { get; set; }

        /// <summary>
        /// Allow CPUs to be added to this virtual
        /// machine while it is running.
        /// </summary>
        [Input("cpuHotAddEnabled")]
        public Input<bool>? CpuHotAddEnabled { get; set; }

        /// <summary>
        /// Allow CPUs to be removed to this
        /// virtual machine while it is running.
        /// </summary>
        [Input("cpuHotRemoveEnabled")]
        public Input<bool>? CpuHotRemoveEnabled { get; set; }

        /// <summary>
        /// The maximum amount of CPU (in MHz) that this virtual
        /// machine can consume, regardless of available resources. The default is no
        /// limit.
        /// </summary>
        [Input("cpuLimit")]
        public Input<int>? CpuLimit { get; set; }

        /// <summary>
        /// Enable CPU performance
        /// counters on this virtual machine. Default: `false`.
        /// </summary>
        [Input("cpuPerformanceCountersEnabled")]
        public Input<bool>? CpuPerformanceCountersEnabled { get; set; }

        /// <summary>
        /// The amount of CPU (in MHz) that this virtual
        /// machine is guaranteed. The default is no reservation.
        /// </summary>
        [Input("cpuReservation")]
        public Input<int>? CpuReservation { get; set; }

        /// <summary>
        /// The number of CPU shares allocated to the
        /// virtual machine when the `cpu_share_level` is `custom`.
        /// </summary>
        [Input("cpuShareCount")]
        public Input<int>? CpuShareCount { get; set; }

        /// <summary>
        /// The allocation level for CPU resources. Can be
        /// one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
        /// </summary>
        [Input("cpuShareLevel")]
        public Input<string>? CpuShareLevel { get; set; }

        [Input("customAttributes")]
        private InputMap<object>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for virtual machine. See
        /// [here][docs-setting-custom-attributes] for a reference on how to set values
        /// for custom attributes.
        /// </summary>
        public InputMap<object> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<object>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The [managed object reference
        /// ID][docs-about-morefs] of the datastore cluster ID to use. This setting
        /// applies to entire virtual machine and implies that you wish to use Storage
        /// DRS with this virtual machine. See the section on virtual machine
        /// migration for details on changing this value.
        /// </summary>
        [Input("datastoreClusterId")]
        public Input<string>? DatastoreClusterId { get; set; }

        /// <summary>
        /// The datastore ID that the ISO is located in.
        /// Requried for using a datastore ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("datastoreId")]
        public Input<string>? DatastoreId { get; set; }

        [Input("disks")]
        private InputList<Inputs.VirtualMachineDisksArgs>? _disks;

        /// <summary>
        /// A specification for a virtual disk device on this virtual
        /// machine. See disk options below.
        /// </summary>
        public InputList<Inputs.VirtualMachineDisksArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VirtualMachineDisksArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// When the `firmware` type is set to is
        /// `efi`, this enables EFI secure boot. Default: `false`.
        /// </summary>
        [Input("efiSecureBootEnabled")]
        public Input<bool>? EfiSecureBootEnabled { get; set; }

        /// <summary>
        /// Expose the UUIDs of attached virtual disks to
        /// the virtual machine, allowing access to them in the guest. Default: `false`.
        /// </summary>
        [Input("enableDiskUuid")]
        public Input<bool>? EnableDiskUuid { get; set; }

        /// <summary>
        /// Enable logging of virtual machine events to a
        /// log file stored in the virtual machine directory. Default: `false`.
        /// </summary>
        [Input("enableLogging")]
        public Input<bool>? EnableLogging { get; set; }

        /// <summary>
        /// The EPT/RVI (hardware memory virtualization)
        /// setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
        /// Default: `automatic`.
        /// </summary>
        [Input("eptRviMode")]
        public Input<string>? EptRviMode { get; set; }

        [Input("extraConfig")]
        private InputMap<object>? _extraConfig;

        /// <summary>
        /// Extra configuration data for this virtual
        /// machine. Can be used to supply advanced parameters not normally in
        /// configuration, such as instance metadata.
        /// </summary>
        public InputMap<object> ExtraConfig
        {
            get => _extraConfig ?? (_extraConfig = new InputMap<object>());
            set => _extraConfig = value;
        }

        /// <summary>
        /// The firmware interface to use on the virtual machine.
        /// Can be one of `bios` or `EFI`. Default: `bios`.
        /// </summary>
        [Input("firmware")]
        public Input<string>? Firmware { get; set; }

        /// <summary>
        /// The path to the folder to put this virtual machine in,
        /// relative to the datacenter that the resource pool is in.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// If a guest shutdown failed or timed out while
        /// updating or destroying (see
        /// `shutdown_wait_timeout`), force the power-off of
        /// the virtual machine. Default: `true`.
        /// </summary>
        [Input("forcePowerOff")]
        public Input<bool>? ForcePowerOff { get; set; }

        /// <summary>
        /// The guest ID for the operating system type. For a
        /// full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
        /// </summary>
        [Input("guestId")]
        public Input<string>? GuestId { get; set; }

        /// <summary>
        /// An optional [managed object reference
        /// ID][docs-about-morefs] of a host to put this virtual machine on. See the
        /// section on virtual machine migration for
        /// details on changing this value. If a `host_system_id` is not supplied,
        /// vSphere will select a host in the resource pool to place the virtual machine,
        /// according to any defaults or DRS policies in place.
        /// </summary>
        [Input("hostSystemId")]
        public Input<string>? HostSystemId { get; set; }

        /// <summary>
        /// The (non-nested) hardware virtualization setting for
        /// this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
        /// `hvAuto`.
        /// </summary>
        [Input("hvMode")]
        public Input<string>? HvMode { get; set; }

        [Input("ignoredGuestIps")]
        private InputList<string>? _ignoredGuestIps;

        /// <summary>
        /// List of IP addresses to ignore while waiting
        /// for an available IP address using either of the waiters. Any IP addresses in
        /// this list will be ignored if they show up so that the waiter will continue to
        /// wait for a real IP address. Default: [].
        /// </summary>
        public InputList<string> IgnoredGuestIps
        {
            get => _ignoredGuestIps ?? (_ignoredGuestIps = new InputList<string>());
            set => _ignoredGuestIps = value;
        }

        /// <summary>
        /// Controls the scheduling delay of the
        /// virtual machine. Use a higher sensitivity for applications that require lower
        /// latency, such as VOIP, media player applications, or applications that
        /// require frequent access to mouse or keyboard devices. Can be one of `low`,
        /// `normal`, `medium`, or `high`.
        /// </summary>
        [Input("latencySensitivity")]
        public Input<string>? LatencySensitivity { get; set; }

        /// <summary>
        /// The size of the virtual machine's memory, in MB.
        /// Default: `1024` (1 GB).
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        /// <summary>
        /// Allow memory to be added to this
        /// virtual machine while it is running.
        /// </summary>
        [Input("memoryHotAddEnabled")]
        public Input<bool>? MemoryHotAddEnabled { get; set; }

        /// <summary>
        /// The maximum amount of memory (in MB) that this
        /// virtual machine can consume, regardless of available resources. The default
        /// is no limit.
        /// </summary>
        [Input("memoryLimit")]
        public Input<int>? MemoryLimit { get; set; }

        /// <summary>
        /// The amount of memory (in MB) that this
        /// virtual machine is guaranteed. The default is no reservation.
        /// </summary>
        [Input("memoryReservation")]
        public Input<int>? MemoryReservation { get; set; }

        /// <summary>
        /// The number of memory shares allocated to
        /// the virtual machine when the `memory_share_level` is `custom`.
        /// </summary>
        [Input("memoryShareCount")]
        public Input<int>? MemoryShareCount { get; set; }

        /// <summary>
        /// The allocation level for memory resources.
        /// Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
        /// </summary>
        [Input("memoryShareLevel")]
        public Input<string>? MemoryShareLevel { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait
        /// for a virtual machine migration to complete before failing. Default: 10
        /// minutes. Also see the section on virtual machine
        /// migration.
        /// </summary>
        [Input("migrateWaitTimeout")]
        public Input<int>? MigrateWaitTimeout { get; set; }

        /// <summary>
        /// An alias for both `label` and `path`, the latter when
        /// using `attach`. Required if not using `label`.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Enable nested hardware virtualization on
        /// this virtual machine, facilitating nested virtualization in the guest.
        /// Default: `false`.
        /// </summary>
        [Input("nestedHvEnabled")]
        public Input<bool>? NestedHvEnabled { get; set; }

        [Input("networkInterfaces", required: true)]
        private InputList<Inputs.VirtualMachineNetworkInterfacesArgs>? _networkInterfaces;

        /// <summary>
        /// A specification for a virtual NIC on this
        /// virtual machine. See network interface options
        /// below.
        /// </summary>
        public InputList<Inputs.VirtualMachineNetworkInterfacesArgs> NetworkInterfaces
        {
            get => _networkInterfaces ?? (_networkInterfaces = new InputList<Inputs.VirtualMachineNetworkInterfacesArgs>());
            set => _networkInterfaces = value;
        }

        /// <summary>
        /// The number of cores per socket in this
        /// virtual machine. The number of vCPUs on the virtual machine will be
        /// `num_cpus` divided by `num_cores_per_socket`. If specified, the value
        /// supplied to `num_cpus` must be evenly divisible by this value. Default: `1`.
        /// </summary>
        [Input("numCoresPerSocket")]
        public Input<int>? NumCoresPerSocket { get; set; }

        /// <summary>
        /// The total number of virtual processor cores to assign
        /// to this virtual machine. Default: `1`.
        /// </summary>
        [Input("numCpus")]
        public Input<int>? NumCpus { get; set; }

        /// <summary>
        /// The [managed object reference
        /// ID][docs-about-morefs] of the resource pool to put this virtual machine in.
        /// See the section on virtual machine migration
        /// for details on changing this value.
        /// </summary>
        [Input("resourcePoolId", required: true)]
        public Input<string> ResourcePoolId { get; set; } = null!;

        /// <summary>
        /// Enable the execution of
        /// post-power-on scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Input("runToolsScriptsAfterPowerOn")]
        public Input<bool>? RunToolsScriptsAfterPowerOn { get; set; }

        /// <summary>
        /// Enable the execution of
        /// post-resume scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Input("runToolsScriptsAfterResume")]
        public Input<bool>? RunToolsScriptsAfterResume { get; set; }

        /// <summary>
        /// Enable the execution of
        /// pre-reboot scripts when VMware tools is installed. Default: `false`.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestReboot")]
        public Input<bool>? RunToolsScriptsBeforeGuestReboot { get; set; }

        /// <summary>
        /// Enable the execution
        /// of pre-shutdown scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestShutdown")]
        public Input<bool>? RunToolsScriptsBeforeGuestShutdown { get; set; }

        /// <summary>
        /// Enable the execution of
        /// pre-standby scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestStandby")]
        public Input<bool>? RunToolsScriptsBeforeGuestStandby { get; set; }

        /// <summary>
        /// Mode for sharing the SCSI bus. The modes are
        /// physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
        /// </summary>
        [Input("scsiBusSharing")]
        public Input<string>? ScsiBusSharing { get; set; }

        /// <summary>
        /// The number of SCSI controllers that Terraform manages on this virtual machine. This directly affects the
        /// amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this
        /// value does not remove controllers.
        /// </summary>
        [Input("scsiControllerCount")]
        public Input<int>? ScsiControllerCount { get; set; }

        /// <summary>
        /// The type of SCSI bus this virtual machine will have.
        /// Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
        /// pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
        /// </summary>
        [Input("scsiType")]
        public Input<string>? ScsiType { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait
        /// for a graceful guest shutdown when making necessary updates to the virtual
        /// machine. If `force_power_off` is set to true, the VM will be force powered-off
        /// after this timeout, otherwise an error is returned. Default: 3 minutes.
        /// </summary>
        [Input("shutdownWaitTimeout")]
        public Input<int>? ShutdownWaitTimeout { get; set; }

        /// <summary>
        /// The swap file placement policy for this
        /// virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
        /// Default: `inherit`.
        /// </summary>
        [Input("swapPlacementPolicy")]
        public Input<string>? SwapPlacementPolicy { get; set; }

        /// <summary>
        /// Enable guest clock synchronization with
        /// the host. Requires VMware tools to be installed. Default: `false`.
        /// </summary>
        [Input("syncTimeWithHost")]
        public Input<bool>? SyncTimeWithHost { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource. See
        /// [here][docs-applying-tags] for a reference on how to apply tags.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Optional vApp configuration. The only sub-key available
        /// is `properties`, which is a key/value map of properties for virtual machines
        /// imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
        /// configuration for
        /// more details.
        /// </summary>
        [Input("vapp")]
        public Input<Inputs.VirtualMachineVappArgs>? Vapp { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to
        /// wait for an available guest IP address on this virtual machine. This should
        /// only be used if your version of VMware Tools does not allow the
        /// `wait_for_guest_net_timeout` waiter to be
        /// used. A value less than 1 disables the waiter. Default: 0.
        /// </summary>
        [Input("waitForGuestIpTimeout")]
        public Input<int>? WaitForGuestIpTimeout { get; set; }

        /// <summary>
        /// Controls whether or not the guest
        /// network waiter waits for a routable address. When `false`, the waiter does
        /// not wait for a default gateway, nor are IP addresses checked against any
        /// discovered default gateways as part of its success criteria. This property is
        /// ignored if the `wait_for_guest_ip_timeout`
        /// waiter is used. Default: `true`.
        /// </summary>
        [Input("waitForGuestNetRoutable")]
        public Input<bool>? WaitForGuestNetRoutable { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to
        /// wait for an available IP address on this virtual machine's NICs. Older
        /// versions of VMware Tools do not populate this property. In those cases, this
        /// waiter can be disabled and the
        /// `wait_for_guest_ip_timeout` waiter can be used
        /// instead. A value less than 1 disables the waiter. Default: 5 minutes.
        /// </summary>
        [Input("waitForGuestNetTimeout")]
        public Input<int>? WaitForGuestNetTimeout { get; set; }

        public VirtualMachineArgs()
        {
        }
    }

    public sealed class VirtualMachineState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The guest name for the operating system
        /// when `guest_id` is `other` or `other-64`.
        /// </summary>
        [Input("alternateGuestName")]
        public Input<string>? AlternateGuestName { get; set; }

        /// <summary>
        /// A user-provided description of the virtual machine.
        /// The default is no annotation.
        /// </summary>
        [Input("annotation")]
        public Input<string>? Annotation { get; set; }

        /// <summary>
        /// The number of milliseconds to wait before starting
        /// the boot sequence. The default is no delay.
        /// </summary>
        [Input("bootDelay")]
        public Input<int>? BootDelay { get; set; }

        /// <summary>
        /// The number of milliseconds to wait before
        /// retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
        /// Default: `10000` (10 seconds).
        /// </summary>
        [Input("bootRetryDelay")]
        public Input<int>? BootRetryDelay { get; set; }

        /// <summary>
        /// If set to true, a virtual machine that
        /// fails to boot will try again after the delay defined in `boot_retry_delay`.
        /// Default: `false`.
        /// </summary>
        [Input("bootRetryEnabled")]
        public Input<bool>? BootRetryEnabled { get; set; }

        /// <summary>
        /// A specification for a CDROM device on this virtual
        /// machine. See CDROM options below.
        /// </summary>
        [Input("cdrom")]
        public Input<Inputs.VirtualMachineCdromGetArgs>? Cdrom { get; set; }

        /// <summary>
        /// A unique identifier for a given version of the last
        /// configuration applied, such the timestamp of the last update to the
        /// configuration.
        /// </summary>
        [Input("changeVersion")]
        public Input<string>? ChangeVersion { get; set; }

        /// <summary>
        /// When specified, the VM will be created as a clone of a
        /// specified template. Optional customization options can be submitted as well.
        /// See creating a virtual machine from a
        /// template for more details.
        /// </summary>
        [Input("clone")]
        public Input<Inputs.VirtualMachineCloneGetArgs>? Clone { get; set; }

        /// <summary>
        /// Allow CPUs to be added to this virtual
        /// machine while it is running.
        /// </summary>
        [Input("cpuHotAddEnabled")]
        public Input<bool>? CpuHotAddEnabled { get; set; }

        /// <summary>
        /// Allow CPUs to be removed to this
        /// virtual machine while it is running.
        /// </summary>
        [Input("cpuHotRemoveEnabled")]
        public Input<bool>? CpuHotRemoveEnabled { get; set; }

        /// <summary>
        /// The maximum amount of CPU (in MHz) that this virtual
        /// machine can consume, regardless of available resources. The default is no
        /// limit.
        /// </summary>
        [Input("cpuLimit")]
        public Input<int>? CpuLimit { get; set; }

        /// <summary>
        /// Enable CPU performance
        /// counters on this virtual machine. Default: `false`.
        /// </summary>
        [Input("cpuPerformanceCountersEnabled")]
        public Input<bool>? CpuPerformanceCountersEnabled { get; set; }

        /// <summary>
        /// The amount of CPU (in MHz) that this virtual
        /// machine is guaranteed. The default is no reservation.
        /// </summary>
        [Input("cpuReservation")]
        public Input<int>? CpuReservation { get; set; }

        /// <summary>
        /// The number of CPU shares allocated to the
        /// virtual machine when the `cpu_share_level` is `custom`.
        /// </summary>
        [Input("cpuShareCount")]
        public Input<int>? CpuShareCount { get; set; }

        /// <summary>
        /// The allocation level for CPU resources. Can be
        /// one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
        /// </summary>
        [Input("cpuShareLevel")]
        public Input<string>? CpuShareLevel { get; set; }

        [Input("customAttributes")]
        private InputMap<object>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value strings to set for virtual machine. See
        /// [here][docs-setting-custom-attributes] for a reference on how to set values
        /// for custom attributes.
        /// </summary>
        public InputMap<object> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<object>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The [managed object reference
        /// ID][docs-about-morefs] of the datastore cluster ID to use. This setting
        /// applies to entire virtual machine and implies that you wish to use Storage
        /// DRS with this virtual machine. See the section on virtual machine
        /// migration for details on changing this value.
        /// </summary>
        [Input("datastoreClusterId")]
        public Input<string>? DatastoreClusterId { get; set; }

        /// <summary>
        /// The datastore ID that the ISO is located in.
        /// Requried for using a datastore ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("datastoreId")]
        public Input<string>? DatastoreId { get; set; }

        /// <summary>
        /// The IP address selected by Terraform to be used for the provisioner.
        /// </summary>
        [Input("defaultIpAddress")]
        public Input<string>? DefaultIpAddress { get; set; }

        [Input("disks")]
        private InputList<Inputs.VirtualMachineDisksGetArgs>? _disks;

        /// <summary>
        /// A specification for a virtual disk device on this virtual
        /// machine. See disk options below.
        /// </summary>
        public InputList<Inputs.VirtualMachineDisksGetArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VirtualMachineDisksGetArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// When the `firmware` type is set to is
        /// `efi`, this enables EFI secure boot. Default: `false`.
        /// </summary>
        [Input("efiSecureBootEnabled")]
        public Input<bool>? EfiSecureBootEnabled { get; set; }

        /// <summary>
        /// Expose the UUIDs of attached virtual disks to
        /// the virtual machine, allowing access to them in the guest. Default: `false`.
        /// </summary>
        [Input("enableDiskUuid")]
        public Input<bool>? EnableDiskUuid { get; set; }

        /// <summary>
        /// Enable logging of virtual machine events to a
        /// log file stored in the virtual machine directory. Default: `false`.
        /// </summary>
        [Input("enableLogging")]
        public Input<bool>? EnableLogging { get; set; }

        /// <summary>
        /// The EPT/RVI (hardware memory virtualization)
        /// setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
        /// Default: `automatic`.
        /// </summary>
        [Input("eptRviMode")]
        public Input<string>? EptRviMode { get; set; }

        [Input("extraConfig")]
        private InputMap<object>? _extraConfig;

        /// <summary>
        /// Extra configuration data for this virtual
        /// machine. Can be used to supply advanced parameters not normally in
        /// configuration, such as instance metadata.
        /// </summary>
        public InputMap<object> ExtraConfig
        {
            get => _extraConfig ?? (_extraConfig = new InputMap<object>());
            set => _extraConfig = value;
        }

        /// <summary>
        /// The firmware interface to use on the virtual machine.
        /// Can be one of `bios` or `EFI`. Default: `bios`.
        /// </summary>
        [Input("firmware")]
        public Input<string>? Firmware { get; set; }

        /// <summary>
        /// The path to the folder to put this virtual machine in,
        /// relative to the datacenter that the resource pool is in.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// If a guest shutdown failed or timed out while
        /// updating or destroying (see
        /// `shutdown_wait_timeout`), force the power-off of
        /// the virtual machine. Default: `true`.
        /// </summary>
        [Input("forcePowerOff")]
        public Input<bool>? ForcePowerOff { get; set; }

        /// <summary>
        /// The guest ID for the operating system type. For a
        /// full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
        /// </summary>
        [Input("guestId")]
        public Input<string>? GuestId { get; set; }

        [Input("guestIpAddresses")]
        private InputList<string>? _guestIpAddresses;

        /// <summary>
        /// The current list of IP addresses on this machine,
        /// including the value of `default_ip_address`. If VMware tools is not running
        /// on the virtual machine, or if the VM is powered off, this list will be empty.
        /// * `moid`: The [managed object reference ID][docs-about-morefs] of the created
        /// virtual machine.
        /// </summary>
        public InputList<string> GuestIpAddresses
        {
            get => _guestIpAddresses ?? (_guestIpAddresses = new InputList<string>());
            set => _guestIpAddresses = value;
        }

        /// <summary>
        /// An optional [managed object reference
        /// ID][docs-about-morefs] of a host to put this virtual machine on. See the
        /// section on virtual machine migration for
        /// details on changing this value. If a `host_system_id` is not supplied,
        /// vSphere will select a host in the resource pool to place the virtual machine,
        /// according to any defaults or DRS policies in place.
        /// </summary>
        [Input("hostSystemId")]
        public Input<string>? HostSystemId { get; set; }

        /// <summary>
        /// The (non-nested) hardware virtualization setting for
        /// this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
        /// `hvAuto`.
        /// </summary>
        [Input("hvMode")]
        public Input<string>? HvMode { get; set; }

        [Input("ignoredGuestIps")]
        private InputList<string>? _ignoredGuestIps;

        /// <summary>
        /// List of IP addresses to ignore while waiting
        /// for an available IP address using either of the waiters. Any IP addresses in
        /// this list will be ignored if they show up so that the waiter will continue to
        /// wait for a real IP address. Default: [].
        /// </summary>
        public InputList<string> IgnoredGuestIps
        {
            get => _ignoredGuestIps ?? (_ignoredGuestIps = new InputList<string>());
            set => _ignoredGuestIps = value;
        }

        /// <summary>
        /// This is flagged if the virtual machine has been imported, or the
        /// state has been migrated from a previous version of the resource. It
        /// influences the behavior of the first post-import apply operation. See the
        /// section on importing below.
        /// </summary>
        [Input("imported")]
        public Input<bool>? Imported { get; set; }

        /// <summary>
        /// Controls the scheduling delay of the
        /// virtual machine. Use a higher sensitivity for applications that require lower
        /// latency, such as VOIP, media player applications, or applications that
        /// require frequent access to mouse or keyboard devices. Can be one of `low`,
        /// `normal`, `medium`, or `high`.
        /// </summary>
        [Input("latencySensitivity")]
        public Input<string>? LatencySensitivity { get; set; }

        /// <summary>
        /// The size of the virtual machine's memory, in MB.
        /// Default: `1024` (1 GB).
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        /// <summary>
        /// Allow memory to be added to this
        /// virtual machine while it is running.
        /// </summary>
        [Input("memoryHotAddEnabled")]
        public Input<bool>? MemoryHotAddEnabled { get; set; }

        /// <summary>
        /// The maximum amount of memory (in MB) that this
        /// virtual machine can consume, regardless of available resources. The default
        /// is no limit.
        /// </summary>
        [Input("memoryLimit")]
        public Input<int>? MemoryLimit { get; set; }

        /// <summary>
        /// The amount of memory (in MB) that this
        /// virtual machine is guaranteed. The default is no reservation.
        /// </summary>
        [Input("memoryReservation")]
        public Input<int>? MemoryReservation { get; set; }

        /// <summary>
        /// The number of memory shares allocated to
        /// the virtual machine when the `memory_share_level` is `custom`.
        /// </summary>
        [Input("memoryShareCount")]
        public Input<int>? MemoryShareCount { get; set; }

        /// <summary>
        /// The allocation level for memory resources.
        /// Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
        /// </summary>
        [Input("memoryShareLevel")]
        public Input<string>? MemoryShareLevel { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait
        /// for a virtual machine migration to complete before failing. Default: 10
        /// minutes. Also see the section on virtual machine
        /// migration.
        /// </summary>
        [Input("migrateWaitTimeout")]
        public Input<int>? MigrateWaitTimeout { get; set; }

        /// <summary>
        /// The machine object ID from VMWare
        /// </summary>
        [Input("moid")]
        public Input<string>? Moid { get; set; }

        /// <summary>
        /// An alias for both `label` and `path`, the latter when
        /// using `attach`. Required if not using `label`.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Enable nested hardware virtualization on
        /// this virtual machine, facilitating nested virtualization in the guest.
        /// Default: `false`.
        /// </summary>
        [Input("nestedHvEnabled")]
        public Input<bool>? NestedHvEnabled { get; set; }

        [Input("networkInterfaces")]
        private InputList<Inputs.VirtualMachineNetworkInterfacesGetArgs>? _networkInterfaces;

        /// <summary>
        /// A specification for a virtual NIC on this
        /// virtual machine. See network interface options
        /// below.
        /// </summary>
        public InputList<Inputs.VirtualMachineNetworkInterfacesGetArgs> NetworkInterfaces
        {
            get => _networkInterfaces ?? (_networkInterfaces = new InputList<Inputs.VirtualMachineNetworkInterfacesGetArgs>());
            set => _networkInterfaces = value;
        }

        /// <summary>
        /// The number of cores per socket in this
        /// virtual machine. The number of vCPUs on the virtual machine will be
        /// `num_cpus` divided by `num_cores_per_socket`. If specified, the value
        /// supplied to `num_cpus` must be evenly divisible by this value. Default: `1`.
        /// </summary>
        [Input("numCoresPerSocket")]
        public Input<int>? NumCoresPerSocket { get; set; }

        /// <summary>
        /// The total number of virtual processor cores to assign
        /// to this virtual machine. Default: `1`.
        /// </summary>
        [Input("numCpus")]
        public Input<int>? NumCpus { get; set; }

        /// <summary>
        /// Value internal to Terraform used to determine if a configuration set change requires a reboot.
        /// </summary>
        [Input("rebootRequired")]
        public Input<bool>? RebootRequired { get; set; }

        /// <summary>
        /// The [managed object reference
        /// ID][docs-about-morefs] of the resource pool to put this virtual machine in.
        /// See the section on virtual machine migration
        /// for details on changing this value.
        /// </summary>
        [Input("resourcePoolId")]
        public Input<string>? ResourcePoolId { get; set; }

        /// <summary>
        /// Enable the execution of
        /// post-power-on scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Input("runToolsScriptsAfterPowerOn")]
        public Input<bool>? RunToolsScriptsAfterPowerOn { get; set; }

        /// <summary>
        /// Enable the execution of
        /// post-resume scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Input("runToolsScriptsAfterResume")]
        public Input<bool>? RunToolsScriptsAfterResume { get; set; }

        /// <summary>
        /// Enable the execution of
        /// pre-reboot scripts when VMware tools is installed. Default: `false`.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestReboot")]
        public Input<bool>? RunToolsScriptsBeforeGuestReboot { get; set; }

        /// <summary>
        /// Enable the execution
        /// of pre-shutdown scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestShutdown")]
        public Input<bool>? RunToolsScriptsBeforeGuestShutdown { get; set; }

        /// <summary>
        /// Enable the execution of
        /// pre-standby scripts when VMware tools is installed. Default: `true`.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestStandby")]
        public Input<bool>? RunToolsScriptsBeforeGuestStandby { get; set; }

        /// <summary>
        /// Mode for sharing the SCSI bus. The modes are
        /// physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
        /// </summary>
        [Input("scsiBusSharing")]
        public Input<string>? ScsiBusSharing { get; set; }

        /// <summary>
        /// The number of SCSI controllers that Terraform manages on this virtual machine. This directly affects the
        /// amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this
        /// value does not remove controllers.
        /// </summary>
        [Input("scsiControllerCount")]
        public Input<int>? ScsiControllerCount { get; set; }

        /// <summary>
        /// The type of SCSI bus this virtual machine will have.
        /// Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
        /// pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
        /// </summary>
        [Input("scsiType")]
        public Input<string>? ScsiType { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait
        /// for a graceful guest shutdown when making necessary updates to the virtual
        /// machine. If `force_power_off` is set to true, the VM will be force powered-off
        /// after this timeout, otherwise an error is returned. Default: 3 minutes.
        /// </summary>
        [Input("shutdownWaitTimeout")]
        public Input<int>? ShutdownWaitTimeout { get; set; }

        /// <summary>
        /// The swap file placement policy for this
        /// virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
        /// Default: `inherit`.
        /// </summary>
        [Input("swapPlacementPolicy")]
        public Input<string>? SwapPlacementPolicy { get; set; }

        /// <summary>
        /// Enable guest clock synchronization with
        /// the host. Requires VMware tools to be installed. Default: `false`.
        /// </summary>
        [Input("syncTimeWithHost")]
        public Input<bool>? SyncTimeWithHost { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource. See
        /// [here][docs-applying-tags] for a reference on how to apply tags.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The UUID of the virtual disk's VMDK file. This is used to track the
        /// virtual disk on the virtual machine.
        /// </summary>
        [Input("uuid")]
        public Input<string>? Uuid { get; set; }

        /// <summary>
        /// Optional vApp configuration. The only sub-key available
        /// is `properties`, which is a key/value map of properties for virtual machines
        /// imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
        /// configuration for
        /// more details.
        /// </summary>
        [Input("vapp")]
        public Input<Inputs.VirtualMachineVappGetArgs>? Vapp { get; set; }

        [Input("vappTransports")]
        private InputList<string>? _vappTransports;

        /// <summary>
        /// Computed value which is only valid for cloned virtual
        /// machines. A list of vApp transport methods supported by the source virtual
        /// machine or template.
        /// </summary>
        public InputList<string> VappTransports
        {
            get => _vappTransports ?? (_vappTransports = new InputList<string>());
            set => _vappTransports = value;
        }

        /// <summary>
        /// The state of VMware tools in the guest. This will
        /// determine the proper course of action for some device operations.
        /// </summary>
        [Input("vmwareToolsStatus")]
        public Input<string>? VmwareToolsStatus { get; set; }

        /// <summary>
        /// The path of the virtual machine's configuration file in the VM's
        /// datastore.
        /// </summary>
        [Input("vmxPath")]
        public Input<string>? VmxPath { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to
        /// wait for an available guest IP address on this virtual machine. This should
        /// only be used if your version of VMware Tools does not allow the
        /// `wait_for_guest_net_timeout` waiter to be
        /// used. A value less than 1 disables the waiter. Default: 0.
        /// </summary>
        [Input("waitForGuestIpTimeout")]
        public Input<int>? WaitForGuestIpTimeout { get; set; }

        /// <summary>
        /// Controls whether or not the guest
        /// network waiter waits for a routable address. When `false`, the waiter does
        /// not wait for a default gateway, nor are IP addresses checked against any
        /// discovered default gateways as part of its success criteria. This property is
        /// ignored if the `wait_for_guest_ip_timeout`
        /// waiter is used. Default: `true`.
        /// </summary>
        [Input("waitForGuestNetRoutable")]
        public Input<bool>? WaitForGuestNetRoutable { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to
        /// wait for an available IP address on this virtual machine's NICs. Older
        /// versions of VMware Tools do not populate this property. In those cases, this
        /// waiter can be disabled and the
        /// `wait_for_guest_ip_timeout` waiter can be used
        /// instead. A value less than 1 disables the waiter. Default: 5 minutes.
        /// </summary>
        [Input("waitForGuestNetTimeout")]
        public Input<int>? WaitForGuestNetTimeout { get; set; }

        public VirtualMachineState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class VirtualMachineCdromArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Indicates whether the device should be backed by
        /// remote client device. Conflicts with `datastore_id` and `path`.
        /// </summary>
        [Input("clientDevice")]
        public Input<bool>? ClientDevice { get; set; }

        /// <summary>
        /// The datastore ID that the ISO is located in.
        /// Requried for using a datastore ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("datastoreId")]
        public Input<string>? DatastoreId { get; set; }

        [Input("deviceAddress")]
        public Input<string>? DeviceAddress { get; set; }

        /// <summary>
        /// The ID of the device within the virtual machine.
        /// </summary>
        [Input("key")]
        public Input<int>? Key { get; set; }

        /// <summary>
        /// The path to the ISO file. Required for using a datastore
        /// ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        public VirtualMachineCdromArgs()
        {
        }
    }

    public sealed class VirtualMachineCdromGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Indicates whether the device should be backed by
        /// remote client device. Conflicts with `datastore_id` and `path`.
        /// </summary>
        [Input("clientDevice")]
        public Input<bool>? ClientDevice { get; set; }

        /// <summary>
        /// The datastore ID that the ISO is located in.
        /// Requried for using a datastore ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("datastoreId")]
        public Input<string>? DatastoreId { get; set; }

        [Input("deviceAddress")]
        public Input<string>? DeviceAddress { get; set; }

        /// <summary>
        /// The ID of the device within the virtual machine.
        /// </summary>
        [Input("key")]
        public Input<int>? Key { get; set; }

        /// <summary>
        /// The path to the ISO file. Required for using a datastore
        /// ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        public VirtualMachineCdromGetArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneArgs : Pulumi.ResourceArgs
    {
        [Input("customize")]
        public Input<VirtualMachineCloneCustomizeArgs>? Customize { get; set; }

        [Input("linkedClone")]
        public Input<bool>? LinkedClone { get; set; }

        [Input("templateUuid", required: true)]
        public Input<string> TemplateUuid { get; set; } = null!;

        [Input("timeout")]
        public Input<int>? Timeout { get; set; }

        public VirtualMachineCloneArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneCustomizeArgs : Pulumi.ResourceArgs
    {
        [Input("dnsServerLists")]
        private InputList<string>? _dnsServerLists;
        public InputList<string> DnsServerLists
        {
            get => _dnsServerLists ?? (_dnsServerLists = new InputList<string>());
            set => _dnsServerLists = value;
        }

        [Input("dnsSuffixLists")]
        private InputList<string>? _dnsSuffixLists;
        public InputList<string> DnsSuffixLists
        {
            get => _dnsSuffixLists ?? (_dnsSuffixLists = new InputList<string>());
            set => _dnsSuffixLists = value;
        }

        [Input("ipv4Gateway")]
        public Input<string>? Ipv4Gateway { get; set; }

        [Input("ipv6Gateway")]
        public Input<string>? Ipv6Gateway { get; set; }

        [Input("linuxOptions")]
        public Input<VirtualMachineCloneCustomizeLinuxOptionsArgs>? LinuxOptions { get; set; }

        [Input("networkInterfaces")]
        private InputList<VirtualMachineCloneCustomizeNetworkInterfacesArgs>? _networkInterfaces;

        /// <summary>
        /// A specification for a virtual NIC on this
        /// virtual machine. See network interface options
        /// below.
        /// </summary>
        public InputList<VirtualMachineCloneCustomizeNetworkInterfacesArgs> NetworkInterfaces
        {
            get => _networkInterfaces ?? (_networkInterfaces = new InputList<VirtualMachineCloneCustomizeNetworkInterfacesArgs>());
            set => _networkInterfaces = value;
        }

        [Input("timeout")]
        public Input<int>? Timeout { get; set; }

        [Input("windowsOptions")]
        public Input<VirtualMachineCloneCustomizeWindowsOptionsArgs>? WindowsOptions { get; set; }

        [Input("windowsSysprepText")]
        public Input<string>? WindowsSysprepText { get; set; }

        public VirtualMachineCloneCustomizeArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneCustomizeGetArgs : Pulumi.ResourceArgs
    {
        [Input("dnsServerLists")]
        private InputList<string>? _dnsServerLists;
        public InputList<string> DnsServerLists
        {
            get => _dnsServerLists ?? (_dnsServerLists = new InputList<string>());
            set => _dnsServerLists = value;
        }

        [Input("dnsSuffixLists")]
        private InputList<string>? _dnsSuffixLists;
        public InputList<string> DnsSuffixLists
        {
            get => _dnsSuffixLists ?? (_dnsSuffixLists = new InputList<string>());
            set => _dnsSuffixLists = value;
        }

        [Input("ipv4Gateway")]
        public Input<string>? Ipv4Gateway { get; set; }

        [Input("ipv6Gateway")]
        public Input<string>? Ipv6Gateway { get; set; }

        [Input("linuxOptions")]
        public Input<VirtualMachineCloneCustomizeLinuxOptionsGetArgs>? LinuxOptions { get; set; }

        [Input("networkInterfaces")]
        private InputList<VirtualMachineCloneCustomizeNetworkInterfacesGetArgs>? _networkInterfaces;

        /// <summary>
        /// A specification for a virtual NIC on this
        /// virtual machine. See network interface options
        /// below.
        /// </summary>
        public InputList<VirtualMachineCloneCustomizeNetworkInterfacesGetArgs> NetworkInterfaces
        {
            get => _networkInterfaces ?? (_networkInterfaces = new InputList<VirtualMachineCloneCustomizeNetworkInterfacesGetArgs>());
            set => _networkInterfaces = value;
        }

        [Input("timeout")]
        public Input<int>? Timeout { get; set; }

        [Input("windowsOptions")]
        public Input<VirtualMachineCloneCustomizeWindowsOptionsGetArgs>? WindowsOptions { get; set; }

        [Input("windowsSysprepText")]
        public Input<string>? WindowsSysprepText { get; set; }

        public VirtualMachineCloneCustomizeGetArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneCustomizeLinuxOptionsArgs : Pulumi.ResourceArgs
    {
        [Input("domain", required: true)]
        public Input<string> Domain { get; set; } = null!;

        [Input("hostName", required: true)]
        public Input<string> HostName { get; set; } = null!;

        [Input("hwClockUtc")]
        public Input<bool>? HwClockUtc { get; set; }

        [Input("timeZone")]
        public Input<string>? TimeZone { get; set; }

        public VirtualMachineCloneCustomizeLinuxOptionsArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneCustomizeLinuxOptionsGetArgs : Pulumi.ResourceArgs
    {
        [Input("domain", required: true)]
        public Input<string> Domain { get; set; } = null!;

        [Input("hostName", required: true)]
        public Input<string> HostName { get; set; } = null!;

        [Input("hwClockUtc")]
        public Input<bool>? HwClockUtc { get; set; }

        [Input("timeZone")]
        public Input<string>? TimeZone { get; set; }

        public VirtualMachineCloneCustomizeLinuxOptionsGetArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneCustomizeNetworkInterfacesArgs : Pulumi.ResourceArgs
    {
        [Input("dnsDomain")]
        public Input<string>? DnsDomain { get; set; }

        [Input("dnsServerLists")]
        private InputList<string>? _dnsServerLists;
        public InputList<string> DnsServerLists
        {
            get => _dnsServerLists ?? (_dnsServerLists = new InputList<string>());
            set => _dnsServerLists = value;
        }

        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        [Input("ipv4Netmask")]
        public Input<int>? Ipv4Netmask { get; set; }

        [Input("ipv6Address")]
        public Input<string>? Ipv6Address { get; set; }

        [Input("ipv6Netmask")]
        public Input<int>? Ipv6Netmask { get; set; }

        public VirtualMachineCloneCustomizeNetworkInterfacesArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneCustomizeNetworkInterfacesGetArgs : Pulumi.ResourceArgs
    {
        [Input("dnsDomain")]
        public Input<string>? DnsDomain { get; set; }

        [Input("dnsServerLists")]
        private InputList<string>? _dnsServerLists;
        public InputList<string> DnsServerLists
        {
            get => _dnsServerLists ?? (_dnsServerLists = new InputList<string>());
            set => _dnsServerLists = value;
        }

        [Input("ipv4Address")]
        public Input<string>? Ipv4Address { get; set; }

        [Input("ipv4Netmask")]
        public Input<int>? Ipv4Netmask { get; set; }

        [Input("ipv6Address")]
        public Input<string>? Ipv6Address { get; set; }

        [Input("ipv6Netmask")]
        public Input<int>? Ipv6Netmask { get; set; }

        public VirtualMachineCloneCustomizeNetworkInterfacesGetArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneCustomizeWindowsOptionsArgs : Pulumi.ResourceArgs
    {
        [Input("adminPassword")]
        public Input<string>? AdminPassword { get; set; }

        [Input("autoLogon")]
        public Input<bool>? AutoLogon { get; set; }

        [Input("autoLogonCount")]
        public Input<int>? AutoLogonCount { get; set; }

        [Input("computerName", required: true)]
        public Input<string> ComputerName { get; set; } = null!;

        [Input("domainAdminPassword")]
        public Input<string>? DomainAdminPassword { get; set; }

        [Input("domainAdminUser")]
        public Input<string>? DomainAdminUser { get; set; }

        [Input("fullName")]
        public Input<string>? FullName { get; set; }

        [Input("joinDomain")]
        public Input<string>? JoinDomain { get; set; }

        [Input("organizationName")]
        public Input<string>? OrganizationName { get; set; }

        [Input("productKey")]
        public Input<string>? ProductKey { get; set; }

        [Input("runOnceCommandLists")]
        private InputList<string>? _runOnceCommandLists;
        public InputList<string> RunOnceCommandLists
        {
            get => _runOnceCommandLists ?? (_runOnceCommandLists = new InputList<string>());
            set => _runOnceCommandLists = value;
        }

        [Input("timeZone")]
        public Input<int>? TimeZone { get; set; }

        [Input("workgroup")]
        public Input<string>? Workgroup { get; set; }

        public VirtualMachineCloneCustomizeWindowsOptionsArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneCustomizeWindowsOptionsGetArgs : Pulumi.ResourceArgs
    {
        [Input("adminPassword")]
        public Input<string>? AdminPassword { get; set; }

        [Input("autoLogon")]
        public Input<bool>? AutoLogon { get; set; }

        [Input("autoLogonCount")]
        public Input<int>? AutoLogonCount { get; set; }

        [Input("computerName", required: true)]
        public Input<string> ComputerName { get; set; } = null!;

        [Input("domainAdminPassword")]
        public Input<string>? DomainAdminPassword { get; set; }

        [Input("domainAdminUser")]
        public Input<string>? DomainAdminUser { get; set; }

        [Input("fullName")]
        public Input<string>? FullName { get; set; }

        [Input("joinDomain")]
        public Input<string>? JoinDomain { get; set; }

        [Input("organizationName")]
        public Input<string>? OrganizationName { get; set; }

        [Input("productKey")]
        public Input<string>? ProductKey { get; set; }

        [Input("runOnceCommandLists")]
        private InputList<string>? _runOnceCommandLists;
        public InputList<string> RunOnceCommandLists
        {
            get => _runOnceCommandLists ?? (_runOnceCommandLists = new InputList<string>());
            set => _runOnceCommandLists = value;
        }

        [Input("timeZone")]
        public Input<int>? TimeZone { get; set; }

        [Input("workgroup")]
        public Input<string>? Workgroup { get; set; }

        public VirtualMachineCloneCustomizeWindowsOptionsGetArgs()
        {
        }
    }

    public sealed class VirtualMachineCloneGetArgs : Pulumi.ResourceArgs
    {
        [Input("customize")]
        public Input<VirtualMachineCloneCustomizeGetArgs>? Customize { get; set; }

        [Input("linkedClone")]
        public Input<bool>? LinkedClone { get; set; }

        [Input("templateUuid", required: true)]
        public Input<string> TemplateUuid { get; set; } = null!;

        [Input("timeout")]
        public Input<int>? Timeout { get; set; }

        public VirtualMachineCloneGetArgs()
        {
        }
    }

    public sealed class VirtualMachineDisksArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Attach an external disk instead of creating a new one.
        /// Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`,
        /// `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
        /// </summary>
        [Input("attach")]
        public Input<bool>? Attach { get; set; }

        /// <summary>
        /// The datastore ID that the ISO is located in.
        /// Requried for using a datastore ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("datastoreId")]
        public Input<string>? DatastoreId { get; set; }

        [Input("deviceAddress")]
        public Input<string>? DeviceAddress { get; set; }

        /// <summary>
        /// The mode of this this virtual disk for purposes of
        /// writes and snapshotting. Can be one of `append`, `independent_nonpersistent`,
        /// `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`.
        /// Default: `persistent`. For an explanation of options, click
        /// [here][vmware-docs-disk-mode].
        /// </summary>
        [Input("diskMode")]
        public Input<string>? DiskMode { get; set; }

        /// <summary>
        /// The sharing mode of this virtual disk. Can be one
        /// of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
        /// </summary>
        [Input("diskSharing")]
        public Input<string>? DiskSharing { get; set; }

        /// <summary>
        /// If set to `true`, the disk space is zeroed out
        /// on VM creation. This will delay the creation of the disk or virtual machine.
        /// Cannot be set to `true` when `thin_provisioned` is `true`.  See the section
        /// on picking a disk type.  Default: `false`.
        /// </summary>
        [Input("eagerlyScrub")]
        public Input<bool>? EagerlyScrub { get; set; }

        /// <summary>
        /// The upper limit of IOPS that this disk can use. The
        /// default is no limit.
        /// </summary>
        [Input("ioLimit")]
        public Input<int>? IoLimit { get; set; }

        /// <summary>
        /// The I/O reservation (guarantee) that this disk
        /// has, in IOPS.  The default is no reservation.
        /// </summary>
        [Input("ioReservation")]
        public Input<int>? IoReservation { get; set; }

        /// <summary>
        /// The share count for this disk when the share
        /// level is `custom`.
        /// </summary>
        [Input("ioShareCount")]
        public Input<int>? IoShareCount { get; set; }

        /// <summary>
        /// The share allocation level for this disk. Can
        /// be one of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        /// </summary>
        [Input("ioShareLevel")]
        public Input<string>? IoShareLevel { get; set; }

        /// <summary>
        /// Keep this disk when removing the device or
        /// destroying the virtual machine. Default: `false`.
        /// </summary>
        [Input("keepOnRemove")]
        public Input<bool>? KeepOnRemove { get; set; }

        /// <summary>
        /// The ID of the device within the virtual machine.
        /// </summary>
        [Input("key")]
        public Input<int>? Key { get; set; }

        /// <summary>
        /// A label for the disk. Forces a new disk if changed.
        /// </summary>
        [Input("label")]
        public Input<string>? Label { get; set; }

        /// <summary>
        /// An alias for both `label` and `path`, the latter when
        /// using `attach`. Required if not using `label`.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The path to the ISO file. Required for using a datastore
        /// ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// The size of the disk, in GB.
        /// </summary>
        [Input("size")]
        public Input<int>? Size { get; set; }

        /// <summary>
        /// If `true`, this disk is thin provisioned,
        /// with space for the file being allocated on an as-needed basis. Cannot be set
        /// to `true` when `eagerly_scrub` is `true`. See the section on picking a disk
        /// type. Default: `true`.
        /// </summary>
        [Input("thinProvisioned")]
        public Input<bool>? ThinProvisioned { get; set; }

        /// <summary>
        /// The disk number on the SCSI bus. The maximum value
        /// for this setting is the value of
        /// `scsi_controller_count` times 15, minus 1 (so `14`,
        /// `29`, `44`, and `59`, for 1-4 controllers respectively). The default is `0`,
        /// for which one disk must be set to. Duplicate unit numbers are not allowed.
        /// </summary>
        [Input("unitNumber")]
        public Input<int>? UnitNumber { get; set; }

        /// <summary>
        /// The UUID of the virtual disk's VMDK file. This is used to track the
        /// virtual disk on the virtual machine.
        /// </summary>
        [Input("uuid")]
        public Input<string>? Uuid { get; set; }

        /// <summary>
        /// If `true`, writes for this disk are sent
        /// directly to the filesystem immediately instead of being buffered. Default:
        /// `false`.
        /// </summary>
        [Input("writeThrough")]
        public Input<bool>? WriteThrough { get; set; }

        public VirtualMachineDisksArgs()
        {
        }
    }

    public sealed class VirtualMachineDisksGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Attach an external disk instead of creating a new one.
        /// Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`,
        /// `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
        /// </summary>
        [Input("attach")]
        public Input<bool>? Attach { get; set; }

        /// <summary>
        /// The datastore ID that the ISO is located in.
        /// Requried for using a datastore ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("datastoreId")]
        public Input<string>? DatastoreId { get; set; }

        [Input("deviceAddress")]
        public Input<string>? DeviceAddress { get; set; }

        /// <summary>
        /// The mode of this this virtual disk for purposes of
        /// writes and snapshotting. Can be one of `append`, `independent_nonpersistent`,
        /// `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`.
        /// Default: `persistent`. For an explanation of options, click
        /// [here][vmware-docs-disk-mode].
        /// </summary>
        [Input("diskMode")]
        public Input<string>? DiskMode { get; set; }

        /// <summary>
        /// The sharing mode of this virtual disk. Can be one
        /// of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
        /// </summary>
        [Input("diskSharing")]
        public Input<string>? DiskSharing { get; set; }

        /// <summary>
        /// If set to `true`, the disk space is zeroed out
        /// on VM creation. This will delay the creation of the disk or virtual machine.
        /// Cannot be set to `true` when `thin_provisioned` is `true`.  See the section
        /// on picking a disk type.  Default: `false`.
        /// </summary>
        [Input("eagerlyScrub")]
        public Input<bool>? EagerlyScrub { get; set; }

        /// <summary>
        /// The upper limit of IOPS that this disk can use. The
        /// default is no limit.
        /// </summary>
        [Input("ioLimit")]
        public Input<int>? IoLimit { get; set; }

        /// <summary>
        /// The I/O reservation (guarantee) that this disk
        /// has, in IOPS.  The default is no reservation.
        /// </summary>
        [Input("ioReservation")]
        public Input<int>? IoReservation { get; set; }

        /// <summary>
        /// The share count for this disk when the share
        /// level is `custom`.
        /// </summary>
        [Input("ioShareCount")]
        public Input<int>? IoShareCount { get; set; }

        /// <summary>
        /// The share allocation level for this disk. Can
        /// be one of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        /// </summary>
        [Input("ioShareLevel")]
        public Input<string>? IoShareLevel { get; set; }

        /// <summary>
        /// Keep this disk when removing the device or
        /// destroying the virtual machine. Default: `false`.
        /// </summary>
        [Input("keepOnRemove")]
        public Input<bool>? KeepOnRemove { get; set; }

        /// <summary>
        /// The ID of the device within the virtual machine.
        /// </summary>
        [Input("key")]
        public Input<int>? Key { get; set; }

        /// <summary>
        /// A label for the disk. Forces a new disk if changed.
        /// </summary>
        [Input("label")]
        public Input<string>? Label { get; set; }

        /// <summary>
        /// An alias for both `label` and `path`, the latter when
        /// using `attach`. Required if not using `label`.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The path to the ISO file. Required for using a datastore
        /// ISO. Conflicts with `client_device`.
        /// </summary>
        [Input("path")]
        public Input<string>? Path { get; set; }

        /// <summary>
        /// The size of the disk, in GB.
        /// </summary>
        [Input("size")]
        public Input<int>? Size { get; set; }

        /// <summary>
        /// If `true`, this disk is thin provisioned,
        /// with space for the file being allocated on an as-needed basis. Cannot be set
        /// to `true` when `eagerly_scrub` is `true`. See the section on picking a disk
        /// type. Default: `true`.
        /// </summary>
        [Input("thinProvisioned")]
        public Input<bool>? ThinProvisioned { get; set; }

        /// <summary>
        /// The disk number on the SCSI bus. The maximum value
        /// for this setting is the value of
        /// `scsi_controller_count` times 15, minus 1 (so `14`,
        /// `29`, `44`, and `59`, for 1-4 controllers respectively). The default is `0`,
        /// for which one disk must be set to. Duplicate unit numbers are not allowed.
        /// </summary>
        [Input("unitNumber")]
        public Input<int>? UnitNumber { get; set; }

        /// <summary>
        /// The UUID of the virtual disk's VMDK file. This is used to track the
        /// virtual disk on the virtual machine.
        /// </summary>
        [Input("uuid")]
        public Input<string>? Uuid { get; set; }

        /// <summary>
        /// If `true`, writes for this disk are sent
        /// directly to the filesystem immediately instead of being buffered. Default:
        /// `false`.
        /// </summary>
        [Input("writeThrough")]
        public Input<bool>? WriteThrough { get; set; }

        public VirtualMachineDisksGetArgs()
        {
        }
    }

    public sealed class VirtualMachineNetworkInterfacesArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The network interface type. Can be one of
        /// `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.
        /// </summary>
        [Input("adapterType")]
        public Input<string>? AdapterType { get; set; }

        /// <summary>
        /// The upper bandwidth limit of this network
        /// interface, in Mbits/sec. The default is no limit.
        /// </summary>
        [Input("bandwidthLimit")]
        public Input<int>? BandwidthLimit { get; set; }

        /// <summary>
        /// The bandwidth reservation of this
        /// network interface, in Mbits/sec. The default is no reservation.
        /// </summary>
        [Input("bandwidthReservation")]
        public Input<int>? BandwidthReservation { get; set; }

        /// <summary>
        /// The share count for this network
        /// interface when the share level is `custom`.
        /// </summary>
        [Input("bandwidthShareCount")]
        public Input<int>? BandwidthShareCount { get; set; }

        /// <summary>
        /// The bandwidth share allocation level for
        /// this interface. Can be one of `low`, `normal`, `high`, or `custom`. Default:
        /// `normal`.
        /// </summary>
        [Input("bandwidthShareLevel")]
        public Input<string>? BandwidthShareLevel { get; set; }

        [Input("deviceAddress")]
        public Input<string>? DeviceAddress { get; set; }

        /// <summary>
        /// The ID of the device within the virtual machine.
        /// </summary>
        [Input("key")]
        public Input<int>? Key { get; set; }

        /// <summary>
        /// The MAC address of this network interface. Can
        /// only be manually set if `use_static_mac` is true, otherwise this is a
        /// computed value that gives the current MAC address of this interface.
        /// </summary>
        [Input("macAddress")]
        public Input<string>? MacAddress { get; set; }

        /// <summary>
        /// The [managed object reference
        /// ID][docs-about-morefs] of the network to connect this interface to.
        /// </summary>
        [Input("networkId", required: true)]
        public Input<string> NetworkId { get; set; } = null!;

        /// <summary>
        /// If true, the `mac_address` field is treated as
        /// a static MAC address and set accordingly. Setting this to `true` requires
        /// `mac_address` to be set. Default: `false`.
        /// </summary>
        [Input("useStaticMac")]
        public Input<bool>? UseStaticMac { get; set; }

        public VirtualMachineNetworkInterfacesArgs()
        {
        }
    }

    public sealed class VirtualMachineNetworkInterfacesGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The network interface type. Can be one of
        /// `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.
        /// </summary>
        [Input("adapterType")]
        public Input<string>? AdapterType { get; set; }

        /// <summary>
        /// The upper bandwidth limit of this network
        /// interface, in Mbits/sec. The default is no limit.
        /// </summary>
        [Input("bandwidthLimit")]
        public Input<int>? BandwidthLimit { get; set; }

        /// <summary>
        /// The bandwidth reservation of this
        /// network interface, in Mbits/sec. The default is no reservation.
        /// </summary>
        [Input("bandwidthReservation")]
        public Input<int>? BandwidthReservation { get; set; }

        /// <summary>
        /// The share count for this network
        /// interface when the share level is `custom`.
        /// </summary>
        [Input("bandwidthShareCount")]
        public Input<int>? BandwidthShareCount { get; set; }

        /// <summary>
        /// The bandwidth share allocation level for
        /// this interface. Can be one of `low`, `normal`, `high`, or `custom`. Default:
        /// `normal`.
        /// </summary>
        [Input("bandwidthShareLevel")]
        public Input<string>? BandwidthShareLevel { get; set; }

        [Input("deviceAddress")]
        public Input<string>? DeviceAddress { get; set; }

        /// <summary>
        /// The ID of the device within the virtual machine.
        /// </summary>
        [Input("key")]
        public Input<int>? Key { get; set; }

        /// <summary>
        /// The MAC address of this network interface. Can
        /// only be manually set if `use_static_mac` is true, otherwise this is a
        /// computed value that gives the current MAC address of this interface.
        /// </summary>
        [Input("macAddress")]
        public Input<string>? MacAddress { get; set; }

        /// <summary>
        /// The [managed object reference
        /// ID][docs-about-morefs] of the network to connect this interface to.
        /// </summary>
        [Input("networkId", required: true)]
        public Input<string> NetworkId { get; set; } = null!;

        /// <summary>
        /// If true, the `mac_address` field is treated as
        /// a static MAC address and set accordingly. Setting this to `true` requires
        /// `mac_address` to be set. Default: `false`.
        /// </summary>
        [Input("useStaticMac")]
        public Input<bool>? UseStaticMac { get; set; }

        public VirtualMachineNetworkInterfacesGetArgs()
        {
        }
    }

    public sealed class VirtualMachineVappArgs : Pulumi.ResourceArgs
    {
        [Input("properties")]
        private InputMap<string>? _properties;
        public InputMap<string> Properties
        {
            get => _properties ?? (_properties = new InputMap<string>());
            set => _properties = value;
        }

        public VirtualMachineVappArgs()
        {
        }
    }

    public sealed class VirtualMachineVappGetArgs : Pulumi.ResourceArgs
    {
        [Input("properties")]
        private InputMap<string>? _properties;
        public InputMap<string> Properties
        {
            get => _properties ?? (_properties = new InputMap<string>());
            set => _properties = value;
        }

        public VirtualMachineVappGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class VirtualMachineCdrom
    {
        /// <summary>
        /// Indicates whether the device should be backed by
        /// remote client device. Conflicts with `datastore_id` and `path`.
        /// </summary>
        public readonly bool? ClientDevice;
        /// <summary>
        /// The datastore ID that the ISO is located in.
        /// Requried for using a datastore ISO. Conflicts with `client_device`.
        /// </summary>
        public readonly string? DatastoreId;
        public readonly string DeviceAddress;
        /// <summary>
        /// The ID of the device within the virtual machine.
        /// </summary>
        public readonly int Key;
        /// <summary>
        /// The path to the ISO file. Required for using a datastore
        /// ISO. Conflicts with `client_device`.
        /// </summary>
        public readonly string? Path;

        [OutputConstructor]
        private VirtualMachineCdrom(
            bool? clientDevice,
            string? datastoreId,
            string deviceAddress,
            int key,
            string? path)
        {
            ClientDevice = clientDevice;
            DatastoreId = datastoreId;
            DeviceAddress = deviceAddress;
            Key = key;
            Path = path;
        }
    }

    [OutputType]
    public sealed class VirtualMachineClone
    {
        public readonly VirtualMachineCloneCustomize? Customize;
        public readonly bool? LinkedClone;
        public readonly string TemplateUuid;
        public readonly int? Timeout;

        [OutputConstructor]
        private VirtualMachineClone(
            VirtualMachineCloneCustomize? customize,
            bool? linkedClone,
            string templateUuid,
            int? timeout)
        {
            Customize = customize;
            LinkedClone = linkedClone;
            TemplateUuid = templateUuid;
            Timeout = timeout;
        }
    }

    [OutputType]
    public sealed class VirtualMachineCloneCustomize
    {
        public readonly ImmutableArray<string> DnsServerLists;
        public readonly ImmutableArray<string> DnsSuffixLists;
        public readonly string? Ipv4Gateway;
        public readonly string? Ipv6Gateway;
        public readonly VirtualMachineCloneCustomizeLinuxOptions? LinuxOptions;
        /// <summary>
        /// A specification for a virtual NIC on this
        /// virtual machine. See network interface options
        /// below.
        /// </summary>
        public readonly ImmutableArray<VirtualMachineCloneCustomizeNetworkInterfaces> NetworkInterfaces;
        public readonly int? Timeout;
        public readonly VirtualMachineCloneCustomizeWindowsOptions? WindowsOptions;
        public readonly string? WindowsSysprepText;

        [OutputConstructor]
        private VirtualMachineCloneCustomize(
            ImmutableArray<string> dnsServerLists,
            ImmutableArray<string> dnsSuffixLists,
            string? ipv4Gateway,
            string? ipv6Gateway,
            VirtualMachineCloneCustomizeLinuxOptions? linuxOptions,
            ImmutableArray<VirtualMachineCloneCustomizeNetworkInterfaces> networkInterfaces,
            int? timeout,
            VirtualMachineCloneCustomizeWindowsOptions? windowsOptions,
            string? windowsSysprepText)
        {
            DnsServerLists = dnsServerLists;
            DnsSuffixLists = dnsSuffixLists;
            Ipv4Gateway = ipv4Gateway;
            Ipv6Gateway = ipv6Gateway;
            LinuxOptions = linuxOptions;
            NetworkInterfaces = networkInterfaces;
            Timeout = timeout;
            WindowsOptions = windowsOptions;
            WindowsSysprepText = windowsSysprepText;
        }
    }

    [OutputType]
    public sealed class VirtualMachineCloneCustomizeLinuxOptions
    {
        public readonly string Domain;
        public readonly string HostName;
        public readonly bool? HwClockUtc;
        public readonly string? TimeZone;

        [OutputConstructor]
        private VirtualMachineCloneCustomizeLinuxOptions(
            string domain,
            string hostName,
            bool? hwClockUtc,
            string? timeZone)
        {
            Domain = domain;
            HostName = hostName;
            HwClockUtc = hwClockUtc;
            TimeZone = timeZone;
        }
    }

    [OutputType]
    public sealed class VirtualMachineCloneCustomizeNetworkInterfaces
    {
        public readonly string? DnsDomain;
        public readonly ImmutableArray<string> DnsServerLists;
        public readonly string? Ipv4Address;
        public readonly int? Ipv4Netmask;
        public readonly string? Ipv6Address;
        public readonly int? Ipv6Netmask;

        [OutputConstructor]
        private VirtualMachineCloneCustomizeNetworkInterfaces(
            string? dnsDomain,
            ImmutableArray<string> dnsServerLists,
            string? ipv4Address,
            int? ipv4Netmask,
            string? ipv6Address,
            int? ipv6Netmask)
        {
            DnsDomain = dnsDomain;
            DnsServerLists = dnsServerLists;
            Ipv4Address = ipv4Address;
            Ipv4Netmask = ipv4Netmask;
            Ipv6Address = ipv6Address;
            Ipv6Netmask = ipv6Netmask;
        }
    }

    [OutputType]
    public sealed class VirtualMachineCloneCustomizeWindowsOptions
    {
        public readonly string? AdminPassword;
        public readonly bool? AutoLogon;
        public readonly int? AutoLogonCount;
        public readonly string ComputerName;
        public readonly string? DomainAdminPassword;
        public readonly string? DomainAdminUser;
        public readonly string? FullName;
        public readonly string? JoinDomain;
        public readonly string? OrganizationName;
        public readonly string? ProductKey;
        public readonly ImmutableArray<string> RunOnceCommandLists;
        public readonly int? TimeZone;
        public readonly string? Workgroup;

        [OutputConstructor]
        private VirtualMachineCloneCustomizeWindowsOptions(
            string? adminPassword,
            bool? autoLogon,
            int? autoLogonCount,
            string computerName,
            string? domainAdminPassword,
            string? domainAdminUser,
            string? fullName,
            string? joinDomain,
            string? organizationName,
            string? productKey,
            ImmutableArray<string> runOnceCommandLists,
            int? timeZone,
            string? workgroup)
        {
            AdminPassword = adminPassword;
            AutoLogon = autoLogon;
            AutoLogonCount = autoLogonCount;
            ComputerName = computerName;
            DomainAdminPassword = domainAdminPassword;
            DomainAdminUser = domainAdminUser;
            FullName = fullName;
            JoinDomain = joinDomain;
            OrganizationName = organizationName;
            ProductKey = productKey;
            RunOnceCommandLists = runOnceCommandLists;
            TimeZone = timeZone;
            Workgroup = workgroup;
        }
    }

    [OutputType]
    public sealed class VirtualMachineDisks
    {
        /// <summary>
        /// Attach an external disk instead of creating a new one.
        /// Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`,
        /// `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
        /// </summary>
        public readonly bool? Attach;
        /// <summary>
        /// The datastore ID that the ISO is located in.
        /// Requried for using a datastore ISO. Conflicts with `client_device`.
        /// </summary>
        public readonly string? DatastoreId;
        public readonly string DeviceAddress;
        /// <summary>
        /// The mode of this this virtual disk for purposes of
        /// writes and snapshotting. Can be one of `append`, `independent_nonpersistent`,
        /// `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`.
        /// Default: `persistent`. For an explanation of options, click
        /// [here][vmware-docs-disk-mode].
        /// </summary>
        public readonly string? DiskMode;
        /// <summary>
        /// The sharing mode of this virtual disk. Can be one
        /// of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
        /// </summary>
        public readonly string? DiskSharing;
        /// <summary>
        /// If set to `true`, the disk space is zeroed out
        /// on VM creation. This will delay the creation of the disk or virtual machine.
        /// Cannot be set to `true` when `thin_provisioned` is `true`.  See the section
        /// on picking a disk type.  Default: `false`.
        /// </summary>
        public readonly bool? EagerlyScrub;
        /// <summary>
        /// The upper limit of IOPS that this disk can use. The
        /// default is no limit.
        /// </summary>
        public readonly int? IoLimit;
        /// <summary>
        /// The I/O reservation (guarantee) that this disk
        /// has, in IOPS.  The default is no reservation.
        /// </summary>
        public readonly int? IoReservation;
        /// <summary>
        /// The share count for this disk when the share
        /// level is `custom`.
        /// </summary>
        public readonly int? IoShareCount;
        /// <summary>
        /// The share allocation level for this disk. Can
        /// be one of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        /// </summary>
        public readonly string? IoShareLevel;
        /// <summary>
        /// Keep this disk when removing the device or
        /// destroying the virtual machine. Default: `false`.
        /// </summary>
        public readonly bool? KeepOnRemove;
        /// <summary>
        /// The ID of the device within the virtual machine.
        /// </summary>
        public readonly int Key;
        /// <summary>
        /// A label for the disk. Forces a new disk if changed.
        /// </summary>
        public readonly string? Label;
        /// <summary>
        /// An alias for both `label` and `path`, the latter when
        /// using `attach`. Required if not using `label`.
        /// </summary>
        public readonly string? Name;
        /// <summary>
        /// The path to the ISO file. Required for using a datastore
        /// ISO. Conflicts with `client_device`.
        /// </summary>
        public readonly string Path;
        /// <summary>
        /// The size of the disk, in GB.
        /// </summary>
        public readonly int? Size;
        /// <summary>
        /// If `true`, this disk is thin provisioned,
        /// with space for the file being allocated on an as-needed basis. Cannot be set
        /// to `true` when `eagerly_scrub` is `true`. See the section on picking a disk
        /// type. Default: `true`.
        /// </summary>
        public readonly bool? ThinProvisioned;
        /// <summary>
        /// The disk number on the SCSI bus. The maximum value
        /// for this setting is the value of
        /// `scsi_controller_count` times 15, minus 1 (so `14`,
        /// `29`, `44`, and `59`, for 1-4 controllers respectively). The default is `0`,
        /// for which one disk must be set to. Duplicate unit numbers are not allowed.
        /// </summary>
        public readonly int? UnitNumber;
        /// <summary>
        /// The UUID of the virtual disk's VMDK file. This is used to track the
        /// virtual disk on the virtual machine.
        /// </summary>
        public readonly string Uuid;
        /// <summary>
        /// If `true`, writes for this disk are sent
        /// directly to the filesystem immediately instead of being buffered. Default:
        /// `false`.
        /// </summary>
        public readonly bool? WriteThrough;

        [OutputConstructor]
        private VirtualMachineDisks(
            bool? attach,
            string? datastoreId,
            string deviceAddress,
            string? diskMode,
            string? diskSharing,
            bool? eagerlyScrub,
            int? ioLimit,
            int? ioReservation,
            int? ioShareCount,
            string? ioShareLevel,
            bool? keepOnRemove,
            int key,
            string? label,
            string? name,
            string path,
            int? size,
            bool? thinProvisioned,
            int? unitNumber,
            string uuid,
            bool? writeThrough)
        {
            Attach = attach;
            DatastoreId = datastoreId;
            DeviceAddress = deviceAddress;
            DiskMode = diskMode;
            DiskSharing = diskSharing;
            EagerlyScrub = eagerlyScrub;
            IoLimit = ioLimit;
            IoReservation = ioReservation;
            IoShareCount = ioShareCount;
            IoShareLevel = ioShareLevel;
            KeepOnRemove = keepOnRemove;
            Key = key;
            Label = label;
            Name = name;
            Path = path;
            Size = size;
            ThinProvisioned = thinProvisioned;
            UnitNumber = unitNumber;
            Uuid = uuid;
            WriteThrough = writeThrough;
        }
    }

    [OutputType]
    public sealed class VirtualMachineNetworkInterfaces
    {
        /// <summary>
        /// The network interface type. Can be one of
        /// `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.
        /// </summary>
        public readonly string? AdapterType;
        /// <summary>
        /// The upper bandwidth limit of this network
        /// interface, in Mbits/sec. The default is no limit.
        /// </summary>
        public readonly int? BandwidthLimit;
        /// <summary>
        /// The bandwidth reservation of this
        /// network interface, in Mbits/sec. The default is no reservation.
        /// </summary>
        public readonly int? BandwidthReservation;
        /// <summary>
        /// The share count for this network
        /// interface when the share level is `custom`.
        /// </summary>
        public readonly int BandwidthShareCount;
        /// <summary>
        /// The bandwidth share allocation level for
        /// this interface. Can be one of `low`, `normal`, `high`, or `custom`. Default:
        /// `normal`.
        /// </summary>
        public readonly string? BandwidthShareLevel;
        public readonly string DeviceAddress;
        /// <summary>
        /// The ID of the device within the virtual machine.
        /// </summary>
        public readonly int Key;
        /// <summary>
        /// The MAC address of this network interface. Can
        /// only be manually set if `use_static_mac` is true, otherwise this is a
        /// computed value that gives the current MAC address of this interface.
        /// </summary>
        public readonly string MacAddress;
        /// <summary>
        /// The [managed object reference
        /// ID][docs-about-morefs] of the network to connect this interface to.
        /// </summary>
        public readonly string NetworkId;
        /// <summary>
        /// If true, the `mac_address` field is treated as
        /// a static MAC address and set accordingly. Setting this to `true` requires
        /// `mac_address` to be set. Default: `false`.
        /// </summary>
        public readonly bool? UseStaticMac;

        [OutputConstructor]
        private VirtualMachineNetworkInterfaces(
            string? adapterType,
            int? bandwidthLimit,
            int? bandwidthReservation,
            int bandwidthShareCount,
            string? bandwidthShareLevel,
            string deviceAddress,
            int key,
            string macAddress,
            string networkId,
            bool? useStaticMac)
        {
            AdapterType = adapterType;
            BandwidthLimit = bandwidthLimit;
            BandwidthReservation = bandwidthReservation;
            BandwidthShareCount = bandwidthShareCount;
            BandwidthShareLevel = bandwidthShareLevel;
            DeviceAddress = deviceAddress;
            Key = key;
            MacAddress = macAddress;
            NetworkId = networkId;
            UseStaticMac = useStaticMac;
        }
    }

    [OutputType]
    public sealed class VirtualMachineVapp
    {
        public readonly ImmutableDictionary<string, string>? Properties;

        [OutputConstructor]
        private VirtualMachineVapp(ImmutableDictionary<string, string>? properties)
        {
            Properties = properties;
        }
    }
    }
}
