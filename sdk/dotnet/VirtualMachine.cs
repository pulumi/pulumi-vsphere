// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.VSphere
{
    /// <summary>
    /// ## Import
    /// 
    /// ### Additional Importing Requirements
    /// 
    /// Many of the requirements for [cloning](#additional-requirements-and-notes-for-cloning) apply to importing. Although importing writes directly to the Terraform state, some rules can not be enforced during import time, so every effort should be made to ensure the correctness of the configuration before the import.
    /// 
    /// The following requirements apply to import:
    /// 
    /// * The disks must have a [`label`](#label) argument assigned in a convention matching `Hard Disk`, starting with disk number 0, based on each virtual disk order on the SCSI bus. As an example, a disk on SCSI controller `0` with a unit number of `0` would be labeled as `Hard Disk 0`, a disk on the same controller with a unit number of `1` would be `Hard Disk 1`, but the next disk, which is on SCSI controller `1` with a unit number of `0`, still becomes `Hard Disk 2`.
    /// 
    /// * Disks are always imported with [`keep_on_remove`](#keep_on_remove) enabled until the first `pulumi up` run which will remove the setting for known disks. This process safeguards against naming or accounting mistakes in the disk configuration.
    /// 
    /// * The storage controller count for the resource is set to the number of contiguous storage controllers found, starting with the controller at SCSI bus number `0`. If no storage controllers are discovered, the virtual machine is not eligible for import. For maximum compatibility, ensure that the virtual machine has the exact number of storage controllers needed and set the storage controller count accordingly.
    /// 
    /// After importing, you should run `pulumi preview`. Unless you have changed anything else in the configuration that would cause other attributes to change. The only difference should be configuration-only changes, which are typically comprised of:
    /// 
    /// * The [`imported`](#imported) flag will transition from `true` to `false`.
    /// 
    /// * The [`keep_on_remove`](#keep_on_remove) of known disks will transition from `true` to `false`.
    /// 
    /// * Configuration supplied in the [`clone`](#clone) block, if present, will be persisted to state. This initial persistence operation does not perform any cloning or customization actions, nor does it force a new resource. After the first apply operation, further changes to `clone` will force the creation of a new resource.
    /// 
    /// These changes only update Terraform state when applied. Hence, it is safe to run when the virtual machine is running. If more settings are modified, you may need to plan maintenance accordingly for any necessary virtual machine re-configurations.
    /// </summary>
    [VSphereResourceType("vsphere:index/virtualMachine:VirtualMachine")]
    public partial class VirtualMachine : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The guest name for the operating system when GuestId is otherGuest or otherGuest64.
        /// </summary>
        [Output("alternateGuestName")]
        public Output<string?> AlternateGuestName { get; private set; } = null!;

        /// <summary>
        /// User-provided description of the virtual machine.
        /// </summary>
        [Output("annotation")]
        public Output<string> Annotation { get; private set; } = null!;

        /// <summary>
        /// The number of milliseconds to wait before starting the boot sequence.
        /// </summary>
        [Output("bootDelay")]
        public Output<int?> BootDelay { get; private set; } = null!;

        /// <summary>
        /// The number of milliseconds to wait before retrying the boot sequence. This only valid if BootRetryEnabled is true.
        /// </summary>
        [Output("bootRetryDelay")]
        public Output<int?> BootRetryDelay { get; private set; } = null!;

        /// <summary>
        /// If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
        /// </summary>
        [Output("bootRetryEnabled")]
        public Output<bool?> BootRetryEnabled { get; private set; } = null!;

        /// <summary>
        /// A specification for a CDROM device on this virtual machine.
        /// </summary>
        [Output("cdroms")]
        public Output<ImmutableArray<Outputs.VirtualMachineCdrom>> Cdroms { get; private set; } = null!;

        /// <summary>
        /// A unique identifier for a given version of the last configuration was applied.
        /// </summary>
        [Output("changeVersion")]
        public Output<string> ChangeVersion { get; private set; } = null!;

        /// <summary>
        /// A specification for cloning a virtual machine from template.
        /// </summary>
        [Output("clone")]
        public Output<Outputs.VirtualMachineClone?> Clone { get; private set; } = null!;

        /// <summary>
        /// Allow CPUs to be added to this virtual machine while it is running.
        /// </summary>
        [Output("cpuHotAddEnabled")]
        public Output<bool?> CpuHotAddEnabled { get; private set; } = null!;

        /// <summary>
        /// Allow CPUs to be added to this virtual machine while it is running.
        /// </summary>
        [Output("cpuHotRemoveEnabled")]
        public Output<bool?> CpuHotRemoveEnabled { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
        /// </summary>
        [Output("cpuLimit")]
        public Output<int?> CpuLimit { get; private set; } = null!;

        /// <summary>
        /// Enable CPU performance counters on this virtual machine.
        /// </summary>
        [Output("cpuPerformanceCountersEnabled")]
        public Output<bool?> CpuPerformanceCountersEnabled { get; private set; } = null!;

        /// <summary>
        /// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
        /// </summary>
        [Output("cpuReservation")]
        public Output<int?> CpuReservation { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to cpu for a custom share level.
        /// </summary>
        [Output("cpuShareCount")]
        public Output<int> CpuShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for cpu resources. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("cpuShareLevel")]
        public Output<string?> CpuShareLevel { get; private set; } = null!;

        /// <summary>
        /// A list of custom attributes to set on this resource.
        /// </summary>
        [Output("customAttributes")]
        public Output<ImmutableDictionary<string, string>?> CustomAttributes { get; private set; } = null!;

        /// <summary>
        /// The ID of the datacenter where the VM is to be created.
        /// </summary>
        [Output("datacenterId")]
        public Output<string?> DatacenterId { get; private set; } = null!;

        /// <summary>
        /// The ID of a datastore cluster to put the virtual machine in.
        /// </summary>
        [Output("datastoreClusterId")]
        public Output<string?> DatastoreClusterId { get; private set; } = null!;

        /// <summary>
        /// The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
        /// </summary>
        [Output("datastoreId")]
        public Output<string> DatastoreId { get; private set; } = null!;

        /// <summary>
        /// The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.
        /// </summary>
        [Output("defaultIpAddress")]
        public Output<string> DefaultIpAddress { get; private set; } = null!;

        /// <summary>
        /// A specification for a virtual disk device on this virtual machine.
        /// </summary>
        [Output("disks")]
        public Output<ImmutableArray<Outputs.VirtualMachineDisk>> Disks { get; private set; } = null!;

        /// <summary>
        /// When the boot type set in firmware is efi, this enables EFI secure boot.
        /// </summary>
        [Output("efiSecureBootEnabled")]
        public Output<bool?> EfiSecureBootEnabled { get; private set; } = null!;

        /// <summary>
        /// Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
        /// </summary>
        [Output("enableDiskUuid")]
        public Output<bool?> EnableDiskUuid { get; private set; } = null!;

        /// <summary>
        /// Enable logging on this virtual machine.
        /// </summary>
        [Output("enableLogging")]
        public Output<bool?> EnableLogging { get; private set; } = null!;

        /// <summary>
        /// The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
        /// </summary>
        [Output("eptRviMode")]
        public Output<string> EptRviMode { get; private set; } = null!;

        /// <summary>
        /// Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
        /// </summary>
        [Output("extraConfig")]
        public Output<ImmutableDictionary<string, string>?> ExtraConfig { get; private set; } = null!;

        /// <summary>
        /// Allow the virtual machine to be rebooted when a change to `ExtraConfig` occurs.
        /// </summary>
        [Output("extraConfigRebootRequired")]
        public Output<bool?> ExtraConfigRebootRequired { get; private set; } = null!;

        /// <summary>
        /// The firmware interface to use on the virtual machine. Can be one of bios or efi.
        /// </summary>
        [Output("firmware")]
        public Output<string?> Firmware { get; private set; } = null!;

        /// <summary>
        /// The name of the folder to locate the virtual machine in.
        /// </summary>
        [Output("folder")]
        public Output<string?> Folder { get; private set; } = null!;

        /// <summary>
        /// Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
        /// </summary>
        [Output("forcePowerOff")]
        public Output<bool?> ForcePowerOff { get; private set; } = null!;

        /// <summary>
        /// The guest ID for the operating system.
        /// </summary>
        [Output("guestId")]
        public Output<string> GuestId { get; private set; } = null!;

        /// <summary>
        /// The current list of IP addresses on this machine, including the value of `DefaultIpAddress`. If VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this list will be empty.
        /// </summary>
        [Output("guestIpAddresses")]
        public Output<ImmutableArray<string>> GuestIpAddresses { get; private set; } = null!;

        /// <summary>
        /// The hardware version for the virtual machine. Allows versions within ranges: 4, 7-11, 13-15, 17-22.
        /// </summary>
        [Output("hardwareVersion")]
        public Output<int> HardwareVersion { get; private set; } = null!;

        /// <summary>
        /// The ID of an optional host system to pin the virtual machine to.
        /// </summary>
        [Output("hostSystemId")]
        public Output<string> HostSystemId { get; private set; } = null!;

        /// <summary>
        /// The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
        /// </summary>
        [Output("hvMode")]
        public Output<string> HvMode { get; private set; } = null!;

        [Output("ideControllerCount")]
        public Output<int?> IdeControllerCount { get; private set; } = null!;

        /// <summary>
        /// List of IP addresses and CIDR networks to ignore while waiting for an IP
        /// </summary>
        [Output("ignoredGuestIps")]
        public Output<ImmutableArray<string>> IgnoredGuestIps { get; private set; } = null!;

        /// <summary>
        /// Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.
        /// </summary>
        [Output("imported")]
        public Output<bool> Imported { get; private set; } = null!;

        /// <summary>
        /// Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
        /// </summary>
        [Output("latencySensitivity")]
        public Output<string?> LatencySensitivity { get; private set; } = null!;

        /// <summary>
        /// The size of the virtual machine's memory, in MB.
        /// </summary>
        [Output("memory")]
        public Output<int?> Memory { get; private set; } = null!;

        /// <summary>
        /// Allow memory to be added to this virtual machine while it is running.
        /// </summary>
        [Output("memoryHotAddEnabled")]
        public Output<bool?> MemoryHotAddEnabled { get; private set; } = null!;

        /// <summary>
        /// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
        /// </summary>
        [Output("memoryLimit")]
        public Output<int?> MemoryLimit { get; private set; } = null!;

        /// <summary>
        /// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
        /// </summary>
        [Output("memoryReservation")]
        public Output<int?> MemoryReservation { get; private set; } = null!;

        /// <summary>
        /// If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine's memory size;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature may only be enabled if it is currently possible to reserve all of the virtual machine's memory.
        /// </summary>
        [Output("memoryReservationLockedToMax")]
        public Output<bool?> MemoryReservationLockedToMax { get; private set; } = null!;

        /// <summary>
        /// The amount of shares to allocate to memory for a custom share level.
        /// </summary>
        [Output("memoryShareCount")]
        public Output<int> MemoryShareCount { get; private set; } = null!;

        /// <summary>
        /// The allocation level for memory resources. Can be one of high, low, normal, or custom.
        /// </summary>
        [Output("memoryShareLevel")]
        public Output<string?> MemoryShareLevel { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
        /// </summary>
        [Output("migrateWaitTimeout")]
        public Output<int?> MigrateWaitTimeout { get; private set; } = null!;

        /// <summary>
        /// The managed object reference ID of the created virtual machine.
        /// </summary>
        [Output("moid")]
        public Output<string> Moid { get; private set; } = null!;

        /// <summary>
        /// The name of this virtual machine.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
        /// </summary>
        [Output("nestedHvEnabled")]
        public Output<bool?> NestedHvEnabled { get; private set; } = null!;

        /// <summary>
        /// A specification for a virtual NIC on this virtual machine.
        /// </summary>
        [Output("networkInterfaces")]
        public Output<ImmutableArray<Outputs.VirtualMachineNetworkInterface>> NetworkInterfaces { get; private set; } = null!;

        /// <summary>
        /// The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to NumCpus must be evenly divisible by this value.
        /// </summary>
        [Output("numCoresPerSocket")]
        public Output<int?> NumCoresPerSocket { get; private set; } = null!;

        /// <summary>
        /// The number of virtual processors to assign to this virtual machine.
        /// </summary>
        [Output("numCpus")]
        public Output<int?> NumCpus { get; private set; } = null!;

        [Output("nvmeControllerCount")]
        public Output<int?> NvmeControllerCount { get; private set; } = null!;

        /// <summary>
        /// A specification for deploying a virtual machine from ovf/ova template.
        /// </summary>
        [Output("ovfDeploy")]
        public Output<Outputs.VirtualMachineOvfDeploy?> OvfDeploy { get; private set; } = null!;

        /// <summary>
        /// A list of PCI passthrough devices
        /// </summary>
        [Output("pciDeviceIds")]
        public Output<ImmutableArray<string>> PciDeviceIds { get; private set; } = null!;

        /// <summary>
        /// A computed value for the current power state of the virtual machine. One of `On`, `Off`, or `Suspended`.
        /// </summary>
        [Output("powerState")]
        public Output<string> PowerState { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in seconds, that we will be trying to power on a VM
        /// </summary>
        [Output("poweronTimeout")]
        public Output<int?> PoweronTimeout { get; private set; } = null!;

        [Output("rebootRequired")]
        public Output<bool> RebootRequired { get; private set; } = null!;

        /// <summary>
        /// Triggers replacement of resource whenever it changes.
        /// </summary>
        [Output("replaceTrigger")]
        public Output<string?> ReplaceTrigger { get; private set; } = null!;

        /// <summary>
        /// The ID of a resource pool to put the virtual machine in.
        /// </summary>
        [Output("resourcePoolId")]
        public Output<string> ResourcePoolId { get; private set; } = null!;

        /// <summary>
        /// Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
        /// </summary>
        [Output("runToolsScriptsAfterPowerOn")]
        public Output<bool?> RunToolsScriptsAfterPowerOn { get; private set; } = null!;

        /// <summary>
        /// Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
        /// </summary>
        [Output("runToolsScriptsAfterResume")]
        public Output<bool?> RunToolsScriptsAfterResume { get; private set; } = null!;

        /// <summary>
        /// Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
        /// </summary>
        [Output("runToolsScriptsBeforeGuestReboot")]
        public Output<bool?> RunToolsScriptsBeforeGuestReboot { get; private set; } = null!;

        /// <summary>
        /// Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
        /// </summary>
        [Output("runToolsScriptsBeforeGuestShutdown")]
        public Output<bool?> RunToolsScriptsBeforeGuestShutdown { get; private set; } = null!;

        /// <summary>
        /// Enable the run of scripts before guest operating system standby when VMware Tools is installed.
        /// </summary>
        [Output("runToolsScriptsBeforeGuestStandby")]
        public Output<bool?> RunToolsScriptsBeforeGuestStandby { get; private set; } = null!;

        [Output("sataControllerCount")]
        public Output<int?> SataControllerCount { get; private set; } = null!;

        /// <summary>
        /// Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
        /// </summary>
        [Output("scsiBusSharing")]
        public Output<string?> ScsiBusSharing { get; private set; } = null!;

        [Output("scsiControllerCount")]
        public Output<int?> ScsiControllerCount { get; private set; } = null!;

        /// <summary>
        /// The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
        /// </summary>
        [Output("scsiType")]
        public Output<string?> ScsiType { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
        /// </summary>
        [Output("shutdownWaitTimeout")]
        public Output<int?> ShutdownWaitTimeout { get; private set; } = null!;

        /// <summary>
        /// The ID of the storage policy to assign to the virtual machine home directory.
        /// </summary>
        [Output("storagePolicyId")]
        public Output<string> StoragePolicyId { get; private set; } = null!;

        /// <summary>
        /// The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
        /// </summary>
        [Output("swapPlacementPolicy")]
        public Output<string?> SwapPlacementPolicy { get; private set; } = null!;

        /// <summary>
        /// Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
        /// </summary>
        [Output("syncTimeWithHost")]
        public Output<bool?> SyncTimeWithHost { get; private set; } = null!;

        /// <summary>
        /// Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `SyncTimeWithHost` is enough for periodic synchronization. Requires VMware Tools to be installed.
        /// </summary>
        [Output("syncTimeWithHostPeriodically")]
        public Output<bool?> SyncTimeWithHostPeriodically { get; private set; } = null!;

        /// <summary>
        /// A list of tag IDs to apply to this object.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// Set the upgrade policy for VMware Tools. Can be one of `Manual` or `upgradeAtPowerCycle`.
        /// </summary>
        [Output("toolsUpgradePolicy")]
        public Output<string?> ToolsUpgradePolicy { get; private set; } = null!;

        /// <summary>
        /// The UUID of the virtual machine. Also exposed as the `Id` of the resource.
        /// </summary>
        [Output("uuid")]
        public Output<string> Uuid { get; private set; } = null!;

        /// <summary>
        /// vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
        /// </summary>
        [Output("vapp")]
        public Output<Outputs.VirtualMachineVapp?> Vapp { get; private set; } = null!;

        /// <summary>
        /// Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.
        /// </summary>
        [Output("vappTransports")]
        public Output<ImmutableArray<string>> VappTransports { get; private set; } = null!;

        /// <summary>
        /// Flag to specify if Virtualization-based security is enabled for this virtual machine.
        /// </summary>
        [Output("vbsEnabled")]
        public Output<bool?> VbsEnabled { get; private set; } = null!;

        /// <summary>
        /// The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.
        /// </summary>
        [Output("vmwareToolsStatus")]
        public Output<string> VmwareToolsStatus { get; private set; } = null!;

        /// <summary>
        /// The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.
        /// </summary>
        [Output("vmxPath")]
        public Output<string> VmxPath { get; private set; } = null!;

        /// <summary>
        /// A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.
        /// </summary>
        [Output("vtpm")]
        public Output<Outputs.VirtualMachineVtpm?> Vtpm { get; private set; } = null!;

        /// <summary>
        /// Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
        /// </summary>
        [Output("vvtdEnabled")]
        public Output<bool?> VvtdEnabled { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
        /// </summary>
        [Output("waitForGuestIpTimeout")]
        public Output<int?> WaitForGuestIpTimeout { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
        /// </summary>
        [Output("waitForGuestNetRoutable")]
        public Output<bool?> WaitForGuestNetRoutable { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
        /// </summary>
        [Output("waitForGuestNetTimeout")]
        public Output<int?> WaitForGuestNetTimeout { get; private set; } = null!;


        /// <summary>
        /// Create a VirtualMachine resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public VirtualMachine(string name, VirtualMachineArgs args, CustomResourceOptions? options = null)
            : base("vsphere:index/virtualMachine:VirtualMachine", name, args ?? new VirtualMachineArgs(), MakeResourceOptions(options, ""))
        {
        }

        private VirtualMachine(string name, Input<string> id, VirtualMachineState? state = null, CustomResourceOptions? options = null)
            : base("vsphere:index/virtualMachine:VirtualMachine", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing VirtualMachine resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static VirtualMachine Get(string name, Input<string> id, VirtualMachineState? state = null, CustomResourceOptions? options = null)
        {
            return new VirtualMachine(name, id, state, options);
        }
    }

    public sealed class VirtualMachineArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The guest name for the operating system when GuestId is otherGuest or otherGuest64.
        /// </summary>
        [Input("alternateGuestName")]
        public Input<string>? AlternateGuestName { get; set; }

        /// <summary>
        /// User-provided description of the virtual machine.
        /// </summary>
        [Input("annotation")]
        public Input<string>? Annotation { get; set; }

        /// <summary>
        /// The number of milliseconds to wait before starting the boot sequence.
        /// </summary>
        [Input("bootDelay")]
        public Input<int>? BootDelay { get; set; }

        /// <summary>
        /// The number of milliseconds to wait before retrying the boot sequence. This only valid if BootRetryEnabled is true.
        /// </summary>
        [Input("bootRetryDelay")]
        public Input<int>? BootRetryDelay { get; set; }

        /// <summary>
        /// If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
        /// </summary>
        [Input("bootRetryEnabled")]
        public Input<bool>? BootRetryEnabled { get; set; }

        [Input("cdroms")]
        private InputList<Inputs.VirtualMachineCdromArgs>? _cdroms;

        /// <summary>
        /// A specification for a CDROM device on this virtual machine.
        /// </summary>
        public InputList<Inputs.VirtualMachineCdromArgs> Cdroms
        {
            get => _cdroms ?? (_cdroms = new InputList<Inputs.VirtualMachineCdromArgs>());
            set => _cdroms = value;
        }

        /// <summary>
        /// A specification for cloning a virtual machine from template.
        /// </summary>
        [Input("clone")]
        public Input<Inputs.VirtualMachineCloneArgs>? Clone { get; set; }

        /// <summary>
        /// Allow CPUs to be added to this virtual machine while it is running.
        /// </summary>
        [Input("cpuHotAddEnabled")]
        public Input<bool>? CpuHotAddEnabled { get; set; }

        /// <summary>
        /// Allow CPUs to be added to this virtual machine while it is running.
        /// </summary>
        [Input("cpuHotRemoveEnabled")]
        public Input<bool>? CpuHotRemoveEnabled { get; set; }

        /// <summary>
        /// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
        /// </summary>
        [Input("cpuLimit")]
        public Input<int>? CpuLimit { get; set; }

        /// <summary>
        /// Enable CPU performance counters on this virtual machine.
        /// </summary>
        [Input("cpuPerformanceCountersEnabled")]
        public Input<bool>? CpuPerformanceCountersEnabled { get; set; }

        /// <summary>
        /// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
        /// </summary>
        [Input("cpuReservation")]
        public Input<int>? CpuReservation { get; set; }

        /// <summary>
        /// The amount of shares to allocate to cpu for a custom share level.
        /// </summary>
        [Input("cpuShareCount")]
        public Input<int>? CpuShareCount { get; set; }

        /// <summary>
        /// The allocation level for cpu resources. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("cpuShareLevel")]
        public Input<string>? CpuShareLevel { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// A list of custom attributes to set on this resource.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The ID of the datacenter where the VM is to be created.
        /// </summary>
        [Input("datacenterId")]
        public Input<string>? DatacenterId { get; set; }

        /// <summary>
        /// The ID of a datastore cluster to put the virtual machine in.
        /// </summary>
        [Input("datastoreClusterId")]
        public Input<string>? DatastoreClusterId { get; set; }

        /// <summary>
        /// The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
        /// </summary>
        [Input("datastoreId")]
        public Input<string>? DatastoreId { get; set; }

        [Input("disks")]
        private InputList<Inputs.VirtualMachineDiskArgs>? _disks;

        /// <summary>
        /// A specification for a virtual disk device on this virtual machine.
        /// </summary>
        public InputList<Inputs.VirtualMachineDiskArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VirtualMachineDiskArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// When the boot type set in firmware is efi, this enables EFI secure boot.
        /// </summary>
        [Input("efiSecureBootEnabled")]
        public Input<bool>? EfiSecureBootEnabled { get; set; }

        /// <summary>
        /// Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
        /// </summary>
        [Input("enableDiskUuid")]
        public Input<bool>? EnableDiskUuid { get; set; }

        /// <summary>
        /// Enable logging on this virtual machine.
        /// </summary>
        [Input("enableLogging")]
        public Input<bool>? EnableLogging { get; set; }

        /// <summary>
        /// The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
        /// </summary>
        [Input("eptRviMode")]
        public Input<string>? EptRviMode { get; set; }

        [Input("extraConfig")]
        private InputMap<string>? _extraConfig;

        /// <summary>
        /// Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
        /// </summary>
        public InputMap<string> ExtraConfig
        {
            get => _extraConfig ?? (_extraConfig = new InputMap<string>());
            set => _extraConfig = value;
        }

        /// <summary>
        /// Allow the virtual machine to be rebooted when a change to `ExtraConfig` occurs.
        /// </summary>
        [Input("extraConfigRebootRequired")]
        public Input<bool>? ExtraConfigRebootRequired { get; set; }

        /// <summary>
        /// The firmware interface to use on the virtual machine. Can be one of bios or efi.
        /// </summary>
        [Input("firmware")]
        public Input<string>? Firmware { get; set; }

        /// <summary>
        /// The name of the folder to locate the virtual machine in.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
        /// </summary>
        [Input("forcePowerOff")]
        public Input<bool>? ForcePowerOff { get; set; }

        /// <summary>
        /// The guest ID for the operating system.
        /// </summary>
        [Input("guestId")]
        public Input<string>? GuestId { get; set; }

        /// <summary>
        /// The hardware version for the virtual machine. Allows versions within ranges: 4, 7-11, 13-15, 17-22.
        /// </summary>
        [Input("hardwareVersion")]
        public Input<int>? HardwareVersion { get; set; }

        /// <summary>
        /// The ID of an optional host system to pin the virtual machine to.
        /// </summary>
        [Input("hostSystemId")]
        public Input<string>? HostSystemId { get; set; }

        /// <summary>
        /// The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
        /// </summary>
        [Input("hvMode")]
        public Input<string>? HvMode { get; set; }

        [Input("ideControllerCount")]
        public Input<int>? IdeControllerCount { get; set; }

        [Input("ignoredGuestIps")]
        private InputList<string>? _ignoredGuestIps;

        /// <summary>
        /// List of IP addresses and CIDR networks to ignore while waiting for an IP
        /// </summary>
        public InputList<string> IgnoredGuestIps
        {
            get => _ignoredGuestIps ?? (_ignoredGuestIps = new InputList<string>());
            set => _ignoredGuestIps = value;
        }

        /// <summary>
        /// Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
        /// </summary>
        [Input("latencySensitivity")]
        public Input<string>? LatencySensitivity { get; set; }

        /// <summary>
        /// The size of the virtual machine's memory, in MB.
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        /// <summary>
        /// Allow memory to be added to this virtual machine while it is running.
        /// </summary>
        [Input("memoryHotAddEnabled")]
        public Input<bool>? MemoryHotAddEnabled { get; set; }

        /// <summary>
        /// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
        /// </summary>
        [Input("memoryLimit")]
        public Input<int>? MemoryLimit { get; set; }

        /// <summary>
        /// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
        /// </summary>
        [Input("memoryReservation")]
        public Input<int>? MemoryReservation { get; set; }

        /// <summary>
        /// If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine's memory size;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature may only be enabled if it is currently possible to reserve all of the virtual machine's memory.
        /// </summary>
        [Input("memoryReservationLockedToMax")]
        public Input<bool>? MemoryReservationLockedToMax { get; set; }

        /// <summary>
        /// The amount of shares to allocate to memory for a custom share level.
        /// </summary>
        [Input("memoryShareCount")]
        public Input<int>? MemoryShareCount { get; set; }

        /// <summary>
        /// The allocation level for memory resources. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("memoryShareLevel")]
        public Input<string>? MemoryShareLevel { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
        /// </summary>
        [Input("migrateWaitTimeout")]
        public Input<int>? MigrateWaitTimeout { get; set; }

        /// <summary>
        /// The name of this virtual machine.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
        /// </summary>
        [Input("nestedHvEnabled")]
        public Input<bool>? NestedHvEnabled { get; set; }

        [Input("networkInterfaces")]
        private InputList<Inputs.VirtualMachineNetworkInterfaceArgs>? _networkInterfaces;

        /// <summary>
        /// A specification for a virtual NIC on this virtual machine.
        /// </summary>
        public InputList<Inputs.VirtualMachineNetworkInterfaceArgs> NetworkInterfaces
        {
            get => _networkInterfaces ?? (_networkInterfaces = new InputList<Inputs.VirtualMachineNetworkInterfaceArgs>());
            set => _networkInterfaces = value;
        }

        /// <summary>
        /// The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to NumCpus must be evenly divisible by this value.
        /// </summary>
        [Input("numCoresPerSocket")]
        public Input<int>? NumCoresPerSocket { get; set; }

        /// <summary>
        /// The number of virtual processors to assign to this virtual machine.
        /// </summary>
        [Input("numCpus")]
        public Input<int>? NumCpus { get; set; }

        [Input("nvmeControllerCount")]
        public Input<int>? NvmeControllerCount { get; set; }

        /// <summary>
        /// A specification for deploying a virtual machine from ovf/ova template.
        /// </summary>
        [Input("ovfDeploy")]
        public Input<Inputs.VirtualMachineOvfDeployArgs>? OvfDeploy { get; set; }

        [Input("pciDeviceIds")]
        private InputList<string>? _pciDeviceIds;

        /// <summary>
        /// A list of PCI passthrough devices
        /// </summary>
        public InputList<string> PciDeviceIds
        {
            get => _pciDeviceIds ?? (_pciDeviceIds = new InputList<string>());
            set => _pciDeviceIds = value;
        }

        /// <summary>
        /// The amount of time, in seconds, that we will be trying to power on a VM
        /// </summary>
        [Input("poweronTimeout")]
        public Input<int>? PoweronTimeout { get; set; }

        /// <summary>
        /// Triggers replacement of resource whenever it changes.
        /// </summary>
        [Input("replaceTrigger")]
        public Input<string>? ReplaceTrigger { get; set; }

        /// <summary>
        /// The ID of a resource pool to put the virtual machine in.
        /// </summary>
        [Input("resourcePoolId", required: true)]
        public Input<string> ResourcePoolId { get; set; } = null!;

        /// <summary>
        /// Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsAfterPowerOn")]
        public Input<bool>? RunToolsScriptsAfterPowerOn { get; set; }

        /// <summary>
        /// Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsAfterResume")]
        public Input<bool>? RunToolsScriptsAfterResume { get; set; }

        /// <summary>
        /// Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestReboot")]
        public Input<bool>? RunToolsScriptsBeforeGuestReboot { get; set; }

        /// <summary>
        /// Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestShutdown")]
        public Input<bool>? RunToolsScriptsBeforeGuestShutdown { get; set; }

        /// <summary>
        /// Enable the run of scripts before guest operating system standby when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestStandby")]
        public Input<bool>? RunToolsScriptsBeforeGuestStandby { get; set; }

        [Input("sataControllerCount")]
        public Input<int>? SataControllerCount { get; set; }

        /// <summary>
        /// Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
        /// </summary>
        [Input("scsiBusSharing")]
        public Input<string>? ScsiBusSharing { get; set; }

        [Input("scsiControllerCount")]
        public Input<int>? ScsiControllerCount { get; set; }

        /// <summary>
        /// The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
        /// </summary>
        [Input("scsiType")]
        public Input<string>? ScsiType { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
        /// </summary>
        [Input("shutdownWaitTimeout")]
        public Input<int>? ShutdownWaitTimeout { get; set; }

        /// <summary>
        /// The ID of the storage policy to assign to the virtual machine home directory.
        /// </summary>
        [Input("storagePolicyId")]
        public Input<string>? StoragePolicyId { get; set; }

        /// <summary>
        /// The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
        /// </summary>
        [Input("swapPlacementPolicy")]
        public Input<string>? SwapPlacementPolicy { get; set; }

        /// <summary>
        /// Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
        /// </summary>
        [Input("syncTimeWithHost")]
        public Input<bool>? SyncTimeWithHost { get; set; }

        /// <summary>
        /// Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `SyncTimeWithHost` is enough for periodic synchronization. Requires VMware Tools to be installed.
        /// </summary>
        [Input("syncTimeWithHostPeriodically")]
        public Input<bool>? SyncTimeWithHostPeriodically { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tag IDs to apply to this object.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Set the upgrade policy for VMware Tools. Can be one of `Manual` or `upgradeAtPowerCycle`.
        /// </summary>
        [Input("toolsUpgradePolicy")]
        public Input<string>? ToolsUpgradePolicy { get; set; }

        /// <summary>
        /// vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
        /// </summary>
        [Input("vapp")]
        public Input<Inputs.VirtualMachineVappArgs>? Vapp { get; set; }

        /// <summary>
        /// Flag to specify if Virtualization-based security is enabled for this virtual machine.
        /// </summary>
        [Input("vbsEnabled")]
        public Input<bool>? VbsEnabled { get; set; }

        /// <summary>
        /// A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.
        /// </summary>
        [Input("vtpm")]
        public Input<Inputs.VirtualMachineVtpmArgs>? Vtpm { get; set; }

        /// <summary>
        /// Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
        /// </summary>
        [Input("vvtdEnabled")]
        public Input<bool>? VvtdEnabled { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
        /// </summary>
        [Input("waitForGuestIpTimeout")]
        public Input<int>? WaitForGuestIpTimeout { get; set; }

        /// <summary>
        /// Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
        /// </summary>
        [Input("waitForGuestNetRoutable")]
        public Input<bool>? WaitForGuestNetRoutable { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
        /// </summary>
        [Input("waitForGuestNetTimeout")]
        public Input<int>? WaitForGuestNetTimeout { get; set; }

        public VirtualMachineArgs()
        {
        }
        public static new VirtualMachineArgs Empty => new VirtualMachineArgs();
    }

    public sealed class VirtualMachineState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The guest name for the operating system when GuestId is otherGuest or otherGuest64.
        /// </summary>
        [Input("alternateGuestName")]
        public Input<string>? AlternateGuestName { get; set; }

        /// <summary>
        /// User-provided description of the virtual machine.
        /// </summary>
        [Input("annotation")]
        public Input<string>? Annotation { get; set; }

        /// <summary>
        /// The number of milliseconds to wait before starting the boot sequence.
        /// </summary>
        [Input("bootDelay")]
        public Input<int>? BootDelay { get; set; }

        /// <summary>
        /// The number of milliseconds to wait before retrying the boot sequence. This only valid if BootRetryEnabled is true.
        /// </summary>
        [Input("bootRetryDelay")]
        public Input<int>? BootRetryDelay { get; set; }

        /// <summary>
        /// If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
        /// </summary>
        [Input("bootRetryEnabled")]
        public Input<bool>? BootRetryEnabled { get; set; }

        [Input("cdroms")]
        private InputList<Inputs.VirtualMachineCdromGetArgs>? _cdroms;

        /// <summary>
        /// A specification for a CDROM device on this virtual machine.
        /// </summary>
        public InputList<Inputs.VirtualMachineCdromGetArgs> Cdroms
        {
            get => _cdroms ?? (_cdroms = new InputList<Inputs.VirtualMachineCdromGetArgs>());
            set => _cdroms = value;
        }

        /// <summary>
        /// A unique identifier for a given version of the last configuration was applied.
        /// </summary>
        [Input("changeVersion")]
        public Input<string>? ChangeVersion { get; set; }

        /// <summary>
        /// A specification for cloning a virtual machine from template.
        /// </summary>
        [Input("clone")]
        public Input<Inputs.VirtualMachineCloneGetArgs>? Clone { get; set; }

        /// <summary>
        /// Allow CPUs to be added to this virtual machine while it is running.
        /// </summary>
        [Input("cpuHotAddEnabled")]
        public Input<bool>? CpuHotAddEnabled { get; set; }

        /// <summary>
        /// Allow CPUs to be added to this virtual machine while it is running.
        /// </summary>
        [Input("cpuHotRemoveEnabled")]
        public Input<bool>? CpuHotRemoveEnabled { get; set; }

        /// <summary>
        /// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
        /// </summary>
        [Input("cpuLimit")]
        public Input<int>? CpuLimit { get; set; }

        /// <summary>
        /// Enable CPU performance counters on this virtual machine.
        /// </summary>
        [Input("cpuPerformanceCountersEnabled")]
        public Input<bool>? CpuPerformanceCountersEnabled { get; set; }

        /// <summary>
        /// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
        /// </summary>
        [Input("cpuReservation")]
        public Input<int>? CpuReservation { get; set; }

        /// <summary>
        /// The amount of shares to allocate to cpu for a custom share level.
        /// </summary>
        [Input("cpuShareCount")]
        public Input<int>? CpuShareCount { get; set; }

        /// <summary>
        /// The allocation level for cpu resources. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("cpuShareLevel")]
        public Input<string>? CpuShareLevel { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// A list of custom attributes to set on this resource.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The ID of the datacenter where the VM is to be created.
        /// </summary>
        [Input("datacenterId")]
        public Input<string>? DatacenterId { get; set; }

        /// <summary>
        /// The ID of a datastore cluster to put the virtual machine in.
        /// </summary>
        [Input("datastoreClusterId")]
        public Input<string>? DatastoreClusterId { get; set; }

        /// <summary>
        /// The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
        /// </summary>
        [Input("datastoreId")]
        public Input<string>? DatastoreId { get; set; }

        /// <summary>
        /// The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.
        /// </summary>
        [Input("defaultIpAddress")]
        public Input<string>? DefaultIpAddress { get; set; }

        [Input("disks")]
        private InputList<Inputs.VirtualMachineDiskGetArgs>? _disks;

        /// <summary>
        /// A specification for a virtual disk device on this virtual machine.
        /// </summary>
        public InputList<Inputs.VirtualMachineDiskGetArgs> Disks
        {
            get => _disks ?? (_disks = new InputList<Inputs.VirtualMachineDiskGetArgs>());
            set => _disks = value;
        }

        /// <summary>
        /// When the boot type set in firmware is efi, this enables EFI secure boot.
        /// </summary>
        [Input("efiSecureBootEnabled")]
        public Input<bool>? EfiSecureBootEnabled { get; set; }

        /// <summary>
        /// Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
        /// </summary>
        [Input("enableDiskUuid")]
        public Input<bool>? EnableDiskUuid { get; set; }

        /// <summary>
        /// Enable logging on this virtual machine.
        /// </summary>
        [Input("enableLogging")]
        public Input<bool>? EnableLogging { get; set; }

        /// <summary>
        /// The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
        /// </summary>
        [Input("eptRviMode")]
        public Input<string>? EptRviMode { get; set; }

        [Input("extraConfig")]
        private InputMap<string>? _extraConfig;

        /// <summary>
        /// Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
        /// </summary>
        public InputMap<string> ExtraConfig
        {
            get => _extraConfig ?? (_extraConfig = new InputMap<string>());
            set => _extraConfig = value;
        }

        /// <summary>
        /// Allow the virtual machine to be rebooted when a change to `ExtraConfig` occurs.
        /// </summary>
        [Input("extraConfigRebootRequired")]
        public Input<bool>? ExtraConfigRebootRequired { get; set; }

        /// <summary>
        /// The firmware interface to use on the virtual machine. Can be one of bios or efi.
        /// </summary>
        [Input("firmware")]
        public Input<string>? Firmware { get; set; }

        /// <summary>
        /// The name of the folder to locate the virtual machine in.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
        /// </summary>
        [Input("forcePowerOff")]
        public Input<bool>? ForcePowerOff { get; set; }

        /// <summary>
        /// The guest ID for the operating system.
        /// </summary>
        [Input("guestId")]
        public Input<string>? GuestId { get; set; }

        [Input("guestIpAddresses")]
        private InputList<string>? _guestIpAddresses;

        /// <summary>
        /// The current list of IP addresses on this machine, including the value of `DefaultIpAddress`. If VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this list will be empty.
        /// </summary>
        public InputList<string> GuestIpAddresses
        {
            get => _guestIpAddresses ?? (_guestIpAddresses = new InputList<string>());
            set => _guestIpAddresses = value;
        }

        /// <summary>
        /// The hardware version for the virtual machine. Allows versions within ranges: 4, 7-11, 13-15, 17-22.
        /// </summary>
        [Input("hardwareVersion")]
        public Input<int>? HardwareVersion { get; set; }

        /// <summary>
        /// The ID of an optional host system to pin the virtual machine to.
        /// </summary>
        [Input("hostSystemId")]
        public Input<string>? HostSystemId { get; set; }

        /// <summary>
        /// The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
        /// </summary>
        [Input("hvMode")]
        public Input<string>? HvMode { get; set; }

        [Input("ideControllerCount")]
        public Input<int>? IdeControllerCount { get; set; }

        [Input("ignoredGuestIps")]
        private InputList<string>? _ignoredGuestIps;

        /// <summary>
        /// List of IP addresses and CIDR networks to ignore while waiting for an IP
        /// </summary>
        public InputList<string> IgnoredGuestIps
        {
            get => _ignoredGuestIps ?? (_ignoredGuestIps = new InputList<string>());
            set => _ignoredGuestIps = value;
        }

        /// <summary>
        /// Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.
        /// </summary>
        [Input("imported")]
        public Input<bool>? Imported { get; set; }

        /// <summary>
        /// Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
        /// </summary>
        [Input("latencySensitivity")]
        public Input<string>? LatencySensitivity { get; set; }

        /// <summary>
        /// The size of the virtual machine's memory, in MB.
        /// </summary>
        [Input("memory")]
        public Input<int>? Memory { get; set; }

        /// <summary>
        /// Allow memory to be added to this virtual machine while it is running.
        /// </summary>
        [Input("memoryHotAddEnabled")]
        public Input<bool>? MemoryHotAddEnabled { get; set; }

        /// <summary>
        /// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
        /// </summary>
        [Input("memoryLimit")]
        public Input<int>? MemoryLimit { get; set; }

        /// <summary>
        /// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
        /// </summary>
        [Input("memoryReservation")]
        public Input<int>? MemoryReservation { get; set; }

        /// <summary>
        /// If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine's memory size;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature may only be enabled if it is currently possible to reserve all of the virtual machine's memory.
        /// </summary>
        [Input("memoryReservationLockedToMax")]
        public Input<bool>? MemoryReservationLockedToMax { get; set; }

        /// <summary>
        /// The amount of shares to allocate to memory for a custom share level.
        /// </summary>
        [Input("memoryShareCount")]
        public Input<int>? MemoryShareCount { get; set; }

        /// <summary>
        /// The allocation level for memory resources. Can be one of high, low, normal, or custom.
        /// </summary>
        [Input("memoryShareLevel")]
        public Input<string>? MemoryShareLevel { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
        /// </summary>
        [Input("migrateWaitTimeout")]
        public Input<int>? MigrateWaitTimeout { get; set; }

        /// <summary>
        /// The managed object reference ID of the created virtual machine.
        /// </summary>
        [Input("moid")]
        public Input<string>? Moid { get; set; }

        /// <summary>
        /// The name of this virtual machine.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
        /// </summary>
        [Input("nestedHvEnabled")]
        public Input<bool>? NestedHvEnabled { get; set; }

        [Input("networkInterfaces")]
        private InputList<Inputs.VirtualMachineNetworkInterfaceGetArgs>? _networkInterfaces;

        /// <summary>
        /// A specification for a virtual NIC on this virtual machine.
        /// </summary>
        public InputList<Inputs.VirtualMachineNetworkInterfaceGetArgs> NetworkInterfaces
        {
            get => _networkInterfaces ?? (_networkInterfaces = new InputList<Inputs.VirtualMachineNetworkInterfaceGetArgs>());
            set => _networkInterfaces = value;
        }

        /// <summary>
        /// The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to NumCpus must be evenly divisible by this value.
        /// </summary>
        [Input("numCoresPerSocket")]
        public Input<int>? NumCoresPerSocket { get; set; }

        /// <summary>
        /// The number of virtual processors to assign to this virtual machine.
        /// </summary>
        [Input("numCpus")]
        public Input<int>? NumCpus { get; set; }

        [Input("nvmeControllerCount")]
        public Input<int>? NvmeControllerCount { get; set; }

        /// <summary>
        /// A specification for deploying a virtual machine from ovf/ova template.
        /// </summary>
        [Input("ovfDeploy")]
        public Input<Inputs.VirtualMachineOvfDeployGetArgs>? OvfDeploy { get; set; }

        [Input("pciDeviceIds")]
        private InputList<string>? _pciDeviceIds;

        /// <summary>
        /// A list of PCI passthrough devices
        /// </summary>
        public InputList<string> PciDeviceIds
        {
            get => _pciDeviceIds ?? (_pciDeviceIds = new InputList<string>());
            set => _pciDeviceIds = value;
        }

        /// <summary>
        /// A computed value for the current power state of the virtual machine. One of `On`, `Off`, or `Suspended`.
        /// </summary>
        [Input("powerState")]
        public Input<string>? PowerState { get; set; }

        /// <summary>
        /// The amount of time, in seconds, that we will be trying to power on a VM
        /// </summary>
        [Input("poweronTimeout")]
        public Input<int>? PoweronTimeout { get; set; }

        [Input("rebootRequired")]
        public Input<bool>? RebootRequired { get; set; }

        /// <summary>
        /// Triggers replacement of resource whenever it changes.
        /// </summary>
        [Input("replaceTrigger")]
        public Input<string>? ReplaceTrigger { get; set; }

        /// <summary>
        /// The ID of a resource pool to put the virtual machine in.
        /// </summary>
        [Input("resourcePoolId")]
        public Input<string>? ResourcePoolId { get; set; }

        /// <summary>
        /// Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsAfterPowerOn")]
        public Input<bool>? RunToolsScriptsAfterPowerOn { get; set; }

        /// <summary>
        /// Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsAfterResume")]
        public Input<bool>? RunToolsScriptsAfterResume { get; set; }

        /// <summary>
        /// Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestReboot")]
        public Input<bool>? RunToolsScriptsBeforeGuestReboot { get; set; }

        /// <summary>
        /// Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestShutdown")]
        public Input<bool>? RunToolsScriptsBeforeGuestShutdown { get; set; }

        /// <summary>
        /// Enable the run of scripts before guest operating system standby when VMware Tools is installed.
        /// </summary>
        [Input("runToolsScriptsBeforeGuestStandby")]
        public Input<bool>? RunToolsScriptsBeforeGuestStandby { get; set; }

        [Input("sataControllerCount")]
        public Input<int>? SataControllerCount { get; set; }

        /// <summary>
        /// Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
        /// </summary>
        [Input("scsiBusSharing")]
        public Input<string>? ScsiBusSharing { get; set; }

        [Input("scsiControllerCount")]
        public Input<int>? ScsiControllerCount { get; set; }

        /// <summary>
        /// The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
        /// </summary>
        [Input("scsiType")]
        public Input<string>? ScsiType { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
        /// </summary>
        [Input("shutdownWaitTimeout")]
        public Input<int>? ShutdownWaitTimeout { get; set; }

        /// <summary>
        /// The ID of the storage policy to assign to the virtual machine home directory.
        /// </summary>
        [Input("storagePolicyId")]
        public Input<string>? StoragePolicyId { get; set; }

        /// <summary>
        /// The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
        /// </summary>
        [Input("swapPlacementPolicy")]
        public Input<string>? SwapPlacementPolicy { get; set; }

        /// <summary>
        /// Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
        /// </summary>
        [Input("syncTimeWithHost")]
        public Input<bool>? SyncTimeWithHost { get; set; }

        /// <summary>
        /// Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `SyncTimeWithHost` is enough for periodic synchronization. Requires VMware Tools to be installed.
        /// </summary>
        [Input("syncTimeWithHostPeriodically")]
        public Input<bool>? SyncTimeWithHostPeriodically { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tag IDs to apply to this object.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Set the upgrade policy for VMware Tools. Can be one of `Manual` or `upgradeAtPowerCycle`.
        /// </summary>
        [Input("toolsUpgradePolicy")]
        public Input<string>? ToolsUpgradePolicy { get; set; }

        /// <summary>
        /// The UUID of the virtual machine. Also exposed as the `Id` of the resource.
        /// </summary>
        [Input("uuid")]
        public Input<string>? Uuid { get; set; }

        /// <summary>
        /// vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
        /// </summary>
        [Input("vapp")]
        public Input<Inputs.VirtualMachineVappGetArgs>? Vapp { get; set; }

        [Input("vappTransports")]
        private InputList<string>? _vappTransports;

        /// <summary>
        /// Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.
        /// </summary>
        public InputList<string> VappTransports
        {
            get => _vappTransports ?? (_vappTransports = new InputList<string>());
            set => _vappTransports = value;
        }

        /// <summary>
        /// Flag to specify if Virtualization-based security is enabled for this virtual machine.
        /// </summary>
        [Input("vbsEnabled")]
        public Input<bool>? VbsEnabled { get; set; }

        /// <summary>
        /// The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.
        /// </summary>
        [Input("vmwareToolsStatus")]
        public Input<string>? VmwareToolsStatus { get; set; }

        /// <summary>
        /// The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.
        /// </summary>
        [Input("vmxPath")]
        public Input<string>? VmxPath { get; set; }

        /// <summary>
        /// A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.
        /// </summary>
        [Input("vtpm")]
        public Input<Inputs.VirtualMachineVtpmGetArgs>? Vtpm { get; set; }

        /// <summary>
        /// Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
        /// </summary>
        [Input("vvtdEnabled")]
        public Input<bool>? VvtdEnabled { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
        /// </summary>
        [Input("waitForGuestIpTimeout")]
        public Input<int>? WaitForGuestIpTimeout { get; set; }

        /// <summary>
        /// Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
        /// </summary>
        [Input("waitForGuestNetRoutable")]
        public Input<bool>? WaitForGuestNetRoutable { get; set; }

        /// <summary>
        /// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
        /// </summary>
        [Input("waitForGuestNetTimeout")]
        public Input<int>? WaitForGuestNetTimeout { get; set; }

        public VirtualMachineState()
        {
        }
        public static new VirtualMachineState Empty => new VirtualMachineState();
    }
}
