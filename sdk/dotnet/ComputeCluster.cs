// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.VSphere
{
    /// <summary>
    /// &gt; **A note on the naming of this resource:** VMware refers to clusters of
    /// hosts in the UI and documentation as _clusters_, _HA clusters_, or _DRS
    /// clusters_. All of these refer to the same kind of resource (with the latter two
    /// referring to specific features of clustering). We use
    /// `vsphere.ComputeCluster` to differentiate host clusters from _datastore
    /// clusters_, which are clusters of datastores that can be used to distribute load
    /// and ensure fault tolerance via distribution of virtual machines. Datastore
    /// clusters can also be managed through the provider, via the
    /// `vsphere.DatastoreCluster` resource.
    /// 
    /// The `vsphere.ComputeCluster` resource can be used to create and manage
    /// clusters of hosts allowing for resource control of compute resources, load
    /// balancing through DRS, and high availability through vSphere HA.
    /// 
    /// For more information on vSphere clusters and DRS, see [this
    /// page][ref-vsphere-drs-clusters]. For more information on vSphere HA, see [this
    /// page][ref-vsphere-ha-clusters].
    /// 
    /// [ref-vsphere-drs-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-resource-management-8-0/creating-a-drs-cluster.html
    /// [ref-vsphere-ha-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-availability.html
    /// 
    /// &gt; **NOTE:** This resource requires vCenter and is not available on
    /// direct ESXi connections.
    /// 
    /// ## Import
    /// 
    /// An existing cluster can be imported into this resource via the
    /// 
    /// path to the cluster, via the following command:
    /// 
    /// [docs-import]: https://developer.hashicorp.com/terraform/cli/import
    /// 
    /// hcl
    /// 
    /// variable "datacenter" {
    /// 
    ///   default = "dc-01"
    /// 
    /// }
    /// 
    /// data "vsphere_datacenter" "datacenter" {
    /// 
    ///   name = var.datacenter
    /// 
    /// }
    /// 
    /// resource "vsphere_compute_cluster" "compute_cluster" {
    /// 
    ///   name          = "cluster-01"
    /// 
    ///   datacenter_id = data.vsphere_datacenter.datacenter.id
    /// 
    /// }
    /// 
    /// hcl
    /// 
    /// resource "vsphere_compute_cluster" "compute_cluster" {
    /// 
    ///   name                      = "cluster-01"
    /// 
    ///   datacenter_id             = data.vsphere_datacenter.datacenter.id
    /// 
    ///   vsan_enabled              = true
    /// 
    ///   vsan_performance_enabled  = true
    /// 
    ///   host_system_ids           = [for host in data.vsphere_host.host : host.id]
    /// 
    ///   dpm_automation_level      = "automated"
    /// 
    ///   drs_automation_level      = "fullyAutomated"
    /// 
    ///   drs_enabled               = true
    /// 
    ///   ha_datastore_apd_response = "restartConservative"
    /// 
    ///   ha_datastore_pdl_response = "restartAggressive"
    /// 
    /// }
    /// 
    /// ```sh
    /// $ pulumi import vsphere:index/computeCluster:ComputeCluster compute_cluster /dc-01/host/cluster-01
    /// ```
    /// 
    /// The above would import the cluster named `cluster-01` that is located in
    /// 
    /// the `dc-01` datacenter.
    /// </summary>
    [VSphereResourceType("vsphere:index/computeCluster:ComputeCluster")]
    public partial class ComputeCluster : global::Pulumi.CustomResource
    {
        /// <summary>
        /// A map of custom attribute ids to attribute
        /// value strings to set for the datastore cluster.
        /// 
        /// &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
        /// and require vCenter Server.
        /// </summary>
        [Output("customAttributes")]
        public Output<ImmutableDictionary<string, string>?> CustomAttributes { get; private set; } = null!;

        /// <summary>
        /// The managed object ID of
        /// the datacenter to create the cluster in. Forces a new resource if changed.
        /// </summary>
        [Output("datacenterId")]
        public Output<string> DatacenterId { get; private set; } = null!;

        /// <summary>
        /// The automation level for host power operations in this cluster. Can be one of manual or automated.
        /// </summary>
        [Output("dpmAutomationLevel")]
        public Output<string?> DpmAutomationLevel { get; private set; } = null!;

        /// <summary>
        /// Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual
        /// machines in the cluster. Requires that DRS be enabled.
        /// </summary>
        [Output("dpmEnabled")]
        public Output<bool?> DpmEnabled { get; private set; } = null!;

        /// <summary>
        /// A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This
        /// affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher
        /// setting.
        /// </summary>
        [Output("dpmThreshold")]
        public Output<int?> DpmThreshold { get; private set; } = null!;

        /// <summary>
        /// Advanced configuration options for DRS and DPM.
        /// </summary>
        [Output("drsAdvancedOptions")]
        public Output<ImmutableDictionary<string, string>?> DrsAdvancedOptions { get; private set; } = null!;

        /// <summary>
        /// The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or
        /// fullyAutomated.
        /// </summary>
        [Output("drsAutomationLevel")]
        public Output<string?> DrsAutomationLevel { get; private set; } = null!;

        /// <summary>
        /// When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
        /// </summary>
        [Output("drsEnablePredictiveDrs")]
        public Output<bool?> DrsEnablePredictiveDrs { get; private set; } = null!;

        /// <summary>
        /// When true, allows individual VM overrides within this cluster to be set.
        /// </summary>
        [Output("drsEnableVmOverrides")]
        public Output<bool?> DrsEnableVmOverrides { get; private set; } = null!;

        /// <summary>
        /// Enable DRS for this cluster.
        /// </summary>
        [Output("drsEnabled")]
        public Output<bool?> DrsEnabled { get; private set; } = null!;

        /// <summary>
        /// A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate
        /// more imbalance while a higher setting will tolerate less.
        /// </summary>
        [Output("drsMigrationThreshold")]
        public Output<int?> DrsMigrationThreshold { get; private set; } = null!;

        /// <summary>
        /// Enable scalable shares for all descendants of this cluster.
        /// </summary>
        [Output("drsScaleDescendantsShares")]
        public Output<string?> DrsScaleDescendantsShares { get; private set; } = null!;

        /// <summary>
        /// The relative path to a folder to put this cluster in.
        /// This is a path relative to the datacenter you are deploying the cluster to.
        /// Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
        /// The provider will place a cluster named `compute-cluster-test` in a
        /// host folder located at `/dc1/host/foo/bar`, with the final inventory path
        /// being `/dc1/host/foo/bar/datastore-cluster-test`.
        /// </summary>
        [Output("folder")]
        public Output<string?> Folder { get; private set; } = null!;

        /// <summary>
        /// Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists
        /// for testing and is not recommended in normal use.
        /// </summary>
        [Output("forceEvacuateOnDestroy")]
        public Output<bool?> ForceEvacuateOnDestroy { get; private set; } = null!;

        /// <summary>
        /// When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated
        /// failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS
        /// will ignore the host when making recommendations.
        /// </summary>
        [Output("haAdmissionControlFailoverHostSystemIds")]
        public Output<ImmutableArray<string>> HaAdmissionControlFailoverHostSystemIds { get; private set; } = null!;

        /// <summary>
        /// The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual
        /// machine operations. The maximum is one less than the number of hosts in the cluster.
        /// </summary>
        [Output("haAdmissionControlHostFailureTolerance")]
        public Output<int?> HaAdmissionControlHostFailureTolerance { get; private set; } = null!;

        /// <summary>
        /// The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces
        /// warnings only, whereas a value of 100 disables the setting.
        /// </summary>
        [Output("haAdmissionControlPerformanceTolerance")]
        public Output<int?> HaAdmissionControlPerformanceTolerance { get; private set; } = null!;

        /// <summary>
        /// The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are
        /// permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,
        /// slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service
        /// issues.
        /// </summary>
        [Output("haAdmissionControlPolicy")]
        public Output<string?> HaAdmissionControlPolicy { get; private set; } = null!;

        /// <summary>
        /// When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by
        /// subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting
        /// from the total amount of resources in the cluster. Disable to supply user-defined values.
        /// </summary>
        [Output("haAdmissionControlResourcePercentageAutoCompute")]
        public Output<bool?> HaAdmissionControlResourcePercentageAutoCompute { get; private set; } = null!;

        /// <summary>
        /// When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in
        /// the cluster to reserve for failover.
        /// </summary>
        [Output("haAdmissionControlResourcePercentageCpu")]
        public Output<int?> HaAdmissionControlResourcePercentageCpu { get; private set; } = null!;

        /// <summary>
        /// When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in
        /// the cluster to reserve for failover.
        /// </summary>
        [Output("haAdmissionControlResourcePercentageMemory")]
        public Output<int?> HaAdmissionControlResourcePercentageMemory { get; private set; } = null!;

        /// <summary>
        /// When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
        /// </summary>
        [Output("haAdmissionControlSlotPolicyExplicitCpu")]
        public Output<int?> HaAdmissionControlSlotPolicyExplicitCpu { get; private set; } = null!;

        /// <summary>
        /// When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.
        /// </summary>
        [Output("haAdmissionControlSlotPolicyExplicitMemory")]
        public Output<int?> HaAdmissionControlSlotPolicyExplicitMemory { get; private set; } = null!;

        /// <summary>
        /// When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values
        /// to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines
        /// currently in the cluster.
        /// </summary>
        [Output("haAdmissionControlSlotPolicyUseExplicitSize")]
        public Output<bool?> HaAdmissionControlSlotPolicyUseExplicitSize { get; private set; } = null!;

        /// <summary>
        /// Advanced configuration options for vSphere HA.
        /// </summary>
        [Output("haAdvancedOptions")]
        public Output<ImmutableDictionary<string, string>?> HaAdvancedOptions { get; private set; } = null!;

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an
        /// affected datastore clears in the middle of an APD event. Can be one of none or reset.
        /// </summary>
        [Output("haDatastoreApdRecoveryAction")]
        public Output<string?> HaDatastoreApdRecoveryAction { get; private set; } = null!;

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
        /// detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or
        /// restartAggressive.
        /// </summary>
        [Output("haDatastoreApdResponse")]
        public Output<string?> HaDatastoreApdResponse { get; private set; } = null!;

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute
        /// the response action defined in ha_datastore_apd_response.
        /// </summary>
        [Output("haDatastoreApdResponseDelay")]
        public Output<int?> HaDatastoreApdResponseDelay { get; private set; } = null!;

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
        /// detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
        /// </summary>
        [Output("haDatastorePdlResponse")]
        public Output<string?> HaDatastorePdlResponse { get; private set; } = null!;

        /// <summary>
        /// Enable vSphere HA for this cluster.
        /// </summary>
        [Output("haEnabled")]
        public Output<bool?> HaEnabled { get; private set; } = null!;

        /// <summary>
        /// The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when
        /// ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
        /// </summary>
        [Output("haHeartbeatDatastoreIds")]
        public Output<ImmutableArray<string>> HaHeartbeatDatastoreIds { get; private set; } = null!;

        /// <summary>
        /// The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or
        /// allFeasibleDsWithUserPreference.
        /// </summary>
        [Output("haHeartbeatDatastorePolicy")]
        public Output<string?> HaHeartbeatDatastorePolicy { get; private set; } = null!;

        /// <summary>
        /// The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.
        /// Can be one of none, powerOff, or shutdown.
        /// </summary>
        [Output("haHostIsolationResponse")]
        public Output<string?> HaHostIsolationResponse { get; private set; } = null!;

        /// <summary>
        /// Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
        /// </summary>
        [Output("haHostMonitoring")]
        public Output<string?> HaHostMonitoring { get; private set; } = null!;

        /// <summary>
        /// Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to
        /// failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
        /// </summary>
        [Output("haVmComponentProtection")]
        public Output<string?> HaVmComponentProtection { get; private set; } = null!;

        /// <summary>
        /// The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move
        /// on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
        /// </summary>
        [Output("haVmDependencyRestartCondition")]
        public Output<string?> HaVmDependencyRestartCondition { get; private set; } = null!;

        /// <summary>
        /// If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as
        /// failed. The value is in seconds.
        /// </summary>
        [Output("haVmFailureInterval")]
        public Output<int?> HaVmFailureInterval { get; private set; } = null!;

        /// <summary>
        /// The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are
        /// attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset
        /// time is allotted.
        /// </summary>
        [Output("haVmMaximumFailureWindow")]
        public Output<int?> HaVmMaximumFailureWindow { get; private set; } = null!;

        /// <summary>
        /// The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
        /// </summary>
        [Output("haVmMaximumResets")]
        public Output<int?> HaVmMaximumResets { get; private set; } = null!;

        /// <summary>
        /// The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
        /// </summary>
        [Output("haVmMinimumUptime")]
        public Output<int?> HaVmMinimumUptime { get; private set; } = null!;

        /// <summary>
        /// The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,
        /// vmMonitoringOnly, or vmAndAppMonitoring.
        /// </summary>
        [Output("haVmMonitoring")]
        public Output<string?> HaVmMonitoring { get; private set; } = null!;

        /// <summary>
        /// Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
        /// </summary>
        [Output("haVmRestartAdditionalDelay")]
        public Output<int?> HaVmRestartAdditionalDelay { get; private set; } = null!;

        /// <summary>
        /// The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,
        /// high, or highest.
        /// </summary>
        [Output("haVmRestartPriority")]
        public Output<string?> HaVmRestartPriority { get; private set; } = null!;

        /// <summary>
        /// The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before
        /// proceeding with the next priority.
        /// </summary>
        [Output("haVmRestartTimeout")]
        public Output<int?> HaVmRestartTimeout { get; private set; } = null!;

        /// <summary>
        /// The timeout for each host maintenance mode operation when removing hosts from a cluster.
        /// </summary>
        [Output("hostClusterExitTimeout")]
        public Output<int?> HostClusterExitTimeout { get; private set; } = null!;

        /// <summary>
        /// Details about the host image which should be applied to the cluster.
        /// </summary>
        [Output("hostImage")]
        public Output<Outputs.ComputeClusterHostImage?> HostImage { get; private set; } = null!;

        /// <summary>
        /// Must be set if cluster enrollment is managed from host resource.
        /// </summary>
        [Output("hostManaged")]
        public Output<bool?> HostManaged { get; private set; } = null!;

        /// <summary>
        /// The managed object IDs of the hosts to put in the cluster.
        /// </summary>
        [Output("hostSystemIds")]
        public Output<ImmutableArray<string>> HostSystemIds { get; private set; } = null!;

        /// <summary>
        /// The name of the cluster.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
        /// </summary>
        [Output("proactiveHaAutomationLevel")]
        public Output<string?> ProactiveHaAutomationLevel { get; private set; } = null!;

        /// <summary>
        /// Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
        /// </summary>
        [Output("proactiveHaEnabled")]
        public Output<bool?> ProactiveHaEnabled { get; private set; } = null!;

        /// <summary>
        /// The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that
        /// this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.
        /// </summary>
        [Output("proactiveHaModerateRemediation")]
        public Output<string?> ProactiveHaModerateRemediation { get; private set; } = null!;

        /// <summary>
        /// The list of IDs for health update providers configured for this cluster.
        /// </summary>
        [Output("proactiveHaProviderIds")]
        public Output<ImmutableArray<string>> ProactiveHaProviderIds { get; private set; } = null!;

        /// <summary>
        /// The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this
        /// cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.
        /// </summary>
        [Output("proactiveHaSevereRemediation")]
        public Output<string?> ProactiveHaSevereRemediation { get; private set; } = null!;

        /// <summary>
        /// The managed object ID of the primary
        /// resource pool for this cluster. This can be passed directly to the
        /// `resource_pool_id`
        /// attribute of the
        /// `vsphere.VirtualMachine` resource.
        /// </summary>
        [Output("resourcePoolId")]
        public Output<string> ResourcePoolId { get; private set; } = null!;

        /// <summary>
        /// The IDs of any tags to attach to this resource.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// Whether the vSAN compression service is enabled for the cluster.
        /// </summary>
        [Output("vsanCompressionEnabled")]
        public Output<bool?> VsanCompressionEnabled { get; private set; } = null!;

        /// <summary>
        /// Whether the vSAN deduplication service is enabled for the cluster.
        /// </summary>
        [Output("vsanDedupEnabled")]
        public Output<bool?> VsanDedupEnabled { get; private set; } = null!;

        /// <summary>
        /// A list of disk UUIDs to add to the vSAN cluster.
        /// </summary>
        [Output("vsanDiskGroups")]
        public Output<ImmutableArray<Outputs.ComputeClusterVsanDiskGroup>> VsanDiskGroups { get; private set; } = null!;

        /// <summary>
        /// Whether the vSAN data-in-transit encryption is enabled for the cluster.
        /// </summary>
        [Output("vsanDitEncryptionEnabled")]
        public Output<bool?> VsanDitEncryptionEnabled { get; private set; } = null!;

        /// <summary>
        /// When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
        /// </summary>
        [Output("vsanDitRekeyInterval")]
        public Output<int> VsanDitRekeyInterval { get; private set; } = null!;

        /// <summary>
        /// Whether the vSAN service is enabled for the cluster.
        /// </summary>
        [Output("vsanEnabled")]
        public Output<bool?> VsanEnabled { get; private set; } = null!;

        /// <summary>
        /// Whether the vSAN ESA service is enabled for the cluster.
        /// </summary>
        [Output("vsanEsaEnabled")]
        public Output<bool?> VsanEsaEnabled { get; private set; } = null!;

        /// <summary>
        /// The configuration for vSAN fault domains.
        /// </summary>
        [Output("vsanFaultDomains")]
        public Output<ImmutableArray<Outputs.ComputeClusterVsanFaultDomain>> VsanFaultDomains { get; private set; } = null!;

        /// <summary>
        /// Whether the vSAN network diagnostic mode is enabled for the cluster.
        /// </summary>
        [Output("vsanNetworkDiagnosticModeEnabled")]
        public Output<bool?> VsanNetworkDiagnosticModeEnabled { get; private set; } = null!;

        /// <summary>
        /// Whether the vSAN performance service is enabled for the cluster.
        /// </summary>
        [Output("vsanPerformanceEnabled")]
        public Output<bool?> VsanPerformanceEnabled { get; private set; } = null!;

        /// <summary>
        /// The managed object IDs of the vSAN datastore to be mounted on the cluster.
        /// </summary>
        [Output("vsanRemoteDatastoreIds")]
        public Output<ImmutableArray<string>> VsanRemoteDatastoreIds { get; private set; } = null!;

        /// <summary>
        /// The configuration for stretched cluster.
        /// </summary>
        [Output("vsanStretchedCluster")]
        public Output<Outputs.ComputeClusterVsanStretchedCluster?> VsanStretchedCluster { get; private set; } = null!;

        /// <summary>
        /// Whether the vSAN unmap service is enabled for the cluster.
        /// </summary>
        [Output("vsanUnmapEnabled")]
        public Output<bool?> VsanUnmapEnabled { get; private set; } = null!;

        /// <summary>
        /// Whether the vSAN verbose mode is enabled for the cluster.
        /// </summary>
        [Output("vsanVerboseModeEnabled")]
        public Output<bool?> VsanVerboseModeEnabled { get; private set; } = null!;


        /// <summary>
        /// Create a ComputeCluster resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ComputeCluster(string name, ComputeClusterArgs args, CustomResourceOptions? options = null)
            : base("vsphere:index/computeCluster:ComputeCluster", name, args ?? new ComputeClusterArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ComputeCluster(string name, Input<string> id, ComputeClusterState? state = null, CustomResourceOptions? options = null)
            : base("vsphere:index/computeCluster:ComputeCluster", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ComputeCluster resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ComputeCluster Get(string name, Input<string> id, ComputeClusterState? state = null, CustomResourceOptions? options = null)
        {
            return new ComputeCluster(name, id, state, options);
        }
    }

    public sealed class ComputeClusterArgs : global::Pulumi.ResourceArgs
    {
        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// A map of custom attribute ids to attribute
        /// value strings to set for the datastore cluster.
        /// 
        /// &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
        /// and require vCenter Server.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The managed object ID of
        /// the datacenter to create the cluster in. Forces a new resource if changed.
        /// </summary>
        [Input("datacenterId", required: true)]
        public Input<string> DatacenterId { get; set; } = null!;

        /// <summary>
        /// The automation level for host power operations in this cluster. Can be one of manual or automated.
        /// </summary>
        [Input("dpmAutomationLevel")]
        public Input<string>? DpmAutomationLevel { get; set; }

        /// <summary>
        /// Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual
        /// machines in the cluster. Requires that DRS be enabled.
        /// </summary>
        [Input("dpmEnabled")]
        public Input<bool>? DpmEnabled { get; set; }

        /// <summary>
        /// A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This
        /// affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher
        /// setting.
        /// </summary>
        [Input("dpmThreshold")]
        public Input<int>? DpmThreshold { get; set; }

        [Input("drsAdvancedOptions")]
        private InputMap<string>? _drsAdvancedOptions;

        /// <summary>
        /// Advanced configuration options for DRS and DPM.
        /// </summary>
        public InputMap<string> DrsAdvancedOptions
        {
            get => _drsAdvancedOptions ?? (_drsAdvancedOptions = new InputMap<string>());
            set => _drsAdvancedOptions = value;
        }

        /// <summary>
        /// The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or
        /// fullyAutomated.
        /// </summary>
        [Input("drsAutomationLevel")]
        public Input<string>? DrsAutomationLevel { get; set; }

        /// <summary>
        /// When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
        /// </summary>
        [Input("drsEnablePredictiveDrs")]
        public Input<bool>? DrsEnablePredictiveDrs { get; set; }

        /// <summary>
        /// When true, allows individual VM overrides within this cluster to be set.
        /// </summary>
        [Input("drsEnableVmOverrides")]
        public Input<bool>? DrsEnableVmOverrides { get; set; }

        /// <summary>
        /// Enable DRS for this cluster.
        /// </summary>
        [Input("drsEnabled")]
        public Input<bool>? DrsEnabled { get; set; }

        /// <summary>
        /// A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate
        /// more imbalance while a higher setting will tolerate less.
        /// </summary>
        [Input("drsMigrationThreshold")]
        public Input<int>? DrsMigrationThreshold { get; set; }

        /// <summary>
        /// Enable scalable shares for all descendants of this cluster.
        /// </summary>
        [Input("drsScaleDescendantsShares")]
        public Input<string>? DrsScaleDescendantsShares { get; set; }

        /// <summary>
        /// The relative path to a folder to put this cluster in.
        /// This is a path relative to the datacenter you are deploying the cluster to.
        /// Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
        /// The provider will place a cluster named `compute-cluster-test` in a
        /// host folder located at `/dc1/host/foo/bar`, with the final inventory path
        /// being `/dc1/host/foo/bar/datastore-cluster-test`.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists
        /// for testing and is not recommended in normal use.
        /// </summary>
        [Input("forceEvacuateOnDestroy")]
        public Input<bool>? ForceEvacuateOnDestroy { get; set; }

        [Input("haAdmissionControlFailoverHostSystemIds")]
        private InputList<string>? _haAdmissionControlFailoverHostSystemIds;

        /// <summary>
        /// When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated
        /// failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS
        /// will ignore the host when making recommendations.
        /// </summary>
        public InputList<string> HaAdmissionControlFailoverHostSystemIds
        {
            get => _haAdmissionControlFailoverHostSystemIds ?? (_haAdmissionControlFailoverHostSystemIds = new InputList<string>());
            set => _haAdmissionControlFailoverHostSystemIds = value;
        }

        /// <summary>
        /// The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual
        /// machine operations. The maximum is one less than the number of hosts in the cluster.
        /// </summary>
        [Input("haAdmissionControlHostFailureTolerance")]
        public Input<int>? HaAdmissionControlHostFailureTolerance { get; set; }

        /// <summary>
        /// The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces
        /// warnings only, whereas a value of 100 disables the setting.
        /// </summary>
        [Input("haAdmissionControlPerformanceTolerance")]
        public Input<int>? HaAdmissionControlPerformanceTolerance { get; set; }

        /// <summary>
        /// The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are
        /// permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,
        /// slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service
        /// issues.
        /// </summary>
        [Input("haAdmissionControlPolicy")]
        public Input<string>? HaAdmissionControlPolicy { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by
        /// subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting
        /// from the total amount of resources in the cluster. Disable to supply user-defined values.
        /// </summary>
        [Input("haAdmissionControlResourcePercentageAutoCompute")]
        public Input<bool>? HaAdmissionControlResourcePercentageAutoCompute { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in
        /// the cluster to reserve for failover.
        /// </summary>
        [Input("haAdmissionControlResourcePercentageCpu")]
        public Input<int>? HaAdmissionControlResourcePercentageCpu { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in
        /// the cluster to reserve for failover.
        /// </summary>
        [Input("haAdmissionControlResourcePercentageMemory")]
        public Input<int>? HaAdmissionControlResourcePercentageMemory { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
        /// </summary>
        [Input("haAdmissionControlSlotPolicyExplicitCpu")]
        public Input<int>? HaAdmissionControlSlotPolicyExplicitCpu { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.
        /// </summary>
        [Input("haAdmissionControlSlotPolicyExplicitMemory")]
        public Input<int>? HaAdmissionControlSlotPolicyExplicitMemory { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values
        /// to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines
        /// currently in the cluster.
        /// </summary>
        [Input("haAdmissionControlSlotPolicyUseExplicitSize")]
        public Input<bool>? HaAdmissionControlSlotPolicyUseExplicitSize { get; set; }

        [Input("haAdvancedOptions")]
        private InputMap<string>? _haAdvancedOptions;

        /// <summary>
        /// Advanced configuration options for vSphere HA.
        /// </summary>
        public InputMap<string> HaAdvancedOptions
        {
            get => _haAdvancedOptions ?? (_haAdvancedOptions = new InputMap<string>());
            set => _haAdvancedOptions = value;
        }

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an
        /// affected datastore clears in the middle of an APD event. Can be one of none or reset.
        /// </summary>
        [Input("haDatastoreApdRecoveryAction")]
        public Input<string>? HaDatastoreApdRecoveryAction { get; set; }

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
        /// detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or
        /// restartAggressive.
        /// </summary>
        [Input("haDatastoreApdResponse")]
        public Input<string>? HaDatastoreApdResponse { get; set; }

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute
        /// the response action defined in ha_datastore_apd_response.
        /// </summary>
        [Input("haDatastoreApdResponseDelay")]
        public Input<int>? HaDatastoreApdResponseDelay { get; set; }

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
        /// detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
        /// </summary>
        [Input("haDatastorePdlResponse")]
        public Input<string>? HaDatastorePdlResponse { get; set; }

        /// <summary>
        /// Enable vSphere HA for this cluster.
        /// </summary>
        [Input("haEnabled")]
        public Input<bool>? HaEnabled { get; set; }

        [Input("haHeartbeatDatastoreIds")]
        private InputList<string>? _haHeartbeatDatastoreIds;

        /// <summary>
        /// The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when
        /// ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
        /// </summary>
        public InputList<string> HaHeartbeatDatastoreIds
        {
            get => _haHeartbeatDatastoreIds ?? (_haHeartbeatDatastoreIds = new InputList<string>());
            set => _haHeartbeatDatastoreIds = value;
        }

        /// <summary>
        /// The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or
        /// allFeasibleDsWithUserPreference.
        /// </summary>
        [Input("haHeartbeatDatastorePolicy")]
        public Input<string>? HaHeartbeatDatastorePolicy { get; set; }

        /// <summary>
        /// The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.
        /// Can be one of none, powerOff, or shutdown.
        /// </summary>
        [Input("haHostIsolationResponse")]
        public Input<string>? HaHostIsolationResponse { get; set; }

        /// <summary>
        /// Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
        /// </summary>
        [Input("haHostMonitoring")]
        public Input<string>? HaHostMonitoring { get; set; }

        /// <summary>
        /// Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to
        /// failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
        /// </summary>
        [Input("haVmComponentProtection")]
        public Input<string>? HaVmComponentProtection { get; set; }

        /// <summary>
        /// The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move
        /// on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
        /// </summary>
        [Input("haVmDependencyRestartCondition")]
        public Input<string>? HaVmDependencyRestartCondition { get; set; }

        /// <summary>
        /// If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as
        /// failed. The value is in seconds.
        /// </summary>
        [Input("haVmFailureInterval")]
        public Input<int>? HaVmFailureInterval { get; set; }

        /// <summary>
        /// The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are
        /// attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset
        /// time is allotted.
        /// </summary>
        [Input("haVmMaximumFailureWindow")]
        public Input<int>? HaVmMaximumFailureWindow { get; set; }

        /// <summary>
        /// The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
        /// </summary>
        [Input("haVmMaximumResets")]
        public Input<int>? HaVmMaximumResets { get; set; }

        /// <summary>
        /// The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
        /// </summary>
        [Input("haVmMinimumUptime")]
        public Input<int>? HaVmMinimumUptime { get; set; }

        /// <summary>
        /// The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,
        /// vmMonitoringOnly, or vmAndAppMonitoring.
        /// </summary>
        [Input("haVmMonitoring")]
        public Input<string>? HaVmMonitoring { get; set; }

        /// <summary>
        /// Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
        /// </summary>
        [Input("haVmRestartAdditionalDelay")]
        public Input<int>? HaVmRestartAdditionalDelay { get; set; }

        /// <summary>
        /// The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,
        /// high, or highest.
        /// </summary>
        [Input("haVmRestartPriority")]
        public Input<string>? HaVmRestartPriority { get; set; }

        /// <summary>
        /// The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before
        /// proceeding with the next priority.
        /// </summary>
        [Input("haVmRestartTimeout")]
        public Input<int>? HaVmRestartTimeout { get; set; }

        /// <summary>
        /// The timeout for each host maintenance mode operation when removing hosts from a cluster.
        /// </summary>
        [Input("hostClusterExitTimeout")]
        public Input<int>? HostClusterExitTimeout { get; set; }

        /// <summary>
        /// Details about the host image which should be applied to the cluster.
        /// </summary>
        [Input("hostImage")]
        public Input<Inputs.ComputeClusterHostImageArgs>? HostImage { get; set; }

        /// <summary>
        /// Must be set if cluster enrollment is managed from host resource.
        /// </summary>
        [Input("hostManaged")]
        public Input<bool>? HostManaged { get; set; }

        [Input("hostSystemIds")]
        private InputList<string>? _hostSystemIds;

        /// <summary>
        /// The managed object IDs of the hosts to put in the cluster.
        /// </summary>
        public InputList<string> HostSystemIds
        {
            get => _hostSystemIds ?? (_hostSystemIds = new InputList<string>());
            set => _hostSystemIds = value;
        }

        /// <summary>
        /// The name of the cluster.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
        /// </summary>
        [Input("proactiveHaAutomationLevel")]
        public Input<string>? ProactiveHaAutomationLevel { get; set; }

        /// <summary>
        /// Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
        /// </summary>
        [Input("proactiveHaEnabled")]
        public Input<bool>? ProactiveHaEnabled { get; set; }

        /// <summary>
        /// The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that
        /// this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.
        /// </summary>
        [Input("proactiveHaModerateRemediation")]
        public Input<string>? ProactiveHaModerateRemediation { get; set; }

        [Input("proactiveHaProviderIds")]
        private InputList<string>? _proactiveHaProviderIds;

        /// <summary>
        /// The list of IDs for health update providers configured for this cluster.
        /// </summary>
        public InputList<string> ProactiveHaProviderIds
        {
            get => _proactiveHaProviderIds ?? (_proactiveHaProviderIds = new InputList<string>());
            set => _proactiveHaProviderIds = value;
        }

        /// <summary>
        /// The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this
        /// cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.
        /// </summary>
        [Input("proactiveHaSevereRemediation")]
        public Input<string>? ProactiveHaSevereRemediation { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Whether the vSAN compression service is enabled for the cluster.
        /// </summary>
        [Input("vsanCompressionEnabled")]
        public Input<bool>? VsanCompressionEnabled { get; set; }

        /// <summary>
        /// Whether the vSAN deduplication service is enabled for the cluster.
        /// </summary>
        [Input("vsanDedupEnabled")]
        public Input<bool>? VsanDedupEnabled { get; set; }

        [Input("vsanDiskGroups")]
        private InputList<Inputs.ComputeClusterVsanDiskGroupArgs>? _vsanDiskGroups;

        /// <summary>
        /// A list of disk UUIDs to add to the vSAN cluster.
        /// </summary>
        public InputList<Inputs.ComputeClusterVsanDiskGroupArgs> VsanDiskGroups
        {
            get => _vsanDiskGroups ?? (_vsanDiskGroups = new InputList<Inputs.ComputeClusterVsanDiskGroupArgs>());
            set => _vsanDiskGroups = value;
        }

        /// <summary>
        /// Whether the vSAN data-in-transit encryption is enabled for the cluster.
        /// </summary>
        [Input("vsanDitEncryptionEnabled")]
        public Input<bool>? VsanDitEncryptionEnabled { get; set; }

        /// <summary>
        /// When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
        /// </summary>
        [Input("vsanDitRekeyInterval")]
        public Input<int>? VsanDitRekeyInterval { get; set; }

        /// <summary>
        /// Whether the vSAN service is enabled for the cluster.
        /// </summary>
        [Input("vsanEnabled")]
        public Input<bool>? VsanEnabled { get; set; }

        /// <summary>
        /// Whether the vSAN ESA service is enabled for the cluster.
        /// </summary>
        [Input("vsanEsaEnabled")]
        public Input<bool>? VsanEsaEnabled { get; set; }

        [Input("vsanFaultDomains")]
        private InputList<Inputs.ComputeClusterVsanFaultDomainArgs>? _vsanFaultDomains;

        /// <summary>
        /// The configuration for vSAN fault domains.
        /// </summary>
        public InputList<Inputs.ComputeClusterVsanFaultDomainArgs> VsanFaultDomains
        {
            get => _vsanFaultDomains ?? (_vsanFaultDomains = new InputList<Inputs.ComputeClusterVsanFaultDomainArgs>());
            set => _vsanFaultDomains = value;
        }

        /// <summary>
        /// Whether the vSAN network diagnostic mode is enabled for the cluster.
        /// </summary>
        [Input("vsanNetworkDiagnosticModeEnabled")]
        public Input<bool>? VsanNetworkDiagnosticModeEnabled { get; set; }

        /// <summary>
        /// Whether the vSAN performance service is enabled for the cluster.
        /// </summary>
        [Input("vsanPerformanceEnabled")]
        public Input<bool>? VsanPerformanceEnabled { get; set; }

        [Input("vsanRemoteDatastoreIds")]
        private InputList<string>? _vsanRemoteDatastoreIds;

        /// <summary>
        /// The managed object IDs of the vSAN datastore to be mounted on the cluster.
        /// </summary>
        public InputList<string> VsanRemoteDatastoreIds
        {
            get => _vsanRemoteDatastoreIds ?? (_vsanRemoteDatastoreIds = new InputList<string>());
            set => _vsanRemoteDatastoreIds = value;
        }

        /// <summary>
        /// The configuration for stretched cluster.
        /// </summary>
        [Input("vsanStretchedCluster")]
        public Input<Inputs.ComputeClusterVsanStretchedClusterArgs>? VsanStretchedCluster { get; set; }

        /// <summary>
        /// Whether the vSAN unmap service is enabled for the cluster.
        /// </summary>
        [Input("vsanUnmapEnabled")]
        public Input<bool>? VsanUnmapEnabled { get; set; }

        /// <summary>
        /// Whether the vSAN verbose mode is enabled for the cluster.
        /// </summary>
        [Input("vsanVerboseModeEnabled")]
        public Input<bool>? VsanVerboseModeEnabled { get; set; }

        public ComputeClusterArgs()
        {
        }
        public static new ComputeClusterArgs Empty => new ComputeClusterArgs();
    }

    public sealed class ComputeClusterState : global::Pulumi.ResourceArgs
    {
        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// A map of custom attribute ids to attribute
        /// value strings to set for the datastore cluster.
        /// 
        /// &gt; **NOTE:** Custom attributes are unsupported on direct ESXi connections
        /// and require vCenter Server.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// The managed object ID of
        /// the datacenter to create the cluster in. Forces a new resource if changed.
        /// </summary>
        [Input("datacenterId")]
        public Input<string>? DatacenterId { get; set; }

        /// <summary>
        /// The automation level for host power operations in this cluster. Can be one of manual or automated.
        /// </summary>
        [Input("dpmAutomationLevel")]
        public Input<string>? DpmAutomationLevel { get; set; }

        /// <summary>
        /// Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual
        /// machines in the cluster. Requires that DRS be enabled.
        /// </summary>
        [Input("dpmEnabled")]
        public Input<bool>? DpmEnabled { get; set; }

        /// <summary>
        /// A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This
        /// affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher
        /// setting.
        /// </summary>
        [Input("dpmThreshold")]
        public Input<int>? DpmThreshold { get; set; }

        [Input("drsAdvancedOptions")]
        private InputMap<string>? _drsAdvancedOptions;

        /// <summary>
        /// Advanced configuration options for DRS and DPM.
        /// </summary>
        public InputMap<string> DrsAdvancedOptions
        {
            get => _drsAdvancedOptions ?? (_drsAdvancedOptions = new InputMap<string>());
            set => _drsAdvancedOptions = value;
        }

        /// <summary>
        /// The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or
        /// fullyAutomated.
        /// </summary>
        [Input("drsAutomationLevel")]
        public Input<string>? DrsAutomationLevel { get; set; }

        /// <summary>
        /// When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
        /// </summary>
        [Input("drsEnablePredictiveDrs")]
        public Input<bool>? DrsEnablePredictiveDrs { get; set; }

        /// <summary>
        /// When true, allows individual VM overrides within this cluster to be set.
        /// </summary>
        [Input("drsEnableVmOverrides")]
        public Input<bool>? DrsEnableVmOverrides { get; set; }

        /// <summary>
        /// Enable DRS for this cluster.
        /// </summary>
        [Input("drsEnabled")]
        public Input<bool>? DrsEnabled { get; set; }

        /// <summary>
        /// A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate
        /// more imbalance while a higher setting will tolerate less.
        /// </summary>
        [Input("drsMigrationThreshold")]
        public Input<int>? DrsMigrationThreshold { get; set; }

        /// <summary>
        /// Enable scalable shares for all descendants of this cluster.
        /// </summary>
        [Input("drsScaleDescendantsShares")]
        public Input<string>? DrsScaleDescendantsShares { get; set; }

        /// <summary>
        /// The relative path to a folder to put this cluster in.
        /// This is a path relative to the datacenter you are deploying the cluster to.
        /// Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
        /// The provider will place a cluster named `compute-cluster-test` in a
        /// host folder located at `/dc1/host/foo/bar`, with the final inventory path
        /// being `/dc1/host/foo/bar/datastore-cluster-test`.
        /// </summary>
        [Input("folder")]
        public Input<string>? Folder { get; set; }

        /// <summary>
        /// Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists
        /// for testing and is not recommended in normal use.
        /// </summary>
        [Input("forceEvacuateOnDestroy")]
        public Input<bool>? ForceEvacuateOnDestroy { get; set; }

        [Input("haAdmissionControlFailoverHostSystemIds")]
        private InputList<string>? _haAdmissionControlFailoverHostSystemIds;

        /// <summary>
        /// When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated
        /// failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS
        /// will ignore the host when making recommendations.
        /// </summary>
        public InputList<string> HaAdmissionControlFailoverHostSystemIds
        {
            get => _haAdmissionControlFailoverHostSystemIds ?? (_haAdmissionControlFailoverHostSystemIds = new InputList<string>());
            set => _haAdmissionControlFailoverHostSystemIds = value;
        }

        /// <summary>
        /// The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual
        /// machine operations. The maximum is one less than the number of hosts in the cluster.
        /// </summary>
        [Input("haAdmissionControlHostFailureTolerance")]
        public Input<int>? HaAdmissionControlHostFailureTolerance { get; set; }

        /// <summary>
        /// The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces
        /// warnings only, whereas a value of 100 disables the setting.
        /// </summary>
        [Input("haAdmissionControlPerformanceTolerance")]
        public Input<int>? HaAdmissionControlPerformanceTolerance { get; set; }

        /// <summary>
        /// The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are
        /// permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,
        /// slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service
        /// issues.
        /// </summary>
        [Input("haAdmissionControlPolicy")]
        public Input<string>? HaAdmissionControlPolicy { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by
        /// subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting
        /// from the total amount of resources in the cluster. Disable to supply user-defined values.
        /// </summary>
        [Input("haAdmissionControlResourcePercentageAutoCompute")]
        public Input<bool>? HaAdmissionControlResourcePercentageAutoCompute { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in
        /// the cluster to reserve for failover.
        /// </summary>
        [Input("haAdmissionControlResourcePercentageCpu")]
        public Input<int>? HaAdmissionControlResourcePercentageCpu { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in
        /// the cluster to reserve for failover.
        /// </summary>
        [Input("haAdmissionControlResourcePercentageMemory")]
        public Input<int>? HaAdmissionControlResourcePercentageMemory { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
        /// </summary>
        [Input("haAdmissionControlSlotPolicyExplicitCpu")]
        public Input<int>? HaAdmissionControlSlotPolicyExplicitCpu { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.
        /// </summary>
        [Input("haAdmissionControlSlotPolicyExplicitMemory")]
        public Input<int>? HaAdmissionControlSlotPolicyExplicitMemory { get; set; }

        /// <summary>
        /// When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values
        /// to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines
        /// currently in the cluster.
        /// </summary>
        [Input("haAdmissionControlSlotPolicyUseExplicitSize")]
        public Input<bool>? HaAdmissionControlSlotPolicyUseExplicitSize { get; set; }

        [Input("haAdvancedOptions")]
        private InputMap<string>? _haAdvancedOptions;

        /// <summary>
        /// Advanced configuration options for vSphere HA.
        /// </summary>
        public InputMap<string> HaAdvancedOptions
        {
            get => _haAdvancedOptions ?? (_haAdvancedOptions = new InputMap<string>());
            set => _haAdvancedOptions = value;
        }

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an
        /// affected datastore clears in the middle of an APD event. Can be one of none or reset.
        /// </summary>
        [Input("haDatastoreApdRecoveryAction")]
        public Input<string>? HaDatastoreApdRecoveryAction { get; set; }

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
        /// detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or
        /// restartAggressive.
        /// </summary>
        [Input("haDatastoreApdResponse")]
        public Input<string>? HaDatastoreApdResponse { get; set; }

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute
        /// the response action defined in ha_datastore_apd_response.
        /// </summary>
        [Input("haDatastoreApdResponseDelay")]
        public Input<int>? HaDatastoreApdResponseDelay { get; set; }

        /// <summary>
        /// When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has
        /// detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
        /// </summary>
        [Input("haDatastorePdlResponse")]
        public Input<string>? HaDatastorePdlResponse { get; set; }

        /// <summary>
        /// Enable vSphere HA for this cluster.
        /// </summary>
        [Input("haEnabled")]
        public Input<bool>? HaEnabled { get; set; }

        [Input("haHeartbeatDatastoreIds")]
        private InputList<string>? _haHeartbeatDatastoreIds;

        /// <summary>
        /// The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when
        /// ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
        /// </summary>
        public InputList<string> HaHeartbeatDatastoreIds
        {
            get => _haHeartbeatDatastoreIds ?? (_haHeartbeatDatastoreIds = new InputList<string>());
            set => _haHeartbeatDatastoreIds = value;
        }

        /// <summary>
        /// The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or
        /// allFeasibleDsWithUserPreference.
        /// </summary>
        [Input("haHeartbeatDatastorePolicy")]
        public Input<string>? HaHeartbeatDatastorePolicy { get; set; }

        /// <summary>
        /// The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.
        /// Can be one of none, powerOff, or shutdown.
        /// </summary>
        [Input("haHostIsolationResponse")]
        public Input<string>? HaHostIsolationResponse { get; set; }

        /// <summary>
        /// Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
        /// </summary>
        [Input("haHostMonitoring")]
        public Input<string>? HaHostMonitoring { get; set; }

        /// <summary>
        /// Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to
        /// failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
        /// </summary>
        [Input("haVmComponentProtection")]
        public Input<string>? HaVmComponentProtection { get; set; }

        /// <summary>
        /// The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move
        /// on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
        /// </summary>
        [Input("haVmDependencyRestartCondition")]
        public Input<string>? HaVmDependencyRestartCondition { get; set; }

        /// <summary>
        /// If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as
        /// failed. The value is in seconds.
        /// </summary>
        [Input("haVmFailureInterval")]
        public Input<int>? HaVmFailureInterval { get; set; }

        /// <summary>
        /// The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are
        /// attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset
        /// time is allotted.
        /// </summary>
        [Input("haVmMaximumFailureWindow")]
        public Input<int>? HaVmMaximumFailureWindow { get; set; }

        /// <summary>
        /// The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
        /// </summary>
        [Input("haVmMaximumResets")]
        public Input<int>? HaVmMaximumResets { get; set; }

        /// <summary>
        /// The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
        /// </summary>
        [Input("haVmMinimumUptime")]
        public Input<int>? HaVmMinimumUptime { get; set; }

        /// <summary>
        /// The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,
        /// vmMonitoringOnly, or vmAndAppMonitoring.
        /// </summary>
        [Input("haVmMonitoring")]
        public Input<string>? HaVmMonitoring { get; set; }

        /// <summary>
        /// Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
        /// </summary>
        [Input("haVmRestartAdditionalDelay")]
        public Input<int>? HaVmRestartAdditionalDelay { get; set; }

        /// <summary>
        /// The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,
        /// high, or highest.
        /// </summary>
        [Input("haVmRestartPriority")]
        public Input<string>? HaVmRestartPriority { get; set; }

        /// <summary>
        /// The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before
        /// proceeding with the next priority.
        /// </summary>
        [Input("haVmRestartTimeout")]
        public Input<int>? HaVmRestartTimeout { get; set; }

        /// <summary>
        /// The timeout for each host maintenance mode operation when removing hosts from a cluster.
        /// </summary>
        [Input("hostClusterExitTimeout")]
        public Input<int>? HostClusterExitTimeout { get; set; }

        /// <summary>
        /// Details about the host image which should be applied to the cluster.
        /// </summary>
        [Input("hostImage")]
        public Input<Inputs.ComputeClusterHostImageGetArgs>? HostImage { get; set; }

        /// <summary>
        /// Must be set if cluster enrollment is managed from host resource.
        /// </summary>
        [Input("hostManaged")]
        public Input<bool>? HostManaged { get; set; }

        [Input("hostSystemIds")]
        private InputList<string>? _hostSystemIds;

        /// <summary>
        /// The managed object IDs of the hosts to put in the cluster.
        /// </summary>
        public InputList<string> HostSystemIds
        {
            get => _hostSystemIds ?? (_hostSystemIds = new InputList<string>());
            set => _hostSystemIds = value;
        }

        /// <summary>
        /// The name of the cluster.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
        /// </summary>
        [Input("proactiveHaAutomationLevel")]
        public Input<string>? ProactiveHaAutomationLevel { get; set; }

        /// <summary>
        /// Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
        /// </summary>
        [Input("proactiveHaEnabled")]
        public Input<bool>? ProactiveHaEnabled { get; set; }

        /// <summary>
        /// The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that
        /// this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.
        /// </summary>
        [Input("proactiveHaModerateRemediation")]
        public Input<string>? ProactiveHaModerateRemediation { get; set; }

        [Input("proactiveHaProviderIds")]
        private InputList<string>? _proactiveHaProviderIds;

        /// <summary>
        /// The list of IDs for health update providers configured for this cluster.
        /// </summary>
        public InputList<string> ProactiveHaProviderIds
        {
            get => _proactiveHaProviderIds ?? (_proactiveHaProviderIds = new InputList<string>());
            set => _proactiveHaProviderIds = value;
        }

        /// <summary>
        /// The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this
        /// cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.
        /// </summary>
        [Input("proactiveHaSevereRemediation")]
        public Input<string>? ProactiveHaSevereRemediation { get; set; }

        /// <summary>
        /// The managed object ID of the primary
        /// resource pool for this cluster. This can be passed directly to the
        /// `resource_pool_id`
        /// attribute of the
        /// `vsphere.VirtualMachine` resource.
        /// </summary>
        [Input("resourcePoolId")]
        public Input<string>? ResourcePoolId { get; set; }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// The IDs of any tags to attach to this resource.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// Whether the vSAN compression service is enabled for the cluster.
        /// </summary>
        [Input("vsanCompressionEnabled")]
        public Input<bool>? VsanCompressionEnabled { get; set; }

        /// <summary>
        /// Whether the vSAN deduplication service is enabled for the cluster.
        /// </summary>
        [Input("vsanDedupEnabled")]
        public Input<bool>? VsanDedupEnabled { get; set; }

        [Input("vsanDiskGroups")]
        private InputList<Inputs.ComputeClusterVsanDiskGroupGetArgs>? _vsanDiskGroups;

        /// <summary>
        /// A list of disk UUIDs to add to the vSAN cluster.
        /// </summary>
        public InputList<Inputs.ComputeClusterVsanDiskGroupGetArgs> VsanDiskGroups
        {
            get => _vsanDiskGroups ?? (_vsanDiskGroups = new InputList<Inputs.ComputeClusterVsanDiskGroupGetArgs>());
            set => _vsanDiskGroups = value;
        }

        /// <summary>
        /// Whether the vSAN data-in-transit encryption is enabled for the cluster.
        /// </summary>
        [Input("vsanDitEncryptionEnabled")]
        public Input<bool>? VsanDitEncryptionEnabled { get; set; }

        /// <summary>
        /// When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
        /// </summary>
        [Input("vsanDitRekeyInterval")]
        public Input<int>? VsanDitRekeyInterval { get; set; }

        /// <summary>
        /// Whether the vSAN service is enabled for the cluster.
        /// </summary>
        [Input("vsanEnabled")]
        public Input<bool>? VsanEnabled { get; set; }

        /// <summary>
        /// Whether the vSAN ESA service is enabled for the cluster.
        /// </summary>
        [Input("vsanEsaEnabled")]
        public Input<bool>? VsanEsaEnabled { get; set; }

        [Input("vsanFaultDomains")]
        private InputList<Inputs.ComputeClusterVsanFaultDomainGetArgs>? _vsanFaultDomains;

        /// <summary>
        /// The configuration for vSAN fault domains.
        /// </summary>
        public InputList<Inputs.ComputeClusterVsanFaultDomainGetArgs> VsanFaultDomains
        {
            get => _vsanFaultDomains ?? (_vsanFaultDomains = new InputList<Inputs.ComputeClusterVsanFaultDomainGetArgs>());
            set => _vsanFaultDomains = value;
        }

        /// <summary>
        /// Whether the vSAN network diagnostic mode is enabled for the cluster.
        /// </summary>
        [Input("vsanNetworkDiagnosticModeEnabled")]
        public Input<bool>? VsanNetworkDiagnosticModeEnabled { get; set; }

        /// <summary>
        /// Whether the vSAN performance service is enabled for the cluster.
        /// </summary>
        [Input("vsanPerformanceEnabled")]
        public Input<bool>? VsanPerformanceEnabled { get; set; }

        [Input("vsanRemoteDatastoreIds")]
        private InputList<string>? _vsanRemoteDatastoreIds;

        /// <summary>
        /// The managed object IDs of the vSAN datastore to be mounted on the cluster.
        /// </summary>
        public InputList<string> VsanRemoteDatastoreIds
        {
            get => _vsanRemoteDatastoreIds ?? (_vsanRemoteDatastoreIds = new InputList<string>());
            set => _vsanRemoteDatastoreIds = value;
        }

        /// <summary>
        /// The configuration for stretched cluster.
        /// </summary>
        [Input("vsanStretchedCluster")]
        public Input<Inputs.ComputeClusterVsanStretchedClusterGetArgs>? VsanStretchedCluster { get; set; }

        /// <summary>
        /// Whether the vSAN unmap service is enabled for the cluster.
        /// </summary>
        [Input("vsanUnmapEnabled")]
        public Input<bool>? VsanUnmapEnabled { get; set; }

        /// <summary>
        /// Whether the vSAN verbose mode is enabled for the cluster.
        /// </summary>
        [Input("vsanVerboseModeEnabled")]
        public Input<bool>? VsanVerboseModeEnabled { get; set; }

        public ComputeClusterState()
        {
        }
        public static new ComputeClusterState Empty => new ComputeClusterState();
    }
}
