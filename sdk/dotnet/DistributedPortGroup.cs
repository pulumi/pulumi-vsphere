// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.VSphere
{
    /// <summary>
    /// The `vsphere.DistributedPortGroup` resource can be used to manage
    /// distributed port groups connected to vSphere Distributed Switches (VDS).
    /// A vSphere Distributed Switch can be managed by the
    /// [`vsphere.DistributedVirtualSwitch`][distributed-virtual-switch] resource.
    /// 
    /// Distributed port groups can be used as networks for virtual machines, allowing
    /// the virtual machines to use the networking supplied by a vSphere Distributed
    /// Switch, with a set of policies that apply to that individual network, if
    /// desired.
    /// 
    /// * For an overview on vSphere networking concepts, refer to the vSphere
    /// [product documentation][ref-vsphere-net-concepts].
    /// 
    /// * For more information on distributed port groups, refer to the vSphere
    /// [product documentation][ref-vsphere-dvportgroup].
    /// 
    /// [distributed-virtual-switch]: /docs/providers/vsphere/r/distributed_virtual_switch.html
    /// [ref-vsphere-net-concepts]: hhttps://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/introduction-to-vsphere-networking.html
    /// [ref-vsphere-dvportgroup]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches/dvport-groups.html
    /// 
    /// &gt; **NOTE:** This resource requires vCenter and is not available on
    /// direct ESXi host connections.
    /// 
    /// ## Example Usage
    /// 
    /// The configuration below builds on the example given in the
    /// [`vsphere.DistributedVirtualSwitch`][distributed-virtual-switch] resource by
    /// adding the `vsphere.DistributedPortGroup` resource, attaching itself to the
    /// vSphere Distributed Switch and assigning VLAN ID 1000.
    /// 
    /// ### Overriding VDS policies
    /// 
    /// All of the [default port policies][vds-default-port-policies] available in the
    /// `vsphere.DistributedVirtualSwitch` resource can be overridden on the port
    /// group level by specifying new settings for them.
    /// 
    /// [vds-default-port-policies]: /docs/providers/vsphere/r/distributed_virtual_switch.html#default-port-group-policy-arguments
    /// 
    /// As an example, we also take this example from the
    /// `vsphere.DistributedVirtualSwitch` resource where we manually specify our
    /// uplink count and uplink order. While the vSphere Distributed Switch has a
    /// default policy of using the first uplink as an active uplink and the second
    /// one as a standby, the overridden port group policy means that both uplinks
    /// will be used as active uplinks in this specific port group.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using VSphere = Pulumi.VSphere;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var vds = new VSphere.DistributedVirtualSwitch("vds", new()
    ///     {
    ///         Name = "vds-01",
    ///         DatacenterId = datacenter.Id,
    ///         Uplinks = new[]
    ///         {
    ///             "uplink1",
    ///             "uplink2",
    ///         },
    ///         ActiveUplinks = new[]
    ///         {
    ///             "uplink1",
    ///         },
    ///         StandbyUplinks = new[]
    ///         {
    ///             "uplink2",
    ///         },
    ///     });
    /// 
    ///     var pg = new VSphere.DistributedPortGroup("pg", new()
    ///     {
    ///         Name = "pg-01",
    ///         DistributedVirtualSwitchUuid = vds.Id,
    ///         VlanId = 1000,
    ///         ActiveUplinks = new[]
    ///         {
    ///             "uplink1",
    ///             "uplink2",
    ///         },
    ///         StandbyUplinks = new[] {},
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// An existing port group can be imported into this resource using
    /// 
    /// the managed object id of the port group, via the following command:
    /// 
    /// [docs-import]: https://developer.hashicorp.com/terraform/cli/import
    /// 
    /// ```sh
    /// $ pulumi import vsphere:index/distributedPortGroup:DistributedPortGroup pg /dc-01/network/pg-01
    /// ```
    /// 
    /// The above would import the port group named `pg-01` that is located in the `dc-01`
    /// 
    /// datacenter.
    /// </summary>
    [VSphereResourceType("vsphere:index/distributedPortGroup:DistributedPortGroup")]
    public partial class DistributedPortGroup : global::Pulumi.CustomResource
    {
        /// <summary>
        /// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        [Output("activeUplinks")]
        public Output<ImmutableArray<string>> ActiveUplinks { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
        /// </summary>
        [Output("allowForgedTransmits")]
        public Output<bool> AllowForgedTransmits { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the Media Access Control (MAC) address can be changed.
        /// </summary>
        [Output("allowMacChanges")]
        public Output<bool> AllowMacChanges { get; private set; } = null!;

        /// <summary>
        /// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Output("allowPromiscuous")]
        public Output<bool> AllowPromiscuous { get; private set; } = null!;

        /// <summary>
        /// Allows the port group to create additional ports
        /// past the limit specified in `NumberOfPorts` if necessary. Default: `True`.
        /// 
        /// &gt; **NOTE:** Using `AutoExpand` with a statically defined `NumberOfPorts`
        /// may lead to errors when the port count grows past the amount specified.  If you
        /// specify `NumberOfPorts`, you may wish to set `AutoExpand` to `False`.
        /// </summary>
        [Output("autoExpand")]
        public Output<bool?> AutoExpand { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to block all ports by default.
        /// </summary>
        [Output("blockAllPorts")]
        public Output<bool> BlockAllPorts { get; private set; } = null!;

        /// <summary>
        /// Allow the blocked setting of an individual port to override the setting in the portgroup.
        /// </summary>
        [Output("blockOverrideAllowed")]
        public Output<bool?> BlockOverrideAllowed { get; private set; } = null!;

        /// <summary>
        /// Enable beacon probing on the ports this policy applies to.
        /// </summary>
        [Output("checkBeacon")]
        public Output<bool> CheckBeacon { get; private set; } = null!;

        /// <summary>
        /// The current version of the port group configuration,
        /// incremented by subsequent updates to the port group.
        /// </summary>
        [Output("configVersion")]
        public Output<string> ConfigVersion { get; private set; } = null!;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value string to set for port group. See [here][docs-setting-custom-attributes]
        /// for a reference on how to set values for custom attributes.
        /// 
        /// [docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource
        /// 
        /// &gt; **NOTE:** Custom attributes are not supported on direct ESXi host
        /// connections and require vCenter Server.
        /// </summary>
        [Output("customAttributes")]
        public Output<ImmutableDictionary<string, string>?> CustomAttributes { get; private set; } = null!;

        /// <summary>
        /// An optional description for the port group.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// Allow VMDirectPath Gen2 on the ports this policy applies to.
        /// </summary>
        [Output("directpathGen2Allowed")]
        public Output<bool> DirectpathGen2Allowed { get; private set; } = null!;

        /// <summary>
        /// The ID of the VDS to add the
        /// port group to. Forces a new resource if changed.
        /// </summary>
        [Output("distributedVirtualSwitchUuid")]
        public Output<string> DistributedVirtualSwitchUuid { get; private set; } = null!;

        /// <summary>
        /// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingAverageBandwidth")]
        public Output<int> EgressShapingAverageBandwidth { get; private set; } = null!;

        /// <summary>
        /// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingBurstSize")]
        public Output<int> EgressShapingBurstSize { get; private set; } = null!;

        /// <summary>
        /// True if the traffic shaper is enabled for egress traffic on the port.
        /// </summary>
        [Output("egressShapingEnabled")]
        public Output<bool> EgressShapingEnabled { get; private set; } = null!;

        /// <summary>
        /// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Output("egressShapingPeakBandwidth")]
        public Output<int> EgressShapingPeakBandwidth { get; private set; } = null!;

        /// <summary>
        /// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
        /// </summary>
        [Output("failback")]
        public Output<bool> Failback { get; private set; } = null!;

        /// <summary>
        /// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingAverageBandwidth")]
        public Output<int> IngressShapingAverageBandwidth { get; private set; } = null!;

        /// <summary>
        /// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingBurstSize")]
        public Output<int> IngressShapingBurstSize { get; private set; } = null!;

        /// <summary>
        /// True if the traffic shaper is enabled for ingress traffic on the port.
        /// </summary>
        [Output("ingressShapingEnabled")]
        public Output<bool> IngressShapingEnabled { get; private set; } = null!;

        /// <summary>
        /// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Output("ingressShapingPeakBandwidth")]
        public Output<int> IngressShapingPeakBandwidth { get; private set; } = null!;

        /// <summary>
        /// The generated UUID of the port group.
        /// </summary>
        [Output("key")]
        public Output<string> Key { get; private set; } = null!;

        /// <summary>
        /// Whether or not to enable LACP on all uplink ports.
        /// </summary>
        [Output("lacpEnabled")]
        public Output<bool> LacpEnabled { get; private set; } = null!;

        /// <summary>
        /// The uplink LACP mode to use. Can be one of active or passive.
        /// </summary>
        [Output("lacpMode")]
        public Output<string> LacpMode { get; private set; } = null!;

        /// <summary>
        /// Allow a live port to be moved in and out of the portgroup.
        /// </summary>
        [Output("livePortMovingAllowed")]
        public Output<bool?> LivePortMovingAllowed { get; private set; } = null!;

        /// <summary>
        /// The name of the port group.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Indicates whether to enable netflow on all ports.
        /// </summary>
        [Output("netflowEnabled")]
        public Output<bool> NetflowEnabled { get; private set; } = null!;

        /// <summary>
        /// Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.
        /// </summary>
        [Output("netflowOverrideAllowed")]
        public Output<bool?> NetflowOverrideAllowed { get; private set; } = null!;

        /// <summary>
        /// The key of a network resource pool
        /// to associate with this port group. The default is `-1`, which implies no
        /// association.
        /// </summary>
        [Output("networkResourcePoolKey")]
        public Output<string?> NetworkResourcePoolKey { get; private set; } = null!;

        /// <summary>
        /// Allow the network resource pool of an individual port to override the setting in the portgroup.
        /// </summary>
        [Output("networkResourcePoolOverrideAllowed")]
        public Output<bool?> NetworkResourcePoolOverrideAllowed { get; private set; } = null!;

        /// <summary>
        /// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
        /// </summary>
        [Output("notifySwitches")]
        public Output<bool> NotifySwitches { get; private set; } = null!;

        /// <summary>
        /// The number of ports available on this port
        /// group. Cannot be decreased below the amount of used ports on the port group.
        /// </summary>
        [Output("numberOfPorts")]
        public Output<int> NumberOfPorts { get; private set; } = null!;

        /// <summary>
        /// Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.
        /// </summary>
        [Output("portConfigResetAtDisconnect")]
        public Output<bool?> PortConfigResetAtDisconnect { get; private set; } = null!;

        /// <summary>
        /// An optional formatting policy for naming of
        /// the ports in this port group. See the `portNameFormat` attribute listed
        /// [here][ext-vsphere-portname-format] for details on the format syntax.
        /// 
        /// [ext-vsphere-portname-format]: https://developer.broadcom.com/xapis/virtual-infrastructure-json-api/latest/data-structures/DVPortgroupConfigInfo/
        /// </summary>
        [Output("portNameFormat")]
        public Output<string?> PortNameFormat { get; private set; } = null!;

        /// <summary>
        /// The secondary VLAN ID for this port.
        /// </summary>
        [Output("portPrivateSecondaryVlanId")]
        public Output<int> PortPrivateSecondaryVlanId { get; private set; } = null!;

        /// <summary>
        /// Allow security policy settings on a port to override those on the portgroup.
        /// </summary>
        [Output("securityPolicyOverrideAllowed")]
        public Output<bool?> SecurityPolicyOverrideAllowed { get; private set; } = null!;

        /// <summary>
        /// Allow the traffic shaping policies of an individual port to override the settings in the portgroup.
        /// </summary>
        [Output("shapingOverrideAllowed")]
        public Output<bool?> ShapingOverrideAllowed { get; private set; } = null!;

        /// <summary>
        /// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        [Output("standbyUplinks")]
        public Output<ImmutableArray<string>> StandbyUplinks { get; private set; } = null!;

        /// <summary>
        /// A list of tag IDs to apply to this object.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<string>> Tags { get; private set; } = null!;

        /// <summary>
        /// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
        /// </summary>
        [Output("teamingPolicy")]
        public Output<string> TeamingPolicy { get; private set; } = null!;

        /// <summary>
        /// Allow any filter policies set on the individual port to override those in the portgroup.
        /// </summary>
        [Output("trafficFilterOverrideAllowed")]
        public Output<bool?> TrafficFilterOverrideAllowed { get; private set; } = null!;

        /// <summary>
        /// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
        /// </summary>
        [Output("txUplink")]
        public Output<bool> TxUplink { get; private set; } = null!;

        /// <summary>
        /// The port group type. Can be one of `earlyBinding` (static
        /// binding) or `Ephemeral`. Default: `earlyBinding`.
        /// </summary>
        [Output("type")]
        public Output<string?> Type { get; private set; } = null!;

        /// <summary>
        /// Allow the uplink teaming policies on a port to override those on the portgroup.
        /// </summary>
        [Output("uplinkTeamingOverrideAllowed")]
        public Output<bool?> UplinkTeamingOverrideAllowed { get; private set; } = null!;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Output("vlanId")]
        public Output<int> VlanId { get; private set; } = null!;

        /// <summary>
        /// Allow the VLAN configuration on a port to override those on the portgroup.
        /// </summary>
        [Output("vlanOverrideAllowed")]
        public Output<bool?> VlanOverrideAllowed { get; private set; } = null!;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Output("vlanRanges")]
        public Output<ImmutableArray<Outputs.DistributedPortGroupVlanRange>> VlanRanges { get; private set; } = null!;


        /// <summary>
        /// Create a DistributedPortGroup resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public DistributedPortGroup(string name, DistributedPortGroupArgs args, CustomResourceOptions? options = null)
            : base("vsphere:index/distributedPortGroup:DistributedPortGroup", name, args ?? new DistributedPortGroupArgs(), MakeResourceOptions(options, ""))
        {
        }

        private DistributedPortGroup(string name, Input<string> id, DistributedPortGroupState? state = null, CustomResourceOptions? options = null)
            : base("vsphere:index/distributedPortGroup:DistributedPortGroup", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing DistributedPortGroup resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static DistributedPortGroup Get(string name, Input<string> id, DistributedPortGroupState? state = null, CustomResourceOptions? options = null)
        {
            return new DistributedPortGroup(name, id, state, options);
        }
    }

    public sealed class DistributedPortGroupArgs : global::Pulumi.ResourceArgs
    {
        [Input("activeUplinks")]
        private InputList<string>? _activeUplinks;

        /// <summary>
        /// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        public InputList<string> ActiveUplinks
        {
            get => _activeUplinks ?? (_activeUplinks = new InputList<string>());
            set => _activeUplinks = value;
        }

        /// <summary>
        /// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access Control (MAC) address can be changed.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// Allows the port group to create additional ports
        /// past the limit specified in `NumberOfPorts` if necessary. Default: `True`.
        /// 
        /// &gt; **NOTE:** Using `AutoExpand` with a statically defined `NumberOfPorts`
        /// may lead to errors when the port count grows past the amount specified.  If you
        /// specify `NumberOfPorts`, you may wish to set `AutoExpand` to `False`.
        /// </summary>
        [Input("autoExpand")]
        public Input<bool>? AutoExpand { get; set; }

        /// <summary>
        /// Indicates whether to block all ports by default.
        /// </summary>
        [Input("blockAllPorts")]
        public Input<bool>? BlockAllPorts { get; set; }

        /// <summary>
        /// Allow the blocked setting of an individual port to override the setting in the portgroup.
        /// </summary>
        [Input("blockOverrideAllowed")]
        public Input<bool>? BlockOverrideAllowed { get; set; }

        /// <summary>
        /// Enable beacon probing on the ports this policy applies to.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value string to set for port group. See [here][docs-setting-custom-attributes]
        /// for a reference on how to set values for custom attributes.
        /// 
        /// [docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource
        /// 
        /// &gt; **NOTE:** Custom attributes are not supported on direct ESXi host
        /// connections and require vCenter Server.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// An optional description for the port group.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Allow VMDirectPath Gen2 on the ports this policy applies to.
        /// </summary>
        [Input("directpathGen2Allowed")]
        public Input<bool>? DirectpathGen2Allowed { get; set; }

        /// <summary>
        /// The ID of the VDS to add the
        /// port group to. Forces a new resource if changed.
        /// </summary>
        [Input("distributedVirtualSwitchUuid", required: true)]
        public Input<string> DistributedVirtualSwitchUuid { get; set; } = null!;

        /// <summary>
        /// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingAverageBandwidth")]
        public Input<int>? EgressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingBurstSize")]
        public Input<int>? EgressShapingBurstSize { get; set; }

        /// <summary>
        /// True if the traffic shaper is enabled for egress traffic on the port.
        /// </summary>
        [Input("egressShapingEnabled")]
        public Input<bool>? EgressShapingEnabled { get; set; }

        /// <summary>
        /// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingPeakBandwidth")]
        public Input<int>? EgressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingAverageBandwidth")]
        public Input<int>? IngressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingBurstSize")]
        public Input<int>? IngressShapingBurstSize { get; set; }

        /// <summary>
        /// True if the traffic shaper is enabled for ingress traffic on the port.
        /// </summary>
        [Input("ingressShapingEnabled")]
        public Input<bool>? IngressShapingEnabled { get; set; }

        /// <summary>
        /// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingPeakBandwidth")]
        public Input<int>? IngressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// Whether or not to enable LACP on all uplink ports.
        /// </summary>
        [Input("lacpEnabled")]
        public Input<bool>? LacpEnabled { get; set; }

        /// <summary>
        /// The uplink LACP mode to use. Can be one of active or passive.
        /// </summary>
        [Input("lacpMode")]
        public Input<string>? LacpMode { get; set; }

        /// <summary>
        /// Allow a live port to be moved in and out of the portgroup.
        /// </summary>
        [Input("livePortMovingAllowed")]
        public Input<bool>? LivePortMovingAllowed { get; set; }

        /// <summary>
        /// The name of the port group.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Indicates whether to enable netflow on all ports.
        /// </summary>
        [Input("netflowEnabled")]
        public Input<bool>? NetflowEnabled { get; set; }

        /// <summary>
        /// Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.
        /// </summary>
        [Input("netflowOverrideAllowed")]
        public Input<bool>? NetflowOverrideAllowed { get; set; }

        /// <summary>
        /// The key of a network resource pool
        /// to associate with this port group. The default is `-1`, which implies no
        /// association.
        /// </summary>
        [Input("networkResourcePoolKey")]
        public Input<string>? NetworkResourcePoolKey { get; set; }

        /// <summary>
        /// Allow the network resource pool of an individual port to override the setting in the portgroup.
        /// </summary>
        [Input("networkResourcePoolOverrideAllowed")]
        public Input<bool>? NetworkResourcePoolOverrideAllowed { get; set; }

        /// <summary>
        /// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// The number of ports available on this port
        /// group. Cannot be decreased below the amount of used ports on the port group.
        /// </summary>
        [Input("numberOfPorts")]
        public Input<int>? NumberOfPorts { get; set; }

        /// <summary>
        /// Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.
        /// </summary>
        [Input("portConfigResetAtDisconnect")]
        public Input<bool>? PortConfigResetAtDisconnect { get; set; }

        /// <summary>
        /// An optional formatting policy for naming of
        /// the ports in this port group. See the `portNameFormat` attribute listed
        /// [here][ext-vsphere-portname-format] for details on the format syntax.
        /// 
        /// [ext-vsphere-portname-format]: https://developer.broadcom.com/xapis/virtual-infrastructure-json-api/latest/data-structures/DVPortgroupConfigInfo/
        /// </summary>
        [Input("portNameFormat")]
        public Input<string>? PortNameFormat { get; set; }

        /// <summary>
        /// The secondary VLAN ID for this port.
        /// </summary>
        [Input("portPrivateSecondaryVlanId")]
        public Input<int>? PortPrivateSecondaryVlanId { get; set; }

        /// <summary>
        /// Allow security policy settings on a port to override those on the portgroup.
        /// </summary>
        [Input("securityPolicyOverrideAllowed")]
        public Input<bool>? SecurityPolicyOverrideAllowed { get; set; }

        /// <summary>
        /// Allow the traffic shaping policies of an individual port to override the settings in the portgroup.
        /// </summary>
        [Input("shapingOverrideAllowed")]
        public Input<bool>? ShapingOverrideAllowed { get; set; }

        [Input("standbyUplinks")]
        private InputList<string>? _standbyUplinks;

        /// <summary>
        /// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        public InputList<string> StandbyUplinks
        {
            get => _standbyUplinks ?? (_standbyUplinks = new InputList<string>());
            set => _standbyUplinks = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tag IDs to apply to this object.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        /// <summary>
        /// Allow any filter policies set on the individual port to override those in the portgroup.
        /// </summary>
        [Input("trafficFilterOverrideAllowed")]
        public Input<bool>? TrafficFilterOverrideAllowed { get; set; }

        /// <summary>
        /// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
        /// </summary>
        [Input("txUplink")]
        public Input<bool>? TxUplink { get; set; }

        /// <summary>
        /// The port group type. Can be one of `earlyBinding` (static
        /// binding) or `Ephemeral`. Default: `earlyBinding`.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// Allow the uplink teaming policies on a port to override those on the portgroup.
        /// </summary>
        [Input("uplinkTeamingOverrideAllowed")]
        public Input<bool>? UplinkTeamingOverrideAllowed { get; set; }

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Input("vlanId")]
        public Input<int>? VlanId { get; set; }

        /// <summary>
        /// Allow the VLAN configuration on a port to override those on the portgroup.
        /// </summary>
        [Input("vlanOverrideAllowed")]
        public Input<bool>? VlanOverrideAllowed { get; set; }

        [Input("vlanRanges")]
        private InputList<Inputs.DistributedPortGroupVlanRangeArgs>? _vlanRanges;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        public InputList<Inputs.DistributedPortGroupVlanRangeArgs> VlanRanges
        {
            get => _vlanRanges ?? (_vlanRanges = new InputList<Inputs.DistributedPortGroupVlanRangeArgs>());
            set => _vlanRanges = value;
        }

        public DistributedPortGroupArgs()
        {
        }
        public static new DistributedPortGroupArgs Empty => new DistributedPortGroupArgs();
    }

    public sealed class DistributedPortGroupState : global::Pulumi.ResourceArgs
    {
        [Input("activeUplinks")]
        private InputList<string>? _activeUplinks;

        /// <summary>
        /// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        public InputList<string> ActiveUplinks
        {
            get => _activeUplinks ?? (_activeUplinks = new InputList<string>());
            set => _activeUplinks = value;
        }

        /// <summary>
        /// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access Control (MAC) address can be changed.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// Allows the port group to create additional ports
        /// past the limit specified in `NumberOfPorts` if necessary. Default: `True`.
        /// 
        /// &gt; **NOTE:** Using `AutoExpand` with a statically defined `NumberOfPorts`
        /// may lead to errors when the port count grows past the amount specified.  If you
        /// specify `NumberOfPorts`, you may wish to set `AutoExpand` to `False`.
        /// </summary>
        [Input("autoExpand")]
        public Input<bool>? AutoExpand { get; set; }

        /// <summary>
        /// Indicates whether to block all ports by default.
        /// </summary>
        [Input("blockAllPorts")]
        public Input<bool>? BlockAllPorts { get; set; }

        /// <summary>
        /// Allow the blocked setting of an individual port to override the setting in the portgroup.
        /// </summary>
        [Input("blockOverrideAllowed")]
        public Input<bool>? BlockOverrideAllowed { get; set; }

        /// <summary>
        /// Enable beacon probing on the ports this policy applies to.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        /// <summary>
        /// The current version of the port group configuration,
        /// incremented by subsequent updates to the port group.
        /// </summary>
        [Input("configVersion")]
        public Input<string>? ConfigVersion { get; set; }

        [Input("customAttributes")]
        private InputMap<string>? _customAttributes;

        /// <summary>
        /// Map of custom attribute ids to attribute
        /// value string to set for port group. See [here][docs-setting-custom-attributes]
        /// for a reference on how to set values for custom attributes.
        /// 
        /// [docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource
        /// 
        /// &gt; **NOTE:** Custom attributes are not supported on direct ESXi host
        /// connections and require vCenter Server.
        /// </summary>
        public InputMap<string> CustomAttributes
        {
            get => _customAttributes ?? (_customAttributes = new InputMap<string>());
            set => _customAttributes = value;
        }

        /// <summary>
        /// An optional description for the port group.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Allow VMDirectPath Gen2 on the ports this policy applies to.
        /// </summary>
        [Input("directpathGen2Allowed")]
        public Input<bool>? DirectpathGen2Allowed { get; set; }

        /// <summary>
        /// The ID of the VDS to add the
        /// port group to. Forces a new resource if changed.
        /// </summary>
        [Input("distributedVirtualSwitchUuid")]
        public Input<string>? DistributedVirtualSwitchUuid { get; set; }

        /// <summary>
        /// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingAverageBandwidth")]
        public Input<int>? EgressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingBurstSize")]
        public Input<int>? EgressShapingBurstSize { get; set; }

        /// <summary>
        /// True if the traffic shaper is enabled for egress traffic on the port.
        /// </summary>
        [Input("egressShapingEnabled")]
        public Input<bool>? EgressShapingEnabled { get; set; }

        /// <summary>
        /// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
        /// </summary>
        [Input("egressShapingPeakBandwidth")]
        public Input<int>? EgressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingAverageBandwidth")]
        public Input<int>? IngressShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingBurstSize")]
        public Input<int>? IngressShapingBurstSize { get; set; }

        /// <summary>
        /// True if the traffic shaper is enabled for ingress traffic on the port.
        /// </summary>
        [Input("ingressShapingEnabled")]
        public Input<bool>? IngressShapingEnabled { get; set; }

        /// <summary>
        /// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
        /// </summary>
        [Input("ingressShapingPeakBandwidth")]
        public Input<int>? IngressShapingPeakBandwidth { get; set; }

        /// <summary>
        /// The generated UUID of the port group.
        /// </summary>
        [Input("key")]
        public Input<string>? Key { get; set; }

        /// <summary>
        /// Whether or not to enable LACP on all uplink ports.
        /// </summary>
        [Input("lacpEnabled")]
        public Input<bool>? LacpEnabled { get; set; }

        /// <summary>
        /// The uplink LACP mode to use. Can be one of active or passive.
        /// </summary>
        [Input("lacpMode")]
        public Input<string>? LacpMode { get; set; }

        /// <summary>
        /// Allow a live port to be moved in and out of the portgroup.
        /// </summary>
        [Input("livePortMovingAllowed")]
        public Input<bool>? LivePortMovingAllowed { get; set; }

        /// <summary>
        /// The name of the port group.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Indicates whether to enable netflow on all ports.
        /// </summary>
        [Input("netflowEnabled")]
        public Input<bool>? NetflowEnabled { get; set; }

        /// <summary>
        /// Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.
        /// </summary>
        [Input("netflowOverrideAllowed")]
        public Input<bool>? NetflowOverrideAllowed { get; set; }

        /// <summary>
        /// The key of a network resource pool
        /// to associate with this port group. The default is `-1`, which implies no
        /// association.
        /// </summary>
        [Input("networkResourcePoolKey")]
        public Input<string>? NetworkResourcePoolKey { get; set; }

        /// <summary>
        /// Allow the network resource pool of an individual port to override the setting in the portgroup.
        /// </summary>
        [Input("networkResourcePoolOverrideAllowed")]
        public Input<bool>? NetworkResourcePoolOverrideAllowed { get; set; }

        /// <summary>
        /// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// The number of ports available on this port
        /// group. Cannot be decreased below the amount of used ports on the port group.
        /// </summary>
        [Input("numberOfPorts")]
        public Input<int>? NumberOfPorts { get; set; }

        /// <summary>
        /// Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.
        /// </summary>
        [Input("portConfigResetAtDisconnect")]
        public Input<bool>? PortConfigResetAtDisconnect { get; set; }

        /// <summary>
        /// An optional formatting policy for naming of
        /// the ports in this port group. See the `portNameFormat` attribute listed
        /// [here][ext-vsphere-portname-format] for details on the format syntax.
        /// 
        /// [ext-vsphere-portname-format]: https://developer.broadcom.com/xapis/virtual-infrastructure-json-api/latest/data-structures/DVPortgroupConfigInfo/
        /// </summary>
        [Input("portNameFormat")]
        public Input<string>? PortNameFormat { get; set; }

        /// <summary>
        /// The secondary VLAN ID for this port.
        /// </summary>
        [Input("portPrivateSecondaryVlanId")]
        public Input<int>? PortPrivateSecondaryVlanId { get; set; }

        /// <summary>
        /// Allow security policy settings on a port to override those on the portgroup.
        /// </summary>
        [Input("securityPolicyOverrideAllowed")]
        public Input<bool>? SecurityPolicyOverrideAllowed { get; set; }

        /// <summary>
        /// Allow the traffic shaping policies of an individual port to override the settings in the portgroup.
        /// </summary>
        [Input("shapingOverrideAllowed")]
        public Input<bool>? ShapingOverrideAllowed { get; set; }

        [Input("standbyUplinks")]
        private InputList<string>? _standbyUplinks;

        /// <summary>
        /// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
        /// </summary>
        public InputList<string> StandbyUplinks
        {
            get => _standbyUplinks ?? (_standbyUplinks = new InputList<string>());
            set => _standbyUplinks = value;
        }

        [Input("tags")]
        private InputList<string>? _tags;

        /// <summary>
        /// A list of tag IDs to apply to this object.
        /// </summary>
        public InputList<string> Tags
        {
            get => _tags ?? (_tags = new InputList<string>());
            set => _tags = value;
        }

        /// <summary>
        /// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        /// <summary>
        /// Allow any filter policies set on the individual port to override those in the portgroup.
        /// </summary>
        [Input("trafficFilterOverrideAllowed")]
        public Input<bool>? TrafficFilterOverrideAllowed { get; set; }

        /// <summary>
        /// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
        /// </summary>
        [Input("txUplink")]
        public Input<bool>? TxUplink { get; set; }

        /// <summary>
        /// The port group type. Can be one of `earlyBinding` (static
        /// binding) or `Ephemeral`. Default: `earlyBinding`.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// Allow the uplink teaming policies on a port to override those on the portgroup.
        /// </summary>
        [Input("uplinkTeamingOverrideAllowed")]
        public Input<bool>? UplinkTeamingOverrideAllowed { get; set; }

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        [Input("vlanId")]
        public Input<int>? VlanId { get; set; }

        /// <summary>
        /// Allow the VLAN configuration on a port to override those on the portgroup.
        /// </summary>
        [Input("vlanOverrideAllowed")]
        public Input<bool>? VlanOverrideAllowed { get; set; }

        [Input("vlanRanges")]
        private InputList<Inputs.DistributedPortGroupVlanRangeGetArgs>? _vlanRanges;

        /// <summary>
        /// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        /// </summary>
        public InputList<Inputs.DistributedPortGroupVlanRangeGetArgs> VlanRanges
        {
            get => _vlanRanges ?? (_vlanRanges = new InputList<Inputs.DistributedPortGroupVlanRangeGetArgs>());
            set => _vlanRanges = value;
        }

        public DistributedPortGroupState()
        {
        }
        public static new DistributedPortGroupState Empty => new DistributedPortGroupState();
    }
}
