// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.VSphere
{
    /// <summary>
    /// The `vsphere..HostVirtualSwitch` resource can be used to manage vSphere
    /// standard switches on an ESXi host. These switches can be used as a backing for
    /// standard port groups, which can be managed by the
    /// `vsphere..HostPortGroup` resource.
    /// 
    /// For an overview on vSphere networking concepts, see [this
    /// page][ref-vsphere-net-concepts].
    /// 
    /// [ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html
    /// </summary>
    public partial class HostVirtualSwitch : Pulumi.CustomResource
    {
        /// <summary>
        /// The list of active network adapters used for load
        /// balancing.
        /// </summary>
        [Output("activeNics")]
        public Output<ImmutableArray<string>> ActiveNics { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the virtual
        /// network adapter is allowed to send network traffic with a different MAC
        /// address than that of its own. Default: `true`.
        /// </summary>
        [Output("allowForgedTransmits")]
        public Output<bool?> AllowForgedTransmits { get; private set; } = null!;

        /// <summary>
        /// Controls whether or not the Media Access
        /// Control (MAC) address can be changed. Default: `true`.
        /// </summary>
        [Output("allowMacChanges")]
        public Output<bool?> AllowMacChanges { get; private set; } = null!;

        /// <summary>
        /// Enable promiscuous mode on the network. This
        /// flag indicates whether or not all traffic is seen on a given port. Default:
        /// `false`.
        /// </summary>
        [Output("allowPromiscuous")]
        public Output<bool?> AllowPromiscuous { get; private set; } = null!;

        /// <summary>
        /// The interval, in seconds, that a NIC beacon
        /// packet is sent out. This can be used with `check_beacon` to
        /// offer link failure capability beyond link status only. Default: `1`.
        /// </summary>
        [Output("beaconInterval")]
        public Output<int?> BeaconInterval { get; private set; } = null!;

        /// <summary>
        /// Enable beacon probing - this requires that the
        /// `beacon_interval` option has been set in the bridge
        /// options. If this is set to `false`, only link status is used to check for
        /// failed NICs.  Default: `false`.
        /// </summary>
        [Output("checkBeacon")]
        public Output<bool?> CheckBeacon { get; private set; } = null!;

        /// <summary>
        /// If set to `true`, the teaming policy will re-activate
        /// failed interfaces higher in precedence when they come back up.  Default:
        /// `true`.
        /// </summary>
        [Output("failback")]
        public Output<bool?> Failback { get; private set; } = null!;

        /// <summary>
        /// The managed object ID of
        /// the host to set the virtual switch up on. Forces a new resource if changed.
        /// </summary>
        [Output("hostSystemId")]
        public Output<string> HostSystemId { get; private set; } = null!;

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic. Default: `listen`.
        /// </summary>
        [Output("linkDiscoveryOperation")]
        public Output<string?> LinkDiscoveryOperation { get; private set; } = null!;

        /// <summary>
        /// The discovery protocol type.  Valid
        /// types are `cpd` and `lldp`. Default: `cdp`.
        /// </summary>
        [Output("linkDiscoveryProtocol")]
        public Output<string?> LinkDiscoveryProtocol { get; private set; } = null!;

        /// <summary>
        /// The maximum transmission unit (MTU) for the virtual
        /// switch. Default: `1500`.
        /// </summary>
        [Output("mtu")]
        public Output<int?> Mtu { get; private set; } = null!;

        /// <summary>
        /// The name of the virtual switch. Forces a new resource if
        /// changed.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The network interfaces to bind to the bridge.
        /// </summary>
        [Output("networkAdapters")]
        public Output<ImmutableArray<string>> NetworkAdapters { get; private set; } = null!;

        /// <summary>
        /// If set to `true`, the teaming policy will
        /// notify the broadcast network of a NIC failover, triggering cache updates.
        /// Default: `true`.
        /// </summary>
        [Output("notifySwitches")]
        public Output<bool?> NotifySwitches { get; private set; } = null!;

        /// <summary>
        /// The number of ports to create with this
        /// virtual switch. Default: `128`.
        /// </summary>
        [Output("numberOfPorts")]
        public Output<int?> NumberOfPorts { get; private set; } = null!;

        /// <summary>
        /// The average bandwidth in bits per
        /// second if traffic shaping is enabled. Default: `0`
        /// </summary>
        [Output("shapingAverageBandwidth")]
        public Output<int?> ShapingAverageBandwidth { get; private set; } = null!;

        /// <summary>
        /// The maximum burst size allowed in bytes if
        /// shaping is enabled. Default: `0`
        /// </summary>
        [Output("shapingBurstSize")]
        public Output<int?> ShapingBurstSize { get; private set; } = null!;

        /// <summary>
        /// Set to `true` to enable the traffic shaper for
        /// ports managed by this virtual switch. Default: `false`.
        /// </summary>
        [Output("shapingEnabled")]
        public Output<bool?> ShapingEnabled { get; private set; } = null!;

        /// <summary>
        /// The peak bandwidth during bursts in
        /// bits per second if traffic shaping is enabled. Default: `0`
        /// </summary>
        [Output("shapingPeakBandwidth")]
        public Output<int?> ShapingPeakBandwidth { get; private set; } = null!;

        /// <summary>
        /// The list of standby network adapters used for
        /// failover.
        /// </summary>
        [Output("standbyNics")]
        public Output<ImmutableArray<string>> StandbyNics { get; private set; } = null!;

        /// <summary>
        /// The network adapter teaming policy. Can be one
        /// of `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
        /// `failover_explicit`. Default: `loadbalance_srcid`.
        /// </summary>
        [Output("teamingPolicy")]
        public Output<string?> TeamingPolicy { get; private set; } = null!;


        /// <summary>
        /// Create a HostVirtualSwitch resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public HostVirtualSwitch(string name, HostVirtualSwitchArgs args, CustomResourceOptions? options = null)
            : base("vsphere:index/hostVirtualSwitch:HostVirtualSwitch", name, args ?? new HostVirtualSwitchArgs(), MakeResourceOptions(options, ""))
        {
        }

        private HostVirtualSwitch(string name, Input<string> id, HostVirtualSwitchState? state = null, CustomResourceOptions? options = null)
            : base("vsphere:index/hostVirtualSwitch:HostVirtualSwitch", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing HostVirtualSwitch resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static HostVirtualSwitch Get(string name, Input<string> id, HostVirtualSwitchState? state = null, CustomResourceOptions? options = null)
        {
            return new HostVirtualSwitch(name, id, state, options);
        }
    }

    public sealed class HostVirtualSwitchArgs : Pulumi.ResourceArgs
    {
        [Input("activeNics", required: true)]
        private InputList<string>? _activeNics;

        /// <summary>
        /// The list of active network adapters used for load
        /// balancing.
        /// </summary>
        public InputList<string> ActiveNics
        {
            get => _activeNics ?? (_activeNics = new InputList<string>());
            set => _activeNics = value;
        }

        /// <summary>
        /// Controls whether or not the virtual
        /// network adapter is allowed to send network traffic with a different MAC
        /// address than that of its own. Default: `true`.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access
        /// Control (MAC) address can be changed. Default: `true`.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This
        /// flag indicates whether or not all traffic is seen on a given port. Default:
        /// `false`.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// The interval, in seconds, that a NIC beacon
        /// packet is sent out. This can be used with `check_beacon` to
        /// offer link failure capability beyond link status only. Default: `1`.
        /// </summary>
        [Input("beaconInterval")]
        public Input<int>? BeaconInterval { get; set; }

        /// <summary>
        /// Enable beacon probing - this requires that the
        /// `beacon_interval` option has been set in the bridge
        /// options. If this is set to `false`, only link status is used to check for
        /// failed NICs.  Default: `false`.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        /// <summary>
        /// If set to `true`, the teaming policy will re-activate
        /// failed interfaces higher in precedence when they come back up.  Default:
        /// `true`.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The managed object ID of
        /// the host to set the virtual switch up on. Forces a new resource if changed.
        /// </summary>
        [Input("hostSystemId", required: true)]
        public Input<string> HostSystemId { get; set; } = null!;

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic. Default: `listen`.
        /// </summary>
        [Input("linkDiscoveryOperation")]
        public Input<string>? LinkDiscoveryOperation { get; set; }

        /// <summary>
        /// The discovery protocol type.  Valid
        /// types are `cpd` and `lldp`. Default: `cdp`.
        /// </summary>
        [Input("linkDiscoveryProtocol")]
        public Input<string>? LinkDiscoveryProtocol { get; set; }

        /// <summary>
        /// The maximum transmission unit (MTU) for the virtual
        /// switch. Default: `1500`.
        /// </summary>
        [Input("mtu")]
        public Input<int>? Mtu { get; set; }

        /// <summary>
        /// The name of the virtual switch. Forces a new resource if
        /// changed.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkAdapters", required: true)]
        private InputList<string>? _networkAdapters;

        /// <summary>
        /// The network interfaces to bind to the bridge.
        /// </summary>
        public InputList<string> NetworkAdapters
        {
            get => _networkAdapters ?? (_networkAdapters = new InputList<string>());
            set => _networkAdapters = value;
        }

        /// <summary>
        /// If set to `true`, the teaming policy will
        /// notify the broadcast network of a NIC failover, triggering cache updates.
        /// Default: `true`.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// The number of ports to create with this
        /// virtual switch. Default: `128`.
        /// </summary>
        [Input("numberOfPorts")]
        public Input<int>? NumberOfPorts { get; set; }

        /// <summary>
        /// The average bandwidth in bits per
        /// second if traffic shaping is enabled. Default: `0`
        /// </summary>
        [Input("shapingAverageBandwidth")]
        public Input<int>? ShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in bytes if
        /// shaping is enabled. Default: `0`
        /// </summary>
        [Input("shapingBurstSize")]
        public Input<int>? ShapingBurstSize { get; set; }

        /// <summary>
        /// Set to `true` to enable the traffic shaper for
        /// ports managed by this virtual switch. Default: `false`.
        /// </summary>
        [Input("shapingEnabled")]
        public Input<bool>? ShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during bursts in
        /// bits per second if traffic shaping is enabled. Default: `0`
        /// </summary>
        [Input("shapingPeakBandwidth")]
        public Input<int>? ShapingPeakBandwidth { get; set; }

        [Input("standbyNics", required: true)]
        private InputList<string>? _standbyNics;

        /// <summary>
        /// The list of standby network adapters used for
        /// failover.
        /// </summary>
        public InputList<string> StandbyNics
        {
            get => _standbyNics ?? (_standbyNics = new InputList<string>());
            set => _standbyNics = value;
        }

        /// <summary>
        /// The network adapter teaming policy. Can be one
        /// of `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
        /// `failover_explicit`. Default: `loadbalance_srcid`.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        public HostVirtualSwitchArgs()
        {
        }
    }

    public sealed class HostVirtualSwitchState : Pulumi.ResourceArgs
    {
        [Input("activeNics")]
        private InputList<string>? _activeNics;

        /// <summary>
        /// The list of active network adapters used for load
        /// balancing.
        /// </summary>
        public InputList<string> ActiveNics
        {
            get => _activeNics ?? (_activeNics = new InputList<string>());
            set => _activeNics = value;
        }

        /// <summary>
        /// Controls whether or not the virtual
        /// network adapter is allowed to send network traffic with a different MAC
        /// address than that of its own. Default: `true`.
        /// </summary>
        [Input("allowForgedTransmits")]
        public Input<bool>? AllowForgedTransmits { get; set; }

        /// <summary>
        /// Controls whether or not the Media Access
        /// Control (MAC) address can be changed. Default: `true`.
        /// </summary>
        [Input("allowMacChanges")]
        public Input<bool>? AllowMacChanges { get; set; }

        /// <summary>
        /// Enable promiscuous mode on the network. This
        /// flag indicates whether or not all traffic is seen on a given port. Default:
        /// `false`.
        /// </summary>
        [Input("allowPromiscuous")]
        public Input<bool>? AllowPromiscuous { get; set; }

        /// <summary>
        /// The interval, in seconds, that a NIC beacon
        /// packet is sent out. This can be used with `check_beacon` to
        /// offer link failure capability beyond link status only. Default: `1`.
        /// </summary>
        [Input("beaconInterval")]
        public Input<int>? BeaconInterval { get; set; }

        /// <summary>
        /// Enable beacon probing - this requires that the
        /// `beacon_interval` option has been set in the bridge
        /// options. If this is set to `false`, only link status is used to check for
        /// failed NICs.  Default: `false`.
        /// </summary>
        [Input("checkBeacon")]
        public Input<bool>? CheckBeacon { get; set; }

        /// <summary>
        /// If set to `true`, the teaming policy will re-activate
        /// failed interfaces higher in precedence when they come back up.  Default:
        /// `true`.
        /// </summary>
        [Input("failback")]
        public Input<bool>? Failback { get; set; }

        /// <summary>
        /// The managed object ID of
        /// the host to set the virtual switch up on. Forces a new resource if changed.
        /// </summary>
        [Input("hostSystemId")]
        public Input<string>? HostSystemId { get; set; }

        /// <summary>
        /// Whether to `advertise` or `listen`
        /// for link discovery traffic. Default: `listen`.
        /// </summary>
        [Input("linkDiscoveryOperation")]
        public Input<string>? LinkDiscoveryOperation { get; set; }

        /// <summary>
        /// The discovery protocol type.  Valid
        /// types are `cpd` and `lldp`. Default: `cdp`.
        /// </summary>
        [Input("linkDiscoveryProtocol")]
        public Input<string>? LinkDiscoveryProtocol { get; set; }

        /// <summary>
        /// The maximum transmission unit (MTU) for the virtual
        /// switch. Default: `1500`.
        /// </summary>
        [Input("mtu")]
        public Input<int>? Mtu { get; set; }

        /// <summary>
        /// The name of the virtual switch. Forces a new resource if
        /// changed.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkAdapters")]
        private InputList<string>? _networkAdapters;

        /// <summary>
        /// The network interfaces to bind to the bridge.
        /// </summary>
        public InputList<string> NetworkAdapters
        {
            get => _networkAdapters ?? (_networkAdapters = new InputList<string>());
            set => _networkAdapters = value;
        }

        /// <summary>
        /// If set to `true`, the teaming policy will
        /// notify the broadcast network of a NIC failover, triggering cache updates.
        /// Default: `true`.
        /// </summary>
        [Input("notifySwitches")]
        public Input<bool>? NotifySwitches { get; set; }

        /// <summary>
        /// The number of ports to create with this
        /// virtual switch. Default: `128`.
        /// </summary>
        [Input("numberOfPorts")]
        public Input<int>? NumberOfPorts { get; set; }

        /// <summary>
        /// The average bandwidth in bits per
        /// second if traffic shaping is enabled. Default: `0`
        /// </summary>
        [Input("shapingAverageBandwidth")]
        public Input<int>? ShapingAverageBandwidth { get; set; }

        /// <summary>
        /// The maximum burst size allowed in bytes if
        /// shaping is enabled. Default: `0`
        /// </summary>
        [Input("shapingBurstSize")]
        public Input<int>? ShapingBurstSize { get; set; }

        /// <summary>
        /// Set to `true` to enable the traffic shaper for
        /// ports managed by this virtual switch. Default: `false`.
        /// </summary>
        [Input("shapingEnabled")]
        public Input<bool>? ShapingEnabled { get; set; }

        /// <summary>
        /// The peak bandwidth during bursts in
        /// bits per second if traffic shaping is enabled. Default: `0`
        /// </summary>
        [Input("shapingPeakBandwidth")]
        public Input<int>? ShapingPeakBandwidth { get; set; }

        [Input("standbyNics")]
        private InputList<string>? _standbyNics;

        /// <summary>
        /// The list of standby network adapters used for
        /// failover.
        /// </summary>
        public InputList<string> StandbyNics
        {
            get => _standbyNics ?? (_standbyNics = new InputList<string>());
            set => _standbyNics = value;
        }

        /// <summary>
        /// The network adapter teaming policy. Can be one
        /// of `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
        /// `failover_explicit`. Default: `loadbalance_srcid`.
        /// </summary>
        [Input("teamingPolicy")]
        public Input<string>? TeamingPolicy { get; set; }

        public HostVirtualSwitchState()
        {
        }
    }
}
