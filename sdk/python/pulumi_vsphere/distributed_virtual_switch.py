# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from . import _utilities, _tables
from . import outputs
from ._inputs import *

__all__ = ['DistributedVirtualSwitch']


class DistributedVirtualSwitch(pulumi.CustomResource):
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 active_uplinks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_forged_transmits: Optional[pulumi.Input[bool]] = None,
                 allow_mac_changes: Optional[pulumi.Input[bool]] = None,
                 allow_promiscuous: Optional[pulumi.Input[bool]] = None,
                 block_all_ports: Optional[pulumi.Input[bool]] = None,
                 check_beacon: Optional[pulumi.Input[bool]] = None,
                 contact_detail: Optional[pulumi.Input[str]] = None,
                 contact_name: Optional[pulumi.Input[str]] = None,
                 custom_attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 datacenter_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 directpath_gen2_allowed: Optional[pulumi.Input[bool]] = None,
                 egress_shaping_average_bandwidth: Optional[pulumi.Input[int]] = None,
                 egress_shaping_burst_size: Optional[pulumi.Input[int]] = None,
                 egress_shaping_enabled: Optional[pulumi.Input[bool]] = None,
                 egress_shaping_peak_bandwidth: Optional[pulumi.Input[int]] = None,
                 failback: Optional[pulumi.Input[bool]] = None,
                 faulttolerance_maximum_mbit: Optional[pulumi.Input[int]] = None,
                 faulttolerance_reservation_mbit: Optional[pulumi.Input[int]] = None,
                 faulttolerance_share_count: Optional[pulumi.Input[int]] = None,
                 faulttolerance_share_level: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None,
                 hbr_maximum_mbit: Optional[pulumi.Input[int]] = None,
                 hbr_reservation_mbit: Optional[pulumi.Input[int]] = None,
                 hbr_share_count: Optional[pulumi.Input[int]] = None,
                 hbr_share_level: Optional[pulumi.Input[str]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchHostArgs']]]]] = None,
                 ignore_other_pvlan_mappings: Optional[pulumi.Input[bool]] = None,
                 ingress_shaping_average_bandwidth: Optional[pulumi.Input[int]] = None,
                 ingress_shaping_burst_size: Optional[pulumi.Input[int]] = None,
                 ingress_shaping_enabled: Optional[pulumi.Input[bool]] = None,
                 ingress_shaping_peak_bandwidth: Optional[pulumi.Input[int]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None,
                 iscsi_maximum_mbit: Optional[pulumi.Input[int]] = None,
                 iscsi_reservation_mbit: Optional[pulumi.Input[int]] = None,
                 iscsi_share_count: Optional[pulumi.Input[int]] = None,
                 iscsi_share_level: Optional[pulumi.Input[str]] = None,
                 lacp_api_version: Optional[pulumi.Input[str]] = None,
                 lacp_enabled: Optional[pulumi.Input[bool]] = None,
                 lacp_mode: Optional[pulumi.Input[str]] = None,
                 link_discovery_operation: Optional[pulumi.Input[str]] = None,
                 link_discovery_protocol: Optional[pulumi.Input[str]] = None,
                 management_maximum_mbit: Optional[pulumi.Input[int]] = None,
                 management_reservation_mbit: Optional[pulumi.Input[int]] = None,
                 management_share_count: Optional[pulumi.Input[int]] = None,
                 management_share_level: Optional[pulumi.Input[str]] = None,
                 max_mtu: Optional[pulumi.Input[int]] = None,
                 multicast_filtering_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 netflow_active_flow_timeout: Optional[pulumi.Input[int]] = None,
                 netflow_collector_ip_address: Optional[pulumi.Input[str]] = None,
                 netflow_collector_port: Optional[pulumi.Input[int]] = None,
                 netflow_enabled: Optional[pulumi.Input[bool]] = None,
                 netflow_idle_flow_timeout: Optional[pulumi.Input[int]] = None,
                 netflow_internal_flows_only: Optional[pulumi.Input[bool]] = None,
                 netflow_observation_domain_id: Optional[pulumi.Input[int]] = None,
                 netflow_sampling_rate: Optional[pulumi.Input[int]] = None,
                 network_resource_control_enabled: Optional[pulumi.Input[bool]] = None,
                 network_resource_control_version: Optional[pulumi.Input[str]] = None,
                 nfs_maximum_mbit: Optional[pulumi.Input[int]] = None,
                 nfs_reservation_mbit: Optional[pulumi.Input[int]] = None,
                 nfs_share_count: Optional[pulumi.Input[int]] = None,
                 nfs_share_level: Optional[pulumi.Input[str]] = None,
                 notify_switches: Optional[pulumi.Input[bool]] = None,
                 port_private_secondary_vlan_id: Optional[pulumi.Input[int]] = None,
                 pvlan_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchPvlanMappingArgs']]]]] = None,
                 standby_uplinks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 teaming_policy: Optional[pulumi.Input[str]] = None,
                 tx_uplink: Optional[pulumi.Input[bool]] = None,
                 uplinks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vdp_maximum_mbit: Optional[pulumi.Input[int]] = None,
                 vdp_reservation_mbit: Optional[pulumi.Input[int]] = None,
                 vdp_share_count: Optional[pulumi.Input[int]] = None,
                 vdp_share_level: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None,
                 virtualmachine_maximum_mbit: Optional[pulumi.Input[int]] = None,
                 virtualmachine_reservation_mbit: Optional[pulumi.Input[int]] = None,
                 virtualmachine_share_count: Optional[pulumi.Input[int]] = None,
                 virtualmachine_share_level: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[int]] = None,
                 vlan_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchVlanRangeArgs']]]]] = None,
                 vmotion_maximum_mbit: Optional[pulumi.Input[int]] = None,
                 vmotion_reservation_mbit: Optional[pulumi.Input[int]] = None,
                 vmotion_share_count: Optional[pulumi.Input[int]] = None,
                 vmotion_share_level: Optional[pulumi.Input[str]] = None,
                 vsan_maximum_mbit: Optional[pulumi.Input[int]] = None,
                 vsan_reservation_mbit: Optional[pulumi.Input[int]] = None,
                 vsan_share_count: Optional[pulumi.Input[int]] = None,
                 vsan_share_level: Optional[pulumi.Input[str]] = None,
                 __props__=None,
                 __name__=None,
                 __opts__=None):
        """
        Create a DistributedVirtualSwitch resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] active_uplinks: A list of active uplinks to be used in load
               balancing. These uplinks need to match the definitions in the
               `uplinks` DVS argument. See
               here for more details.
        :param pulumi.Input[bool] allow_forged_transmits: Controls whether or not a virtual
               network adapter is allowed to send network traffic with a different MAC
               address than that of its own.
        :param pulumi.Input[bool] allow_mac_changes: Controls whether or not the Media Access
               Control (MAC) address can be changed.
        :param pulumi.Input[bool] allow_promiscuous: Enable promiscuous mode on the network. This
               flag indicates whether or not all traffic is seen on a given port.
        :param pulumi.Input[bool] block_all_ports: Shuts down all ports in the port groups that
               this policy applies to, effectively blocking all network access to connected
               virtual devices.
        :param pulumi.Input[bool] check_beacon: Enables beacon probing as an additional measure
               to detect NIC failure.
        :param pulumi.Input[str] contact_detail: The detailed contact information for the person
               who is responsible for the DVS.
        :param pulumi.Input[str] contact_name: The name of the person who is responsible for the
               DVS.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_attributes: Map of custom attribute ids to attribute
               value strings to set for virtual switch.
        :param pulumi.Input[str] datacenter_id: The ID of the datacenter where the distributed
               virtual switch will be created. Forces a new resource if changed.
        :param pulumi.Input[str] description: A detailed description for the DVS.
        :param pulumi.Input[bool] directpath_gen2_allowed: Allow VMDirectPath Gen2 for the ports
               for which this policy applies to.
        :param pulumi.Input[int] egress_shaping_average_bandwidth: The average bandwidth in bits
               per second if egress traffic shaping is enabled on the port.
        :param pulumi.Input[int] egress_shaping_burst_size: The maximum burst size allowed in
               bytes if egress traffic shaping is enabled on the port.
        :param pulumi.Input[bool] egress_shaping_enabled: `true` if the traffic shaper is enabled
               on the port for egress traffic.
        :param pulumi.Input[int] egress_shaping_peak_bandwidth: The peak bandwidth during bursts
               in bits per second if egress traffic shaping is enabled on the port.
        :param pulumi.Input[bool] failback: If `true`, the teaming policy will re-activate failed
               uplinks higher in precedence when they come back up.
        :param pulumi.Input[int] faulttolerance_maximum_mbit: The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        :param pulumi.Input[int] faulttolerance_reservation_mbit: The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        :param pulumi.Input[int] faulttolerance_share_count: The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        :param pulumi.Input[str] faulttolerance_share_level: The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[str] folder: The folder to create the DVS in. Forces a new resource
               if changed.
        :param pulumi.Input[int] hbr_maximum_mbit: The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        :param pulumi.Input[int] hbr_reservation_mbit: The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        :param pulumi.Input[int] hbr_share_count: The amount of shares to allocate to the hbr traffic class for a custom share level.
        :param pulumi.Input[str] hbr_share_level: The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchHostArgs']]]] hosts: Use the `host` block to declare a host specification. The
               options are:
        :param pulumi.Input[bool] ignore_other_pvlan_mappings: Whether to ignore existing PVLAN
               mappings not managed by this resource. Defaults to false.
        :param pulumi.Input[int] ingress_shaping_average_bandwidth: The average bandwidth in
               bits per second if ingress traffic shaping is enabled on the port.
        :param pulumi.Input[int] ingress_shaping_burst_size: The maximum burst size allowed in
               bytes if ingress traffic shaping is enabled on the port.
        :param pulumi.Input[bool] ingress_shaping_enabled: `true` if the traffic shaper is
               enabled on the port for ingress traffic.
        :param pulumi.Input[int] ingress_shaping_peak_bandwidth: The peak bandwidth during
               bursts in bits per second if ingress traffic shaping is enabled on the port.
        :param pulumi.Input[str] ipv4_address: An IPv4 address to identify the switch. This is
               mostly useful when used with the Netflow arguments found
               below.
        :param pulumi.Input[int] iscsi_maximum_mbit: The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        :param pulumi.Input[int] iscsi_reservation_mbit: The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        :param pulumi.Input[int] iscsi_share_count: The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        :param pulumi.Input[str] iscsi_share_level: The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[str] lacp_api_version: The Link Aggregation Control Protocol group
               version to use with the switch. Possible values are `singleLag` and
               `multipleLag`.
        :param pulumi.Input[bool] lacp_enabled: Enables LACP for the ports that this policy
               applies to.
        :param pulumi.Input[str] lacp_mode: The LACP mode. Can be one of `active` or `passive`.
        :param pulumi.Input[str] link_discovery_operation: Whether to `advertise` or `listen`
               for link discovery traffic.
        :param pulumi.Input[str] link_discovery_protocol: The discovery protocol type. Valid
               types are `cdp` and `lldp`.
        :param pulumi.Input[int] management_maximum_mbit: The maximum allowed usage for the management traffic class, in Mbits/sec.
        :param pulumi.Input[int] management_reservation_mbit: The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        :param pulumi.Input[int] management_share_count: The amount of shares to allocate to the management traffic class for a custom share level.
        :param pulumi.Input[str] management_share_level: The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[int] max_mtu: The maximum transmission unit (MTU) for the virtual
               switch.
        :param pulumi.Input[str] multicast_filtering_mode: The multicast filtering mode to use
               with the switch. Can be one of `legacyFiltering` or `snooping`.
        :param pulumi.Input[str] name: The name of the distributed virtual switch.
        :param pulumi.Input[int] netflow_active_flow_timeout: The number of seconds after which
               active flows are forced to be exported to the collector. Allowed range is
               `60` to `3600`. Default: `60`.
        :param pulumi.Input[str] netflow_collector_ip_address: IP address for the Netflow
               collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
               Switch Version 6.0 or later. Must be set before Netflow can be enabled.
        :param pulumi.Input[int] netflow_collector_port: Port for the Netflow collector. This
               must be set before Netflow can be enabled.
        :param pulumi.Input[bool] netflow_enabled: Enables Netflow on all ports that this policy
               applies to.
        :param pulumi.Input[int] netflow_idle_flow_timeout: The number of seconds after which
               idle flows are forced to be exported to the collector. Allowed range is `10`
               to `600`. Default: `15`.
        :param pulumi.Input[bool] netflow_internal_flows_only: Whether to limit analysis to
               traffic that has both source and destination served by the same host.
               Default: `false`.
        :param pulumi.Input[int] netflow_observation_domain_id: The observation domain ID for
               the Netflow collector.
        :param pulumi.Input[int] netflow_sampling_rate: The ratio of total number of packets to
               the number of packets analyzed. The default is `0`, which indicates that the
               switch should analyze all packets. The maximum value is `1000`, which
               indicates an analysis rate of 0.001%.
        :param pulumi.Input[bool] network_resource_control_enabled: Set to `true` to enable
               network I/O control. Default: `false`.
        :param pulumi.Input[str] network_resource_control_version: The version of network I/O
               control to use. Can be one of `version2` or `version3`. Default: `version2`.
        :param pulumi.Input[int] nfs_maximum_mbit: The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        :param pulumi.Input[int] nfs_reservation_mbit: The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        :param pulumi.Input[int] nfs_share_count: The amount of shares to allocate to the nfs traffic class for a custom share level.
        :param pulumi.Input[str] nfs_share_level: The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[bool] notify_switches: If `true`, the teaming policy will notify the
               broadcast network of an uplink failover, triggering cache updates.
        :param pulumi.Input[int] port_private_secondary_vlan_id: Used to define a secondary VLAN
               ID when using private VLANs.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchPvlanMappingArgs']]]] pvlan_mappings: Use the `pvlan_mapping` block to declare a
               private VLAN mapping. The options are:
        :param pulumi.Input[Sequence[pulumi.Input[str]]] standby_uplinks: A list of standby uplinks to be used in
               failover. These uplinks need to match the definitions in the
               `uplinks` DVS argument. See
               here for more details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: The IDs of any tags to attach to this resource.
        :param pulumi.Input[str] teaming_policy: The uplink teaming policy. Can be one of
               `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
               `failover_explicit`.
        :param pulumi.Input[bool] tx_uplink: Forward all traffic transmitted by ports for which
               this policy applies to its DVS uplinks.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] uplinks: A list of strings that uniquely identifies the names
               of the uplinks on the DVS across hosts. The number of items in this list
               controls the number of uplinks that exist on the DVS, in addition to the
               names.  See here for an example on how to
               use this option.
        :param pulumi.Input[int] vdp_maximum_mbit: The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        :param pulumi.Input[int] vdp_reservation_mbit: The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        :param pulumi.Input[int] vdp_share_count: The amount of shares to allocate to the vdp traffic class for a custom share level.
        :param pulumi.Input[str] vdp_share_level: The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[str] version: - The version of the DVS to create. The default is to
               create the DVS at the latest version supported by the version of vSphere
               being used. A DVS can be upgraded to another version, but cannot be
               downgraded.
        :param pulumi.Input[int] virtualmachine_maximum_mbit: The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        :param pulumi.Input[int] virtualmachine_reservation_mbit: The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        :param pulumi.Input[int] virtualmachine_share_count: The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        :param pulumi.Input[str] virtualmachine_share_level: The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[int] vlan_id: The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchVlanRangeArgs']]]] vlan_ranges: Used to denote VLAN trunking. Use the `min_vlan`
               and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
               `vlan_range` definitions are allowed, but they must not overlap. Example
               below:
        :param pulumi.Input[int] vmotion_maximum_mbit: The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        :param pulumi.Input[int] vmotion_reservation_mbit: The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        :param pulumi.Input[int] vmotion_share_count: The amount of shares to allocate to the vmotion traffic class for a custom share level.
        :param pulumi.Input[str] vmotion_share_level: The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[int] vsan_maximum_mbit: The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        :param pulumi.Input[int] vsan_reservation_mbit: The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        :param pulumi.Input[int] vsan_share_count: The amount of shares to allocate to the vsan traffic class for a custom share level.
        :param pulumi.Input[str] vsan_share_level: The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        """
        if __name__ is not None:
            warnings.warn("explicit use of __name__ is deprecated", DeprecationWarning)
            resource_name = __name__
        if __opts__ is not None:
            warnings.warn("explicit use of __opts__ is deprecated, use 'opts' instead", DeprecationWarning)
            opts = __opts__
        if opts is None:
            opts = pulumi.ResourceOptions()
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.version is None:
            opts.version = _utilities.get_version()
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = dict()

            __props__['active_uplinks'] = active_uplinks
            __props__['allow_forged_transmits'] = allow_forged_transmits
            __props__['allow_mac_changes'] = allow_mac_changes
            __props__['allow_promiscuous'] = allow_promiscuous
            __props__['block_all_ports'] = block_all_ports
            __props__['check_beacon'] = check_beacon
            __props__['contact_detail'] = contact_detail
            __props__['contact_name'] = contact_name
            __props__['custom_attributes'] = custom_attributes
            if datacenter_id is None and not opts.urn:
                raise TypeError("Missing required property 'datacenter_id'")
            __props__['datacenter_id'] = datacenter_id
            __props__['description'] = description
            __props__['directpath_gen2_allowed'] = directpath_gen2_allowed
            __props__['egress_shaping_average_bandwidth'] = egress_shaping_average_bandwidth
            __props__['egress_shaping_burst_size'] = egress_shaping_burst_size
            __props__['egress_shaping_enabled'] = egress_shaping_enabled
            __props__['egress_shaping_peak_bandwidth'] = egress_shaping_peak_bandwidth
            __props__['failback'] = failback
            __props__['faulttolerance_maximum_mbit'] = faulttolerance_maximum_mbit
            __props__['faulttolerance_reservation_mbit'] = faulttolerance_reservation_mbit
            __props__['faulttolerance_share_count'] = faulttolerance_share_count
            __props__['faulttolerance_share_level'] = faulttolerance_share_level
            __props__['folder'] = folder
            __props__['hbr_maximum_mbit'] = hbr_maximum_mbit
            __props__['hbr_reservation_mbit'] = hbr_reservation_mbit
            __props__['hbr_share_count'] = hbr_share_count
            __props__['hbr_share_level'] = hbr_share_level
            __props__['hosts'] = hosts
            __props__['ignore_other_pvlan_mappings'] = ignore_other_pvlan_mappings
            __props__['ingress_shaping_average_bandwidth'] = ingress_shaping_average_bandwidth
            __props__['ingress_shaping_burst_size'] = ingress_shaping_burst_size
            __props__['ingress_shaping_enabled'] = ingress_shaping_enabled
            __props__['ingress_shaping_peak_bandwidth'] = ingress_shaping_peak_bandwidth
            __props__['ipv4_address'] = ipv4_address
            __props__['iscsi_maximum_mbit'] = iscsi_maximum_mbit
            __props__['iscsi_reservation_mbit'] = iscsi_reservation_mbit
            __props__['iscsi_share_count'] = iscsi_share_count
            __props__['iscsi_share_level'] = iscsi_share_level
            __props__['lacp_api_version'] = lacp_api_version
            __props__['lacp_enabled'] = lacp_enabled
            __props__['lacp_mode'] = lacp_mode
            __props__['link_discovery_operation'] = link_discovery_operation
            __props__['link_discovery_protocol'] = link_discovery_protocol
            __props__['management_maximum_mbit'] = management_maximum_mbit
            __props__['management_reservation_mbit'] = management_reservation_mbit
            __props__['management_share_count'] = management_share_count
            __props__['management_share_level'] = management_share_level
            __props__['max_mtu'] = max_mtu
            __props__['multicast_filtering_mode'] = multicast_filtering_mode
            __props__['name'] = name
            __props__['netflow_active_flow_timeout'] = netflow_active_flow_timeout
            __props__['netflow_collector_ip_address'] = netflow_collector_ip_address
            __props__['netflow_collector_port'] = netflow_collector_port
            __props__['netflow_enabled'] = netflow_enabled
            __props__['netflow_idle_flow_timeout'] = netflow_idle_flow_timeout
            __props__['netflow_internal_flows_only'] = netflow_internal_flows_only
            __props__['netflow_observation_domain_id'] = netflow_observation_domain_id
            __props__['netflow_sampling_rate'] = netflow_sampling_rate
            __props__['network_resource_control_enabled'] = network_resource_control_enabled
            __props__['network_resource_control_version'] = network_resource_control_version
            __props__['nfs_maximum_mbit'] = nfs_maximum_mbit
            __props__['nfs_reservation_mbit'] = nfs_reservation_mbit
            __props__['nfs_share_count'] = nfs_share_count
            __props__['nfs_share_level'] = nfs_share_level
            __props__['notify_switches'] = notify_switches
            __props__['port_private_secondary_vlan_id'] = port_private_secondary_vlan_id
            __props__['pvlan_mappings'] = pvlan_mappings
            __props__['standby_uplinks'] = standby_uplinks
            __props__['tags'] = tags
            __props__['teaming_policy'] = teaming_policy
            __props__['tx_uplink'] = tx_uplink
            __props__['uplinks'] = uplinks
            __props__['vdp_maximum_mbit'] = vdp_maximum_mbit
            __props__['vdp_reservation_mbit'] = vdp_reservation_mbit
            __props__['vdp_share_count'] = vdp_share_count
            __props__['vdp_share_level'] = vdp_share_level
            __props__['version'] = version
            __props__['virtualmachine_maximum_mbit'] = virtualmachine_maximum_mbit
            __props__['virtualmachine_reservation_mbit'] = virtualmachine_reservation_mbit
            __props__['virtualmachine_share_count'] = virtualmachine_share_count
            __props__['virtualmachine_share_level'] = virtualmachine_share_level
            __props__['vlan_id'] = vlan_id
            __props__['vlan_ranges'] = vlan_ranges
            __props__['vmotion_maximum_mbit'] = vmotion_maximum_mbit
            __props__['vmotion_reservation_mbit'] = vmotion_reservation_mbit
            __props__['vmotion_share_count'] = vmotion_share_count
            __props__['vmotion_share_level'] = vmotion_share_level
            __props__['vsan_maximum_mbit'] = vsan_maximum_mbit
            __props__['vsan_reservation_mbit'] = vsan_reservation_mbit
            __props__['vsan_share_count'] = vsan_share_count
            __props__['vsan_share_level'] = vsan_share_level
            __props__['config_version'] = None
        super(DistributedVirtualSwitch, __self__).__init__(
            'vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            active_uplinks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            allow_forged_transmits: Optional[pulumi.Input[bool]] = None,
            allow_mac_changes: Optional[pulumi.Input[bool]] = None,
            allow_promiscuous: Optional[pulumi.Input[bool]] = None,
            block_all_ports: Optional[pulumi.Input[bool]] = None,
            check_beacon: Optional[pulumi.Input[bool]] = None,
            config_version: Optional[pulumi.Input[str]] = None,
            contact_detail: Optional[pulumi.Input[str]] = None,
            contact_name: Optional[pulumi.Input[str]] = None,
            custom_attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            datacenter_id: Optional[pulumi.Input[str]] = None,
            description: Optional[pulumi.Input[str]] = None,
            directpath_gen2_allowed: Optional[pulumi.Input[bool]] = None,
            egress_shaping_average_bandwidth: Optional[pulumi.Input[int]] = None,
            egress_shaping_burst_size: Optional[pulumi.Input[int]] = None,
            egress_shaping_enabled: Optional[pulumi.Input[bool]] = None,
            egress_shaping_peak_bandwidth: Optional[pulumi.Input[int]] = None,
            failback: Optional[pulumi.Input[bool]] = None,
            faulttolerance_maximum_mbit: Optional[pulumi.Input[int]] = None,
            faulttolerance_reservation_mbit: Optional[pulumi.Input[int]] = None,
            faulttolerance_share_count: Optional[pulumi.Input[int]] = None,
            faulttolerance_share_level: Optional[pulumi.Input[str]] = None,
            folder: Optional[pulumi.Input[str]] = None,
            hbr_maximum_mbit: Optional[pulumi.Input[int]] = None,
            hbr_reservation_mbit: Optional[pulumi.Input[int]] = None,
            hbr_share_count: Optional[pulumi.Input[int]] = None,
            hbr_share_level: Optional[pulumi.Input[str]] = None,
            hosts: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchHostArgs']]]]] = None,
            ignore_other_pvlan_mappings: Optional[pulumi.Input[bool]] = None,
            ingress_shaping_average_bandwidth: Optional[pulumi.Input[int]] = None,
            ingress_shaping_burst_size: Optional[pulumi.Input[int]] = None,
            ingress_shaping_enabled: Optional[pulumi.Input[bool]] = None,
            ingress_shaping_peak_bandwidth: Optional[pulumi.Input[int]] = None,
            ipv4_address: Optional[pulumi.Input[str]] = None,
            iscsi_maximum_mbit: Optional[pulumi.Input[int]] = None,
            iscsi_reservation_mbit: Optional[pulumi.Input[int]] = None,
            iscsi_share_count: Optional[pulumi.Input[int]] = None,
            iscsi_share_level: Optional[pulumi.Input[str]] = None,
            lacp_api_version: Optional[pulumi.Input[str]] = None,
            lacp_enabled: Optional[pulumi.Input[bool]] = None,
            lacp_mode: Optional[pulumi.Input[str]] = None,
            link_discovery_operation: Optional[pulumi.Input[str]] = None,
            link_discovery_protocol: Optional[pulumi.Input[str]] = None,
            management_maximum_mbit: Optional[pulumi.Input[int]] = None,
            management_reservation_mbit: Optional[pulumi.Input[int]] = None,
            management_share_count: Optional[pulumi.Input[int]] = None,
            management_share_level: Optional[pulumi.Input[str]] = None,
            max_mtu: Optional[pulumi.Input[int]] = None,
            multicast_filtering_mode: Optional[pulumi.Input[str]] = None,
            name: Optional[pulumi.Input[str]] = None,
            netflow_active_flow_timeout: Optional[pulumi.Input[int]] = None,
            netflow_collector_ip_address: Optional[pulumi.Input[str]] = None,
            netflow_collector_port: Optional[pulumi.Input[int]] = None,
            netflow_enabled: Optional[pulumi.Input[bool]] = None,
            netflow_idle_flow_timeout: Optional[pulumi.Input[int]] = None,
            netflow_internal_flows_only: Optional[pulumi.Input[bool]] = None,
            netflow_observation_domain_id: Optional[pulumi.Input[int]] = None,
            netflow_sampling_rate: Optional[pulumi.Input[int]] = None,
            network_resource_control_enabled: Optional[pulumi.Input[bool]] = None,
            network_resource_control_version: Optional[pulumi.Input[str]] = None,
            nfs_maximum_mbit: Optional[pulumi.Input[int]] = None,
            nfs_reservation_mbit: Optional[pulumi.Input[int]] = None,
            nfs_share_count: Optional[pulumi.Input[int]] = None,
            nfs_share_level: Optional[pulumi.Input[str]] = None,
            notify_switches: Optional[pulumi.Input[bool]] = None,
            port_private_secondary_vlan_id: Optional[pulumi.Input[int]] = None,
            pvlan_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchPvlanMappingArgs']]]]] = None,
            standby_uplinks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            teaming_policy: Optional[pulumi.Input[str]] = None,
            tx_uplink: Optional[pulumi.Input[bool]] = None,
            uplinks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            vdp_maximum_mbit: Optional[pulumi.Input[int]] = None,
            vdp_reservation_mbit: Optional[pulumi.Input[int]] = None,
            vdp_share_count: Optional[pulumi.Input[int]] = None,
            vdp_share_level: Optional[pulumi.Input[str]] = None,
            version: Optional[pulumi.Input[str]] = None,
            virtualmachine_maximum_mbit: Optional[pulumi.Input[int]] = None,
            virtualmachine_reservation_mbit: Optional[pulumi.Input[int]] = None,
            virtualmachine_share_count: Optional[pulumi.Input[int]] = None,
            virtualmachine_share_level: Optional[pulumi.Input[str]] = None,
            vlan_id: Optional[pulumi.Input[int]] = None,
            vlan_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchVlanRangeArgs']]]]] = None,
            vmotion_maximum_mbit: Optional[pulumi.Input[int]] = None,
            vmotion_reservation_mbit: Optional[pulumi.Input[int]] = None,
            vmotion_share_count: Optional[pulumi.Input[int]] = None,
            vmotion_share_level: Optional[pulumi.Input[str]] = None,
            vsan_maximum_mbit: Optional[pulumi.Input[int]] = None,
            vsan_reservation_mbit: Optional[pulumi.Input[int]] = None,
            vsan_share_count: Optional[pulumi.Input[int]] = None,
            vsan_share_level: Optional[pulumi.Input[str]] = None) -> 'DistributedVirtualSwitch':
        """
        Get an existing DistributedVirtualSwitch resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] active_uplinks: A list of active uplinks to be used in load
               balancing. These uplinks need to match the definitions in the
               `uplinks` DVS argument. See
               here for more details.
        :param pulumi.Input[bool] allow_forged_transmits: Controls whether or not a virtual
               network adapter is allowed to send network traffic with a different MAC
               address than that of its own.
        :param pulumi.Input[bool] allow_mac_changes: Controls whether or not the Media Access
               Control (MAC) address can be changed.
        :param pulumi.Input[bool] allow_promiscuous: Enable promiscuous mode on the network. This
               flag indicates whether or not all traffic is seen on a given port.
        :param pulumi.Input[bool] block_all_ports: Shuts down all ports in the port groups that
               this policy applies to, effectively blocking all network access to connected
               virtual devices.
        :param pulumi.Input[bool] check_beacon: Enables beacon probing as an additional measure
               to detect NIC failure.
        :param pulumi.Input[str] config_version: The version string of the configuration that this spec is trying to change.
        :param pulumi.Input[str] contact_detail: The detailed contact information for the person
               who is responsible for the DVS.
        :param pulumi.Input[str] contact_name: The name of the person who is responsible for the
               DVS.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_attributes: Map of custom attribute ids to attribute
               value strings to set for virtual switch.
        :param pulumi.Input[str] datacenter_id: The ID of the datacenter where the distributed
               virtual switch will be created. Forces a new resource if changed.
        :param pulumi.Input[str] description: A detailed description for the DVS.
        :param pulumi.Input[bool] directpath_gen2_allowed: Allow VMDirectPath Gen2 for the ports
               for which this policy applies to.
        :param pulumi.Input[int] egress_shaping_average_bandwidth: The average bandwidth in bits
               per second if egress traffic shaping is enabled on the port.
        :param pulumi.Input[int] egress_shaping_burst_size: The maximum burst size allowed in
               bytes if egress traffic shaping is enabled on the port.
        :param pulumi.Input[bool] egress_shaping_enabled: `true` if the traffic shaper is enabled
               on the port for egress traffic.
        :param pulumi.Input[int] egress_shaping_peak_bandwidth: The peak bandwidth during bursts
               in bits per second if egress traffic shaping is enabled on the port.
        :param pulumi.Input[bool] failback: If `true`, the teaming policy will re-activate failed
               uplinks higher in precedence when they come back up.
        :param pulumi.Input[int] faulttolerance_maximum_mbit: The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        :param pulumi.Input[int] faulttolerance_reservation_mbit: The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        :param pulumi.Input[int] faulttolerance_share_count: The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        :param pulumi.Input[str] faulttolerance_share_level: The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[str] folder: The folder to create the DVS in. Forces a new resource
               if changed.
        :param pulumi.Input[int] hbr_maximum_mbit: The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        :param pulumi.Input[int] hbr_reservation_mbit: The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        :param pulumi.Input[int] hbr_share_count: The amount of shares to allocate to the hbr traffic class for a custom share level.
        :param pulumi.Input[str] hbr_share_level: The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchHostArgs']]]] hosts: Use the `host` block to declare a host specification. The
               options are:
        :param pulumi.Input[bool] ignore_other_pvlan_mappings: Whether to ignore existing PVLAN
               mappings not managed by this resource. Defaults to false.
        :param pulumi.Input[int] ingress_shaping_average_bandwidth: The average bandwidth in
               bits per second if ingress traffic shaping is enabled on the port.
        :param pulumi.Input[int] ingress_shaping_burst_size: The maximum burst size allowed in
               bytes if ingress traffic shaping is enabled on the port.
        :param pulumi.Input[bool] ingress_shaping_enabled: `true` if the traffic shaper is
               enabled on the port for ingress traffic.
        :param pulumi.Input[int] ingress_shaping_peak_bandwidth: The peak bandwidth during
               bursts in bits per second if ingress traffic shaping is enabled on the port.
        :param pulumi.Input[str] ipv4_address: An IPv4 address to identify the switch. This is
               mostly useful when used with the Netflow arguments found
               below.
        :param pulumi.Input[int] iscsi_maximum_mbit: The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        :param pulumi.Input[int] iscsi_reservation_mbit: The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        :param pulumi.Input[int] iscsi_share_count: The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        :param pulumi.Input[str] iscsi_share_level: The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[str] lacp_api_version: The Link Aggregation Control Protocol group
               version to use with the switch. Possible values are `singleLag` and
               `multipleLag`.
        :param pulumi.Input[bool] lacp_enabled: Enables LACP for the ports that this policy
               applies to.
        :param pulumi.Input[str] lacp_mode: The LACP mode. Can be one of `active` or `passive`.
        :param pulumi.Input[str] link_discovery_operation: Whether to `advertise` or `listen`
               for link discovery traffic.
        :param pulumi.Input[str] link_discovery_protocol: The discovery protocol type. Valid
               types are `cdp` and `lldp`.
        :param pulumi.Input[int] management_maximum_mbit: The maximum allowed usage for the management traffic class, in Mbits/sec.
        :param pulumi.Input[int] management_reservation_mbit: The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        :param pulumi.Input[int] management_share_count: The amount of shares to allocate to the management traffic class for a custom share level.
        :param pulumi.Input[str] management_share_level: The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[int] max_mtu: The maximum transmission unit (MTU) for the virtual
               switch.
        :param pulumi.Input[str] multicast_filtering_mode: The multicast filtering mode to use
               with the switch. Can be one of `legacyFiltering` or `snooping`.
        :param pulumi.Input[str] name: The name of the distributed virtual switch.
        :param pulumi.Input[int] netflow_active_flow_timeout: The number of seconds after which
               active flows are forced to be exported to the collector. Allowed range is
               `60` to `3600`. Default: `60`.
        :param pulumi.Input[str] netflow_collector_ip_address: IP address for the Netflow
               collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
               Switch Version 6.0 or later. Must be set before Netflow can be enabled.
        :param pulumi.Input[int] netflow_collector_port: Port for the Netflow collector. This
               must be set before Netflow can be enabled.
        :param pulumi.Input[bool] netflow_enabled: Enables Netflow on all ports that this policy
               applies to.
        :param pulumi.Input[int] netflow_idle_flow_timeout: The number of seconds after which
               idle flows are forced to be exported to the collector. Allowed range is `10`
               to `600`. Default: `15`.
        :param pulumi.Input[bool] netflow_internal_flows_only: Whether to limit analysis to
               traffic that has both source and destination served by the same host.
               Default: `false`.
        :param pulumi.Input[int] netflow_observation_domain_id: The observation domain ID for
               the Netflow collector.
        :param pulumi.Input[int] netflow_sampling_rate: The ratio of total number of packets to
               the number of packets analyzed. The default is `0`, which indicates that the
               switch should analyze all packets. The maximum value is `1000`, which
               indicates an analysis rate of 0.001%.
        :param pulumi.Input[bool] network_resource_control_enabled: Set to `true` to enable
               network I/O control. Default: `false`.
        :param pulumi.Input[str] network_resource_control_version: The version of network I/O
               control to use. Can be one of `version2` or `version3`. Default: `version2`.
        :param pulumi.Input[int] nfs_maximum_mbit: The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        :param pulumi.Input[int] nfs_reservation_mbit: The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        :param pulumi.Input[int] nfs_share_count: The amount of shares to allocate to the nfs traffic class for a custom share level.
        :param pulumi.Input[str] nfs_share_level: The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[bool] notify_switches: If `true`, the teaming policy will notify the
               broadcast network of an uplink failover, triggering cache updates.
        :param pulumi.Input[int] port_private_secondary_vlan_id: Used to define a secondary VLAN
               ID when using private VLANs.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchPvlanMappingArgs']]]] pvlan_mappings: Use the `pvlan_mapping` block to declare a
               private VLAN mapping. The options are:
        :param pulumi.Input[Sequence[pulumi.Input[str]]] standby_uplinks: A list of standby uplinks to be used in
               failover. These uplinks need to match the definitions in the
               `uplinks` DVS argument. See
               here for more details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: The IDs of any tags to attach to this resource.
        :param pulumi.Input[str] teaming_policy: The uplink teaming policy. Can be one of
               `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
               `failover_explicit`.
        :param pulumi.Input[bool] tx_uplink: Forward all traffic transmitted by ports for which
               this policy applies to its DVS uplinks.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] uplinks: A list of strings that uniquely identifies the names
               of the uplinks on the DVS across hosts. The number of items in this list
               controls the number of uplinks that exist on the DVS, in addition to the
               names.  See here for an example on how to
               use this option.
        :param pulumi.Input[int] vdp_maximum_mbit: The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        :param pulumi.Input[int] vdp_reservation_mbit: The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        :param pulumi.Input[int] vdp_share_count: The amount of shares to allocate to the vdp traffic class for a custom share level.
        :param pulumi.Input[str] vdp_share_level: The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[str] version: - The version of the DVS to create. The default is to
               create the DVS at the latest version supported by the version of vSphere
               being used. A DVS can be upgraded to another version, but cannot be
               downgraded.
        :param pulumi.Input[int] virtualmachine_maximum_mbit: The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        :param pulumi.Input[int] virtualmachine_reservation_mbit: The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        :param pulumi.Input[int] virtualmachine_share_count: The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        :param pulumi.Input[str] virtualmachine_share_level: The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[int] vlan_id: The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DistributedVirtualSwitchVlanRangeArgs']]]] vlan_ranges: Used to denote VLAN trunking. Use the `min_vlan`
               and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
               `vlan_range` definitions are allowed, but they must not overlap. Example
               below:
        :param pulumi.Input[int] vmotion_maximum_mbit: The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        :param pulumi.Input[int] vmotion_reservation_mbit: The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        :param pulumi.Input[int] vmotion_share_count: The amount of shares to allocate to the vmotion traffic class for a custom share level.
        :param pulumi.Input[str] vmotion_share_level: The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        :param pulumi.Input[int] vsan_maximum_mbit: The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        :param pulumi.Input[int] vsan_reservation_mbit: The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        :param pulumi.Input[int] vsan_share_count: The amount of shares to allocate to the vsan traffic class for a custom share level.
        :param pulumi.Input[str] vsan_share_level: The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = dict()

        __props__["active_uplinks"] = active_uplinks
        __props__["allow_forged_transmits"] = allow_forged_transmits
        __props__["allow_mac_changes"] = allow_mac_changes
        __props__["allow_promiscuous"] = allow_promiscuous
        __props__["block_all_ports"] = block_all_ports
        __props__["check_beacon"] = check_beacon
        __props__["config_version"] = config_version
        __props__["contact_detail"] = contact_detail
        __props__["contact_name"] = contact_name
        __props__["custom_attributes"] = custom_attributes
        __props__["datacenter_id"] = datacenter_id
        __props__["description"] = description
        __props__["directpath_gen2_allowed"] = directpath_gen2_allowed
        __props__["egress_shaping_average_bandwidth"] = egress_shaping_average_bandwidth
        __props__["egress_shaping_burst_size"] = egress_shaping_burst_size
        __props__["egress_shaping_enabled"] = egress_shaping_enabled
        __props__["egress_shaping_peak_bandwidth"] = egress_shaping_peak_bandwidth
        __props__["failback"] = failback
        __props__["faulttolerance_maximum_mbit"] = faulttolerance_maximum_mbit
        __props__["faulttolerance_reservation_mbit"] = faulttolerance_reservation_mbit
        __props__["faulttolerance_share_count"] = faulttolerance_share_count
        __props__["faulttolerance_share_level"] = faulttolerance_share_level
        __props__["folder"] = folder
        __props__["hbr_maximum_mbit"] = hbr_maximum_mbit
        __props__["hbr_reservation_mbit"] = hbr_reservation_mbit
        __props__["hbr_share_count"] = hbr_share_count
        __props__["hbr_share_level"] = hbr_share_level
        __props__["hosts"] = hosts
        __props__["ignore_other_pvlan_mappings"] = ignore_other_pvlan_mappings
        __props__["ingress_shaping_average_bandwidth"] = ingress_shaping_average_bandwidth
        __props__["ingress_shaping_burst_size"] = ingress_shaping_burst_size
        __props__["ingress_shaping_enabled"] = ingress_shaping_enabled
        __props__["ingress_shaping_peak_bandwidth"] = ingress_shaping_peak_bandwidth
        __props__["ipv4_address"] = ipv4_address
        __props__["iscsi_maximum_mbit"] = iscsi_maximum_mbit
        __props__["iscsi_reservation_mbit"] = iscsi_reservation_mbit
        __props__["iscsi_share_count"] = iscsi_share_count
        __props__["iscsi_share_level"] = iscsi_share_level
        __props__["lacp_api_version"] = lacp_api_version
        __props__["lacp_enabled"] = lacp_enabled
        __props__["lacp_mode"] = lacp_mode
        __props__["link_discovery_operation"] = link_discovery_operation
        __props__["link_discovery_protocol"] = link_discovery_protocol
        __props__["management_maximum_mbit"] = management_maximum_mbit
        __props__["management_reservation_mbit"] = management_reservation_mbit
        __props__["management_share_count"] = management_share_count
        __props__["management_share_level"] = management_share_level
        __props__["max_mtu"] = max_mtu
        __props__["multicast_filtering_mode"] = multicast_filtering_mode
        __props__["name"] = name
        __props__["netflow_active_flow_timeout"] = netflow_active_flow_timeout
        __props__["netflow_collector_ip_address"] = netflow_collector_ip_address
        __props__["netflow_collector_port"] = netflow_collector_port
        __props__["netflow_enabled"] = netflow_enabled
        __props__["netflow_idle_flow_timeout"] = netflow_idle_flow_timeout
        __props__["netflow_internal_flows_only"] = netflow_internal_flows_only
        __props__["netflow_observation_domain_id"] = netflow_observation_domain_id
        __props__["netflow_sampling_rate"] = netflow_sampling_rate
        __props__["network_resource_control_enabled"] = network_resource_control_enabled
        __props__["network_resource_control_version"] = network_resource_control_version
        __props__["nfs_maximum_mbit"] = nfs_maximum_mbit
        __props__["nfs_reservation_mbit"] = nfs_reservation_mbit
        __props__["nfs_share_count"] = nfs_share_count
        __props__["nfs_share_level"] = nfs_share_level
        __props__["notify_switches"] = notify_switches
        __props__["port_private_secondary_vlan_id"] = port_private_secondary_vlan_id
        __props__["pvlan_mappings"] = pvlan_mappings
        __props__["standby_uplinks"] = standby_uplinks
        __props__["tags"] = tags
        __props__["teaming_policy"] = teaming_policy
        __props__["tx_uplink"] = tx_uplink
        __props__["uplinks"] = uplinks
        __props__["vdp_maximum_mbit"] = vdp_maximum_mbit
        __props__["vdp_reservation_mbit"] = vdp_reservation_mbit
        __props__["vdp_share_count"] = vdp_share_count
        __props__["vdp_share_level"] = vdp_share_level
        __props__["version"] = version
        __props__["virtualmachine_maximum_mbit"] = virtualmachine_maximum_mbit
        __props__["virtualmachine_reservation_mbit"] = virtualmachine_reservation_mbit
        __props__["virtualmachine_share_count"] = virtualmachine_share_count
        __props__["virtualmachine_share_level"] = virtualmachine_share_level
        __props__["vlan_id"] = vlan_id
        __props__["vlan_ranges"] = vlan_ranges
        __props__["vmotion_maximum_mbit"] = vmotion_maximum_mbit
        __props__["vmotion_reservation_mbit"] = vmotion_reservation_mbit
        __props__["vmotion_share_count"] = vmotion_share_count
        __props__["vmotion_share_level"] = vmotion_share_level
        __props__["vsan_maximum_mbit"] = vsan_maximum_mbit
        __props__["vsan_reservation_mbit"] = vsan_reservation_mbit
        __props__["vsan_share_count"] = vsan_share_count
        __props__["vsan_share_level"] = vsan_share_level
        return DistributedVirtualSwitch(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="activeUplinks")
    def active_uplinks(self) -> pulumi.Output[Sequence[str]]:
        """
        A list of active uplinks to be used in load
        balancing. These uplinks need to match the definitions in the
        `uplinks` DVS argument. See
        here for more details.
        """
        return pulumi.get(self, "active_uplinks")

    @property
    @pulumi.getter(name="allowForgedTransmits")
    def allow_forged_transmits(self) -> pulumi.Output[bool]:
        """
        Controls whether or not a virtual
        network adapter is allowed to send network traffic with a different MAC
        address than that of its own.
        """
        return pulumi.get(self, "allow_forged_transmits")

    @property
    @pulumi.getter(name="allowMacChanges")
    def allow_mac_changes(self) -> pulumi.Output[bool]:
        """
        Controls whether or not the Media Access
        Control (MAC) address can be changed.
        """
        return pulumi.get(self, "allow_mac_changes")

    @property
    @pulumi.getter(name="allowPromiscuous")
    def allow_promiscuous(self) -> pulumi.Output[bool]:
        """
        Enable promiscuous mode on the network. This
        flag indicates whether or not all traffic is seen on a given port.
        """
        return pulumi.get(self, "allow_promiscuous")

    @property
    @pulumi.getter(name="blockAllPorts")
    def block_all_ports(self) -> pulumi.Output[bool]:
        """
        Shuts down all ports in the port groups that
        this policy applies to, effectively blocking all network access to connected
        virtual devices.
        """
        return pulumi.get(self, "block_all_ports")

    @property
    @pulumi.getter(name="checkBeacon")
    def check_beacon(self) -> pulumi.Output[bool]:
        """
        Enables beacon probing as an additional measure
        to detect NIC failure.
        """
        return pulumi.get(self, "check_beacon")

    @property
    @pulumi.getter(name="configVersion")
    def config_version(self) -> pulumi.Output[str]:
        """
        The version string of the configuration that this spec is trying to change.
        """
        return pulumi.get(self, "config_version")

    @property
    @pulumi.getter(name="contactDetail")
    def contact_detail(self) -> pulumi.Output[Optional[str]]:
        """
        The detailed contact information for the person
        who is responsible for the DVS.
        """
        return pulumi.get(self, "contact_detail")

    @property
    @pulumi.getter(name="contactName")
    def contact_name(self) -> pulumi.Output[Optional[str]]:
        """
        The name of the person who is responsible for the
        DVS.
        """
        return pulumi.get(self, "contact_name")

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        Map of custom attribute ids to attribute
        value strings to set for virtual switch.
        """
        return pulumi.get(self, "custom_attributes")

    @property
    @pulumi.getter(name="datacenterId")
    def datacenter_id(self) -> pulumi.Output[str]:
        """
        The ID of the datacenter where the distributed
        virtual switch will be created. Forces a new resource if changed.
        """
        return pulumi.get(self, "datacenter_id")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[str]]:
        """
        A detailed description for the DVS.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="directpathGen2Allowed")
    def directpath_gen2_allowed(self) -> pulumi.Output[bool]:
        """
        Allow VMDirectPath Gen2 for the ports
        for which this policy applies to.
        """
        return pulumi.get(self, "directpath_gen2_allowed")

    @property
    @pulumi.getter(name="egressShapingAverageBandwidth")
    def egress_shaping_average_bandwidth(self) -> pulumi.Output[int]:
        """
        The average bandwidth in bits
        per second if egress traffic shaping is enabled on the port.
        """
        return pulumi.get(self, "egress_shaping_average_bandwidth")

    @property
    @pulumi.getter(name="egressShapingBurstSize")
    def egress_shaping_burst_size(self) -> pulumi.Output[int]:
        """
        The maximum burst size allowed in
        bytes if egress traffic shaping is enabled on the port.
        """
        return pulumi.get(self, "egress_shaping_burst_size")

    @property
    @pulumi.getter(name="egressShapingEnabled")
    def egress_shaping_enabled(self) -> pulumi.Output[bool]:
        """
        `true` if the traffic shaper is enabled
        on the port for egress traffic.
        """
        return pulumi.get(self, "egress_shaping_enabled")

    @property
    @pulumi.getter(name="egressShapingPeakBandwidth")
    def egress_shaping_peak_bandwidth(self) -> pulumi.Output[int]:
        """
        The peak bandwidth during bursts
        in bits per second if egress traffic shaping is enabled on the port.
        """
        return pulumi.get(self, "egress_shaping_peak_bandwidth")

    @property
    @pulumi.getter
    def failback(self) -> pulumi.Output[bool]:
        """
        If `true`, the teaming policy will re-activate failed
        uplinks higher in precedence when they come back up.
        """
        return pulumi.get(self, "failback")

    @property
    @pulumi.getter(name="faulttoleranceMaximumMbit")
    def faulttolerance_maximum_mbit(self) -> pulumi.Output[int]:
        """
        The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "faulttolerance_maximum_mbit")

    @property
    @pulumi.getter(name="faulttoleranceReservationMbit")
    def faulttolerance_reservation_mbit(self) -> pulumi.Output[int]:
        """
        The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "faulttolerance_reservation_mbit")

    @property
    @pulumi.getter(name="faulttoleranceShareCount")
    def faulttolerance_share_count(self) -> pulumi.Output[int]:
        """
        The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
        """
        return pulumi.get(self, "faulttolerance_share_count")

    @property
    @pulumi.getter(name="faulttoleranceShareLevel")
    def faulttolerance_share_level(self) -> pulumi.Output[str]:
        """
        The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
        """
        return pulumi.get(self, "faulttolerance_share_level")

    @property
    @pulumi.getter
    def folder(self) -> pulumi.Output[Optional[str]]:
        """
        The folder to create the DVS in. Forces a new resource
        if changed.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="hbrMaximumMbit")
    def hbr_maximum_mbit(self) -> pulumi.Output[int]:
        """
        The maximum allowed usage for the hbr traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "hbr_maximum_mbit")

    @property
    @pulumi.getter(name="hbrReservationMbit")
    def hbr_reservation_mbit(self) -> pulumi.Output[int]:
        """
        The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "hbr_reservation_mbit")

    @property
    @pulumi.getter(name="hbrShareCount")
    def hbr_share_count(self) -> pulumi.Output[int]:
        """
        The amount of shares to allocate to the hbr traffic class for a custom share level.
        """
        return pulumi.get(self, "hbr_share_count")

    @property
    @pulumi.getter(name="hbrShareLevel")
    def hbr_share_level(self) -> pulumi.Output[str]:
        """
        The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
        """
        return pulumi.get(self, "hbr_share_level")

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Output[Optional[Sequence['outputs.DistributedVirtualSwitchHost']]]:
        """
        Use the `host` block to declare a host specification. The
        options are:
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="ignoreOtherPvlanMappings")
    def ignore_other_pvlan_mappings(self) -> pulumi.Output[Optional[bool]]:
        """
        Whether to ignore existing PVLAN
        mappings not managed by this resource. Defaults to false.
        """
        return pulumi.get(self, "ignore_other_pvlan_mappings")

    @property
    @pulumi.getter(name="ingressShapingAverageBandwidth")
    def ingress_shaping_average_bandwidth(self) -> pulumi.Output[int]:
        """
        The average bandwidth in
        bits per second if ingress traffic shaping is enabled on the port.
        """
        return pulumi.get(self, "ingress_shaping_average_bandwidth")

    @property
    @pulumi.getter(name="ingressShapingBurstSize")
    def ingress_shaping_burst_size(self) -> pulumi.Output[int]:
        """
        The maximum burst size allowed in
        bytes if ingress traffic shaping is enabled on the port.
        """
        return pulumi.get(self, "ingress_shaping_burst_size")

    @property
    @pulumi.getter(name="ingressShapingEnabled")
    def ingress_shaping_enabled(self) -> pulumi.Output[bool]:
        """
        `true` if the traffic shaper is
        enabled on the port for ingress traffic.
        """
        return pulumi.get(self, "ingress_shaping_enabled")

    @property
    @pulumi.getter(name="ingressShapingPeakBandwidth")
    def ingress_shaping_peak_bandwidth(self) -> pulumi.Output[int]:
        """
        The peak bandwidth during
        bursts in bits per second if ingress traffic shaping is enabled on the port.
        """
        return pulumi.get(self, "ingress_shaping_peak_bandwidth")

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> pulumi.Output[Optional[str]]:
        """
        An IPv4 address to identify the switch. This is
        mostly useful when used with the Netflow arguments found
        below.
        """
        return pulumi.get(self, "ipv4_address")

    @property
    @pulumi.getter(name="iscsiMaximumMbit")
    def iscsi_maximum_mbit(self) -> pulumi.Output[int]:
        """
        The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "iscsi_maximum_mbit")

    @property
    @pulumi.getter(name="iscsiReservationMbit")
    def iscsi_reservation_mbit(self) -> pulumi.Output[int]:
        """
        The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "iscsi_reservation_mbit")

    @property
    @pulumi.getter(name="iscsiShareCount")
    def iscsi_share_count(self) -> pulumi.Output[int]:
        """
        The amount of shares to allocate to the iSCSI traffic class for a custom share level.
        """
        return pulumi.get(self, "iscsi_share_count")

    @property
    @pulumi.getter(name="iscsiShareLevel")
    def iscsi_share_level(self) -> pulumi.Output[str]:
        """
        The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
        """
        return pulumi.get(self, "iscsi_share_level")

    @property
    @pulumi.getter(name="lacpApiVersion")
    def lacp_api_version(self) -> pulumi.Output[str]:
        """
        The Link Aggregation Control Protocol group
        version to use with the switch. Possible values are `singleLag` and
        `multipleLag`.
        """
        return pulumi.get(self, "lacp_api_version")

    @property
    @pulumi.getter(name="lacpEnabled")
    def lacp_enabled(self) -> pulumi.Output[bool]:
        """
        Enables LACP for the ports that this policy
        applies to.
        """
        return pulumi.get(self, "lacp_enabled")

    @property
    @pulumi.getter(name="lacpMode")
    def lacp_mode(self) -> pulumi.Output[str]:
        """
        The LACP mode. Can be one of `active` or `passive`.
        """
        return pulumi.get(self, "lacp_mode")

    @property
    @pulumi.getter(name="linkDiscoveryOperation")
    def link_discovery_operation(self) -> pulumi.Output[Optional[str]]:
        """
        Whether to `advertise` or `listen`
        for link discovery traffic.
        """
        return pulumi.get(self, "link_discovery_operation")

    @property
    @pulumi.getter(name="linkDiscoveryProtocol")
    def link_discovery_protocol(self) -> pulumi.Output[Optional[str]]:
        """
        The discovery protocol type. Valid
        types are `cdp` and `lldp`.
        """
        return pulumi.get(self, "link_discovery_protocol")

    @property
    @pulumi.getter(name="managementMaximumMbit")
    def management_maximum_mbit(self) -> pulumi.Output[int]:
        """
        The maximum allowed usage for the management traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "management_maximum_mbit")

    @property
    @pulumi.getter(name="managementReservationMbit")
    def management_reservation_mbit(self) -> pulumi.Output[int]:
        """
        The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "management_reservation_mbit")

    @property
    @pulumi.getter(name="managementShareCount")
    def management_share_count(self) -> pulumi.Output[int]:
        """
        The amount of shares to allocate to the management traffic class for a custom share level.
        """
        return pulumi.get(self, "management_share_count")

    @property
    @pulumi.getter(name="managementShareLevel")
    def management_share_level(self) -> pulumi.Output[str]:
        """
        The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
        """
        return pulumi.get(self, "management_share_level")

    @property
    @pulumi.getter(name="maxMtu")
    def max_mtu(self) -> pulumi.Output[int]:
        """
        The maximum transmission unit (MTU) for the virtual
        switch.
        """
        return pulumi.get(self, "max_mtu")

    @property
    @pulumi.getter(name="multicastFilteringMode")
    def multicast_filtering_mode(self) -> pulumi.Output[str]:
        """
        The multicast filtering mode to use
        with the switch. Can be one of `legacyFiltering` or `snooping`.
        """
        return pulumi.get(self, "multicast_filtering_mode")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        The name of the distributed virtual switch.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="netflowActiveFlowTimeout")
    def netflow_active_flow_timeout(self) -> pulumi.Output[Optional[int]]:
        """
        The number of seconds after which
        active flows are forced to be exported to the collector. Allowed range is
        `60` to `3600`. Default: `60`.
        """
        return pulumi.get(self, "netflow_active_flow_timeout")

    @property
    @pulumi.getter(name="netflowCollectorIpAddress")
    def netflow_collector_ip_address(self) -> pulumi.Output[Optional[str]]:
        """
        IP address for the Netflow
        collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
        Switch Version 6.0 or later. Must be set before Netflow can be enabled.
        """
        return pulumi.get(self, "netflow_collector_ip_address")

    @property
    @pulumi.getter(name="netflowCollectorPort")
    def netflow_collector_port(self) -> pulumi.Output[Optional[int]]:
        """
        Port for the Netflow collector. This
        must be set before Netflow can be enabled.
        """
        return pulumi.get(self, "netflow_collector_port")

    @property
    @pulumi.getter(name="netflowEnabled")
    def netflow_enabled(self) -> pulumi.Output[bool]:
        """
        Enables Netflow on all ports that this policy
        applies to.
        """
        return pulumi.get(self, "netflow_enabled")

    @property
    @pulumi.getter(name="netflowIdleFlowTimeout")
    def netflow_idle_flow_timeout(self) -> pulumi.Output[Optional[int]]:
        """
        The number of seconds after which
        idle flows are forced to be exported to the collector. Allowed range is `10`
        to `600`. Default: `15`.
        """
        return pulumi.get(self, "netflow_idle_flow_timeout")

    @property
    @pulumi.getter(name="netflowInternalFlowsOnly")
    def netflow_internal_flows_only(self) -> pulumi.Output[Optional[bool]]:
        """
        Whether to limit analysis to
        traffic that has both source and destination served by the same host.
        Default: `false`.
        """
        return pulumi.get(self, "netflow_internal_flows_only")

    @property
    @pulumi.getter(name="netflowObservationDomainId")
    def netflow_observation_domain_id(self) -> pulumi.Output[Optional[int]]:
        """
        The observation domain ID for
        the Netflow collector.
        """
        return pulumi.get(self, "netflow_observation_domain_id")

    @property
    @pulumi.getter(name="netflowSamplingRate")
    def netflow_sampling_rate(self) -> pulumi.Output[Optional[int]]:
        """
        The ratio of total number of packets to
        the number of packets analyzed. The default is `0`, which indicates that the
        switch should analyze all packets. The maximum value is `1000`, which
        indicates an analysis rate of 0.001%.
        """
        return pulumi.get(self, "netflow_sampling_rate")

    @property
    @pulumi.getter(name="networkResourceControlEnabled")
    def network_resource_control_enabled(self) -> pulumi.Output[Optional[bool]]:
        """
        Set to `true` to enable
        network I/O control. Default: `false`.
        """
        return pulumi.get(self, "network_resource_control_enabled")

    @property
    @pulumi.getter(name="networkResourceControlVersion")
    def network_resource_control_version(self) -> pulumi.Output[str]:
        """
        The version of network I/O
        control to use. Can be one of `version2` or `version3`. Default: `version2`.
        """
        return pulumi.get(self, "network_resource_control_version")

    @property
    @pulumi.getter(name="nfsMaximumMbit")
    def nfs_maximum_mbit(self) -> pulumi.Output[int]:
        """
        The maximum allowed usage for the nfs traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "nfs_maximum_mbit")

    @property
    @pulumi.getter(name="nfsReservationMbit")
    def nfs_reservation_mbit(self) -> pulumi.Output[int]:
        """
        The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "nfs_reservation_mbit")

    @property
    @pulumi.getter(name="nfsShareCount")
    def nfs_share_count(self) -> pulumi.Output[int]:
        """
        The amount of shares to allocate to the nfs traffic class for a custom share level.
        """
        return pulumi.get(self, "nfs_share_count")

    @property
    @pulumi.getter(name="nfsShareLevel")
    def nfs_share_level(self) -> pulumi.Output[str]:
        """
        The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
        """
        return pulumi.get(self, "nfs_share_level")

    @property
    @pulumi.getter(name="notifySwitches")
    def notify_switches(self) -> pulumi.Output[bool]:
        """
        If `true`, the teaming policy will notify the
        broadcast network of an uplink failover, triggering cache updates.
        """
        return pulumi.get(self, "notify_switches")

    @property
    @pulumi.getter(name="portPrivateSecondaryVlanId")
    def port_private_secondary_vlan_id(self) -> pulumi.Output[int]:
        """
        Used to define a secondary VLAN
        ID when using private VLANs.
        """
        return pulumi.get(self, "port_private_secondary_vlan_id")

    @property
    @pulumi.getter(name="pvlanMappings")
    def pvlan_mappings(self) -> pulumi.Output[Optional[Sequence['outputs.DistributedVirtualSwitchPvlanMapping']]]:
        """
        Use the `pvlan_mapping` block to declare a
        private VLAN mapping. The options are:
        """
        return pulumi.get(self, "pvlan_mappings")

    @property
    @pulumi.getter(name="standbyUplinks")
    def standby_uplinks(self) -> pulumi.Output[Sequence[str]]:
        """
        A list of standby uplinks to be used in
        failover. These uplinks need to match the definitions in the
        `uplinks` DVS argument. See
        here for more details.
        """
        return pulumi.get(self, "standby_uplinks")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        The IDs of any tags to attach to this resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="teamingPolicy")
    def teaming_policy(self) -> pulumi.Output[str]:
        """
        The uplink teaming policy. Can be one of
        `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or
        `failover_explicit`.
        """
        return pulumi.get(self, "teaming_policy")

    @property
    @pulumi.getter(name="txUplink")
    def tx_uplink(self) -> pulumi.Output[bool]:
        """
        Forward all traffic transmitted by ports for which
        this policy applies to its DVS uplinks.
        """
        return pulumi.get(self, "tx_uplink")

    @property
    @pulumi.getter
    def uplinks(self) -> pulumi.Output[Sequence[str]]:
        """
        A list of strings that uniquely identifies the names
        of the uplinks on the DVS across hosts. The number of items in this list
        controls the number of uplinks that exist on the DVS, in addition to the
        names.  See here for an example on how to
        use this option.
        """
        return pulumi.get(self, "uplinks")

    @property
    @pulumi.getter(name="vdpMaximumMbit")
    def vdp_maximum_mbit(self) -> pulumi.Output[int]:
        """
        The maximum allowed usage for the vdp traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "vdp_maximum_mbit")

    @property
    @pulumi.getter(name="vdpReservationMbit")
    def vdp_reservation_mbit(self) -> pulumi.Output[int]:
        """
        The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "vdp_reservation_mbit")

    @property
    @pulumi.getter(name="vdpShareCount")
    def vdp_share_count(self) -> pulumi.Output[int]:
        """
        The amount of shares to allocate to the vdp traffic class for a custom share level.
        """
        return pulumi.get(self, "vdp_share_count")

    @property
    @pulumi.getter(name="vdpShareLevel")
    def vdp_share_level(self) -> pulumi.Output[str]:
        """
        The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
        """
        return pulumi.get(self, "vdp_share_level")

    @property
    @pulumi.getter
    def version(self) -> pulumi.Output[str]:
        """
        - The version of the DVS to create. The default is to
        create the DVS at the latest version supported by the version of vSphere
        being used. A DVS can be upgraded to another version, but cannot be
        downgraded.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="virtualmachineMaximumMbit")
    def virtualmachine_maximum_mbit(self) -> pulumi.Output[int]:
        """
        The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "virtualmachine_maximum_mbit")

    @property
    @pulumi.getter(name="virtualmachineReservationMbit")
    def virtualmachine_reservation_mbit(self) -> pulumi.Output[int]:
        """
        The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "virtualmachine_reservation_mbit")

    @property
    @pulumi.getter(name="virtualmachineShareCount")
    def virtualmachine_share_count(self) -> pulumi.Output[int]:
        """
        The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
        """
        return pulumi.get(self, "virtualmachine_share_count")

    @property
    @pulumi.getter(name="virtualmachineShareLevel")
    def virtualmachine_share_level(self) -> pulumi.Output[str]:
        """
        The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
        """
        return pulumi.get(self, "virtualmachine_share_level")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Output[int]:
        """
        The VLAN ID for single VLAN mode. 0 denotes no VLAN.
        """
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="vlanRanges")
    def vlan_ranges(self) -> pulumi.Output[Sequence['outputs.DistributedVirtualSwitchVlanRange']]:
        """
        Used to denote VLAN trunking. Use the `min_vlan`
        and `max_vlan` sub-arguments to define the tagged VLAN range. Multiple
        `vlan_range` definitions are allowed, but they must not overlap. Example
        below:
        """
        return pulumi.get(self, "vlan_ranges")

    @property
    @pulumi.getter(name="vmotionMaximumMbit")
    def vmotion_maximum_mbit(self) -> pulumi.Output[int]:
        """
        The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "vmotion_maximum_mbit")

    @property
    @pulumi.getter(name="vmotionReservationMbit")
    def vmotion_reservation_mbit(self) -> pulumi.Output[int]:
        """
        The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "vmotion_reservation_mbit")

    @property
    @pulumi.getter(name="vmotionShareCount")
    def vmotion_share_count(self) -> pulumi.Output[int]:
        """
        The amount of shares to allocate to the vmotion traffic class for a custom share level.
        """
        return pulumi.get(self, "vmotion_share_count")

    @property
    @pulumi.getter(name="vmotionShareLevel")
    def vmotion_share_level(self) -> pulumi.Output[str]:
        """
        The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
        """
        return pulumi.get(self, "vmotion_share_level")

    @property
    @pulumi.getter(name="vsanMaximumMbit")
    def vsan_maximum_mbit(self) -> pulumi.Output[int]:
        """
        The maximum allowed usage for the vsan traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "vsan_maximum_mbit")

    @property
    @pulumi.getter(name="vsanReservationMbit")
    def vsan_reservation_mbit(self) -> pulumi.Output[int]:
        """
        The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
        """
        return pulumi.get(self, "vsan_reservation_mbit")

    @property
    @pulumi.getter(name="vsanShareCount")
    def vsan_share_count(self) -> pulumi.Output[int]:
        """
        The amount of shares to allocate to the vsan traffic class for a custom share level.
        """
        return pulumi.get(self, "vsan_share_count")

    @property
    @pulumi.getter(name="vsanShareLevel")
    def vsan_share_level(self) -> pulumi.Output[str]:
        """
        The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
        """
        return pulumi.get(self, "vsan_share_level")

    def translate_output_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop

    def translate_input_property(self, prop):
        return _tables.SNAKE_TO_CAMEL_CASE_TABLE.get(prop) or prop

