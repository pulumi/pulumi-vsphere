# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ComputeClusterVsanDiskGroup',
    'ContentLibraryPublication',
    'ContentLibrarySubscription',
    'DistributedPortGroupVlanRange',
    'DistributedVirtualSwitchHost',
    'DistributedVirtualSwitchPvlanMapping',
    'DistributedVirtualSwitchVlanRange',
    'EntityPermissionsPermission',
    'HostPortGroupPorts',
    'VirtualMachineCdrom',
    'VirtualMachineClone',
    'VirtualMachineCloneCustomize',
    'VirtualMachineCloneCustomizeLinuxOptions',
    'VirtualMachineCloneCustomizeNetworkInterface',
    'VirtualMachineCloneCustomizeWindowsOptions',
    'VirtualMachineDisk',
    'VirtualMachineNetworkInterface',
    'VirtualMachineOvfDeploy',
    'VirtualMachineVapp',
    'VmStoragePolicyTagRule',
    'VnicIpv4',
    'VnicIpv6',
    'GetVirtualMachineDiskResult',
    'GetVirtualMachineVappResult',
]

@pulumi.output_type
class ComputeClusterVsanDiskGroup(dict):
    def __init__(__self__, *,
                 cache: Optional[str] = None,
                 storages: Optional[Sequence[str]] = None):
        if cache is not None:
            pulumi.set(__self__, "cache", cache)
        if storages is not None:
            pulumi.set(__self__, "storages", storages)

    @property
    @pulumi.getter
    def cache(self) -> Optional[str]:
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter
    def storages(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "storages")


@pulumi.output_type
class ContentLibraryPublication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethod":
            suggest = "authentication_method"
        elif key == "publishUrl":
            suggest = "publish_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentLibraryPublication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentLibraryPublication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentLibraryPublication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_method: Optional[str] = None,
                 password: Optional[str] = None,
                 publish_url: Optional[str] = None,
                 published: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str authentication_method: Method to log into remote Content Library. Must be `NONE` or `BASIC`.
        :param str password: Password to log in with.
        :param str publish_url: URL to remotely access the published Content Library.
        :param bool published: Bool determining if Content Library is published.
        :param str username: User name to log in with.
        """
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if publish_url is not None:
            pulumi.set(__self__, "publish_url", publish_url)
        if published is not None:
            pulumi.set(__self__, "published", published)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[str]:
        """
        Method to log into remote Content Library. Must be `NONE` or `BASIC`.
        """
        return pulumi.get(self, "authentication_method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password to log in with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="publishUrl")
    def publish_url(self) -> Optional[str]:
        """
        URL to remotely access the published Content Library.
        """
        return pulumi.get(self, "publish_url")

    @property
    @pulumi.getter
    def published(self) -> Optional[bool]:
        """
        Bool determining if Content Library is published.
        """
        return pulumi.get(self, "published")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        User name to log in with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContentLibrarySubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethod":
            suggest = "authentication_method"
        elif key == "automaticSync":
            suggest = "automatic_sync"
        elif key == "onDemand":
            suggest = "on_demand"
        elif key == "subscriptionUrl":
            suggest = "subscription_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentLibrarySubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentLibrarySubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentLibrarySubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_method: Optional[str] = None,
                 automatic_sync: Optional[bool] = None,
                 on_demand: Optional[bool] = None,
                 password: Optional[str] = None,
                 subscription_url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str authentication_method: Method to log into remote Content Library. Must be `NONE` or `BASIC`.
        :param bool automatic_sync: Enable automatic synchronization with the external content library.
        :param bool on_demand: Download all library content immediately.
        :param str password: Password to log in with.
        :param str subscription_url: URL of remote Content Library.
        :param str username: User name to log in with.
        """
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if automatic_sync is not None:
            pulumi.set(__self__, "automatic_sync", automatic_sync)
        if on_demand is not None:
            pulumi.set(__self__, "on_demand", on_demand)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if subscription_url is not None:
            pulumi.set(__self__, "subscription_url", subscription_url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[str]:
        """
        Method to log into remote Content Library. Must be `NONE` or `BASIC`.
        """
        return pulumi.get(self, "authentication_method")

    @property
    @pulumi.getter(name="automaticSync")
    def automatic_sync(self) -> Optional[bool]:
        """
        Enable automatic synchronization with the external content library.
        """
        return pulumi.get(self, "automatic_sync")

    @property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional[bool]:
        """
        Download all library content immediately.
        """
        return pulumi.get(self, "on_demand")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password to log in with.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="subscriptionUrl")
    def subscription_url(self) -> Optional[str]:
        """
        URL of remote Content Library.
        """
        return pulumi.get(self, "subscription_url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        User name to log in with.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DistributedPortGroupVlanRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVlan":
            suggest = "max_vlan"
        elif key == "minVlan":
            suggest = "min_vlan"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributedPortGroupVlanRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributedPortGroupVlanRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributedPortGroupVlanRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_vlan: int,
                 min_vlan: int):
        pulumi.set(__self__, "max_vlan", max_vlan)
        pulumi.set(__self__, "min_vlan", min_vlan)

    @property
    @pulumi.getter(name="maxVlan")
    def max_vlan(self) -> int:
        return pulumi.get(self, "max_vlan")

    @property
    @pulumi.getter(name="minVlan")
    def min_vlan(self) -> int:
        return pulumi.get(self, "min_vlan")


@pulumi.output_type
class DistributedVirtualSwitchHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostSystemId":
            suggest = "host_system_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributedVirtualSwitchHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributedVirtualSwitchHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributedVirtualSwitchHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 devices: Sequence[str],
                 host_system_id: str):
        """
        :param Sequence[str] devices: The list of NIC devices to map to uplinks on the DVS,
               added in order they are specified.
        :param str host_system_id: The host system ID of the host to add to the
               DVS.
        """
        pulumi.set(__self__, "devices", devices)
        pulumi.set(__self__, "host_system_id", host_system_id)

    @property
    @pulumi.getter
    def devices(self) -> Sequence[str]:
        """
        The list of NIC devices to map to uplinks on the DVS,
        added in order they are specified.
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="hostSystemId")
    def host_system_id(self) -> str:
        """
        The host system ID of the host to add to the
        DVS.
        """
        return pulumi.get(self, "host_system_id")


@pulumi.output_type
class DistributedVirtualSwitchPvlanMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryVlanId":
            suggest = "primary_vlan_id"
        elif key == "pvlanType":
            suggest = "pvlan_type"
        elif key == "secondaryVlanId":
            suggest = "secondary_vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributedVirtualSwitchPvlanMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributedVirtualSwitchPvlanMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributedVirtualSwitchPvlanMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_vlan_id: int,
                 pvlan_type: str,
                 secondary_vlan_id: int):
        """
        :param int primary_vlan_id: The primary VLAN ID. The VLAN IDs of 0 and
               4095 are reserved and cannot be used in this property.
        :param str pvlan_type: The private VLAN type. Valid values are
               promiscuous, community and isolated.
        :param int secondary_vlan_id: The secondary VLAN ID. The VLAN IDs of 0
               and 4095 are reserved and cannot be used in this property.
        """
        pulumi.set(__self__, "primary_vlan_id", primary_vlan_id)
        pulumi.set(__self__, "pvlan_type", pvlan_type)
        pulumi.set(__self__, "secondary_vlan_id", secondary_vlan_id)

    @property
    @pulumi.getter(name="primaryVlanId")
    def primary_vlan_id(self) -> int:
        """
        The primary VLAN ID. The VLAN IDs of 0 and
        4095 are reserved and cannot be used in this property.
        """
        return pulumi.get(self, "primary_vlan_id")

    @property
    @pulumi.getter(name="pvlanType")
    def pvlan_type(self) -> str:
        """
        The private VLAN type. Valid values are
        promiscuous, community and isolated.
        """
        return pulumi.get(self, "pvlan_type")

    @property
    @pulumi.getter(name="secondaryVlanId")
    def secondary_vlan_id(self) -> int:
        """
        The secondary VLAN ID. The VLAN IDs of 0
        and 4095 are reserved and cannot be used in this property.
        """
        return pulumi.get(self, "secondary_vlan_id")


@pulumi.output_type
class DistributedVirtualSwitchVlanRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVlan":
            suggest = "max_vlan"
        elif key == "minVlan":
            suggest = "min_vlan"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributedVirtualSwitchVlanRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributedVirtualSwitchVlanRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributedVirtualSwitchVlanRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_vlan: int,
                 min_vlan: int):
        pulumi.set(__self__, "max_vlan", max_vlan)
        pulumi.set(__self__, "min_vlan", min_vlan)

    @property
    @pulumi.getter(name="maxVlan")
    def max_vlan(self) -> int:
        return pulumi.get(self, "max_vlan")

    @property
    @pulumi.getter(name="minVlan")
    def min_vlan(self) -> int:
        return pulumi.get(self, "min_vlan")


@pulumi.output_type
class EntityPermissionsPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isGroup":
            suggest = "is_group"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "userOrGroup":
            suggest = "user_or_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntityPermissionsPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntityPermissionsPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntityPermissionsPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_group: bool,
                 propagate: bool,
                 role_id: str,
                 user_or_group: str):
        """
        :param bool is_group: Whether user_or_group field refers to a user or a group. True for a group and false for a user.
        :param bool propagate: Whether or not this permission propagates down the hierarchy to sub-entities.
        :param str role_id: The role id of the role to be given to the user on the specified entity.
        :param str user_or_group: The user/group getting the permission.
        """
        pulumi.set(__self__, "is_group", is_group)
        pulumi.set(__self__, "propagate", propagate)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "user_or_group", user_or_group)

    @property
    @pulumi.getter(name="isGroup")
    def is_group(self) -> bool:
        """
        Whether user_or_group field refers to a user or a group. True for a group and false for a user.
        """
        return pulumi.get(self, "is_group")

    @property
    @pulumi.getter
    def propagate(self) -> bool:
        """
        Whether or not this permission propagates down the hierarchy to sub-entities.
        """
        return pulumi.get(self, "propagate")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        The role id of the role to be given to the user on the specified entity.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="userOrGroup")
    def user_or_group(self) -> str:
        """
        The user/group getting the permission.
        """
        return pulumi.get(self, "user_or_group")


@pulumi.output_type
class HostPortGroupPorts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macAddresses":
            suggest = "mac_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostPortGroupPorts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostPortGroupPorts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostPortGroupPorts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mac_addresses: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str key: The key for this port group as returned from the vSphere API.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mac_addresses is not None:
            pulumi.set(__self__, "mac_addresses", mac_addresses)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key for this port group as returned from the vSphere API.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="macAddresses")
    def mac_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "mac_addresses")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class VirtualMachineCdrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientDevice":
            suggest = "client_device"
        elif key == "datastoreId":
            suggest = "datastore_id"
        elif key == "deviceAddress":
            suggest = "device_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCdrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCdrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCdrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_device: Optional[bool] = None,
                 datastore_id: Optional[str] = None,
                 device_address: Optional[str] = None,
                 key: Optional[int] = None,
                 path: Optional[str] = None):
        """
        :param bool client_device: Indicates whether the device should be backed by
               remote client device. Conflicts with `datastore_id` and `path`.
        :param str datastore_id: The datastore ID that the ISO is located in.
               Requried for using a datastore ISO. Conflicts with `client_device`.
        :param str device_address: An address internal to this provider that helps locate the
               device when `key` is unavailable. This follows a convention of
               `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device
               unit 1 on SCSI bus 0.
        :param int key: The ID of the device within the virtual machine.
        :param str path: The path to the ISO file. Required for using a datastore
               ISO. Conflicts with `client_device`.
        """
        if client_device is not None:
            pulumi.set(__self__, "client_device", client_device)
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if device_address is not None:
            pulumi.set(__self__, "device_address", device_address)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="clientDevice")
    def client_device(self) -> Optional[bool]:
        """
        Indicates whether the device should be backed by
        remote client device. Conflicts with `datastore_id` and `path`.
        """
        return pulumi.get(self, "client_device")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        The datastore ID that the ISO is located in.
        Requried for using a datastore ISO. Conflicts with `client_device`.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter(name="deviceAddress")
    def device_address(self) -> Optional[str]:
        """
        An address internal to this provider that helps locate the
        device when `key` is unavailable. This follows a convention of
        `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device
        unit 1 on SCSI bus 0.
        """
        return pulumi.get(self, "device_address")

    @property
    @pulumi.getter
    def key(self) -> Optional[int]:
        """
        The ID of the device within the virtual machine.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the ISO file. Required for using a datastore
        ISO. Conflicts with `client_device`.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class VirtualMachineClone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateUuid":
            suggest = "template_uuid"
        elif key == "linkedClone":
            suggest = "linked_clone"
        elif key == "ovfNetworkMap":
            suggest = "ovf_network_map"
        elif key == "ovfStorageMap":
            suggest = "ovf_storage_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineClone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineClone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineClone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_uuid: str,
                 customize: Optional['outputs.VirtualMachineCloneCustomize'] = None,
                 linked_clone: Optional[bool] = None,
                 ovf_network_map: Optional[Mapping[str, str]] = None,
                 ovf_storage_map: Optional[Mapping[str, str]] = None,
                 timeout: Optional[int] = None):
        pulumi.set(__self__, "template_uuid", template_uuid)
        if customize is not None:
            pulumi.set(__self__, "customize", customize)
        if linked_clone is not None:
            pulumi.set(__self__, "linked_clone", linked_clone)
        if ovf_network_map is not None:
            pulumi.set(__self__, "ovf_network_map", ovf_network_map)
        if ovf_storage_map is not None:
            pulumi.set(__self__, "ovf_storage_map", ovf_storage_map)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="templateUuid")
    def template_uuid(self) -> str:
        return pulumi.get(self, "template_uuid")

    @property
    @pulumi.getter
    def customize(self) -> Optional['outputs.VirtualMachineCloneCustomize']:
        return pulumi.get(self, "customize")

    @property
    @pulumi.getter(name="linkedClone")
    def linked_clone(self) -> Optional[bool]:
        return pulumi.get(self, "linked_clone")

    @property
    @pulumi.getter(name="ovfNetworkMap")
    def ovf_network_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "ovf_network_map")

    @property
    @pulumi.getter(name="ovfStorageMap")
    def ovf_storage_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "ovf_storage_map")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class VirtualMachineCloneCustomize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServerLists":
            suggest = "dns_server_lists"
        elif key == "dnsSuffixLists":
            suggest = "dns_suffix_lists"
        elif key == "ipv4Gateway":
            suggest = "ipv4_gateway"
        elif key == "ipv6Gateway":
            suggest = "ipv6_gateway"
        elif key == "linuxOptions":
            suggest = "linux_options"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "windowsOptions":
            suggest = "windows_options"
        elif key == "windowsSysprepText":
            suggest = "windows_sysprep_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCloneCustomize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCloneCustomize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCloneCustomize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_server_lists: Optional[Sequence[str]] = None,
                 dns_suffix_lists: Optional[Sequence[str]] = None,
                 ipv4_gateway: Optional[str] = None,
                 ipv6_gateway: Optional[str] = None,
                 linux_options: Optional['outputs.VirtualMachineCloneCustomizeLinuxOptions'] = None,
                 network_interfaces: Optional[Sequence['outputs.VirtualMachineCloneCustomizeNetworkInterface']] = None,
                 timeout: Optional[int] = None,
                 windows_options: Optional['outputs.VirtualMachineCloneCustomizeWindowsOptions'] = None,
                 windows_sysprep_text: Optional[str] = None):
        """
        :param Sequence['VirtualMachineCloneCustomizeNetworkInterfaceArgs'] network_interfaces: A specification for a virtual NIC on this
               virtual machine. See network interface options
               below.
        """
        if dns_server_lists is not None:
            pulumi.set(__self__, "dns_server_lists", dns_server_lists)
        if dns_suffix_lists is not None:
            pulumi.set(__self__, "dns_suffix_lists", dns_suffix_lists)
        if ipv4_gateway is not None:
            pulumi.set(__self__, "ipv4_gateway", ipv4_gateway)
        if ipv6_gateway is not None:
            pulumi.set(__self__, "ipv6_gateway", ipv6_gateway)
        if linux_options is not None:
            pulumi.set(__self__, "linux_options", linux_options)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)
        if windows_sysprep_text is not None:
            pulumi.set(__self__, "windows_sysprep_text", windows_sysprep_text)

    @property
    @pulumi.getter(name="dnsServerLists")
    def dns_server_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_server_lists")

    @property
    @pulumi.getter(name="dnsSuffixLists")
    def dns_suffix_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_suffix_lists")

    @property
    @pulumi.getter(name="ipv4Gateway")
    def ipv4_gateway(self) -> Optional[str]:
        return pulumi.get(self, "ipv4_gateway")

    @property
    @pulumi.getter(name="ipv6Gateway")
    def ipv6_gateway(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_gateway")

    @property
    @pulumi.getter(name="linuxOptions")
    def linux_options(self) -> Optional['outputs.VirtualMachineCloneCustomizeLinuxOptions']:
        return pulumi.get(self, "linux_options")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.VirtualMachineCloneCustomizeNetworkInterface']]:
        """
        A specification for a virtual NIC on this
        virtual machine. See network interface options
        below.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.VirtualMachineCloneCustomizeWindowsOptions']:
        return pulumi.get(self, "windows_options")

    @property
    @pulumi.getter(name="windowsSysprepText")
    def windows_sysprep_text(self) -> Optional[str]:
        return pulumi.get(self, "windows_sysprep_text")


@pulumi.output_type
class VirtualMachineCloneCustomizeLinuxOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "hwClockUtc":
            suggest = "hw_clock_utc"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCloneCustomizeLinuxOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCloneCustomizeLinuxOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCloneCustomizeLinuxOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 host_name: str,
                 hw_clock_utc: Optional[bool] = None,
                 time_zone: Optional[str] = None):
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "host_name", host_name)
        if hw_clock_utc is not None:
            pulumi.set(__self__, "hw_clock_utc", hw_clock_utc)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="hwClockUtc")
    def hw_clock_utc(self) -> Optional[bool]:
        return pulumi.get(self, "hw_clock_utc")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class VirtualMachineCloneCustomizeNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsDomain":
            suggest = "dns_domain"
        elif key == "dnsServerLists":
            suggest = "dns_server_lists"
        elif key == "ipv4Address":
            suggest = "ipv4_address"
        elif key == "ipv4Netmask":
            suggest = "ipv4_netmask"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "ipv6Netmask":
            suggest = "ipv6_netmask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCloneCustomizeNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCloneCustomizeNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCloneCustomizeNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_domain: Optional[str] = None,
                 dns_server_lists: Optional[Sequence[str]] = None,
                 ipv4_address: Optional[str] = None,
                 ipv4_netmask: Optional[int] = None,
                 ipv6_address: Optional[str] = None,
                 ipv6_netmask: Optional[int] = None):
        if dns_domain is not None:
            pulumi.set(__self__, "dns_domain", dns_domain)
        if dns_server_lists is not None:
            pulumi.set(__self__, "dns_server_lists", dns_server_lists)
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)
        if ipv4_netmask is not None:
            pulumi.set(__self__, "ipv4_netmask", ipv4_netmask)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_netmask is not None:
            pulumi.set(__self__, "ipv6_netmask", ipv6_netmask)

    @property
    @pulumi.getter(name="dnsDomain")
    def dns_domain(self) -> Optional[str]:
        return pulumi.get(self, "dns_domain")

    @property
    @pulumi.getter(name="dnsServerLists")
    def dns_server_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_server_lists")

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[str]:
        return pulumi.get(self, "ipv4_address")

    @property
    @pulumi.getter(name="ipv4Netmask")
    def ipv4_netmask(self) -> Optional[int]:
        return pulumi.get(self, "ipv4_netmask")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6Netmask")
    def ipv6_netmask(self) -> Optional[int]:
        return pulumi.get(self, "ipv6_netmask")


@pulumi.output_type
class VirtualMachineCloneCustomizeWindowsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computerName":
            suggest = "computer_name"
        elif key == "adminPassword":
            suggest = "admin_password"
        elif key == "autoLogon":
            suggest = "auto_logon"
        elif key == "autoLogonCount":
            suggest = "auto_logon_count"
        elif key == "domainAdminPassword":
            suggest = "domain_admin_password"
        elif key == "domainAdminUser":
            suggest = "domain_admin_user"
        elif key == "fullName":
            suggest = "full_name"
        elif key == "joinDomain":
            suggest = "join_domain"
        elif key == "organizationName":
            suggest = "organization_name"
        elif key == "productKey":
            suggest = "product_key"
        elif key == "runOnceCommandLists":
            suggest = "run_once_command_lists"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCloneCustomizeWindowsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCloneCustomizeWindowsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCloneCustomizeWindowsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computer_name: str,
                 admin_password: Optional[str] = None,
                 auto_logon: Optional[bool] = None,
                 auto_logon_count: Optional[int] = None,
                 domain_admin_password: Optional[str] = None,
                 domain_admin_user: Optional[str] = None,
                 full_name: Optional[str] = None,
                 join_domain: Optional[str] = None,
                 organization_name: Optional[str] = None,
                 product_key: Optional[str] = None,
                 run_once_command_lists: Optional[Sequence[str]] = None,
                 time_zone: Optional[int] = None,
                 workgroup: Optional[str] = None):
        pulumi.set(__self__, "computer_name", computer_name)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if auto_logon is not None:
            pulumi.set(__self__, "auto_logon", auto_logon)
        if auto_logon_count is not None:
            pulumi.set(__self__, "auto_logon_count", auto_logon_count)
        if domain_admin_password is not None:
            pulumi.set(__self__, "domain_admin_password", domain_admin_password)
        if domain_admin_user is not None:
            pulumi.set(__self__, "domain_admin_user", domain_admin_user)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if join_domain is not None:
            pulumi.set(__self__, "join_domain", join_domain)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if product_key is not None:
            pulumi.set(__self__, "product_key", product_key)
        if run_once_command_lists is not None:
            pulumi.set(__self__, "run_once_command_lists", run_once_command_lists)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if workgroup is not None:
            pulumi.set(__self__, "workgroup", workgroup)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> str:
        return pulumi.get(self, "computer_name")

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="autoLogon")
    def auto_logon(self) -> Optional[bool]:
        return pulumi.get(self, "auto_logon")

    @property
    @pulumi.getter(name="autoLogonCount")
    def auto_logon_count(self) -> Optional[int]:
        return pulumi.get(self, "auto_logon_count")

    @property
    @pulumi.getter(name="domainAdminPassword")
    def domain_admin_password(self) -> Optional[str]:
        return pulumi.get(self, "domain_admin_password")

    @property
    @pulumi.getter(name="domainAdminUser")
    def domain_admin_user(self) -> Optional[str]:
        return pulumi.get(self, "domain_admin_user")

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        return pulumi.get(self, "full_name")

    @property
    @pulumi.getter(name="joinDomain")
    def join_domain(self) -> Optional[str]:
        return pulumi.get(self, "join_domain")

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[str]:
        return pulumi.get(self, "organization_name")

    @property
    @pulumi.getter(name="productKey")
    def product_key(self) -> Optional[str]:
        return pulumi.get(self, "product_key")

    @property
    @pulumi.getter(name="runOnceCommandLists")
    def run_once_command_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "run_once_command_lists")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[int]:
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def workgroup(self) -> Optional[str]:
        return pulumi.get(self, "workgroup")


@pulumi.output_type
class VirtualMachineDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controllerType":
            suggest = "controller_type"
        elif key == "datastoreId":
            suggest = "datastore_id"
        elif key == "deviceAddress":
            suggest = "device_address"
        elif key == "diskMode":
            suggest = "disk_mode"
        elif key == "diskSharing":
            suggest = "disk_sharing"
        elif key == "eagerlyScrub":
            suggest = "eagerly_scrub"
        elif key == "ioLimit":
            suggest = "io_limit"
        elif key == "ioReservation":
            suggest = "io_reservation"
        elif key == "ioShareCount":
            suggest = "io_share_count"
        elif key == "ioShareLevel":
            suggest = "io_share_level"
        elif key == "keepOnRemove":
            suggest = "keep_on_remove"
        elif key == "storagePolicyId":
            suggest = "storage_policy_id"
        elif key == "thinProvisioned":
            suggest = "thin_provisioned"
        elif key == "unitNumber":
            suggest = "unit_number"
        elif key == "writeThrough":
            suggest = "write_through"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach: Optional[bool] = None,
                 controller_type: Optional[str] = None,
                 datastore_id: Optional[str] = None,
                 device_address: Optional[str] = None,
                 disk_mode: Optional[str] = None,
                 disk_sharing: Optional[str] = None,
                 eagerly_scrub: Optional[bool] = None,
                 io_limit: Optional[int] = None,
                 io_reservation: Optional[int] = None,
                 io_share_count: Optional[int] = None,
                 io_share_level: Optional[str] = None,
                 keep_on_remove: Optional[bool] = None,
                 key: Optional[int] = None,
                 label: Optional[str] = None,
                 name: Optional[str] = None,
                 path: Optional[str] = None,
                 size: Optional[int] = None,
                 storage_policy_id: Optional[str] = None,
                 thin_provisioned: Optional[bool] = None,
                 unit_number: Optional[int] = None,
                 uuid: Optional[str] = None,
                 write_through: Optional[bool] = None):
        """
        :param bool attach: Attach an external disk instead of creating a new one.
               Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`,
               `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
        :param str controller_type: The type of storage controller to attach the
               disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate
               number of controllers enabled for the selected type. Default `scsi`.
        :param str datastore_id: The datastore ID that the ISO is located in.
               Requried for using a datastore ISO. Conflicts with `client_device`.
        :param str device_address: An address internal to this provider that helps locate the
               device when `key` is unavailable. This follows a convention of
               `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device
               unit 1 on SCSI bus 0.
        :param str disk_mode: The mode of this this virtual disk for purposes of
               writes and snapshotting. Can be one of `append`, `independent_nonpersistent`,
               `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`.
               Default: `persistent`. For an explanation of options, click
               [here][vmware-docs-disk-mode].
        :param str disk_sharing: The sharing mode of this virtual disk. Can be one
               of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
        :param bool eagerly_scrub: If set to `true`, the disk space is zeroed out
               on VM creation. This will delay the creation of the disk or virtual machine.
               Cannot be set to `true` when `thin_provisioned` is `true`.  See the section
               on picking a disk type.  Default: `false`.
        :param int io_limit: The upper limit of IOPS that this disk can use. The
               default is no limit.
        :param int io_reservation: The I/O reservation (guarantee) that this disk
               has, in IOPS.  The default is no reservation.
        :param int io_share_count: The share count for this disk when the share
               level is `custom`.
        :param str io_share_level: The share allocation level for this disk. Can
               be one of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        :param bool keep_on_remove: Keep this disk when removing the device or
               destroying the virtual machine. Default: `false`.
        :param int key: The ID of the device within the virtual machine.
        :param str label: A label for the disk. Forces a new disk if changed.
        :param str name: An alias for both `label` and `path`, the latter when
               using `attach`. Required if not using `label`.
        :param str path: The path to the ISO file. Required for using a datastore
               ISO. Conflicts with `client_device`.
        :param int size: The size of the disk, in GB.
        :param str storage_policy_id: The UUID of the storage policy to assign to this disk.
        :param bool thin_provisioned: If `true`, this disk is thin provisioned,
               with space for the file being allocated on an as-needed basis. Cannot be set
               to `true` when `eagerly_scrub` is `true`. See the section on picking a disk
               type. Default: `true`.
        :param int unit_number: The disk number on the storage bus. The maximum
               value for this setting is the value of the controller count times the
               controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE).
               The default is `0`, for which one disk must be set to. Duplicate unit numbers
               are not allowed.
        :param str uuid: The UUID of the virtual disk's VMDK file. This is used to track the
               virtual disk on the virtual machine.
        :param bool write_through: If `true`, writes for this disk are sent
               directly to the filesystem immediately instead of being buffered. Default:
               `false`.
        """
        if attach is not None:
            pulumi.set(__self__, "attach", attach)
        if controller_type is not None:
            pulumi.set(__self__, "controller_type", controller_type)
        if datastore_id is not None:
            pulumi.set(__self__, "datastore_id", datastore_id)
        if device_address is not None:
            pulumi.set(__self__, "device_address", device_address)
        if disk_mode is not None:
            pulumi.set(__self__, "disk_mode", disk_mode)
        if disk_sharing is not None:
            pulumi.set(__self__, "disk_sharing", disk_sharing)
        if eagerly_scrub is not None:
            pulumi.set(__self__, "eagerly_scrub", eagerly_scrub)
        if io_limit is not None:
            pulumi.set(__self__, "io_limit", io_limit)
        if io_reservation is not None:
            pulumi.set(__self__, "io_reservation", io_reservation)
        if io_share_count is not None:
            pulumi.set(__self__, "io_share_count", io_share_count)
        if io_share_level is not None:
            pulumi.set(__self__, "io_share_level", io_share_level)
        if keep_on_remove is not None:
            pulumi.set(__self__, "keep_on_remove", keep_on_remove)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if storage_policy_id is not None:
            pulumi.set(__self__, "storage_policy_id", storage_policy_id)
        if thin_provisioned is not None:
            pulumi.set(__self__, "thin_provisioned", thin_provisioned)
        if unit_number is not None:
            pulumi.set(__self__, "unit_number", unit_number)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if write_through is not None:
            pulumi.set(__self__, "write_through", write_through)

    @property
    @pulumi.getter
    def attach(self) -> Optional[bool]:
        """
        Attach an external disk instead of creating a new one.
        Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`,
        `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
        """
        return pulumi.get(self, "attach")

    @property
    @pulumi.getter(name="controllerType")
    def controller_type(self) -> Optional[str]:
        """
        The type of storage controller to attach the
        disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate
        number of controllers enabled for the selected type. Default `scsi`.
        """
        return pulumi.get(self, "controller_type")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        The datastore ID that the ISO is located in.
        Requried for using a datastore ISO. Conflicts with `client_device`.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter(name="deviceAddress")
    def device_address(self) -> Optional[str]:
        """
        An address internal to this provider that helps locate the
        device when `key` is unavailable. This follows a convention of
        `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device
        unit 1 on SCSI bus 0.
        """
        return pulumi.get(self, "device_address")

    @property
    @pulumi.getter(name="diskMode")
    def disk_mode(self) -> Optional[str]:
        """
        The mode of this this virtual disk for purposes of
        writes and snapshotting. Can be one of `append`, `independent_nonpersistent`,
        `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`.
        Default: `persistent`. For an explanation of options, click
        [here][vmware-docs-disk-mode].
        """
        return pulumi.get(self, "disk_mode")

    @property
    @pulumi.getter(name="diskSharing")
    def disk_sharing(self) -> Optional[str]:
        """
        The sharing mode of this virtual disk. Can be one
        of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
        """
        return pulumi.get(self, "disk_sharing")

    @property
    @pulumi.getter(name="eagerlyScrub")
    def eagerly_scrub(self) -> Optional[bool]:
        """
        If set to `true`, the disk space is zeroed out
        on VM creation. This will delay the creation of the disk or virtual machine.
        Cannot be set to `true` when `thin_provisioned` is `true`.  See the section
        on picking a disk type.  Default: `false`.
        """
        return pulumi.get(self, "eagerly_scrub")

    @property
    @pulumi.getter(name="ioLimit")
    def io_limit(self) -> Optional[int]:
        """
        The upper limit of IOPS that this disk can use. The
        default is no limit.
        """
        return pulumi.get(self, "io_limit")

    @property
    @pulumi.getter(name="ioReservation")
    def io_reservation(self) -> Optional[int]:
        """
        The I/O reservation (guarantee) that this disk
        has, in IOPS.  The default is no reservation.
        """
        return pulumi.get(self, "io_reservation")

    @property
    @pulumi.getter(name="ioShareCount")
    def io_share_count(self) -> Optional[int]:
        """
        The share count for this disk when the share
        level is `custom`.
        """
        return pulumi.get(self, "io_share_count")

    @property
    @pulumi.getter(name="ioShareLevel")
    def io_share_level(self) -> Optional[str]:
        """
        The share allocation level for this disk. Can
        be one of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        """
        return pulumi.get(self, "io_share_level")

    @property
    @pulumi.getter(name="keepOnRemove")
    def keep_on_remove(self) -> Optional[bool]:
        """
        Keep this disk when removing the device or
        destroying the virtual machine. Default: `false`.
        """
        return pulumi.get(self, "keep_on_remove")

    @property
    @pulumi.getter
    def key(self) -> Optional[int]:
        """
        The ID of the device within the virtual machine.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A label for the disk. Forces a new disk if changed.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        An alias for both `label` and `path`, the latter when
        using `attach`. Required if not using `label`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the ISO file. Required for using a datastore
        ISO. Conflicts with `client_device`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the disk, in GB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="storagePolicyId")
    def storage_policy_id(self) -> Optional[str]:
        """
        The UUID of the storage policy to assign to this disk.
        """
        return pulumi.get(self, "storage_policy_id")

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> Optional[bool]:
        """
        If `true`, this disk is thin provisioned,
        with space for the file being allocated on an as-needed basis. Cannot be set
        to `true` when `eagerly_scrub` is `true`. See the section on picking a disk
        type. Default: `true`.
        """
        return pulumi.get(self, "thin_provisioned")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> Optional[int]:
        """
        The disk number on the storage bus. The maximum
        value for this setting is the value of the controller count times the
        controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE).
        The default is `0`, for which one disk must be set to. Duplicate unit numbers
        are not allowed.
        """
        return pulumi.get(self, "unit_number")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        The UUID of the virtual disk's VMDK file. This is used to track the
        virtual disk on the virtual machine.
        """
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter(name="writeThrough")
    def write_through(self) -> Optional[bool]:
        """
        If `true`, writes for this disk are sent
        directly to the filesystem immediately instead of being buffered. Default:
        `false`.
        """
        return pulumi.get(self, "write_through")


@pulumi.output_type
class VirtualMachineNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "adapterType":
            suggest = "adapter_type"
        elif key == "bandwidthLimit":
            suggest = "bandwidth_limit"
        elif key == "bandwidthReservation":
            suggest = "bandwidth_reservation"
        elif key == "bandwidthShareCount":
            suggest = "bandwidth_share_count"
        elif key == "bandwidthShareLevel":
            suggest = "bandwidth_share_level"
        elif key == "deviceAddress":
            suggest = "device_address"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "ovfMapping":
            suggest = "ovf_mapping"
        elif key == "useStaticMac":
            suggest = "use_static_mac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 adapter_type: Optional[str] = None,
                 bandwidth_limit: Optional[int] = None,
                 bandwidth_reservation: Optional[int] = None,
                 bandwidth_share_count: Optional[int] = None,
                 bandwidth_share_level: Optional[str] = None,
                 device_address: Optional[str] = None,
                 key: Optional[int] = None,
                 mac_address: Optional[str] = None,
                 ovf_mapping: Optional[str] = None,
                 use_static_mac: Optional[bool] = None):
        """
        :param str network_id: The managed object reference
               ID of the network to connect this interface to.
        :param str adapter_type: The network interface type. Can be one of
               `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.
        :param int bandwidth_limit: The upper bandwidth limit of this network
               interface, in Mbits/sec. The default is no limit.
        :param int bandwidth_reservation: The bandwidth reservation of this
               network interface, in Mbits/sec. The default is no reservation.
        :param int bandwidth_share_count: The share count for this network
               interface when the share level is `custom`.
        :param str bandwidth_share_level: The bandwidth share allocation level for
               this interface. Can be one of `low`, `normal`, `high`, or `custom`. Default:
               `normal`.
        :param str device_address: An address internal to this provider that helps locate the
               device when `key` is unavailable. This follows a convention of
               `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device
               unit 1 on SCSI bus 0.
        :param int key: The ID of the device within the virtual machine.
        :param str mac_address: The MAC address of this network interface. Can
               only be manually set if `use_static_mac` is true, otherwise this is a
               computed value that gives the current MAC address of this interface.
        :param str ovf_mapping: Specifies which OVF NIC the `network_interface`
               should be associated with. Only applies at creation and only when deploying
               from an OVF source.
        :param bool use_static_mac: If true, the `mac_address` field is treated as
               a static MAC address and set accordingly. Setting this to `true` requires
               `mac_address` to be set. Default: `false`.
        """
        pulumi.set(__self__, "network_id", network_id)
        if adapter_type is not None:
            pulumi.set(__self__, "adapter_type", adapter_type)
        if bandwidth_limit is not None:
            pulumi.set(__self__, "bandwidth_limit", bandwidth_limit)
        if bandwidth_reservation is not None:
            pulumi.set(__self__, "bandwidth_reservation", bandwidth_reservation)
        if bandwidth_share_count is not None:
            pulumi.set(__self__, "bandwidth_share_count", bandwidth_share_count)
        if bandwidth_share_level is not None:
            pulumi.set(__self__, "bandwidth_share_level", bandwidth_share_level)
        if device_address is not None:
            pulumi.set(__self__, "device_address", device_address)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if ovf_mapping is not None:
            pulumi.set(__self__, "ovf_mapping", ovf_mapping)
        if use_static_mac is not None:
            pulumi.set(__self__, "use_static_mac", use_static_mac)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        The managed object reference
        ID of the network to connect this interface to.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> Optional[str]:
        """
        The network interface type. Can be one of
        `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.
        """
        return pulumi.get(self, "adapter_type")

    @property
    @pulumi.getter(name="bandwidthLimit")
    def bandwidth_limit(self) -> Optional[int]:
        """
        The upper bandwidth limit of this network
        interface, in Mbits/sec. The default is no limit.
        """
        return pulumi.get(self, "bandwidth_limit")

    @property
    @pulumi.getter(name="bandwidthReservation")
    def bandwidth_reservation(self) -> Optional[int]:
        """
        The bandwidth reservation of this
        network interface, in Mbits/sec. The default is no reservation.
        """
        return pulumi.get(self, "bandwidth_reservation")

    @property
    @pulumi.getter(name="bandwidthShareCount")
    def bandwidth_share_count(self) -> Optional[int]:
        """
        The share count for this network
        interface when the share level is `custom`.
        """
        return pulumi.get(self, "bandwidth_share_count")

    @property
    @pulumi.getter(name="bandwidthShareLevel")
    def bandwidth_share_level(self) -> Optional[str]:
        """
        The bandwidth share allocation level for
        this interface. Can be one of `low`, `normal`, `high`, or `custom`. Default:
        `normal`.
        """
        return pulumi.get(self, "bandwidth_share_level")

    @property
    @pulumi.getter(name="deviceAddress")
    def device_address(self) -> Optional[str]:
        """
        An address internal to this provider that helps locate the
        device when `key` is unavailable. This follows a convention of
        `CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device
        unit 1 on SCSI bus 0.
        """
        return pulumi.get(self, "device_address")

    @property
    @pulumi.getter
    def key(self) -> Optional[int]:
        """
        The ID of the device within the virtual machine.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        The MAC address of this network interface. Can
        only be manually set if `use_static_mac` is true, otherwise this is a
        computed value that gives the current MAC address of this interface.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="ovfMapping")
    def ovf_mapping(self) -> Optional[str]:
        """
        Specifies which OVF NIC the `network_interface`
        should be associated with. Only applies at creation and only when deploying
        from an OVF source.
        """
        return pulumi.get(self, "ovf_mapping")

    @property
    @pulumi.getter(name="useStaticMac")
    def use_static_mac(self) -> Optional[bool]:
        """
        If true, the `mac_address` field is treated as
        a static MAC address and set accordingly. Setting this to `true` requires
        `mac_address` to be set. Default: `false`.
        """
        return pulumi.get(self, "use_static_mac")


@pulumi.output_type
class VirtualMachineOvfDeploy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowUnverifiedSslCert":
            suggest = "allow_unverified_ssl_cert"
        elif key == "deploymentOption":
            suggest = "deployment_option"
        elif key == "diskProvisioning":
            suggest = "disk_provisioning"
        elif key == "ipAllocationPolicy":
            suggest = "ip_allocation_policy"
        elif key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "localOvfPath":
            suggest = "local_ovf_path"
        elif key == "ovfNetworkMap":
            suggest = "ovf_network_map"
        elif key == "remoteOvfUrl":
            suggest = "remote_ovf_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOvfDeploy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOvfDeploy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOvfDeploy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_unverified_ssl_cert: Optional[bool] = None,
                 deployment_option: Optional[str] = None,
                 disk_provisioning: Optional[str] = None,
                 ip_allocation_policy: Optional[str] = None,
                 ip_protocol: Optional[str] = None,
                 local_ovf_path: Optional[str] = None,
                 ovf_network_map: Optional[Mapping[str, str]] = None,
                 remote_ovf_url: Optional[str] = None):
        if allow_unverified_ssl_cert is not None:
            pulumi.set(__self__, "allow_unverified_ssl_cert", allow_unverified_ssl_cert)
        if deployment_option is not None:
            pulumi.set(__self__, "deployment_option", deployment_option)
        if disk_provisioning is not None:
            pulumi.set(__self__, "disk_provisioning", disk_provisioning)
        if ip_allocation_policy is not None:
            pulumi.set(__self__, "ip_allocation_policy", ip_allocation_policy)
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if local_ovf_path is not None:
            pulumi.set(__self__, "local_ovf_path", local_ovf_path)
        if ovf_network_map is not None:
            pulumi.set(__self__, "ovf_network_map", ovf_network_map)
        if remote_ovf_url is not None:
            pulumi.set(__self__, "remote_ovf_url", remote_ovf_url)

    @property
    @pulumi.getter(name="allowUnverifiedSslCert")
    def allow_unverified_ssl_cert(self) -> Optional[bool]:
        return pulumi.get(self, "allow_unverified_ssl_cert")

    @property
    @pulumi.getter(name="deploymentOption")
    def deployment_option(self) -> Optional[str]:
        return pulumi.get(self, "deployment_option")

    @property
    @pulumi.getter(name="diskProvisioning")
    def disk_provisioning(self) -> Optional[str]:
        return pulumi.get(self, "disk_provisioning")

    @property
    @pulumi.getter(name="ipAllocationPolicy")
    def ip_allocation_policy(self) -> Optional[str]:
        return pulumi.get(self, "ip_allocation_policy")

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[str]:
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter(name="localOvfPath")
    def local_ovf_path(self) -> Optional[str]:
        return pulumi.get(self, "local_ovf_path")

    @property
    @pulumi.getter(name="ovfNetworkMap")
    def ovf_network_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "ovf_network_map")

    @property
    @pulumi.getter(name="remoteOvfUrl")
    def remote_ovf_url(self) -> Optional[str]:
        return pulumi.get(self, "remote_ovf_url")


@pulumi.output_type
class VirtualMachineVapp(dict):
    def __init__(__self__, *,
                 properties: Optional[Mapping[str, str]] = None):
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "properties")


@pulumi.output_type
class VmStoragePolicyTagRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagCategory":
            suggest = "tag_category"
        elif key == "includeDatastoresWithTags":
            suggest = "include_datastores_with_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmStoragePolicyTagRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmStoragePolicyTagRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmStoragePolicyTagRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_category: str,
                 tags: Sequence[str],
                 include_datastores_with_tags: Optional[bool] = None):
        """
        :param str tag_category: Name of the tag category.
        :param Sequence[str] tags: List of Name of tags to select from the given category.
        :param bool include_datastores_with_tags: Whether to include datastores with the given tags or exclude. Default 
               value is true i.e. include datastores with the given tags.
        """
        pulumi.set(__self__, "tag_category", tag_category)
        pulumi.set(__self__, "tags", tags)
        if include_datastores_with_tags is not None:
            pulumi.set(__self__, "include_datastores_with_tags", include_datastores_with_tags)

    @property
    @pulumi.getter(name="tagCategory")
    def tag_category(self) -> str:
        """
        Name of the tag category.
        """
        return pulumi.get(self, "tag_category")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of Name of tags to select from the given category.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="includeDatastoresWithTags")
    def include_datastores_with_tags(self) -> Optional[bool]:
        """
        Whether to include datastores with the given tags or exclude. Default 
        value is true i.e. include datastores with the given tags.
        """
        return pulumi.get(self, "include_datastores_with_tags")


@pulumi.output_type
class VnicIpv4(dict):
    def __init__(__self__, *,
                 dhcp: Optional[bool] = None,
                 gw: Optional[str] = None,
                 ip: Optional[str] = None,
                 netmask: Optional[str] = None):
        """
        :param bool dhcp: Use DHCP to configure the interface's IPv4 stack.
        :param str gw: IP address of the default gateway, if DHCP or autoconfig is not set.
        :param str ip: Address of the interface, if DHCP is not set.
        :param str netmask: Netmask of the interface, if DHCP is not set.
        """
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if gw is not None:
            pulumi.set(__self__, "gw", gw)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[bool]:
        """
        Use DHCP to configure the interface's IPv4 stack.
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter
    def gw(self) -> Optional[str]:
        """
        IP address of the default gateway, if DHCP or autoconfig is not set.
        """
        return pulumi.get(self, "gw")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Address of the interface, if DHCP is not set.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def netmask(self) -> Optional[str]:
        """
        Netmask of the interface, if DHCP is not set.
        """
        return pulumi.get(self, "netmask")


@pulumi.output_type
class VnicIpv6(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence[str]] = None,
                 autoconfig: Optional[bool] = None,
                 dhcp: Optional[bool] = None,
                 gw: Optional[str] = None):
        """
        :param Sequence[str] addresses: List of IPv6 addresses
        :param bool autoconfig: Use IPv6 Autoconfiguration (RFC2462).
        :param bool dhcp: Use DHCP to configure the interface's IPv4 stack.
        :param str gw: IP address of the default gateway, if DHCP or autoconfig is not set.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if autoconfig is not None:
            pulumi.set(__self__, "autoconfig", autoconfig)
        if dhcp is not None:
            pulumi.set(__self__, "dhcp", dhcp)
        if gw is not None:
            pulumi.set(__self__, "gw", gw)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        """
        List of IPv6 addresses
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def autoconfig(self) -> Optional[bool]:
        """
        Use IPv6 Autoconfiguration (RFC2462).
        """
        return pulumi.get(self, "autoconfig")

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[bool]:
        """
        Use DHCP to configure the interface's IPv4 stack.
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter
    def gw(self) -> Optional[str]:
        """
        IP address of the default gateway, if DHCP or autoconfig is not set.
        """
        return pulumi.get(self, "gw")


@pulumi.output_type
class GetVirtualMachineDiskResult(dict):
    def __init__(__self__, *,
                 eagerly_scrub: bool,
                 label: str,
                 size: int,
                 thin_provisioned: bool,
                 unit_number: int):
        """
        :param bool eagerly_scrub: Set to `true` if the disk has been eager zeroed.
        :param str label: The label for the disk.
        :param int size: The size of the disk, in GIB.
        :param bool thin_provisioned: Set to `true` if the disk has been thin provisioned.
        :param int unit_number: The disk number on the storage bus.
        """
        pulumi.set(__self__, "eagerly_scrub", eagerly_scrub)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "thin_provisioned", thin_provisioned)
        pulumi.set(__self__, "unit_number", unit_number)

    @property
    @pulumi.getter(name="eagerlyScrub")
    def eagerly_scrub(self) -> bool:
        """
        Set to `true` if the disk has been eager zeroed.
        """
        return pulumi.get(self, "eagerly_scrub")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The label for the disk.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the disk, in GIB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> bool:
        """
        Set to `true` if the disk has been thin provisioned.
        """
        return pulumi.get(self, "thin_provisioned")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> int:
        """
        The disk number on the storage bus.
        """
        return pulumi.get(self, "unit_number")


@pulumi.output_type
class GetVirtualMachineVappResult(dict):
    def __init__(__self__, *,
                 properties: Optional[Mapping[str, str]] = None):
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "properties")


