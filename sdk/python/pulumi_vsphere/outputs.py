# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ComputeClusterVsanDiskGroup',
    'ContentLibraryPublication',
    'ContentLibrarySubscription',
    'DistributedPortGroupVlanRange',
    'DistributedVirtualSwitchHost',
    'DistributedVirtualSwitchPvlanMapping',
    'DistributedVirtualSwitchVlanRange',
    'EntityPermissionsPermission',
    'HostPortGroupPort',
    'VirtualMachineCdrom',
    'VirtualMachineClone',
    'VirtualMachineCloneCustomize',
    'VirtualMachineCloneCustomizeLinuxOptions',
    'VirtualMachineCloneCustomizeNetworkInterface',
    'VirtualMachineCloneCustomizeWindowsOptions',
    'VirtualMachineDisk',
    'VirtualMachineNetworkInterface',
    'VirtualMachineOvfDeploy',
    'VirtualMachineVapp',
    'VmStoragePolicyTagRule',
    'VnicIpv4',
    'VnicIpv6',
    'GetVirtualMachineDiskResult',
    'GetVirtualMachineNetworkInterfaceResult',
    'GetVirtualMachineVappResult',
]

@pulumi.output_type
class ComputeClusterVsanDiskGroup(dict):
    def __init__(__self__, *,
                 cache: Optional[str] = None,
                 storages: Optional[Sequence[str]] = None):
        """
        :param str cache: The canonical name of the disk to use for vSAN cache.
        :param Sequence[str] storages: An array of disk canonical names for vSAN storage.
               
               > **NOTE:** You must disable vSphere HA before you enable vSAN on the cluster.
               You can enable or re-enable vSphere HA after vSAN is configured.
               
               ```python
               import pulumi
               import pulumi_vsphere as vsphere
               
               compute_cluster = vsphere.ComputeCluster("computeCluster",
                   datacenter_id=data["vsphere_datacenter"]["datacenter"]["id"],
                   host_system_ids=[[__item["id"] for __item in data["vsphere_host"]["host"]]],
                   drs_enabled=True,
                   drs_automation_level="fullyAutomated",
                   ha_enabled=False,
                   vsan_enabled=True,
                   vsan_dedup_enabled=True,
                   vsan_compression_enabled=True,
                   vsan_performance_enabled=True,
                   vsan_verbose_mode_enabled=True,
                   vsan_network_diagnostic_mode_enabled=True,
                   vsan_unmap_enabled=True,
                   vsan_dit_encryption_enabled=True,
                   vsan_dit_rekey_interval=1800,
                   vsan_disk_groups=[vsphere.ComputeClusterVsanDiskGroupArgs(
                       cache=data["vsphere_vmfs_disks"]["cache_disks"],
                       storages=data["vsphere_vmfs_disks"]["storage_disks"],
                   )])
               ```
        """
        ComputeClusterVsanDiskGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache=cache,
            storages=storages,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache: Optional[str] = None,
             storages: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cache is not None:
            _setter("cache", cache)
        if storages is not None:
            _setter("storages", storages)

    @property
    @pulumi.getter
    def cache(self) -> Optional[str]:
        """
        The canonical name of the disk to use for vSAN cache.
        """
        return pulumi.get(self, "cache")

    @property
    @pulumi.getter
    def storages(self) -> Optional[Sequence[str]]:
        """
        An array of disk canonical names for vSAN storage.

        > **NOTE:** You must disable vSphere HA before you enable vSAN on the cluster.
        You can enable or re-enable vSphere HA after vSAN is configured.

        ```python
        import pulumi
        import pulumi_vsphere as vsphere

        compute_cluster = vsphere.ComputeCluster("computeCluster",
            datacenter_id=data["vsphere_datacenter"]["datacenter"]["id"],
            host_system_ids=[[__item["id"] for __item in data["vsphere_host"]["host"]]],
            drs_enabled=True,
            drs_automation_level="fullyAutomated",
            ha_enabled=False,
            vsan_enabled=True,
            vsan_dedup_enabled=True,
            vsan_compression_enabled=True,
            vsan_performance_enabled=True,
            vsan_verbose_mode_enabled=True,
            vsan_network_diagnostic_mode_enabled=True,
            vsan_unmap_enabled=True,
            vsan_dit_encryption_enabled=True,
            vsan_dit_rekey_interval=1800,
            vsan_disk_groups=[vsphere.ComputeClusterVsanDiskGroupArgs(
                cache=data["vsphere_vmfs_disks"]["cache_disks"],
                storages=data["vsphere_vmfs_disks"]["storage_disks"],
            )])
        ```
        """
        return pulumi.get(self, "storages")


@pulumi.output_type
class ContentLibraryPublication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethod":
            suggest = "authentication_method"
        elif key == "publishUrl":
            suggest = "publish_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentLibraryPublication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentLibraryPublication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentLibraryPublication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_method: Optional[str] = None,
                 password: Optional[str] = None,
                 publish_url: Optional[str] = None,
                 published: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str authentication_method: Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.
        :param str password: Password used for authentication.
        :param str publish_url: The URL of the published content library.
        :param bool published: Publish the content library. Default `false`.
        :param str username: Username used for authentication.
        """
        ContentLibraryPublication._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication_method=authentication_method,
            password=password,
            publish_url=publish_url,
            published=published,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication_method: Optional[str] = None,
             password: Optional[str] = None,
             publish_url: Optional[str] = None,
             published: Optional[bool] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if authentication_method is not None:
            _setter("authentication_method", authentication_method)
        if password is not None:
            _setter("password", password)
        if publish_url is not None:
            _setter("publish_url", publish_url)
        if published is not None:
            _setter("published", published)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[str]:
        """
        Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.
        """
        return pulumi.get(self, "authentication_method")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password used for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="publishUrl")
    def publish_url(self) -> Optional[str]:
        """
        The URL of the published content library.
        """
        return pulumi.get(self, "publish_url")

    @property
    @pulumi.getter
    def published(self) -> Optional[bool]:
        """
        Publish the content library. Default `false`.
        """
        return pulumi.get(self, "published")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username used for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ContentLibrarySubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethod":
            suggest = "authentication_method"
        elif key == "automaticSync":
            suggest = "automatic_sync"
        elif key == "onDemand":
            suggest = "on_demand"
        elif key == "subscriptionUrl":
            suggest = "subscription_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentLibrarySubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentLibrarySubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentLibrarySubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_method: Optional[str] = None,
                 automatic_sync: Optional[bool] = None,
                 on_demand: Optional[bool] = None,
                 password: Optional[str] = None,
                 subscription_url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str authentication_method: Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.
        :param bool automatic_sync: Enable automatic synchronization with the published library. Default `false`.
        :param bool on_demand: Download the library from a content only when needed. Default `true`.
        :param str password: Password used for authentication.
        :param str subscription_url: URL of the published content library.
        :param str username: Username used for authentication.
        """
        ContentLibrarySubscription._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication_method=authentication_method,
            automatic_sync=automatic_sync,
            on_demand=on_demand,
            password=password,
            subscription_url=subscription_url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication_method: Optional[str] = None,
             automatic_sync: Optional[bool] = None,
             on_demand: Optional[bool] = None,
             password: Optional[str] = None,
             subscription_url: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if authentication_method is not None:
            _setter("authentication_method", authentication_method)
        if automatic_sync is not None:
            _setter("automatic_sync", automatic_sync)
        if on_demand is not None:
            _setter("on_demand", on_demand)
        if password is not None:
            _setter("password", password)
        if subscription_url is not None:
            _setter("subscription_url", subscription_url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[str]:
        """
        Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.
        """
        return pulumi.get(self, "authentication_method")

    @property
    @pulumi.getter(name="automaticSync")
    def automatic_sync(self) -> Optional[bool]:
        """
        Enable automatic synchronization with the published library. Default `false`.
        """
        return pulumi.get(self, "automatic_sync")

    @property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional[bool]:
        """
        Download the library from a content only when needed. Default `true`.
        """
        return pulumi.get(self, "on_demand")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password used for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="subscriptionUrl")
    def subscription_url(self) -> Optional[str]:
        """
        URL of the published content library.
        """
        return pulumi.get(self, "subscription_url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username used for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DistributedPortGroupVlanRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVlan":
            suggest = "max_vlan"
        elif key == "minVlan":
            suggest = "min_vlan"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributedPortGroupVlanRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributedPortGroupVlanRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributedPortGroupVlanRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_vlan: int,
                 min_vlan: int):
        DistributedPortGroupVlanRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_vlan=max_vlan,
            min_vlan=min_vlan,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_vlan: int,
             min_vlan: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_vlan", max_vlan)
        _setter("min_vlan", min_vlan)

    @property
    @pulumi.getter(name="maxVlan")
    def max_vlan(self) -> int:
        return pulumi.get(self, "max_vlan")

    @property
    @pulumi.getter(name="minVlan")
    def min_vlan(self) -> int:
        return pulumi.get(self, "min_vlan")


@pulumi.output_type
class DistributedVirtualSwitchHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostSystemId":
            suggest = "host_system_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributedVirtualSwitchHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributedVirtualSwitchHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributedVirtualSwitchHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_system_id: str,
                 devices: Optional[Sequence[str]] = None):
        """
        :param str host_system_id: The host system ID of the host to add to the
               VDS.
        :param Sequence[str] devices: The list of NIC devices to map to uplinks on the VDS,
               added in order they are specified.
        """
        DistributedVirtualSwitchHost._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_system_id=host_system_id,
            devices=devices,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_system_id: str,
             devices: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("host_system_id", host_system_id)
        if devices is not None:
            _setter("devices", devices)

    @property
    @pulumi.getter(name="hostSystemId")
    def host_system_id(self) -> str:
        """
        The host system ID of the host to add to the
        VDS.
        """
        return pulumi.get(self, "host_system_id")

    @property
    @pulumi.getter
    def devices(self) -> Optional[Sequence[str]]:
        """
        The list of NIC devices to map to uplinks on the VDS,
        added in order they are specified.
        """
        return pulumi.get(self, "devices")


@pulumi.output_type
class DistributedVirtualSwitchPvlanMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryVlanId":
            suggest = "primary_vlan_id"
        elif key == "pvlanType":
            suggest = "pvlan_type"
        elif key == "secondaryVlanId":
            suggest = "secondary_vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributedVirtualSwitchPvlanMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributedVirtualSwitchPvlanMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributedVirtualSwitchPvlanMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_vlan_id: int,
                 pvlan_type: str,
                 secondary_vlan_id: int):
        """
        :param int primary_vlan_id: The primary VLAN ID. The VLAN IDs of 0 and
               4095 are reserved and cannot be used in this property.
        :param str pvlan_type: The private VLAN type. Valid values are
               promiscuous, community and isolated.
        :param int secondary_vlan_id: The secondary VLAN ID. The VLAN IDs of 0
               and 4095 are reserved and cannot be used in this property.
        """
        DistributedVirtualSwitchPvlanMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            primary_vlan_id=primary_vlan_id,
            pvlan_type=pvlan_type,
            secondary_vlan_id=secondary_vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             primary_vlan_id: int,
             pvlan_type: str,
             secondary_vlan_id: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("primary_vlan_id", primary_vlan_id)
        _setter("pvlan_type", pvlan_type)
        _setter("secondary_vlan_id", secondary_vlan_id)

    @property
    @pulumi.getter(name="primaryVlanId")
    def primary_vlan_id(self) -> int:
        """
        The primary VLAN ID. The VLAN IDs of 0 and
        4095 are reserved and cannot be used in this property.
        """
        return pulumi.get(self, "primary_vlan_id")

    @property
    @pulumi.getter(name="pvlanType")
    def pvlan_type(self) -> str:
        """
        The private VLAN type. Valid values are
        promiscuous, community and isolated.
        """
        return pulumi.get(self, "pvlan_type")

    @property
    @pulumi.getter(name="secondaryVlanId")
    def secondary_vlan_id(self) -> int:
        """
        The secondary VLAN ID. The VLAN IDs of 0
        and 4095 are reserved and cannot be used in this property.
        """
        return pulumi.get(self, "secondary_vlan_id")


@pulumi.output_type
class DistributedVirtualSwitchVlanRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVlan":
            suggest = "max_vlan"
        elif key == "minVlan":
            suggest = "min_vlan"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributedVirtualSwitchVlanRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributedVirtualSwitchVlanRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributedVirtualSwitchVlanRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_vlan: int,
                 min_vlan: int):
        DistributedVirtualSwitchVlanRange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_vlan=max_vlan,
            min_vlan=min_vlan,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_vlan: int,
             min_vlan: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_vlan", max_vlan)
        _setter("min_vlan", min_vlan)

    @property
    @pulumi.getter(name="maxVlan")
    def max_vlan(self) -> int:
        return pulumi.get(self, "max_vlan")

    @property
    @pulumi.getter(name="minVlan")
    def min_vlan(self) -> int:
        return pulumi.get(self, "min_vlan")


@pulumi.output_type
class EntityPermissionsPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isGroup":
            suggest = "is_group"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "userOrGroup":
            suggest = "user_or_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntityPermissionsPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntityPermissionsPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntityPermissionsPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_group: bool,
                 propagate: bool,
                 role_id: str,
                 user_or_group: str):
        """
        :param bool is_group: Whether user_or_group field refers to a user or a group. True for a group and false for a user.
        :param bool propagate: Whether or not this permission propagates down the hierarchy to sub-entities.
        :param str role_id: The role id of the role to be given to the user on the specified entity.
        :param str user_or_group: The user/group getting the permission.
        """
        EntityPermissionsPermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_group=is_group,
            propagate=propagate,
            role_id=role_id,
            user_or_group=user_or_group,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_group: bool,
             propagate: bool,
             role_id: str,
             user_or_group: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_group", is_group)
        _setter("propagate", propagate)
        _setter("role_id", role_id)
        _setter("user_or_group", user_or_group)

    @property
    @pulumi.getter(name="isGroup")
    def is_group(self) -> bool:
        """
        Whether user_or_group field refers to a user or a group. True for a group and false for a user.
        """
        return pulumi.get(self, "is_group")

    @property
    @pulumi.getter
    def propagate(self) -> bool:
        """
        Whether or not this permission propagates down the hierarchy to sub-entities.
        """
        return pulumi.get(self, "propagate")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        The role id of the role to be given to the user on the specified entity.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="userOrGroup")
    def user_or_group(self) -> str:
        """
        The user/group getting the permission.
        """
        return pulumi.get(self, "user_or_group")


@pulumi.output_type
class HostPortGroupPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macAddresses":
            suggest = "mac_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostPortGroupPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostPortGroupPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostPortGroupPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mac_addresses: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str key: The key for this port group as returned from the vSphere API.
        """
        HostPortGroupPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            mac_addresses=mac_addresses,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             mac_addresses: Optional[Sequence[str]] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if mac_addresses is not None:
            _setter("mac_addresses", mac_addresses)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key for this port group as returned from the vSphere API.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="macAddresses")
    def mac_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "mac_addresses")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class VirtualMachineCdrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientDevice":
            suggest = "client_device"
        elif key == "datastoreId":
            suggest = "datastore_id"
        elif key == "deviceAddress":
            suggest = "device_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCdrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCdrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCdrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_device: Optional[bool] = None,
                 datastore_id: Optional[str] = None,
                 device_address: Optional[str] = None,
                 key: Optional[int] = None,
                 path: Optional[str] = None):
        """
        :param bool client_device: Indicates whether the device should be backed by remote client device. Conflicts with `datastore_id` and `path`.
        :param str datastore_id: The datastore ID that on which the ISO is located. Required for using a datastore ISO. Conflicts with `client_device`.
        :param int key: The ID of the device within the virtual machine.
        :param str path: The path to the ISO file. Required for using a datastore ISO. Conflicts with `client_device`.
               
               > **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .
               
               > **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.
        """
        VirtualMachineCdrom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_device=client_device,
            datastore_id=datastore_id,
            device_address=device_address,
            key=key,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_device: Optional[bool] = None,
             datastore_id: Optional[str] = None,
             device_address: Optional[str] = None,
             key: Optional[int] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if client_device is not None:
            _setter("client_device", client_device)
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if device_address is not None:
            _setter("device_address", device_address)
        if key is not None:
            _setter("key", key)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="clientDevice")
    def client_device(self) -> Optional[bool]:
        """
        Indicates whether the device should be backed by remote client device. Conflicts with `datastore_id` and `path`.
        """
        return pulumi.get(self, "client_device")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        The datastore ID that on which the ISO is located. Required for using a datastore ISO. Conflicts with `client_device`.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter(name="deviceAddress")
    def device_address(self) -> Optional[str]:
        return pulumi.get(self, "device_address")

    @property
    @pulumi.getter
    def key(self) -> Optional[int]:
        """
        The ID of the device within the virtual machine.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the ISO file. Required for using a datastore ISO. Conflicts with `client_device`.

        > **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .

        > **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class VirtualMachineClone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateUuid":
            suggest = "template_uuid"
        elif key == "linkedClone":
            suggest = "linked_clone"
        elif key == "ovfNetworkMap":
            suggest = "ovf_network_map"
        elif key == "ovfStorageMap":
            suggest = "ovf_storage_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineClone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineClone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineClone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_uuid: str,
                 customize: Optional['outputs.VirtualMachineCloneCustomize'] = None,
                 linked_clone: Optional[bool] = None,
                 ovf_network_map: Optional[Mapping[str, str]] = None,
                 ovf_storage_map: Optional[Mapping[str, str]] = None,
                 timeout: Optional[int] = None):
        VirtualMachineClone._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            template_uuid=template_uuid,
            customize=customize,
            linked_clone=linked_clone,
            ovf_network_map=ovf_network_map,
            ovf_storage_map=ovf_storage_map,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             template_uuid: str,
             customize: Optional['outputs.VirtualMachineCloneCustomize'] = None,
             linked_clone: Optional[bool] = None,
             ovf_network_map: Optional[Mapping[str, str]] = None,
             ovf_storage_map: Optional[Mapping[str, str]] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("template_uuid", template_uuid)
        if customize is not None:
            _setter("customize", customize)
        if linked_clone is not None:
            _setter("linked_clone", linked_clone)
        if ovf_network_map is not None:
            _setter("ovf_network_map", ovf_network_map)
        if ovf_storage_map is not None:
            _setter("ovf_storage_map", ovf_storage_map)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="templateUuid")
    def template_uuid(self) -> str:
        return pulumi.get(self, "template_uuid")

    @property
    @pulumi.getter
    def customize(self) -> Optional['outputs.VirtualMachineCloneCustomize']:
        return pulumi.get(self, "customize")

    @property
    @pulumi.getter(name="linkedClone")
    def linked_clone(self) -> Optional[bool]:
        return pulumi.get(self, "linked_clone")

    @property
    @pulumi.getter(name="ovfNetworkMap")
    def ovf_network_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "ovf_network_map")

    @property
    @pulumi.getter(name="ovfStorageMap")
    def ovf_storage_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "ovf_storage_map")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class VirtualMachineCloneCustomize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServerLists":
            suggest = "dns_server_lists"
        elif key == "dnsSuffixLists":
            suggest = "dns_suffix_lists"
        elif key == "ipv4Gateway":
            suggest = "ipv4_gateway"
        elif key == "ipv6Gateway":
            suggest = "ipv6_gateway"
        elif key == "linuxOptions":
            suggest = "linux_options"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "windowsOptions":
            suggest = "windows_options"
        elif key == "windowsSysprepText":
            suggest = "windows_sysprep_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCloneCustomize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCloneCustomize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCloneCustomize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_server_lists: Optional[Sequence[str]] = None,
                 dns_suffix_lists: Optional[Sequence[str]] = None,
                 ipv4_gateway: Optional[str] = None,
                 ipv6_gateway: Optional[str] = None,
                 linux_options: Optional['outputs.VirtualMachineCloneCustomizeLinuxOptions'] = None,
                 network_interfaces: Optional[Sequence['outputs.VirtualMachineCloneCustomizeNetworkInterface']] = None,
                 timeout: Optional[int] = None,
                 windows_options: Optional['outputs.VirtualMachineCloneCustomizeWindowsOptions'] = None,
                 windows_sysprep_text: Optional[str] = None):
        """
        :param Sequence['VirtualMachineCloneCustomizeNetworkInterfaceArgs'] network_interfaces: A specification for a virtual NIC on the virtual machine. See network interface options for more information.
        """
        VirtualMachineCloneCustomize._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_server_lists=dns_server_lists,
            dns_suffix_lists=dns_suffix_lists,
            ipv4_gateway=ipv4_gateway,
            ipv6_gateway=ipv6_gateway,
            linux_options=linux_options,
            network_interfaces=network_interfaces,
            timeout=timeout,
            windows_options=windows_options,
            windows_sysprep_text=windows_sysprep_text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_server_lists: Optional[Sequence[str]] = None,
             dns_suffix_lists: Optional[Sequence[str]] = None,
             ipv4_gateway: Optional[str] = None,
             ipv6_gateway: Optional[str] = None,
             linux_options: Optional['outputs.VirtualMachineCloneCustomizeLinuxOptions'] = None,
             network_interfaces: Optional[Sequence['outputs.VirtualMachineCloneCustomizeNetworkInterface']] = None,
             timeout: Optional[int] = None,
             windows_options: Optional['outputs.VirtualMachineCloneCustomizeWindowsOptions'] = None,
             windows_sysprep_text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dns_server_lists is not None:
            _setter("dns_server_lists", dns_server_lists)
        if dns_suffix_lists is not None:
            _setter("dns_suffix_lists", dns_suffix_lists)
        if ipv4_gateway is not None:
            _setter("ipv4_gateway", ipv4_gateway)
        if ipv6_gateway is not None:
            _setter("ipv6_gateway", ipv6_gateway)
        if linux_options is not None:
            _setter("linux_options", linux_options)
        if network_interfaces is not None:
            _setter("network_interfaces", network_interfaces)
        if timeout is not None:
            _setter("timeout", timeout)
        if windows_options is not None:
            _setter("windows_options", windows_options)
        if windows_sysprep_text is not None:
            _setter("windows_sysprep_text", windows_sysprep_text)

    @property
    @pulumi.getter(name="dnsServerLists")
    def dns_server_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_server_lists")

    @property
    @pulumi.getter(name="dnsSuffixLists")
    def dns_suffix_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_suffix_lists")

    @property
    @pulumi.getter(name="ipv4Gateway")
    def ipv4_gateway(self) -> Optional[str]:
        return pulumi.get(self, "ipv4_gateway")

    @property
    @pulumi.getter(name="ipv6Gateway")
    def ipv6_gateway(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_gateway")

    @property
    @pulumi.getter(name="linuxOptions")
    def linux_options(self) -> Optional['outputs.VirtualMachineCloneCustomizeLinuxOptions']:
        return pulumi.get(self, "linux_options")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.VirtualMachineCloneCustomizeNetworkInterface']]:
        """
        A specification for a virtual NIC on the virtual machine. See network interface options for more information.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.VirtualMachineCloneCustomizeWindowsOptions']:
        return pulumi.get(self, "windows_options")

    @property
    @pulumi.getter(name="windowsSysprepText")
    def windows_sysprep_text(self) -> Optional[str]:
        return pulumi.get(self, "windows_sysprep_text")


@pulumi.output_type
class VirtualMachineCloneCustomizeLinuxOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "hwClockUtc":
            suggest = "hw_clock_utc"
        elif key == "scriptText":
            suggest = "script_text"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCloneCustomizeLinuxOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCloneCustomizeLinuxOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCloneCustomizeLinuxOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: str,
                 host_name: str,
                 hw_clock_utc: Optional[bool] = None,
                 script_text: Optional[str] = None,
                 time_zone: Optional[str] = None):
        VirtualMachineCloneCustomizeLinuxOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            host_name=host_name,
            hw_clock_utc=hw_clock_utc,
            script_text=script_text,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: str,
             host_name: str,
             hw_clock_utc: Optional[bool] = None,
             script_text: Optional[str] = None,
             time_zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("host_name", host_name)
        if hw_clock_utc is not None:
            _setter("hw_clock_utc", hw_clock_utc)
        if script_text is not None:
            _setter("script_text", script_text)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="hwClockUtc")
    def hw_clock_utc(self) -> Optional[bool]:
        return pulumi.get(self, "hw_clock_utc")

    @property
    @pulumi.getter(name="scriptText")
    def script_text(self) -> Optional[str]:
        return pulumi.get(self, "script_text")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class VirtualMachineCloneCustomizeNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsDomain":
            suggest = "dns_domain"
        elif key == "dnsServerLists":
            suggest = "dns_server_lists"
        elif key == "ipv4Address":
            suggest = "ipv4_address"
        elif key == "ipv4Netmask":
            suggest = "ipv4_netmask"
        elif key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "ipv6Netmask":
            suggest = "ipv6_netmask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCloneCustomizeNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCloneCustomizeNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCloneCustomizeNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_domain: Optional[str] = None,
                 dns_server_lists: Optional[Sequence[str]] = None,
                 ipv4_address: Optional[str] = None,
                 ipv4_netmask: Optional[int] = None,
                 ipv6_address: Optional[str] = None,
                 ipv6_netmask: Optional[int] = None):
        VirtualMachineCloneCustomizeNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_domain=dns_domain,
            dns_server_lists=dns_server_lists,
            ipv4_address=ipv4_address,
            ipv4_netmask=ipv4_netmask,
            ipv6_address=ipv6_address,
            ipv6_netmask=ipv6_netmask,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_domain: Optional[str] = None,
             dns_server_lists: Optional[Sequence[str]] = None,
             ipv4_address: Optional[str] = None,
             ipv4_netmask: Optional[int] = None,
             ipv6_address: Optional[str] = None,
             ipv6_netmask: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dns_domain is not None:
            _setter("dns_domain", dns_domain)
        if dns_server_lists is not None:
            _setter("dns_server_lists", dns_server_lists)
        if ipv4_address is not None:
            _setter("ipv4_address", ipv4_address)
        if ipv4_netmask is not None:
            _setter("ipv4_netmask", ipv4_netmask)
        if ipv6_address is not None:
            _setter("ipv6_address", ipv6_address)
        if ipv6_netmask is not None:
            _setter("ipv6_netmask", ipv6_netmask)

    @property
    @pulumi.getter(name="dnsDomain")
    def dns_domain(self) -> Optional[str]:
        return pulumi.get(self, "dns_domain")

    @property
    @pulumi.getter(name="dnsServerLists")
    def dns_server_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_server_lists")

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[str]:
        return pulumi.get(self, "ipv4_address")

    @property
    @pulumi.getter(name="ipv4Netmask")
    def ipv4_netmask(self) -> Optional[int]:
        return pulumi.get(self, "ipv4_netmask")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6Netmask")
    def ipv6_netmask(self) -> Optional[int]:
        return pulumi.get(self, "ipv6_netmask")


@pulumi.output_type
class VirtualMachineCloneCustomizeWindowsOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computerName":
            suggest = "computer_name"
        elif key == "adminPassword":
            suggest = "admin_password"
        elif key == "autoLogon":
            suggest = "auto_logon"
        elif key == "autoLogonCount":
            suggest = "auto_logon_count"
        elif key == "domainAdminPassword":
            suggest = "domain_admin_password"
        elif key == "domainAdminUser":
            suggest = "domain_admin_user"
        elif key == "fullName":
            suggest = "full_name"
        elif key == "joinDomain":
            suggest = "join_domain"
        elif key == "organizationName":
            suggest = "organization_name"
        elif key == "productKey":
            suggest = "product_key"
        elif key == "runOnceCommandLists":
            suggest = "run_once_command_lists"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineCloneCustomizeWindowsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineCloneCustomizeWindowsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineCloneCustomizeWindowsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computer_name: str,
                 admin_password: Optional[str] = None,
                 auto_logon: Optional[bool] = None,
                 auto_logon_count: Optional[int] = None,
                 domain_admin_password: Optional[str] = None,
                 domain_admin_user: Optional[str] = None,
                 full_name: Optional[str] = None,
                 join_domain: Optional[str] = None,
                 organization_name: Optional[str] = None,
                 product_key: Optional[str] = None,
                 run_once_command_lists: Optional[Sequence[str]] = None,
                 time_zone: Optional[int] = None,
                 workgroup: Optional[str] = None):
        VirtualMachineCloneCustomizeWindowsOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computer_name=computer_name,
            admin_password=admin_password,
            auto_logon=auto_logon,
            auto_logon_count=auto_logon_count,
            domain_admin_password=domain_admin_password,
            domain_admin_user=domain_admin_user,
            full_name=full_name,
            join_domain=join_domain,
            organization_name=organization_name,
            product_key=product_key,
            run_once_command_lists=run_once_command_lists,
            time_zone=time_zone,
            workgroup=workgroup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computer_name: str,
             admin_password: Optional[str] = None,
             auto_logon: Optional[bool] = None,
             auto_logon_count: Optional[int] = None,
             domain_admin_password: Optional[str] = None,
             domain_admin_user: Optional[str] = None,
             full_name: Optional[str] = None,
             join_domain: Optional[str] = None,
             organization_name: Optional[str] = None,
             product_key: Optional[str] = None,
             run_once_command_lists: Optional[Sequence[str]] = None,
             time_zone: Optional[int] = None,
             workgroup: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computer_name", computer_name)
        if admin_password is not None:
            _setter("admin_password", admin_password)
        if auto_logon is not None:
            _setter("auto_logon", auto_logon)
        if auto_logon_count is not None:
            _setter("auto_logon_count", auto_logon_count)
        if domain_admin_password is not None:
            _setter("domain_admin_password", domain_admin_password)
        if domain_admin_user is not None:
            _setter("domain_admin_user", domain_admin_user)
        if full_name is not None:
            _setter("full_name", full_name)
        if join_domain is not None:
            _setter("join_domain", join_domain)
        if organization_name is not None:
            _setter("organization_name", organization_name)
        if product_key is not None:
            _setter("product_key", product_key)
        if run_once_command_lists is not None:
            _setter("run_once_command_lists", run_once_command_lists)
        if time_zone is not None:
            _setter("time_zone", time_zone)
        if workgroup is not None:
            _setter("workgroup", workgroup)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> str:
        return pulumi.get(self, "computer_name")

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="autoLogon")
    def auto_logon(self) -> Optional[bool]:
        return pulumi.get(self, "auto_logon")

    @property
    @pulumi.getter(name="autoLogonCount")
    def auto_logon_count(self) -> Optional[int]:
        return pulumi.get(self, "auto_logon_count")

    @property
    @pulumi.getter(name="domainAdminPassword")
    def domain_admin_password(self) -> Optional[str]:
        return pulumi.get(self, "domain_admin_password")

    @property
    @pulumi.getter(name="domainAdminUser")
    def domain_admin_user(self) -> Optional[str]:
        return pulumi.get(self, "domain_admin_user")

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        return pulumi.get(self, "full_name")

    @property
    @pulumi.getter(name="joinDomain")
    def join_domain(self) -> Optional[str]:
        return pulumi.get(self, "join_domain")

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[str]:
        return pulumi.get(self, "organization_name")

    @property
    @pulumi.getter(name="productKey")
    def product_key(self) -> Optional[str]:
        return pulumi.get(self, "product_key")

    @property
    @pulumi.getter(name="runOnceCommandLists")
    def run_once_command_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "run_once_command_lists")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[int]:
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def workgroup(self) -> Optional[str]:
        return pulumi.get(self, "workgroup")


@pulumi.output_type
class VirtualMachineDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controllerType":
            suggest = "controller_type"
        elif key == "datastoreId":
            suggest = "datastore_id"
        elif key == "deviceAddress":
            suggest = "device_address"
        elif key == "diskMode":
            suggest = "disk_mode"
        elif key == "diskSharing":
            suggest = "disk_sharing"
        elif key == "eagerlyScrub":
            suggest = "eagerly_scrub"
        elif key == "ioLimit":
            suggest = "io_limit"
        elif key == "ioReservation":
            suggest = "io_reservation"
        elif key == "ioShareCount":
            suggest = "io_share_count"
        elif key == "ioShareLevel":
            suggest = "io_share_level"
        elif key == "keepOnRemove":
            suggest = "keep_on_remove"
        elif key == "storagePolicyId":
            suggest = "storage_policy_id"
        elif key == "thinProvisioned":
            suggest = "thin_provisioned"
        elif key == "unitNumber":
            suggest = "unit_number"
        elif key == "writeThrough":
            suggest = "write_through"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: str,
                 attach: Optional[bool] = None,
                 controller_type: Optional[str] = None,
                 datastore_id: Optional[str] = None,
                 device_address: Optional[str] = None,
                 disk_mode: Optional[str] = None,
                 disk_sharing: Optional[str] = None,
                 eagerly_scrub: Optional[bool] = None,
                 io_limit: Optional[int] = None,
                 io_reservation: Optional[int] = None,
                 io_share_count: Optional[int] = None,
                 io_share_level: Optional[str] = None,
                 keep_on_remove: Optional[bool] = None,
                 key: Optional[int] = None,
                 path: Optional[str] = None,
                 size: Optional[int] = None,
                 storage_policy_id: Optional[str] = None,
                 thin_provisioned: Optional[bool] = None,
                 unit_number: Optional[int] = None,
                 uuid: Optional[str] = None,
                 write_through: Optional[bool] = None):
        """
        :param bool attach: Attach an external disk instead of creating a new one. Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`, `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
               
               > **NOTE:** External disks cannot be attached when `datastore_cluster_id` is used.
        :param str controller_type: The type of storage controller to attach the  disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate number of controllers enabled for the selected type. Default `scsi`.
        :param str datastore_id: The datastore ID that on which the ISO is located. Required for using a datastore ISO. Conflicts with `client_device`.
        :param str disk_mode: The mode of this this virtual disk for purposes of writes and snapshots. One of `append`, `independent_nonpersistent`, `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`. Default: `persistent`. For more information on these option, please refer to the [product documentation][vmware-docs-disk-mode].
               
               [vmware-docs-disk-mode]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.device.VirtualDiskOption.DiskMode.html
        :param str disk_sharing: The sharing mode of this virtual disk. One of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
               
               > **NOTE:** Disk sharing is only available on vSphere 6.0 and later.
        :param bool eagerly_scrub: If set to `true`, the disk space is zeroed out when the virtual machine is created. This will delay the creation of the virtual disk. Cannot be set to `true` when `thin_provisioned` is `true`.  See the section on picking a disk type for more information.  Default: `false`.
        :param int io_limit: The upper limit of IOPS that this disk can use. The default is no limit.
        :param int io_reservation: The I/O reservation (guarantee) for the virtual disk has, in IOPS.  The default is no reservation.
        :param int io_share_count: The share count for the virtual disk when the share level is `custom`.
        :param str io_share_level: The share allocation level for the virtual disk. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        :param bool keep_on_remove: Keep this disk when removing the device or destroying the virtual machine. Default: `false`.
        :param int key: The ID of the device within the virtual machine.
        :param str path: The path to the ISO file. Required for using a datastore ISO. Conflicts with `client_device`.
               
               > **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .
               
               > **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.
        :param int size: The size of the disk, in GB. Must be a whole number.
        :param str storage_policy_id: The UUID of the storage policy to assign to the virtual disk.
        :param bool thin_provisioned: If `true`, the disk is thin provisioned, with space for the file being allocated on an as-needed basis. Cannot be set to `true` when `eagerly_scrub` is `true`. See the section on selecting a disk type for more information. Default: `true`.
        :param int unit_number: The disk number on the storage bus. The maximum value for this setting is the value of the controller count times the controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE). Duplicate unit numbers are not allowed. Default `0`, for which one disk must be set to.
        :param str uuid: The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.
        :param bool write_through: If `true`, writes for this disk are sent directly to the filesystem immediately instead of being buffered. Default: `false`.
        """
        VirtualMachineDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label=label,
            attach=attach,
            controller_type=controller_type,
            datastore_id=datastore_id,
            device_address=device_address,
            disk_mode=disk_mode,
            disk_sharing=disk_sharing,
            eagerly_scrub=eagerly_scrub,
            io_limit=io_limit,
            io_reservation=io_reservation,
            io_share_count=io_share_count,
            io_share_level=io_share_level,
            keep_on_remove=keep_on_remove,
            key=key,
            path=path,
            size=size,
            storage_policy_id=storage_policy_id,
            thin_provisioned=thin_provisioned,
            unit_number=unit_number,
            uuid=uuid,
            write_through=write_through,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label: str,
             attach: Optional[bool] = None,
             controller_type: Optional[str] = None,
             datastore_id: Optional[str] = None,
             device_address: Optional[str] = None,
             disk_mode: Optional[str] = None,
             disk_sharing: Optional[str] = None,
             eagerly_scrub: Optional[bool] = None,
             io_limit: Optional[int] = None,
             io_reservation: Optional[int] = None,
             io_share_count: Optional[int] = None,
             io_share_level: Optional[str] = None,
             keep_on_remove: Optional[bool] = None,
             key: Optional[int] = None,
             path: Optional[str] = None,
             size: Optional[int] = None,
             storage_policy_id: Optional[str] = None,
             thin_provisioned: Optional[bool] = None,
             unit_number: Optional[int] = None,
             uuid: Optional[str] = None,
             write_through: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("label", label)
        if attach is not None:
            _setter("attach", attach)
        if controller_type is not None:
            _setter("controller_type", controller_type)
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if device_address is not None:
            _setter("device_address", device_address)
        if disk_mode is not None:
            _setter("disk_mode", disk_mode)
        if disk_sharing is not None:
            _setter("disk_sharing", disk_sharing)
        if eagerly_scrub is not None:
            _setter("eagerly_scrub", eagerly_scrub)
        if io_limit is not None:
            _setter("io_limit", io_limit)
        if io_reservation is not None:
            _setter("io_reservation", io_reservation)
        if io_share_count is not None:
            _setter("io_share_count", io_share_count)
        if io_share_level is not None:
            _setter("io_share_level", io_share_level)
        if keep_on_remove is not None:
            _setter("keep_on_remove", keep_on_remove)
        if key is not None:
            _setter("key", key)
        if path is not None:
            _setter("path", path)
        if size is not None:
            _setter("size", size)
        if storage_policy_id is not None:
            _setter("storage_policy_id", storage_policy_id)
        if thin_provisioned is not None:
            _setter("thin_provisioned", thin_provisioned)
        if unit_number is not None:
            _setter("unit_number", unit_number)
        if uuid is not None:
            _setter("uuid", uuid)
        if write_through is not None:
            _setter("write_through", write_through)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def attach(self) -> Optional[bool]:
        """
        Attach an external disk instead of creating a new one. Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`, `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.

        > **NOTE:** External disks cannot be attached when `datastore_cluster_id` is used.
        """
        return pulumi.get(self, "attach")

    @property
    @pulumi.getter(name="controllerType")
    def controller_type(self) -> Optional[str]:
        """
        The type of storage controller to attach the  disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate number of controllers enabled for the selected type. Default `scsi`.
        """
        return pulumi.get(self, "controller_type")

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[str]:
        """
        The datastore ID that on which the ISO is located. Required for using a datastore ISO. Conflicts with `client_device`.
        """
        return pulumi.get(self, "datastore_id")

    @property
    @pulumi.getter(name="deviceAddress")
    def device_address(self) -> Optional[str]:
        return pulumi.get(self, "device_address")

    @property
    @pulumi.getter(name="diskMode")
    def disk_mode(self) -> Optional[str]:
        """
        The mode of this this virtual disk for purposes of writes and snapshots. One of `append`, `independent_nonpersistent`, `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`. Default: `persistent`. For more information on these option, please refer to the [product documentation][vmware-docs-disk-mode].

        [vmware-docs-disk-mode]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.device.VirtualDiskOption.DiskMode.html
        """
        return pulumi.get(self, "disk_mode")

    @property
    @pulumi.getter(name="diskSharing")
    def disk_sharing(self) -> Optional[str]:
        """
        The sharing mode of this virtual disk. One of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.

        > **NOTE:** Disk sharing is only available on vSphere 6.0 and later.
        """
        return pulumi.get(self, "disk_sharing")

    @property
    @pulumi.getter(name="eagerlyScrub")
    def eagerly_scrub(self) -> Optional[bool]:
        """
        If set to `true`, the disk space is zeroed out when the virtual machine is created. This will delay the creation of the virtual disk. Cannot be set to `true` when `thin_provisioned` is `true`.  See the section on picking a disk type for more information.  Default: `false`.
        """
        return pulumi.get(self, "eagerly_scrub")

    @property
    @pulumi.getter(name="ioLimit")
    def io_limit(self) -> Optional[int]:
        """
        The upper limit of IOPS that this disk can use. The default is no limit.
        """
        return pulumi.get(self, "io_limit")

    @property
    @pulumi.getter(name="ioReservation")
    def io_reservation(self) -> Optional[int]:
        """
        The I/O reservation (guarantee) for the virtual disk has, in IOPS.  The default is no reservation.
        """
        return pulumi.get(self, "io_reservation")

    @property
    @pulumi.getter(name="ioShareCount")
    def io_share_count(self) -> Optional[int]:
        """
        The share count for the virtual disk when the share level is `custom`.
        """
        return pulumi.get(self, "io_share_count")

    @property
    @pulumi.getter(name="ioShareLevel")
    def io_share_level(self) -> Optional[str]:
        """
        The share allocation level for the virtual disk. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        """
        return pulumi.get(self, "io_share_level")

    @property
    @pulumi.getter(name="keepOnRemove")
    def keep_on_remove(self) -> Optional[bool]:
        """
        Keep this disk when removing the device or destroying the virtual machine. Default: `false`.
        """
        return pulumi.get(self, "keep_on_remove")

    @property
    @pulumi.getter
    def key(self) -> Optional[int]:
        """
        The ID of the device within the virtual machine.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the ISO file. Required for using a datastore ISO. Conflicts with `client_device`.

        > **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .

        > **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the disk, in GB. Must be a whole number.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="storagePolicyId")
    def storage_policy_id(self) -> Optional[str]:
        """
        The UUID of the storage policy to assign to the virtual disk.
        """
        return pulumi.get(self, "storage_policy_id")

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> Optional[bool]:
        """
        If `true`, the disk is thin provisioned, with space for the file being allocated on an as-needed basis. Cannot be set to `true` when `eagerly_scrub` is `true`. See the section on selecting a disk type for more information. Default: `true`.
        """
        return pulumi.get(self, "thin_provisioned")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> Optional[int]:
        """
        The disk number on the storage bus. The maximum value for this setting is the value of the controller count times the controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE). Duplicate unit numbers are not allowed. Default `0`, for which one disk must be set to.
        """
        return pulumi.get(self, "unit_number")

    @property
    @pulumi.getter
    def uuid(self) -> Optional[str]:
        """
        The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.
        """
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter(name="writeThrough")
    def write_through(self) -> Optional[bool]:
        """
        If `true`, writes for this disk are sent directly to the filesystem immediately instead of being buffered. Default: `false`.
        """
        return pulumi.get(self, "write_through")


@pulumi.output_type
class VirtualMachineNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "adapterType":
            suggest = "adapter_type"
        elif key == "bandwidthLimit":
            suggest = "bandwidth_limit"
        elif key == "bandwidthReservation":
            suggest = "bandwidth_reservation"
        elif key == "bandwidthShareCount":
            suggest = "bandwidth_share_count"
        elif key == "bandwidthShareLevel":
            suggest = "bandwidth_share_level"
        elif key == "deviceAddress":
            suggest = "device_address"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "ovfMapping":
            suggest = "ovf_mapping"
        elif key == "useStaticMac":
            suggest = "use_static_mac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 adapter_type: Optional[str] = None,
                 bandwidth_limit: Optional[int] = None,
                 bandwidth_reservation: Optional[int] = None,
                 bandwidth_share_count: Optional[int] = None,
                 bandwidth_share_level: Optional[str] = None,
                 device_address: Optional[str] = None,
                 key: Optional[int] = None,
                 mac_address: Optional[str] = None,
                 ovf_mapping: Optional[str] = None,
                 use_static_mac: Optional[bool] = None):
        """
        :param str network_id: The [managed object reference ID][docs-about-morefs] of the network on which to connect the virtual machine network interface.
        :param str adapter_type: The network interface type. One of `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.
        :param int bandwidth_limit: The upper bandwidth limit of the network interface, in Mbits/sec. The default is no limit.
        :param int bandwidth_reservation: The bandwidth reservation of the network interface, in Mbits/sec. The default is no reservation.
        :param int bandwidth_share_count: The share count for the network interface when the share level is `custom`.
        :param str bandwidth_share_level: The bandwidth share allocation level for the network interface. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        :param int key: The ID of the device within the virtual machine.
        :param str mac_address: The MAC address of the network interface. Can only be manually set if `use_static_mac` is `true`. Otherwise, the value is computed and presents the assigned MAC address for the interface.
        :param str ovf_mapping: Specifies which NIC in an OVF/OVA the `network_interface` should be associated. Only applies at creation when deploying from an OVF/OVA.
        :param bool use_static_mac: If true, the `mac_address` field is treated as a static MAC address and set accordingly. Setting this to `true` requires `mac_address` to be set. Default: `false`.
        """
        VirtualMachineNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            adapter_type=adapter_type,
            bandwidth_limit=bandwidth_limit,
            bandwidth_reservation=bandwidth_reservation,
            bandwidth_share_count=bandwidth_share_count,
            bandwidth_share_level=bandwidth_share_level,
            device_address=device_address,
            key=key,
            mac_address=mac_address,
            ovf_mapping=ovf_mapping,
            use_static_mac=use_static_mac,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: str,
             adapter_type: Optional[str] = None,
             bandwidth_limit: Optional[int] = None,
             bandwidth_reservation: Optional[int] = None,
             bandwidth_share_count: Optional[int] = None,
             bandwidth_share_level: Optional[str] = None,
             device_address: Optional[str] = None,
             key: Optional[int] = None,
             mac_address: Optional[str] = None,
             ovf_mapping: Optional[str] = None,
             use_static_mac: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("network_id", network_id)
        if adapter_type is not None:
            _setter("adapter_type", adapter_type)
        if bandwidth_limit is not None:
            _setter("bandwidth_limit", bandwidth_limit)
        if bandwidth_reservation is not None:
            _setter("bandwidth_reservation", bandwidth_reservation)
        if bandwidth_share_count is not None:
            _setter("bandwidth_share_count", bandwidth_share_count)
        if bandwidth_share_level is not None:
            _setter("bandwidth_share_level", bandwidth_share_level)
        if device_address is not None:
            _setter("device_address", device_address)
        if key is not None:
            _setter("key", key)
        if mac_address is not None:
            _setter("mac_address", mac_address)
        if ovf_mapping is not None:
            _setter("ovf_mapping", ovf_mapping)
        if use_static_mac is not None:
            _setter("use_static_mac", use_static_mac)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        The [managed object reference ID][docs-about-morefs] of the network on which to connect the virtual machine network interface.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> Optional[str]:
        """
        The network interface type. One of `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.
        """
        return pulumi.get(self, "adapter_type")

    @property
    @pulumi.getter(name="bandwidthLimit")
    def bandwidth_limit(self) -> Optional[int]:
        """
        The upper bandwidth limit of the network interface, in Mbits/sec. The default is no limit.
        """
        return pulumi.get(self, "bandwidth_limit")

    @property
    @pulumi.getter(name="bandwidthReservation")
    def bandwidth_reservation(self) -> Optional[int]:
        """
        The bandwidth reservation of the network interface, in Mbits/sec. The default is no reservation.
        """
        return pulumi.get(self, "bandwidth_reservation")

    @property
    @pulumi.getter(name="bandwidthShareCount")
    def bandwidth_share_count(self) -> Optional[int]:
        """
        The share count for the network interface when the share level is `custom`.
        """
        return pulumi.get(self, "bandwidth_share_count")

    @property
    @pulumi.getter(name="bandwidthShareLevel")
    def bandwidth_share_level(self) -> Optional[str]:
        """
        The bandwidth share allocation level for the network interface. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        """
        return pulumi.get(self, "bandwidth_share_level")

    @property
    @pulumi.getter(name="deviceAddress")
    def device_address(self) -> Optional[str]:
        return pulumi.get(self, "device_address")

    @property
    @pulumi.getter
    def key(self) -> Optional[int]:
        """
        The ID of the device within the virtual machine.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        The MAC address of the network interface. Can only be manually set if `use_static_mac` is `true`. Otherwise, the value is computed and presents the assigned MAC address for the interface.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="ovfMapping")
    def ovf_mapping(self) -> Optional[str]:
        """
        Specifies which NIC in an OVF/OVA the `network_interface` should be associated. Only applies at creation when deploying from an OVF/OVA.
        """
        return pulumi.get(self, "ovf_mapping")

    @property
    @pulumi.getter(name="useStaticMac")
    def use_static_mac(self) -> Optional[bool]:
        """
        If true, the `mac_address` field is treated as a static MAC address and set accordingly. Setting this to `true` requires `mac_address` to be set. Default: `false`.
        """
        return pulumi.get(self, "use_static_mac")


@pulumi.output_type
class VirtualMachineOvfDeploy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowUnverifiedSslCert":
            suggest = "allow_unverified_ssl_cert"
        elif key == "deploymentOption":
            suggest = "deployment_option"
        elif key == "diskProvisioning":
            suggest = "disk_provisioning"
        elif key == "enableHiddenProperties":
            suggest = "enable_hidden_properties"
        elif key == "ipAllocationPolicy":
            suggest = "ip_allocation_policy"
        elif key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "localOvfPath":
            suggest = "local_ovf_path"
        elif key == "ovfNetworkMap":
            suggest = "ovf_network_map"
        elif key == "remoteOvfUrl":
            suggest = "remote_ovf_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualMachineOvfDeploy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualMachineOvfDeploy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualMachineOvfDeploy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_unverified_ssl_cert: Optional[bool] = None,
                 deployment_option: Optional[str] = None,
                 disk_provisioning: Optional[str] = None,
                 enable_hidden_properties: Optional[bool] = None,
                 ip_allocation_policy: Optional[str] = None,
                 ip_protocol: Optional[str] = None,
                 local_ovf_path: Optional[str] = None,
                 ovf_network_map: Optional[Mapping[str, str]] = None,
                 remote_ovf_url: Optional[str] = None):
        VirtualMachineOvfDeploy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_unverified_ssl_cert=allow_unverified_ssl_cert,
            deployment_option=deployment_option,
            disk_provisioning=disk_provisioning,
            enable_hidden_properties=enable_hidden_properties,
            ip_allocation_policy=ip_allocation_policy,
            ip_protocol=ip_protocol,
            local_ovf_path=local_ovf_path,
            ovf_network_map=ovf_network_map,
            remote_ovf_url=remote_ovf_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_unverified_ssl_cert: Optional[bool] = None,
             deployment_option: Optional[str] = None,
             disk_provisioning: Optional[str] = None,
             enable_hidden_properties: Optional[bool] = None,
             ip_allocation_policy: Optional[str] = None,
             ip_protocol: Optional[str] = None,
             local_ovf_path: Optional[str] = None,
             ovf_network_map: Optional[Mapping[str, str]] = None,
             remote_ovf_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_unverified_ssl_cert is not None:
            _setter("allow_unverified_ssl_cert", allow_unverified_ssl_cert)
        if deployment_option is not None:
            _setter("deployment_option", deployment_option)
        if disk_provisioning is not None:
            _setter("disk_provisioning", disk_provisioning)
        if enable_hidden_properties is not None:
            _setter("enable_hidden_properties", enable_hidden_properties)
        if ip_allocation_policy is not None:
            _setter("ip_allocation_policy", ip_allocation_policy)
        if ip_protocol is not None:
            _setter("ip_protocol", ip_protocol)
        if local_ovf_path is not None:
            _setter("local_ovf_path", local_ovf_path)
        if ovf_network_map is not None:
            _setter("ovf_network_map", ovf_network_map)
        if remote_ovf_url is not None:
            _setter("remote_ovf_url", remote_ovf_url)

    @property
    @pulumi.getter(name="allowUnverifiedSslCert")
    def allow_unverified_ssl_cert(self) -> Optional[bool]:
        return pulumi.get(self, "allow_unverified_ssl_cert")

    @property
    @pulumi.getter(name="deploymentOption")
    def deployment_option(self) -> Optional[str]:
        return pulumi.get(self, "deployment_option")

    @property
    @pulumi.getter(name="diskProvisioning")
    def disk_provisioning(self) -> Optional[str]:
        return pulumi.get(self, "disk_provisioning")

    @property
    @pulumi.getter(name="enableHiddenProperties")
    def enable_hidden_properties(self) -> Optional[bool]:
        return pulumi.get(self, "enable_hidden_properties")

    @property
    @pulumi.getter(name="ipAllocationPolicy")
    def ip_allocation_policy(self) -> Optional[str]:
        return pulumi.get(self, "ip_allocation_policy")

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[str]:
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter(name="localOvfPath")
    def local_ovf_path(self) -> Optional[str]:
        return pulumi.get(self, "local_ovf_path")

    @property
    @pulumi.getter(name="ovfNetworkMap")
    def ovf_network_map(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "ovf_network_map")

    @property
    @pulumi.getter(name="remoteOvfUrl")
    def remote_ovf_url(self) -> Optional[str]:
        return pulumi.get(self, "remote_ovf_url")


@pulumi.output_type
class VirtualMachineVapp(dict):
    def __init__(__self__, *,
                 properties: Optional[Mapping[str, str]] = None):
        VirtualMachineVapp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "properties")


@pulumi.output_type
class VmStoragePolicyTagRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagCategory":
            suggest = "tag_category"
        elif key == "includeDatastoresWithTags":
            suggest = "include_datastores_with_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmStoragePolicyTagRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmStoragePolicyTagRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmStoragePolicyTagRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_category: str,
                 tags: Sequence[str],
                 include_datastores_with_tags: Optional[bool] = None):
        """
        :param str tag_category: Name of the tag category.
        :param Sequence[str] tags: List of Name of tags to select from the given category.
        :param bool include_datastores_with_tags: Include datastores with the given tags or exclude. Default `true`.
        """
        VmStoragePolicyTagRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tag_category=tag_category,
            tags=tags,
            include_datastores_with_tags=include_datastores_with_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tag_category: str,
             tags: Sequence[str],
             include_datastores_with_tags: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("tag_category", tag_category)
        _setter("tags", tags)
        if include_datastores_with_tags is not None:
            _setter("include_datastores_with_tags", include_datastores_with_tags)

    @property
    @pulumi.getter(name="tagCategory")
    def tag_category(self) -> str:
        """
        Name of the tag category.
        """
        return pulumi.get(self, "tag_category")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of Name of tags to select from the given category.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="includeDatastoresWithTags")
    def include_datastores_with_tags(self) -> Optional[bool]:
        """
        Include datastores with the given tags or exclude. Default `true`.
        """
        return pulumi.get(self, "include_datastores_with_tags")


@pulumi.output_type
class VnicIpv4(dict):
    def __init__(__self__, *,
                 dhcp: Optional[bool] = None,
                 gw: Optional[str] = None,
                 ip: Optional[str] = None,
                 netmask: Optional[str] = None):
        """
        :param bool dhcp: Use DHCP to configure the interface's IPv6 stack.
        :param str gw: IP address of the default gateway, if DHCP or autoconfig is not set.
        :param str ip: Address of the interface, if DHCP is not set.
        :param str netmask: Netmask of the interface, if DHCP is not set.
        """
        VnicIpv4._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dhcp=dhcp,
            gw=gw,
            ip=ip,
            netmask=netmask,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dhcp: Optional[bool] = None,
             gw: Optional[str] = None,
             ip: Optional[str] = None,
             netmask: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dhcp is not None:
            _setter("dhcp", dhcp)
        if gw is not None:
            _setter("gw", gw)
        if ip is not None:
            _setter("ip", ip)
        if netmask is not None:
            _setter("netmask", netmask)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[bool]:
        """
        Use DHCP to configure the interface's IPv6 stack.
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter
    def gw(self) -> Optional[str]:
        """
        IP address of the default gateway, if DHCP or autoconfig is not set.
        """
        return pulumi.get(self, "gw")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Address of the interface, if DHCP is not set.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def netmask(self) -> Optional[str]:
        """
        Netmask of the interface, if DHCP is not set.
        """
        return pulumi.get(self, "netmask")


@pulumi.output_type
class VnicIpv6(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence[str]] = None,
                 autoconfig: Optional[bool] = None,
                 dhcp: Optional[bool] = None,
                 gw: Optional[str] = None):
        """
        :param Sequence[str] addresses: List of IPv6 addresses
        :param bool autoconfig: Use IPv6 Autoconfiguration (RFC2462).
        :param bool dhcp: Use DHCP to configure the interface's IPv6 stack.
        :param str gw: IP address of the default gateway, if DHCP or autoconfig is not set.
        """
        VnicIpv6._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addresses=addresses,
            autoconfig=autoconfig,
            dhcp=dhcp,
            gw=gw,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addresses: Optional[Sequence[str]] = None,
             autoconfig: Optional[bool] = None,
             dhcp: Optional[bool] = None,
             gw: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if addresses is not None:
            _setter("addresses", addresses)
        if autoconfig is not None:
            _setter("autoconfig", autoconfig)
        if dhcp is not None:
            _setter("dhcp", dhcp)
        if gw is not None:
            _setter("gw", gw)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        """
        List of IPv6 addresses
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def autoconfig(self) -> Optional[bool]:
        """
        Use IPv6 Autoconfiguration (RFC2462).
        """
        return pulumi.get(self, "autoconfig")

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[bool]:
        """
        Use DHCP to configure the interface's IPv6 stack.
        """
        return pulumi.get(self, "dhcp")

    @property
    @pulumi.getter
    def gw(self) -> Optional[str]:
        """
        IP address of the default gateway, if DHCP or autoconfig is not set.
        """
        return pulumi.get(self, "gw")


@pulumi.output_type
class GetVirtualMachineDiskResult(dict):
    def __init__(__self__, *,
                 eagerly_scrub: bool,
                 label: str,
                 size: int,
                 thin_provisioned: bool,
                 unit_number: int):
        """
        :param bool eagerly_scrub: Set to `true` if the disk has been eager zeroed.
        :param str label: The label for the disk.
        :param int size: The size of the disk, in GIB.
        :param bool thin_provisioned: Set to `true` if the disk has been thin provisioned.
        :param int unit_number: The disk number on the storage bus.
        """
        GetVirtualMachineDiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            eagerly_scrub=eagerly_scrub,
            label=label,
            size=size,
            thin_provisioned=thin_provisioned,
            unit_number=unit_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             eagerly_scrub: bool,
             label: str,
             size: int,
             thin_provisioned: bool,
             unit_number: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("eagerly_scrub", eagerly_scrub)
        _setter("label", label)
        _setter("size", size)
        _setter("thin_provisioned", thin_provisioned)
        _setter("unit_number", unit_number)

    @property
    @pulumi.getter(name="eagerlyScrub")
    def eagerly_scrub(self) -> bool:
        """
        Set to `true` if the disk has been eager zeroed.
        """
        return pulumi.get(self, "eagerly_scrub")

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        The label for the disk.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        The size of the disk, in GIB.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> bool:
        """
        Set to `true` if the disk has been thin provisioned.
        """
        return pulumi.get(self, "thin_provisioned")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> int:
        """
        The disk number on the storage bus.
        """
        return pulumi.get(self, "unit_number")


@pulumi.output_type
class GetVirtualMachineNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 adapter_type: str,
                 bandwidth_share_count: int,
                 mac_address: str,
                 network_id: str,
                 bandwidth_limit: Optional[int] = None,
                 bandwidth_reservation: Optional[int] = None,
                 bandwidth_share_level: Optional[str] = None):
        """
        :param str adapter_type: The network interface types for each network interface found 
               on the virtual machine, in device bus order. Will be one of `e1000`, `e1000e`,
               `vmxnet3vrdma`, or `vmxnet3`.
        :param int bandwidth_share_count: The share count for this network interface when the
               share level is custom.
        :param str mac_address: The MAC address of this network interface.
        :param str network_id: The managed object reference ID of the network this interface is
               connected to.
        :param int bandwidth_limit: The upper bandwidth limit of this network interface, 
               in Mbits/sec.
        :param int bandwidth_reservation: The bandwidth reservation of this network interface,
               in Mbits/sec.
        :param str bandwidth_share_level: The bandwidth share allocation level for this interface.
               Can be one of `low`, `normal`, `high`, or `custom`.
        """
        GetVirtualMachineNetworkInterfaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            adapter_type=adapter_type,
            bandwidth_share_count=bandwidth_share_count,
            mac_address=mac_address,
            network_id=network_id,
            bandwidth_limit=bandwidth_limit,
            bandwidth_reservation=bandwidth_reservation,
            bandwidth_share_level=bandwidth_share_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             adapter_type: str,
             bandwidth_share_count: int,
             mac_address: str,
             network_id: str,
             bandwidth_limit: Optional[int] = None,
             bandwidth_reservation: Optional[int] = None,
             bandwidth_share_level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("adapter_type", adapter_type)
        _setter("bandwidth_share_count", bandwidth_share_count)
        _setter("mac_address", mac_address)
        _setter("network_id", network_id)
        if bandwidth_limit is not None:
            _setter("bandwidth_limit", bandwidth_limit)
        if bandwidth_reservation is not None:
            _setter("bandwidth_reservation", bandwidth_reservation)
        if bandwidth_share_level is not None:
            _setter("bandwidth_share_level", bandwidth_share_level)

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> str:
        """
        The network interface types for each network interface found 
        on the virtual machine, in device bus order. Will be one of `e1000`, `e1000e`,
        `vmxnet3vrdma`, or `vmxnet3`.
        """
        return pulumi.get(self, "adapter_type")

    @property
    @pulumi.getter(name="bandwidthShareCount")
    def bandwidth_share_count(self) -> int:
        """
        The share count for this network interface when the
        share level is custom.
        """
        return pulumi.get(self, "bandwidth_share_count")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        The MAC address of this network interface.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        The managed object reference ID of the network this interface is
        connected to.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="bandwidthLimit")
    def bandwidth_limit(self) -> Optional[int]:
        """
        The upper bandwidth limit of this network interface, 
        in Mbits/sec.
        """
        return pulumi.get(self, "bandwidth_limit")

    @property
    @pulumi.getter(name="bandwidthReservation")
    def bandwidth_reservation(self) -> Optional[int]:
        """
        The bandwidth reservation of this network interface,
        in Mbits/sec.
        """
        return pulumi.get(self, "bandwidth_reservation")

    @property
    @pulumi.getter(name="bandwidthShareLevel")
    def bandwidth_share_level(self) -> Optional[str]:
        """
        The bandwidth share allocation level for this interface.
        Can be one of `low`, `normal`, `high`, or `custom`.
        """
        return pulumi.get(self, "bandwidth_share_level")


@pulumi.output_type
class GetVirtualMachineVappResult(dict):
    def __init__(__self__, *,
                 properties: Optional[Mapping[str, str]] = None):
        GetVirtualMachineVappResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "properties")


