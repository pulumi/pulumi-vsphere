# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ComputeClusterVsanDiskGroupArgs',
    'ContentLibraryPublicationArgs',
    'ContentLibrarySubscriptionArgs',
    'DistributedPortGroupVlanRangeArgs',
    'DistributedVirtualSwitchHostArgs',
    'DistributedVirtualSwitchPvlanMappingArgs',
    'DistributedVirtualSwitchVlanRangeArgs',
    'EntityPermissionsPermissionArgs',
    'HostPortGroupPortArgs',
    'VirtualMachineCdromArgs',
    'VirtualMachineCloneArgs',
    'VirtualMachineCloneCustomizeArgs',
    'VirtualMachineCloneCustomizeLinuxOptionsArgs',
    'VirtualMachineCloneCustomizeNetworkInterfaceArgs',
    'VirtualMachineCloneCustomizeWindowsOptionsArgs',
    'VirtualMachineDiskArgs',
    'VirtualMachineNetworkInterfaceArgs',
    'VirtualMachineOvfDeployArgs',
    'VirtualMachineVappArgs',
    'VmStoragePolicyTagRuleArgs',
    'VnicIpv4Args',
    'VnicIpv6Args',
    'GetVirtualMachineVappArgs',
]

@pulumi.input_type
class ComputeClusterVsanDiskGroupArgs:
    def __init__(__self__, *,
                 cache: Optional[pulumi.Input[str]] = None,
                 storages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] cache: The canonical name of the disk to use for vSAN cache.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] storages: An array of disk canonical names for vSAN storage.
               
               > **NOTE:** You must disable vSphere HA before you enable vSAN on the cluster.
               You can enable or re-enable vSphere HA after vSAN is configured.
               
               ```python
               import pulumi
               import pulumi_vsphere as vsphere
               
               compute_cluster = vsphere.ComputeCluster("computeCluster",
                   datacenter_id=data["vsphere_datacenter"]["datacenter"]["id"],
                   host_system_ids=[[__item["id"] for __item in data["vsphere_host"]["host"]]],
                   drs_enabled=True,
                   drs_automation_level="fullyAutomated",
                   ha_enabled=False,
                   vsan_enabled=True,
                   vsan_dedup_enabled=True,
                   vsan_compression_enabled=True,
                   vsan_performance_enabled=True,
                   vsan_verbose_mode_enabled=True,
                   vsan_network_diagnostic_mode_enabled=True,
                   vsan_unmap_enabled=True,
                   vsan_dit_encryption_enabled=True,
                   vsan_dit_rekey_interval=1800,
                   vsan_disk_groups=[vsphere.ComputeClusterVsanDiskGroupArgs(
                       cache=data["vsphere_vmfs_disks"]["cache_disks"],
                       storages=data["vsphere_vmfs_disks"]["storage_disks"],
                   )])
               ```
        """
        ComputeClusterVsanDiskGroupArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache=cache,
            storages=storages,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache: Optional[pulumi.Input[str]] = None,
             storages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cache is not None:
            _setter("cache", cache)
        if storages is not None:
            _setter("storages", storages)

    @property
    @pulumi.getter
    def cache(self) -> Optional[pulumi.Input[str]]:
        """
        The canonical name of the disk to use for vSAN cache.
        """
        return pulumi.get(self, "cache")

    @cache.setter
    def cache(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache", value)

    @property
    @pulumi.getter
    def storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of disk canonical names for vSAN storage.

        > **NOTE:** You must disable vSphere HA before you enable vSAN on the cluster.
        You can enable or re-enable vSphere HA after vSAN is configured.

        ```python
        import pulumi
        import pulumi_vsphere as vsphere

        compute_cluster = vsphere.ComputeCluster("computeCluster",
            datacenter_id=data["vsphere_datacenter"]["datacenter"]["id"],
            host_system_ids=[[__item["id"] for __item in data["vsphere_host"]["host"]]],
            drs_enabled=True,
            drs_automation_level="fullyAutomated",
            ha_enabled=False,
            vsan_enabled=True,
            vsan_dedup_enabled=True,
            vsan_compression_enabled=True,
            vsan_performance_enabled=True,
            vsan_verbose_mode_enabled=True,
            vsan_network_diagnostic_mode_enabled=True,
            vsan_unmap_enabled=True,
            vsan_dit_encryption_enabled=True,
            vsan_dit_rekey_interval=1800,
            vsan_disk_groups=[vsphere.ComputeClusterVsanDiskGroupArgs(
                cache=data["vsphere_vmfs_disks"]["cache_disks"],
                storages=data["vsphere_vmfs_disks"]["storage_disks"],
            )])
        ```
        """
        return pulumi.get(self, "storages")

    @storages.setter
    def storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "storages", value)


@pulumi.input_type
class ContentLibraryPublicationArgs:
    def __init__(__self__, *,
                 authentication_method: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 publish_url: Optional[pulumi.Input[str]] = None,
                 published: Optional[pulumi.Input[bool]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authentication_method: Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.
        :param pulumi.Input[str] password: Password used for authentication.
        :param pulumi.Input[str] publish_url: The URL of the published content library.
        :param pulumi.Input[bool] published: Publish the content library. Default `false`.
        :param pulumi.Input[str] username: Username used for authentication.
        """
        ContentLibraryPublicationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication_method=authentication_method,
            password=password,
            publish_url=publish_url,
            published=published,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication_method: Optional[pulumi.Input[str]] = None,
             password: Optional[pulumi.Input[str]] = None,
             publish_url: Optional[pulumi.Input[str]] = None,
             published: Optional[pulumi.Input[bool]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if authentication_method is not None:
            _setter("authentication_method", authentication_method)
        if password is not None:
            _setter("password", password)
        if publish_url is not None:
            _setter("publish_url", publish_url)
        if published is not None:
            _setter("published", published)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[pulumi.Input[str]]:
        """
        Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.
        """
        return pulumi.get(self, "authentication_method")

    @authentication_method.setter
    def authentication_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_method", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password used for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="publishUrl")
    def publish_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the published content library.
        """
        return pulumi.get(self, "publish_url")

    @publish_url.setter
    def publish_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publish_url", value)

    @property
    @pulumi.getter
    def published(self) -> Optional[pulumi.Input[bool]]:
        """
        Publish the content library. Default `false`.
        """
        return pulumi.get(self, "published")

    @published.setter
    def published(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "published", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username used for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ContentLibrarySubscriptionArgs:
    def __init__(__self__, *,
                 authentication_method: Optional[pulumi.Input[str]] = None,
                 automatic_sync: Optional[pulumi.Input[bool]] = None,
                 on_demand: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 subscription_url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authentication_method: Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.
        :param pulumi.Input[bool] automatic_sync: Enable automatic synchronization with the published library. Default `false`.
        :param pulumi.Input[bool] on_demand: Download the library from a content only when needed. Default `true`.
        :param pulumi.Input[str] password: Password used for authentication.
        :param pulumi.Input[str] subscription_url: URL of the published content library.
        :param pulumi.Input[str] username: Username used for authentication.
        """
        ContentLibrarySubscriptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authentication_method=authentication_method,
            automatic_sync=automatic_sync,
            on_demand=on_demand,
            password=password,
            subscription_url=subscription_url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authentication_method: Optional[pulumi.Input[str]] = None,
             automatic_sync: Optional[pulumi.Input[bool]] = None,
             on_demand: Optional[pulumi.Input[bool]] = None,
             password: Optional[pulumi.Input[str]] = None,
             subscription_url: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if authentication_method is not None:
            _setter("authentication_method", authentication_method)
        if automatic_sync is not None:
            _setter("automatic_sync", automatic_sync)
        if on_demand is not None:
            _setter("on_demand", on_demand)
        if password is not None:
            _setter("password", password)
        if subscription_url is not None:
            _setter("subscription_url", subscription_url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[pulumi.Input[str]]:
        """
        Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.
        """
        return pulumi.get(self, "authentication_method")

    @authentication_method.setter
    def authentication_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_method", value)

    @property
    @pulumi.getter(name="automaticSync")
    def automatic_sync(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable automatic synchronization with the published library. Default `false`.
        """
        return pulumi.get(self, "automatic_sync")

    @automatic_sync.setter
    def automatic_sync(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_sync", value)

    @property
    @pulumi.getter(name="onDemand")
    def on_demand(self) -> Optional[pulumi.Input[bool]]:
        """
        Download the library from a content only when needed. Default `true`.
        """
        return pulumi.get(self, "on_demand")

    @on_demand.setter
    def on_demand(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_demand", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password used for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="subscriptionUrl")
    def subscription_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the published content library.
        """
        return pulumi.get(self, "subscription_url")

    @subscription_url.setter
    def subscription_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username used for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DistributedPortGroupVlanRangeArgs:
    def __init__(__self__, *,
                 max_vlan: pulumi.Input[int],
                 min_vlan: pulumi.Input[int]):
        DistributedPortGroupVlanRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_vlan=max_vlan,
            min_vlan=min_vlan,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_vlan: pulumi.Input[int],
             min_vlan: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_vlan", max_vlan)
        _setter("min_vlan", min_vlan)

    @property
    @pulumi.getter(name="maxVlan")
    def max_vlan(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max_vlan")

    @max_vlan.setter
    def max_vlan(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_vlan", value)

    @property
    @pulumi.getter(name="minVlan")
    def min_vlan(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min_vlan")

    @min_vlan.setter
    def min_vlan(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_vlan", value)


@pulumi.input_type
class DistributedVirtualSwitchHostArgs:
    def __init__(__self__, *,
                 host_system_id: pulumi.Input[str],
                 devices: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] host_system_id: The host system ID of the host to add to the
               VDS.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] devices: The list of NIC devices to map to uplinks on the VDS,
               added in order they are specified.
        """
        DistributedVirtualSwitchHostArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_system_id=host_system_id,
            devices=devices,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_system_id: pulumi.Input[str],
             devices: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("host_system_id", host_system_id)
        if devices is not None:
            _setter("devices", devices)

    @property
    @pulumi.getter(name="hostSystemId")
    def host_system_id(self) -> pulumi.Input[str]:
        """
        The host system ID of the host to add to the
        VDS.
        """
        return pulumi.get(self, "host_system_id")

    @host_system_id.setter
    def host_system_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_system_id", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of NIC devices to map to uplinks on the VDS,
        added in order they are specified.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "devices", value)


@pulumi.input_type
class DistributedVirtualSwitchPvlanMappingArgs:
    def __init__(__self__, *,
                 primary_vlan_id: pulumi.Input[int],
                 pvlan_type: pulumi.Input[str],
                 secondary_vlan_id: pulumi.Input[int]):
        """
        :param pulumi.Input[int] primary_vlan_id: The primary VLAN ID. The VLAN IDs of 0 and
               4095 are reserved and cannot be used in this property.
        :param pulumi.Input[str] pvlan_type: The private VLAN type. Valid values are
               promiscuous, community and isolated.
        :param pulumi.Input[int] secondary_vlan_id: The secondary VLAN ID. The VLAN IDs of 0
               and 4095 are reserved and cannot be used in this property.
        """
        DistributedVirtualSwitchPvlanMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            primary_vlan_id=primary_vlan_id,
            pvlan_type=pvlan_type,
            secondary_vlan_id=secondary_vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             primary_vlan_id: pulumi.Input[int],
             pvlan_type: pulumi.Input[str],
             secondary_vlan_id: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("primary_vlan_id", primary_vlan_id)
        _setter("pvlan_type", pvlan_type)
        _setter("secondary_vlan_id", secondary_vlan_id)

    @property
    @pulumi.getter(name="primaryVlanId")
    def primary_vlan_id(self) -> pulumi.Input[int]:
        """
        The primary VLAN ID. The VLAN IDs of 0 and
        4095 are reserved and cannot be used in this property.
        """
        return pulumi.get(self, "primary_vlan_id")

    @primary_vlan_id.setter
    def primary_vlan_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "primary_vlan_id", value)

    @property
    @pulumi.getter(name="pvlanType")
    def pvlan_type(self) -> pulumi.Input[str]:
        """
        The private VLAN type. Valid values are
        promiscuous, community and isolated.
        """
        return pulumi.get(self, "pvlan_type")

    @pvlan_type.setter
    def pvlan_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "pvlan_type", value)

    @property
    @pulumi.getter(name="secondaryVlanId")
    def secondary_vlan_id(self) -> pulumi.Input[int]:
        """
        The secondary VLAN ID. The VLAN IDs of 0
        and 4095 are reserved and cannot be used in this property.
        """
        return pulumi.get(self, "secondary_vlan_id")

    @secondary_vlan_id.setter
    def secondary_vlan_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "secondary_vlan_id", value)


@pulumi.input_type
class DistributedVirtualSwitchVlanRangeArgs:
    def __init__(__self__, *,
                 max_vlan: pulumi.Input[int],
                 min_vlan: pulumi.Input[int]):
        DistributedVirtualSwitchVlanRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_vlan=max_vlan,
            min_vlan=min_vlan,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_vlan: pulumi.Input[int],
             min_vlan: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_vlan", max_vlan)
        _setter("min_vlan", min_vlan)

    @property
    @pulumi.getter(name="maxVlan")
    def max_vlan(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max_vlan")

    @max_vlan.setter
    def max_vlan(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_vlan", value)

    @property
    @pulumi.getter(name="minVlan")
    def min_vlan(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min_vlan")

    @min_vlan.setter
    def min_vlan(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_vlan", value)


@pulumi.input_type
class EntityPermissionsPermissionArgs:
    def __init__(__self__, *,
                 is_group: pulumi.Input[bool],
                 propagate: pulumi.Input[bool],
                 role_id: pulumi.Input[str],
                 user_or_group: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] is_group: Whether user_or_group field refers to a user or a group. True for a group and false for a user.
        :param pulumi.Input[bool] propagate: Whether or not this permission propagates down the hierarchy to sub-entities.
        :param pulumi.Input[str] role_id: The role id of the role to be given to the user on the specified entity.
        :param pulumi.Input[str] user_or_group: The user/group getting the permission.
        """
        EntityPermissionsPermissionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_group=is_group,
            propagate=propagate,
            role_id=role_id,
            user_or_group=user_or_group,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_group: pulumi.Input[bool],
             propagate: pulumi.Input[bool],
             role_id: pulumi.Input[str],
             user_or_group: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_group", is_group)
        _setter("propagate", propagate)
        _setter("role_id", role_id)
        _setter("user_or_group", user_or_group)

    @property
    @pulumi.getter(name="isGroup")
    def is_group(self) -> pulumi.Input[bool]:
        """
        Whether user_or_group field refers to a user or a group. True for a group and false for a user.
        """
        return pulumi.get(self, "is_group")

    @is_group.setter
    def is_group(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_group", value)

    @property
    @pulumi.getter
    def propagate(self) -> pulumi.Input[bool]:
        """
        Whether or not this permission propagates down the hierarchy to sub-entities.
        """
        return pulumi.get(self, "propagate")

    @propagate.setter
    def propagate(self, value: pulumi.Input[bool]):
        pulumi.set(self, "propagate", value)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> pulumi.Input[str]:
        """
        The role id of the role to be given to the user on the specified entity.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_id", value)

    @property
    @pulumi.getter(name="userOrGroup")
    def user_or_group(self) -> pulumi.Input[str]:
        """
        The user/group getting the permission.
        """
        return pulumi.get(self, "user_or_group")

    @user_or_group.setter
    def user_or_group(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_or_group", value)


@pulumi.input_type
class HostPortGroupPortArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 mac_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key for this port group as returned from the vSphere API.
        """
        HostPortGroupPortArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            mac_addresses=mac_addresses,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             mac_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if mac_addresses is not None:
            _setter("mac_addresses", mac_addresses)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key for this port group as returned from the vSphere API.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="macAddresses")
    def mac_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "mac_addresses")

    @mac_addresses.setter
    def mac_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "mac_addresses", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VirtualMachineCdromArgs:
    def __init__(__self__, *,
                 client_device: Optional[pulumi.Input[bool]] = None,
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 device_address: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] client_device: Indicates whether the device should be backed by remote client device. Conflicts with `datastore_id` and `path`.
        :param pulumi.Input[str] datastore_id: The datastore ID that on which the ISO is located. Required for using a datastore ISO. Conflicts with `client_device`.
        :param pulumi.Input[int] key: The ID of the device within the virtual machine.
        :param pulumi.Input[str] path: The path to the ISO file. Required for using a datastore ISO. Conflicts with `client_device`.
               
               > **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .
               
               > **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.
        """
        VirtualMachineCdromArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_device=client_device,
            datastore_id=datastore_id,
            device_address=device_address,
            key=key,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_device: Optional[pulumi.Input[bool]] = None,
             datastore_id: Optional[pulumi.Input[str]] = None,
             device_address: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[int]] = None,
             path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if client_device is not None:
            _setter("client_device", client_device)
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if device_address is not None:
            _setter("device_address", device_address)
        if key is not None:
            _setter("key", key)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="clientDevice")
    def client_device(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the device should be backed by remote client device. Conflicts with `datastore_id` and `path`.
        """
        return pulumi.get(self, "client_device")

    @client_device.setter
    def client_device(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_device", value)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The datastore ID that on which the ISO is located. Required for using a datastore ISO. Conflicts with `client_device`.
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter(name="deviceAddress")
    def device_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "device_address")

    @device_address.setter
    def device_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_address", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the device within the virtual machine.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the ISO file. Required for using a datastore ISO. Conflicts with `client_device`.

        > **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .

        > **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class VirtualMachineCloneArgs:
    def __init__(__self__, *,
                 template_uuid: pulumi.Input[str],
                 customize: Optional[pulumi.Input['VirtualMachineCloneCustomizeArgs']] = None,
                 linked_clone: Optional[pulumi.Input[bool]] = None,
                 ovf_network_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ovf_storage_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        VirtualMachineCloneArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            template_uuid=template_uuid,
            customize=customize,
            linked_clone=linked_clone,
            ovf_network_map=ovf_network_map,
            ovf_storage_map=ovf_storage_map,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             template_uuid: pulumi.Input[str],
             customize: Optional[pulumi.Input['VirtualMachineCloneCustomizeArgs']] = None,
             linked_clone: Optional[pulumi.Input[bool]] = None,
             ovf_network_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             ovf_storage_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             timeout: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("template_uuid", template_uuid)
        if customize is not None:
            _setter("customize", customize)
        if linked_clone is not None:
            _setter("linked_clone", linked_clone)
        if ovf_network_map is not None:
            _setter("ovf_network_map", ovf_network_map)
        if ovf_storage_map is not None:
            _setter("ovf_storage_map", ovf_storage_map)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="templateUuid")
    def template_uuid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "template_uuid")

    @template_uuid.setter
    def template_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "template_uuid", value)

    @property
    @pulumi.getter
    def customize(self) -> Optional[pulumi.Input['VirtualMachineCloneCustomizeArgs']]:
        return pulumi.get(self, "customize")

    @customize.setter
    def customize(self, value: Optional[pulumi.Input['VirtualMachineCloneCustomizeArgs']]):
        pulumi.set(self, "customize", value)

    @property
    @pulumi.getter(name="linkedClone")
    def linked_clone(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "linked_clone")

    @linked_clone.setter
    def linked_clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "linked_clone", value)

    @property
    @pulumi.getter(name="ovfNetworkMap")
    def ovf_network_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "ovf_network_map")

    @ovf_network_map.setter
    def ovf_network_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "ovf_network_map", value)

    @property
    @pulumi.getter(name="ovfStorageMap")
    def ovf_storage_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "ovf_storage_map")

    @ovf_storage_map.setter
    def ovf_storage_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "ovf_storage_map", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class VirtualMachineCloneCustomizeArgs:
    def __init__(__self__, *,
                 dns_server_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_suffix_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv4_gateway: Optional[pulumi.Input[str]] = None,
                 ipv6_gateway: Optional[pulumi.Input[str]] = None,
                 linux_options: Optional[pulumi.Input['VirtualMachineCloneCustomizeLinuxOptionsArgs']] = None,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineCloneCustomizeNetworkInterfaceArgs']]]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 windows_options: Optional[pulumi.Input['VirtualMachineCloneCustomizeWindowsOptionsArgs']] = None,
                 windows_sysprep_text: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineCloneCustomizeNetworkInterfaceArgs']]] network_interfaces: A specification for a virtual NIC on the virtual machine. See network interface options for more information.
        """
        VirtualMachineCloneCustomizeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_server_lists=dns_server_lists,
            dns_suffix_lists=dns_suffix_lists,
            ipv4_gateway=ipv4_gateway,
            ipv6_gateway=ipv6_gateway,
            linux_options=linux_options,
            network_interfaces=network_interfaces,
            timeout=timeout,
            windows_options=windows_options,
            windows_sysprep_text=windows_sysprep_text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_server_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             dns_suffix_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ipv4_gateway: Optional[pulumi.Input[str]] = None,
             ipv6_gateway: Optional[pulumi.Input[str]] = None,
             linux_options: Optional[pulumi.Input['VirtualMachineCloneCustomizeLinuxOptionsArgs']] = None,
             network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineCloneCustomizeNetworkInterfaceArgs']]]] = None,
             timeout: Optional[pulumi.Input[int]] = None,
             windows_options: Optional[pulumi.Input['VirtualMachineCloneCustomizeWindowsOptionsArgs']] = None,
             windows_sysprep_text: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dns_server_lists is not None:
            _setter("dns_server_lists", dns_server_lists)
        if dns_suffix_lists is not None:
            _setter("dns_suffix_lists", dns_suffix_lists)
        if ipv4_gateway is not None:
            _setter("ipv4_gateway", ipv4_gateway)
        if ipv6_gateway is not None:
            _setter("ipv6_gateway", ipv6_gateway)
        if linux_options is not None:
            _setter("linux_options", linux_options)
        if network_interfaces is not None:
            _setter("network_interfaces", network_interfaces)
        if timeout is not None:
            _setter("timeout", timeout)
        if windows_options is not None:
            _setter("windows_options", windows_options)
        if windows_sysprep_text is not None:
            _setter("windows_sysprep_text", windows_sysprep_text)

    @property
    @pulumi.getter(name="dnsServerLists")
    def dns_server_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "dns_server_lists")

    @dns_server_lists.setter
    def dns_server_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_server_lists", value)

    @property
    @pulumi.getter(name="dnsSuffixLists")
    def dns_suffix_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "dns_suffix_lists")

    @dns_suffix_lists.setter
    def dns_suffix_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_suffix_lists", value)

    @property
    @pulumi.getter(name="ipv4Gateway")
    def ipv4_gateway(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv4_gateway")

    @ipv4_gateway.setter
    def ipv4_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_gateway", value)

    @property
    @pulumi.getter(name="ipv6Gateway")
    def ipv6_gateway(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6_gateway")

    @ipv6_gateway.setter
    def ipv6_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_gateway", value)

    @property
    @pulumi.getter(name="linuxOptions")
    def linux_options(self) -> Optional[pulumi.Input['VirtualMachineCloneCustomizeLinuxOptionsArgs']]:
        return pulumi.get(self, "linux_options")

    @linux_options.setter
    def linux_options(self, value: Optional[pulumi.Input['VirtualMachineCloneCustomizeLinuxOptionsArgs']]):
        pulumi.set(self, "linux_options", value)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineCloneCustomizeNetworkInterfaceArgs']]]]:
        """
        A specification for a virtual NIC on the virtual machine. See network interface options for more information.
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineCloneCustomizeNetworkInterfaceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['VirtualMachineCloneCustomizeWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['VirtualMachineCloneCustomizeWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)

    @property
    @pulumi.getter(name="windowsSysprepText")
    def windows_sysprep_text(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "windows_sysprep_text")

    @windows_sysprep_text.setter
    def windows_sysprep_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_sysprep_text", value)


@pulumi.input_type
class VirtualMachineCloneCustomizeLinuxOptionsArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 host_name: pulumi.Input[str],
                 hw_clock_utc: Optional[pulumi.Input[bool]] = None,
                 script_text: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        VirtualMachineCloneCustomizeLinuxOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            host_name=host_name,
            hw_clock_utc=hw_clock_utc,
            script_text=script_text,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: pulumi.Input[str],
             host_name: pulumi.Input[str],
             hw_clock_utc: Optional[pulumi.Input[bool]] = None,
             script_text: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain", domain)
        _setter("host_name", host_name)
        if hw_clock_utc is not None:
            _setter("hw_clock_utc", hw_clock_utc)
        if script_text is not None:
            _setter("script_text", script_text)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter(name="hwClockUtc")
    def hw_clock_utc(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hw_clock_utc")

    @hw_clock_utc.setter
    def hw_clock_utc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hw_clock_utc", value)

    @property
    @pulumi.getter(name="scriptText")
    def script_text(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "script_text")

    @script_text.setter
    def script_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_text", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class VirtualMachineCloneCustomizeNetworkInterfaceArgs:
    def __init__(__self__, *,
                 dns_domain: Optional[pulumi.Input[str]] = None,
                 dns_server_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None,
                 ipv4_netmask: Optional[pulumi.Input[int]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 ipv6_netmask: Optional[pulumi.Input[int]] = None):
        VirtualMachineCloneCustomizeNetworkInterfaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_domain=dns_domain,
            dns_server_lists=dns_server_lists,
            ipv4_address=ipv4_address,
            ipv4_netmask=ipv4_netmask,
            ipv6_address=ipv6_address,
            ipv6_netmask=ipv6_netmask,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_domain: Optional[pulumi.Input[str]] = None,
             dns_server_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ipv4_address: Optional[pulumi.Input[str]] = None,
             ipv4_netmask: Optional[pulumi.Input[int]] = None,
             ipv6_address: Optional[pulumi.Input[str]] = None,
             ipv6_netmask: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dns_domain is not None:
            _setter("dns_domain", dns_domain)
        if dns_server_lists is not None:
            _setter("dns_server_lists", dns_server_lists)
        if ipv4_address is not None:
            _setter("ipv4_address", ipv4_address)
        if ipv4_netmask is not None:
            _setter("ipv4_netmask", ipv4_netmask)
        if ipv6_address is not None:
            _setter("ipv6_address", ipv6_address)
        if ipv6_netmask is not None:
            _setter("ipv6_netmask", ipv6_netmask)

    @property
    @pulumi.getter(name="dnsDomain")
    def dns_domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dns_domain")

    @dns_domain.setter
    def dns_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_domain", value)

    @property
    @pulumi.getter(name="dnsServerLists")
    def dns_server_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "dns_server_lists")

    @dns_server_lists.setter
    def dns_server_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_server_lists", value)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_address", value)

    @property
    @pulumi.getter(name="ipv4Netmask")
    def ipv4_netmask(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ipv4_netmask")

    @ipv4_netmask.setter
    def ipv4_netmask(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ipv4_netmask", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="ipv6Netmask")
    def ipv6_netmask(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ipv6_netmask")

    @ipv6_netmask.setter
    def ipv6_netmask(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ipv6_netmask", value)


@pulumi.input_type
class VirtualMachineCloneCustomizeWindowsOptionsArgs:
    def __init__(__self__, *,
                 computer_name: pulumi.Input[str],
                 admin_password: Optional[pulumi.Input[str]] = None,
                 auto_logon: Optional[pulumi.Input[bool]] = None,
                 auto_logon_count: Optional[pulumi.Input[int]] = None,
                 domain_admin_password: Optional[pulumi.Input[str]] = None,
                 domain_admin_user: Optional[pulumi.Input[str]] = None,
                 full_name: Optional[pulumi.Input[str]] = None,
                 join_domain: Optional[pulumi.Input[str]] = None,
                 organization_name: Optional[pulumi.Input[str]] = None,
                 product_key: Optional[pulumi.Input[str]] = None,
                 run_once_command_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_zone: Optional[pulumi.Input[int]] = None,
                 workgroup: Optional[pulumi.Input[str]] = None):
        VirtualMachineCloneCustomizeWindowsOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computer_name=computer_name,
            admin_password=admin_password,
            auto_logon=auto_logon,
            auto_logon_count=auto_logon_count,
            domain_admin_password=domain_admin_password,
            domain_admin_user=domain_admin_user,
            full_name=full_name,
            join_domain=join_domain,
            organization_name=organization_name,
            product_key=product_key,
            run_once_command_lists=run_once_command_lists,
            time_zone=time_zone,
            workgroup=workgroup,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computer_name: pulumi.Input[str],
             admin_password: Optional[pulumi.Input[str]] = None,
             auto_logon: Optional[pulumi.Input[bool]] = None,
             auto_logon_count: Optional[pulumi.Input[int]] = None,
             domain_admin_password: Optional[pulumi.Input[str]] = None,
             domain_admin_user: Optional[pulumi.Input[str]] = None,
             full_name: Optional[pulumi.Input[str]] = None,
             join_domain: Optional[pulumi.Input[str]] = None,
             organization_name: Optional[pulumi.Input[str]] = None,
             product_key: Optional[pulumi.Input[str]] = None,
             run_once_command_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             time_zone: Optional[pulumi.Input[int]] = None,
             workgroup: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computer_name", computer_name)
        if admin_password is not None:
            _setter("admin_password", admin_password)
        if auto_logon is not None:
            _setter("auto_logon", auto_logon)
        if auto_logon_count is not None:
            _setter("auto_logon_count", auto_logon_count)
        if domain_admin_password is not None:
            _setter("domain_admin_password", domain_admin_password)
        if domain_admin_user is not None:
            _setter("domain_admin_user", domain_admin_user)
        if full_name is not None:
            _setter("full_name", full_name)
        if join_domain is not None:
            _setter("join_domain", join_domain)
        if organization_name is not None:
            _setter("organization_name", organization_name)
        if product_key is not None:
            _setter("product_key", product_key)
        if run_once_command_lists is not None:
            _setter("run_once_command_lists", run_once_command_lists)
        if time_zone is not None:
            _setter("time_zone", time_zone)
        if workgroup is not None:
            _setter("workgroup", workgroup)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "computer_name")

    @computer_name.setter
    def computer_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "computer_name", value)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="autoLogon")
    def auto_logon(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_logon")

    @auto_logon.setter
    def auto_logon(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_logon", value)

    @property
    @pulumi.getter(name="autoLogonCount")
    def auto_logon_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "auto_logon_count")

    @auto_logon_count.setter
    def auto_logon_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_logon_count", value)

    @property
    @pulumi.getter(name="domainAdminPassword")
    def domain_admin_password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain_admin_password")

    @domain_admin_password.setter
    def domain_admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_admin_password", value)

    @property
    @pulumi.getter(name="domainAdminUser")
    def domain_admin_user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain_admin_user")

    @domain_admin_user.setter
    def domain_admin_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_admin_user", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter(name="joinDomain")
    def join_domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "join_domain")

    @join_domain.setter
    def join_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_domain", value)

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "organization_name")

    @organization_name.setter
    def organization_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization_name", value)

    @property
    @pulumi.getter(name="productKey")
    def product_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "product_key")

    @product_key.setter
    def product_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product_key", value)

    @property
    @pulumi.getter(name="runOnceCommandLists")
    def run_once_command_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "run_once_command_lists")

    @run_once_command_lists.setter
    def run_once_command_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "run_once_command_lists", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def workgroup(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "workgroup")

    @workgroup.setter
    def workgroup(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workgroup", value)


@pulumi.input_type
class VirtualMachineDiskArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 attach: Optional[pulumi.Input[bool]] = None,
                 controller_type: Optional[pulumi.Input[str]] = None,
                 datastore_id: Optional[pulumi.Input[str]] = None,
                 device_address: Optional[pulumi.Input[str]] = None,
                 disk_mode: Optional[pulumi.Input[str]] = None,
                 disk_sharing: Optional[pulumi.Input[str]] = None,
                 eagerly_scrub: Optional[pulumi.Input[bool]] = None,
                 io_limit: Optional[pulumi.Input[int]] = None,
                 io_reservation: Optional[pulumi.Input[int]] = None,
                 io_share_count: Optional[pulumi.Input[int]] = None,
                 io_share_level: Optional[pulumi.Input[str]] = None,
                 keep_on_remove: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 storage_policy_id: Optional[pulumi.Input[str]] = None,
                 thin_provisioned: Optional[pulumi.Input[bool]] = None,
                 unit_number: Optional[pulumi.Input[int]] = None,
                 uuid: Optional[pulumi.Input[str]] = None,
                 write_through: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] attach: Attach an external disk instead of creating a new one. Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`, `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.
               
               > **NOTE:** External disks cannot be attached when `datastore_cluster_id` is used.
        :param pulumi.Input[str] controller_type: The type of storage controller to attach the  disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate number of controllers enabled for the selected type. Default `scsi`.
        :param pulumi.Input[str] datastore_id: The datastore ID that on which the ISO is located. Required for using a datastore ISO. Conflicts with `client_device`.
        :param pulumi.Input[str] disk_mode: The mode of this this virtual disk for purposes of writes and snapshots. One of `append`, `independent_nonpersistent`, `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`. Default: `persistent`. For more information on these option, please refer to the [product documentation][vmware-docs-disk-mode].
               
               [vmware-docs-disk-mode]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.device.VirtualDiskOption.DiskMode.html
        :param pulumi.Input[str] disk_sharing: The sharing mode of this virtual disk. One of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.
               
               > **NOTE:** Disk sharing is only available on vSphere 6.0 and later.
        :param pulumi.Input[bool] eagerly_scrub: If set to `true`, the disk space is zeroed out when the virtual machine is created. This will delay the creation of the virtual disk. Cannot be set to `true` when `thin_provisioned` is `true`.  See the section on picking a disk type for more information.  Default: `false`.
        :param pulumi.Input[int] io_limit: The upper limit of IOPS that this disk can use. The default is no limit.
        :param pulumi.Input[int] io_reservation: The I/O reservation (guarantee) for the virtual disk has, in IOPS.  The default is no reservation.
        :param pulumi.Input[int] io_share_count: The share count for the virtual disk when the share level is `custom`.
        :param pulumi.Input[str] io_share_level: The share allocation level for the virtual disk. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        :param pulumi.Input[bool] keep_on_remove: Keep this disk when removing the device or destroying the virtual machine. Default: `false`.
        :param pulumi.Input[int] key: The ID of the device within the virtual machine.
        :param pulumi.Input[str] path: The path to the ISO file. Required for using a datastore ISO. Conflicts with `client_device`.
               
               > **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .
               
               > **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.
        :param pulumi.Input[int] size: The size of the disk, in GB. Must be a whole number.
        :param pulumi.Input[str] storage_policy_id: The UUID of the storage policy to assign to the virtual disk.
        :param pulumi.Input[bool] thin_provisioned: If `true`, the disk is thin provisioned, with space for the file being allocated on an as-needed basis. Cannot be set to `true` when `eagerly_scrub` is `true`. See the section on selecting a disk type for more information. Default: `true`.
        :param pulumi.Input[int] unit_number: The disk number on the storage bus. The maximum value for this setting is the value of the controller count times the controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE). Duplicate unit numbers are not allowed. Default `0`, for which one disk must be set to.
        :param pulumi.Input[str] uuid: The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.
        :param pulumi.Input[bool] write_through: If `true`, writes for this disk are sent directly to the filesystem immediately instead of being buffered. Default: `false`.
        """
        VirtualMachineDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label=label,
            attach=attach,
            controller_type=controller_type,
            datastore_id=datastore_id,
            device_address=device_address,
            disk_mode=disk_mode,
            disk_sharing=disk_sharing,
            eagerly_scrub=eagerly_scrub,
            io_limit=io_limit,
            io_reservation=io_reservation,
            io_share_count=io_share_count,
            io_share_level=io_share_level,
            keep_on_remove=keep_on_remove,
            key=key,
            path=path,
            size=size,
            storage_policy_id=storage_policy_id,
            thin_provisioned=thin_provisioned,
            unit_number=unit_number,
            uuid=uuid,
            write_through=write_through,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label: pulumi.Input[str],
             attach: Optional[pulumi.Input[bool]] = None,
             controller_type: Optional[pulumi.Input[str]] = None,
             datastore_id: Optional[pulumi.Input[str]] = None,
             device_address: Optional[pulumi.Input[str]] = None,
             disk_mode: Optional[pulumi.Input[str]] = None,
             disk_sharing: Optional[pulumi.Input[str]] = None,
             eagerly_scrub: Optional[pulumi.Input[bool]] = None,
             io_limit: Optional[pulumi.Input[int]] = None,
             io_reservation: Optional[pulumi.Input[int]] = None,
             io_share_count: Optional[pulumi.Input[int]] = None,
             io_share_level: Optional[pulumi.Input[str]] = None,
             keep_on_remove: Optional[pulumi.Input[bool]] = None,
             key: Optional[pulumi.Input[int]] = None,
             path: Optional[pulumi.Input[str]] = None,
             size: Optional[pulumi.Input[int]] = None,
             storage_policy_id: Optional[pulumi.Input[str]] = None,
             thin_provisioned: Optional[pulumi.Input[bool]] = None,
             unit_number: Optional[pulumi.Input[int]] = None,
             uuid: Optional[pulumi.Input[str]] = None,
             write_through: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("label", label)
        if attach is not None:
            _setter("attach", attach)
        if controller_type is not None:
            _setter("controller_type", controller_type)
        if datastore_id is not None:
            _setter("datastore_id", datastore_id)
        if device_address is not None:
            _setter("device_address", device_address)
        if disk_mode is not None:
            _setter("disk_mode", disk_mode)
        if disk_sharing is not None:
            _setter("disk_sharing", disk_sharing)
        if eagerly_scrub is not None:
            _setter("eagerly_scrub", eagerly_scrub)
        if io_limit is not None:
            _setter("io_limit", io_limit)
        if io_reservation is not None:
            _setter("io_reservation", io_reservation)
        if io_share_count is not None:
            _setter("io_share_count", io_share_count)
        if io_share_level is not None:
            _setter("io_share_level", io_share_level)
        if keep_on_remove is not None:
            _setter("keep_on_remove", keep_on_remove)
        if key is not None:
            _setter("key", key)
        if path is not None:
            _setter("path", path)
        if size is not None:
            _setter("size", size)
        if storage_policy_id is not None:
            _setter("storage_policy_id", storage_policy_id)
        if thin_provisioned is not None:
            _setter("thin_provisioned", thin_provisioned)
        if unit_number is not None:
            _setter("unit_number", unit_number)
        if uuid is not None:
            _setter("uuid", uuid)
        if write_through is not None:
            _setter("write_through", write_through)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def attach(self) -> Optional[pulumi.Input[bool]]:
        """
        Attach an external disk instead of creating a new one. Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`, `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.

        > **NOTE:** External disks cannot be attached when `datastore_cluster_id` is used.
        """
        return pulumi.get(self, "attach")

    @attach.setter
    def attach(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "attach", value)

    @property
    @pulumi.getter(name="controllerType")
    def controller_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of storage controller to attach the  disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate number of controllers enabled for the selected type. Default `scsi`.
        """
        return pulumi.get(self, "controller_type")

    @controller_type.setter
    def controller_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "controller_type", value)

    @property
    @pulumi.getter(name="datastoreId")
    def datastore_id(self) -> Optional[pulumi.Input[str]]:
        """
        The datastore ID that on which the ISO is located. Required for using a datastore ISO. Conflicts with `client_device`.
        """
        return pulumi.get(self, "datastore_id")

    @datastore_id.setter
    def datastore_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_id", value)

    @property
    @pulumi.getter(name="deviceAddress")
    def device_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "device_address")

    @device_address.setter
    def device_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_address", value)

    @property
    @pulumi.getter(name="diskMode")
    def disk_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode of this this virtual disk for purposes of writes and snapshots. One of `append`, `independent_nonpersistent`, `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`. Default: `persistent`. For more information on these option, please refer to the [product documentation][vmware-docs-disk-mode].

        [vmware-docs-disk-mode]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.device.VirtualDiskOption.DiskMode.html
        """
        return pulumi.get(self, "disk_mode")

    @disk_mode.setter
    def disk_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_mode", value)

    @property
    @pulumi.getter(name="diskSharing")
    def disk_sharing(self) -> Optional[pulumi.Input[str]]:
        """
        The sharing mode of this virtual disk. One of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.

        > **NOTE:** Disk sharing is only available on vSphere 6.0 and later.
        """
        return pulumi.get(self, "disk_sharing")

    @disk_sharing.setter
    def disk_sharing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_sharing", value)

    @property
    @pulumi.getter(name="eagerlyScrub")
    def eagerly_scrub(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, the disk space is zeroed out when the virtual machine is created. This will delay the creation of the virtual disk. Cannot be set to `true` when `thin_provisioned` is `true`.  See the section on picking a disk type for more information.  Default: `false`.
        """
        return pulumi.get(self, "eagerly_scrub")

    @eagerly_scrub.setter
    def eagerly_scrub(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "eagerly_scrub", value)

    @property
    @pulumi.getter(name="ioLimit")
    def io_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The upper limit of IOPS that this disk can use. The default is no limit.
        """
        return pulumi.get(self, "io_limit")

    @io_limit.setter
    def io_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "io_limit", value)

    @property
    @pulumi.getter(name="ioReservation")
    def io_reservation(self) -> Optional[pulumi.Input[int]]:
        """
        The I/O reservation (guarantee) for the virtual disk has, in IOPS.  The default is no reservation.
        """
        return pulumi.get(self, "io_reservation")

    @io_reservation.setter
    def io_reservation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "io_reservation", value)

    @property
    @pulumi.getter(name="ioShareCount")
    def io_share_count(self) -> Optional[pulumi.Input[int]]:
        """
        The share count for the virtual disk when the share level is `custom`.
        """
        return pulumi.get(self, "io_share_count")

    @io_share_count.setter
    def io_share_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "io_share_count", value)

    @property
    @pulumi.getter(name="ioShareLevel")
    def io_share_level(self) -> Optional[pulumi.Input[str]]:
        """
        The share allocation level for the virtual disk. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        """
        return pulumi.get(self, "io_share_level")

    @io_share_level.setter
    def io_share_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "io_share_level", value)

    @property
    @pulumi.getter(name="keepOnRemove")
    def keep_on_remove(self) -> Optional[pulumi.Input[bool]]:
        """
        Keep this disk when removing the device or destroying the virtual machine. Default: `false`.
        """
        return pulumi.get(self, "keep_on_remove")

    @keep_on_remove.setter
    def keep_on_remove(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_on_remove", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the device within the virtual machine.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the ISO file. Required for using a datastore ISO. Conflicts with `client_device`.

        > **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .

        > **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the disk, in GB. Must be a whole number.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="storagePolicyId")
    def storage_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the storage policy to assign to the virtual disk.
        """
        return pulumi.get(self, "storage_policy_id")

    @storage_policy_id.setter
    def storage_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_policy_id", value)

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, the disk is thin provisioned, with space for the file being allocated on an as-needed basis. Cannot be set to `true` when `eagerly_scrub` is `true`. See the section on selecting a disk type for more information. Default: `true`.
        """
        return pulumi.get(self, "thin_provisioned")

    @thin_provisioned.setter
    def thin_provisioned(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "thin_provisioned", value)

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> Optional[pulumi.Input[int]]:
        """
        The disk number on the storage bus. The maximum value for this setting is the value of the controller count times the controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE). Duplicate unit numbers are not allowed. Default `0`, for which one disk must be set to.
        """
        return pulumi.get(self, "unit_number")

    @unit_number.setter
    def unit_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit_number", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter(name="writeThrough")
    def write_through(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, writes for this disk are sent directly to the filesystem immediately instead of being buffered. Default: `false`.
        """
        return pulumi.get(self, "write_through")

    @write_through.setter
    def write_through(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_through", value)


@pulumi.input_type
class VirtualMachineNetworkInterfaceArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[str],
                 adapter_type: Optional[pulumi.Input[str]] = None,
                 bandwidth_limit: Optional[pulumi.Input[int]] = None,
                 bandwidth_reservation: Optional[pulumi.Input[int]] = None,
                 bandwidth_share_count: Optional[pulumi.Input[int]] = None,
                 bandwidth_share_level: Optional[pulumi.Input[str]] = None,
                 device_address: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[int]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 ovf_mapping: Optional[pulumi.Input[str]] = None,
                 use_static_mac: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] network_id: The [managed object reference ID][docs-about-morefs] of the network on which to connect the virtual machine network interface.
        :param pulumi.Input[str] adapter_type: The network interface type. One of `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.
        :param pulumi.Input[int] bandwidth_limit: The upper bandwidth limit of the network interface, in Mbits/sec. The default is no limit.
        :param pulumi.Input[int] bandwidth_reservation: The bandwidth reservation of the network interface, in Mbits/sec. The default is no reservation.
        :param pulumi.Input[int] bandwidth_share_count: The share count for the network interface when the share level is `custom`.
        :param pulumi.Input[str] bandwidth_share_level: The bandwidth share allocation level for the network interface. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        :param pulumi.Input[int] key: The ID of the device within the virtual machine.
        :param pulumi.Input[str] mac_address: The MAC address of the network interface. Can only be manually set if `use_static_mac` is `true`. Otherwise, the value is computed and presents the assigned MAC address for the interface.
        :param pulumi.Input[str] ovf_mapping: Specifies which NIC in an OVF/OVA the `network_interface` should be associated. Only applies at creation when deploying from an OVF/OVA.
        :param pulumi.Input[bool] use_static_mac: If true, the `mac_address` field is treated as a static MAC address and set accordingly. Setting this to `true` requires `mac_address` to be set. Default: `false`.
        """
        VirtualMachineNetworkInterfaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            adapter_type=adapter_type,
            bandwidth_limit=bandwidth_limit,
            bandwidth_reservation=bandwidth_reservation,
            bandwidth_share_count=bandwidth_share_count,
            bandwidth_share_level=bandwidth_share_level,
            device_address=device_address,
            key=key,
            mac_address=mac_address,
            ovf_mapping=ovf_mapping,
            use_static_mac=use_static_mac,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: pulumi.Input[str],
             adapter_type: Optional[pulumi.Input[str]] = None,
             bandwidth_limit: Optional[pulumi.Input[int]] = None,
             bandwidth_reservation: Optional[pulumi.Input[int]] = None,
             bandwidth_share_count: Optional[pulumi.Input[int]] = None,
             bandwidth_share_level: Optional[pulumi.Input[str]] = None,
             device_address: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[int]] = None,
             mac_address: Optional[pulumi.Input[str]] = None,
             ovf_mapping: Optional[pulumi.Input[str]] = None,
             use_static_mac: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("network_id", network_id)
        if adapter_type is not None:
            _setter("adapter_type", adapter_type)
        if bandwidth_limit is not None:
            _setter("bandwidth_limit", bandwidth_limit)
        if bandwidth_reservation is not None:
            _setter("bandwidth_reservation", bandwidth_reservation)
        if bandwidth_share_count is not None:
            _setter("bandwidth_share_count", bandwidth_share_count)
        if bandwidth_share_level is not None:
            _setter("bandwidth_share_level", bandwidth_share_level)
        if device_address is not None:
            _setter("device_address", device_address)
        if key is not None:
            _setter("key", key)
        if mac_address is not None:
            _setter("mac_address", mac_address)
        if ovf_mapping is not None:
            _setter("ovf_mapping", ovf_mapping)
        if use_static_mac is not None:
            _setter("use_static_mac", use_static_mac)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[str]:
        """
        The [managed object reference ID][docs-about-morefs] of the network on which to connect the virtual machine network interface.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> Optional[pulumi.Input[str]]:
        """
        The network interface type. One of `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.
        """
        return pulumi.get(self, "adapter_type")

    @adapter_type.setter
    def adapter_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adapter_type", value)

    @property
    @pulumi.getter(name="bandwidthLimit")
    def bandwidth_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The upper bandwidth limit of the network interface, in Mbits/sec. The default is no limit.
        """
        return pulumi.get(self, "bandwidth_limit")

    @bandwidth_limit.setter
    def bandwidth_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bandwidth_limit", value)

    @property
    @pulumi.getter(name="bandwidthReservation")
    def bandwidth_reservation(self) -> Optional[pulumi.Input[int]]:
        """
        The bandwidth reservation of the network interface, in Mbits/sec. The default is no reservation.
        """
        return pulumi.get(self, "bandwidth_reservation")

    @bandwidth_reservation.setter
    def bandwidth_reservation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bandwidth_reservation", value)

    @property
    @pulumi.getter(name="bandwidthShareCount")
    def bandwidth_share_count(self) -> Optional[pulumi.Input[int]]:
        """
        The share count for the network interface when the share level is `custom`.
        """
        return pulumi.get(self, "bandwidth_share_count")

    @bandwidth_share_count.setter
    def bandwidth_share_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bandwidth_share_count", value)

    @property
    @pulumi.getter(name="bandwidthShareLevel")
    def bandwidth_share_level(self) -> Optional[pulumi.Input[str]]:
        """
        The bandwidth share allocation level for the network interface. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.
        """
        return pulumi.get(self, "bandwidth_share_level")

    @bandwidth_share_level.setter
    def bandwidth_share_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bandwidth_share_level", value)

    @property
    @pulumi.getter(name="deviceAddress")
    def device_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "device_address")

    @device_address.setter
    def device_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_address", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the device within the virtual machine.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        The MAC address of the network interface. Can only be manually set if `use_static_mac` is `true`. Otherwise, the value is computed and presents the assigned MAC address for the interface.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter(name="ovfMapping")
    def ovf_mapping(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which NIC in an OVF/OVA the `network_interface` should be associated. Only applies at creation when deploying from an OVF/OVA.
        """
        return pulumi.get(self, "ovf_mapping")

    @ovf_mapping.setter
    def ovf_mapping(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ovf_mapping", value)

    @property
    @pulumi.getter(name="useStaticMac")
    def use_static_mac(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the `mac_address` field is treated as a static MAC address and set accordingly. Setting this to `true` requires `mac_address` to be set. Default: `false`.
        """
        return pulumi.get(self, "use_static_mac")

    @use_static_mac.setter
    def use_static_mac(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_static_mac", value)


@pulumi.input_type
class VirtualMachineOvfDeployArgs:
    def __init__(__self__, *,
                 allow_unverified_ssl_cert: Optional[pulumi.Input[bool]] = None,
                 deployment_option: Optional[pulumi.Input[str]] = None,
                 disk_provisioning: Optional[pulumi.Input[str]] = None,
                 enable_hidden_properties: Optional[pulumi.Input[bool]] = None,
                 ip_allocation_policy: Optional[pulumi.Input[str]] = None,
                 ip_protocol: Optional[pulumi.Input[str]] = None,
                 local_ovf_path: Optional[pulumi.Input[str]] = None,
                 ovf_network_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 remote_ovf_url: Optional[pulumi.Input[str]] = None):
        VirtualMachineOvfDeployArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_unverified_ssl_cert=allow_unverified_ssl_cert,
            deployment_option=deployment_option,
            disk_provisioning=disk_provisioning,
            enable_hidden_properties=enable_hidden_properties,
            ip_allocation_policy=ip_allocation_policy,
            ip_protocol=ip_protocol,
            local_ovf_path=local_ovf_path,
            ovf_network_map=ovf_network_map,
            remote_ovf_url=remote_ovf_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_unverified_ssl_cert: Optional[pulumi.Input[bool]] = None,
             deployment_option: Optional[pulumi.Input[str]] = None,
             disk_provisioning: Optional[pulumi.Input[str]] = None,
             enable_hidden_properties: Optional[pulumi.Input[bool]] = None,
             ip_allocation_policy: Optional[pulumi.Input[str]] = None,
             ip_protocol: Optional[pulumi.Input[str]] = None,
             local_ovf_path: Optional[pulumi.Input[str]] = None,
             ovf_network_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             remote_ovf_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_unverified_ssl_cert is not None:
            _setter("allow_unverified_ssl_cert", allow_unverified_ssl_cert)
        if deployment_option is not None:
            _setter("deployment_option", deployment_option)
        if disk_provisioning is not None:
            _setter("disk_provisioning", disk_provisioning)
        if enable_hidden_properties is not None:
            _setter("enable_hidden_properties", enable_hidden_properties)
        if ip_allocation_policy is not None:
            _setter("ip_allocation_policy", ip_allocation_policy)
        if ip_protocol is not None:
            _setter("ip_protocol", ip_protocol)
        if local_ovf_path is not None:
            _setter("local_ovf_path", local_ovf_path)
        if ovf_network_map is not None:
            _setter("ovf_network_map", ovf_network_map)
        if remote_ovf_url is not None:
            _setter("remote_ovf_url", remote_ovf_url)

    @property
    @pulumi.getter(name="allowUnverifiedSslCert")
    def allow_unverified_ssl_cert(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_unverified_ssl_cert")

    @allow_unverified_ssl_cert.setter
    def allow_unverified_ssl_cert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_unverified_ssl_cert", value)

    @property
    @pulumi.getter(name="deploymentOption")
    def deployment_option(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "deployment_option")

    @deployment_option.setter
    def deployment_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deployment_option", value)

    @property
    @pulumi.getter(name="diskProvisioning")
    def disk_provisioning(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_provisioning")

    @disk_provisioning.setter
    def disk_provisioning(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_provisioning", value)

    @property
    @pulumi.getter(name="enableHiddenProperties")
    def enable_hidden_properties(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_hidden_properties")

    @enable_hidden_properties.setter
    def enable_hidden_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_hidden_properties", value)

    @property
    @pulumi.getter(name="ipAllocationPolicy")
    def ip_allocation_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_allocation_policy")

    @ip_allocation_policy.setter
    def ip_allocation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_allocation_policy", value)

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_protocol", value)

    @property
    @pulumi.getter(name="localOvfPath")
    def local_ovf_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "local_ovf_path")

    @local_ovf_path.setter
    def local_ovf_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_ovf_path", value)

    @property
    @pulumi.getter(name="ovfNetworkMap")
    def ovf_network_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "ovf_network_map")

    @ovf_network_map.setter
    def ovf_network_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "ovf_network_map", value)

    @property
    @pulumi.getter(name="remoteOvfUrl")
    def remote_ovf_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_ovf_url")

    @remote_ovf_url.setter
    def remote_ovf_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_ovf_url", value)


@pulumi.input_type
class VirtualMachineVappArgs:
    def __init__(__self__, *,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        VirtualMachineVappArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)


@pulumi.input_type
class VmStoragePolicyTagRuleArgs:
    def __init__(__self__, *,
                 tag_category: pulumi.Input[str],
                 tags: pulumi.Input[Sequence[pulumi.Input[str]]],
                 include_datastores_with_tags: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] tag_category: Name of the tag category.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: List of Name of tags to select from the given category.
        :param pulumi.Input[bool] include_datastores_with_tags: Include datastores with the given tags or exclude. Default `true`.
        """
        VmStoragePolicyTagRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tag_category=tag_category,
            tags=tags,
            include_datastores_with_tags=include_datastores_with_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tag_category: pulumi.Input[str],
             tags: pulumi.Input[Sequence[pulumi.Input[str]]],
             include_datastores_with_tags: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("tag_category", tag_category)
        _setter("tags", tags)
        if include_datastores_with_tags is not None:
            _setter("include_datastores_with_tags", include_datastores_with_tags)

    @property
    @pulumi.getter(name="tagCategory")
    def tag_category(self) -> pulumi.Input[str]:
        """
        Name of the tag category.
        """
        return pulumi.get(self, "tag_category")

    @tag_category.setter
    def tag_category(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_category", value)

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of Name of tags to select from the given category.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="includeDatastoresWithTags")
    def include_datastores_with_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Include datastores with the given tags or exclude. Default `true`.
        """
        return pulumi.get(self, "include_datastores_with_tags")

    @include_datastores_with_tags.setter
    def include_datastores_with_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_datastores_with_tags", value)


@pulumi.input_type
class VnicIpv4Args:
    def __init__(__self__, *,
                 dhcp: Optional[pulumi.Input[bool]] = None,
                 gw: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 netmask: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] dhcp: Use DHCP to configure the interface's IPv4 stack.
        :param pulumi.Input[str] gw: IP address of the default gateway, if DHCP or autoconfig is not set.
        :param pulumi.Input[str] ip: Address of the interface, if DHCP is not set.
        :param pulumi.Input[str] netmask: Netmask of the interface, if DHCP is not set.
        """
        VnicIpv4Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dhcp=dhcp,
            gw=gw,
            ip=ip,
            netmask=netmask,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dhcp: Optional[pulumi.Input[bool]] = None,
             gw: Optional[pulumi.Input[str]] = None,
             ip: Optional[pulumi.Input[str]] = None,
             netmask: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dhcp is not None:
            _setter("dhcp", dhcp)
        if gw is not None:
            _setter("gw", gw)
        if ip is not None:
            _setter("ip", ip)
        if netmask is not None:
            _setter("netmask", netmask)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[pulumi.Input[bool]]:
        """
        Use DHCP to configure the interface's IPv4 stack.
        """
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter
    def gw(self) -> Optional[pulumi.Input[str]]:
        """
        IP address of the default gateway, if DHCP or autoconfig is not set.
        """
        return pulumi.get(self, "gw")

    @gw.setter
    def gw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gw", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        Address of the interface, if DHCP is not set.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        Netmask of the interface, if DHCP is not set.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)


@pulumi.input_type
class VnicIpv6Args:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 autoconfig: Optional[pulumi.Input[bool]] = None,
                 dhcp: Optional[pulumi.Input[bool]] = None,
                 gw: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: List of IPv6 addresses
        :param pulumi.Input[bool] autoconfig: Use IPv6 Autoconfiguration (RFC2462).
        :param pulumi.Input[bool] dhcp: Use DHCP to configure the interface's IPv4 stack.
        :param pulumi.Input[str] gw: IP address of the default gateway, if DHCP or autoconfig is not set.
        """
        VnicIpv6Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addresses=addresses,
            autoconfig=autoconfig,
            dhcp=dhcp,
            gw=gw,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             autoconfig: Optional[pulumi.Input[bool]] = None,
             dhcp: Optional[pulumi.Input[bool]] = None,
             gw: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if addresses is not None:
            _setter("addresses", addresses)
        if autoconfig is not None:
            _setter("autoconfig", autoconfig)
        if dhcp is not None:
            _setter("dhcp", dhcp)
        if gw is not None:
            _setter("gw", gw)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IPv6 addresses
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def autoconfig(self) -> Optional[pulumi.Input[bool]]:
        """
        Use IPv6 Autoconfiguration (RFC2462).
        """
        return pulumi.get(self, "autoconfig")

    @autoconfig.setter
    def autoconfig(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoconfig", value)

    @property
    @pulumi.getter
    def dhcp(self) -> Optional[pulumi.Input[bool]]:
        """
        Use DHCP to configure the interface's IPv4 stack.
        """
        return pulumi.get(self, "dhcp")

    @dhcp.setter
    def dhcp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp", value)

    @property
    @pulumi.getter
    def gw(self) -> Optional[pulumi.Input[str]]:
        """
        IP address of the default gateway, if DHCP or autoconfig is not set.
        """
        return pulumi.get(self, "gw")

    @gw.setter
    def gw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gw", value)


@pulumi.input_type
class GetVirtualMachineVappArgs:
    def __init__(__self__, *,
                 properties: Optional[Mapping[str, str]] = None):
        GetVirtualMachineVappArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             properties: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "properties", value)


