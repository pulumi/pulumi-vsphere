// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vsphere

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The `VmfsDatastore` resource can be used to create and manage VMFS
// datastores on an ESXi host or a set of hosts. The resource supports using any
// SCSI device that can generally be used in a datastore, such as local disks, or
// disks presented to a host or multiple hosts over Fibre Channel or iSCSI.
// Devices can be specified manually, or discovered using the
// [`getVmfsDisks`][data-source-vmfs-disks] data source.
//
// [data-source-vmfs-disks]: /docs/providers/vsphere/d/vmfs_disks.html
//
// ## Auto-Mounting of Datastores Within vCenter
//
// Note that the current behavior of this resource will auto-mount any created
// datastores to any other host within vCenter that has access to the same disk.
//
// Example: You want to create a datastore with a iSCSI LUN that is visible on 3
// hosts in a single vSphere cluster (`esxi1`, `esxi2` and `esxi3`). When you
// create the datastore on `esxi1`, the datastore will be automatically mounted on
// `esxi2` and `esxi3`, without the need to configure the resource on either of
// those two hosts.
//
// Future versions of this resource may allow you to control the hosts that a
// datastore is mounted to, but currently, this automatic behavior cannot be
// changed, so keep this in mind when writing your configurations and deploying
// your disks.
//
// ## Increasing Datastore Size
//
// To increase the size of a datastore, you must add additional disks to the
// `disks` attribute. Expanding the size of a datastore by increasing the size of
// an already provisioned disk is currently not supported (but may be in future
// versions of this resource).
//
// > **NOTE:** You cannot decrease the size of a datastore. If the resource
// detects disks removed from the configuration, the provider will give an error.
//
// [cmd-taint]: /docs/commands/taint.html
//
// ## Example Usage
//
// ### Addition of local disks on a single host
//
// The following example uses the default datacenter and default host to add a
// datastore with local disks to a single ESXi server.
//
// > **NOTE:** There are some situations where datastore creation will not work
// when working through vCenter (usually when trying to create a datastore on a
// single host with local disks). If you experience trouble creating the datastore
// you need through vCenter, break the datastore off into a different configuration
// and deploy it using the ESXi server as the provider endpoint, using a similar
// configuration to what is below.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			datacenter, err := vsphere.LookupDatacenter(ctx, &vsphere.LookupDatacenterArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = vsphere.LookupHost(ctx, &vsphere.LookupHostArgs{
//				DatacenterId: datacenter.Id,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = vsphere.NewVmfsDatastore(ctx, "datastore", &vsphere.VmfsDatastoreArgs{
//				Name:         pulumi.String("test"),
//				HostSystemId: pulumi.Any(esxiHost.Id),
//				Disks: pulumi.StringArray{
//					pulumi.String("mpx.vmhba1:C0:T1:L0"),
//					pulumi.String("mpx.vmhba1:C0:T2:L0"),
//					pulumi.String("mpx.vmhba1:C0:T2:L0"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Auto-detection of disks via `getVmfsDisks`
//
// The following example makes use of the
// `getVmfsDisks` data source to auto-detect
// exported iSCSI LUNS matching a certain NAA vendor ID (in this case, LUNs
// exported from a [NetApp][ext-netapp]). These discovered disks are then loaded
// into `VmfsDatastore`. The datastore is also placed in the
// `datastore-folder` folder afterwards.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			datacenter, err := vsphere.LookupDatacenter(ctx, &vsphere.LookupDatacenterArgs{
//				Name: pulumi.StringRef("dc-01"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			host, err := vsphere.LookupHost(ctx, &vsphere.LookupHostArgs{
//				Name:         pulumi.StringRef("esxi-01.example.com"),
//				DatacenterId: datacenter.Id,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			available, err := vsphere.GetVmfsDisks(ctx, &vsphere.GetVmfsDisksArgs{
//				HostSystemId: host.Id,
//				Rescan:       pulumi.BoolRef(true),
//				Filter:       pulumi.StringRef("naa.60a98000"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = vsphere.NewVmfsDatastore(ctx, "datastore", &vsphere.VmfsDatastoreArgs{
//				Name:         pulumi.String("test"),
//				HostSystemId: pulumi.Any(esxiHost.Id),
//				Folder:       pulumi.String("datastore-folder"),
//				Disks: pulumi.StringArray{
//					interface{}(available.Disks),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # An existing VMFS datastore can be imported into this resource
//
// via its managed object ID, via the command below. You also need the host system
//
// ID.
//
// ```sh
// $ pulumi import vsphere:index/vmfsDatastore:VmfsDatastore datastore datastore-123:host-10
// ```
//
// You need a tool like [`govc`][ext-govc] that can display managed object IDs.
//
// # In the case of govc, you can locate a managed object ID from an inventory path
//
// by doing the following:
//
// $ govc ls -i /dc/datastore/terraform-test
//
// Datastore:datastore-123
//
// # To locate host IDs, it might be a good idea to supply the `-l` flag as well so
//
// that you can line up the names with the IDs:
//
// $ govc ls -l -i /dc/host/cluster1
//
// ResourcePool:resgroup-10 /dc/host/cluster1/Resources
//
// HostSystem:host-10 /dc/host/cluster1/esxi1
//
// HostSystem:host-11 /dc/host/cluster1/esxi2
//
// HostSystem:host-12 /dc/host/cluster1/esxi3
//
// [ext-netapp]: https://kb.netapp.com/support/s/article/ka31A0000000rLRQAY/how-to-match-a-lun-s-naa-number-to-its-serial-number?language=en_US
// [ext-govc]: https://github.com/vmware/govmomi/tree/master/govc
//
// [docs-import]: https://developer.hashicorp.com/terraform/cli/import
type VmfsDatastore struct {
	pulumi.CustomResourceState

	// The connectivity status of the datastore. If this is `false`,
	// some other computed attributes may be out of date.
	Accessible pulumi.BoolOutput `pulumi:"accessible"`
	// Maximum capacity of the datastore, in megabytes.
	Capacity pulumi.IntOutput `pulumi:"capacity"`
	// Map of custom attribute ids to attribute
	// value string to set on datastore resource.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi connections
	// and require vCenter.
	CustomAttributes pulumi.StringMapOutput `pulumi:"customAttributes"`
	// The managed object
	// ID of a datastore cluster to put this datastore in.
	// Conflicts with `folder`.
	DatastoreClusterId pulumi.StringPtrOutput `pulumi:"datastoreClusterId"`
	// The disks to use with the datastore.
	Disks pulumi.StringArrayOutput `pulumi:"disks"`
	// The relative path to a folder to put this datastore in.
	// This is a path relative to the datacenter you are deploying the datastore to.
	// Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
	// The provider will place a datastore named `test` in a datastore folder
	// located at `/dc1/datastore/foo/bar`, with the final inventory path being
	// `/dc1/datastore/foo/bar/test`. Conflicts with
	// `datastoreClusterId`.
	Folder pulumi.StringPtrOutput `pulumi:"folder"`
	// Available space of this datastore, in megabytes.
	FreeSpace pulumi.IntOutput `pulumi:"freeSpace"`
	// The managed object ID of
	// the host to set the datastore up on. Note that this is not necessarily the
	// only host that the datastore will be set up on - see
	// here for more info. Forces a
	// new resource if changed.
	HostSystemId pulumi.StringOutput `pulumi:"hostSystemId"`
	// The current maintenance mode state of the datastore.
	MaintenanceMode pulumi.StringOutput `pulumi:"maintenanceMode"`
	// If `true`, more than one host in the datacenter has
	// been configured with access to the datastore.
	MultipleHostAccess pulumi.BoolOutput `pulumi:"multipleHostAccess"`
	// The name of the datastore. Forces a new resource if
	// changed.
	Name pulumi.StringOutput `pulumi:"name"`
	// The IDs of any tags to attach to this resource.
	//
	// > **NOTE:** Tagging support is unsupported on direct ESXi connections and
	// requires vCenter 6.0 or higher.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// Total additional storage space, in megabytes,
	// potentially used by all virtual machines on this datastore.
	UncommittedSpace pulumi.IntOutput `pulumi:"uncommittedSpace"`
	// The unique locator for the datastore.
	Url pulumi.StringOutput `pulumi:"url"`
}

// NewVmfsDatastore registers a new resource with the given unique name, arguments, and options.
func NewVmfsDatastore(ctx *pulumi.Context,
	name string, args *VmfsDatastoreArgs, opts ...pulumi.ResourceOption) (*VmfsDatastore, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Disks == nil {
		return nil, errors.New("invalid value for required argument 'Disks'")
	}
	if args.HostSystemId == nil {
		return nil, errors.New("invalid value for required argument 'HostSystemId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource VmfsDatastore
	err := ctx.RegisterResource("vsphere:index/vmfsDatastore:VmfsDatastore", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVmfsDatastore gets an existing VmfsDatastore resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVmfsDatastore(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VmfsDatastoreState, opts ...pulumi.ResourceOption) (*VmfsDatastore, error) {
	var resource VmfsDatastore
	err := ctx.ReadResource("vsphere:index/vmfsDatastore:VmfsDatastore", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VmfsDatastore resources.
type vmfsDatastoreState struct {
	// The connectivity status of the datastore. If this is `false`,
	// some other computed attributes may be out of date.
	Accessible *bool `pulumi:"accessible"`
	// Maximum capacity of the datastore, in megabytes.
	Capacity *int `pulumi:"capacity"`
	// Map of custom attribute ids to attribute
	// value string to set on datastore resource.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi connections
	// and require vCenter.
	CustomAttributes map[string]string `pulumi:"customAttributes"`
	// The managed object
	// ID of a datastore cluster to put this datastore in.
	// Conflicts with `folder`.
	DatastoreClusterId *string `pulumi:"datastoreClusterId"`
	// The disks to use with the datastore.
	Disks []string `pulumi:"disks"`
	// The relative path to a folder to put this datastore in.
	// This is a path relative to the datacenter you are deploying the datastore to.
	// Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
	// The provider will place a datastore named `test` in a datastore folder
	// located at `/dc1/datastore/foo/bar`, with the final inventory path being
	// `/dc1/datastore/foo/bar/test`. Conflicts with
	// `datastoreClusterId`.
	Folder *string `pulumi:"folder"`
	// Available space of this datastore, in megabytes.
	FreeSpace *int `pulumi:"freeSpace"`
	// The managed object ID of
	// the host to set the datastore up on. Note that this is not necessarily the
	// only host that the datastore will be set up on - see
	// here for more info. Forces a
	// new resource if changed.
	HostSystemId *string `pulumi:"hostSystemId"`
	// The current maintenance mode state of the datastore.
	MaintenanceMode *string `pulumi:"maintenanceMode"`
	// If `true`, more than one host in the datacenter has
	// been configured with access to the datastore.
	MultipleHostAccess *bool `pulumi:"multipleHostAccess"`
	// The name of the datastore. Forces a new resource if
	// changed.
	Name *string `pulumi:"name"`
	// The IDs of any tags to attach to this resource.
	//
	// > **NOTE:** Tagging support is unsupported on direct ESXi connections and
	// requires vCenter 6.0 or higher.
	Tags []string `pulumi:"tags"`
	// Total additional storage space, in megabytes,
	// potentially used by all virtual machines on this datastore.
	UncommittedSpace *int `pulumi:"uncommittedSpace"`
	// The unique locator for the datastore.
	Url *string `pulumi:"url"`
}

type VmfsDatastoreState struct {
	// The connectivity status of the datastore. If this is `false`,
	// some other computed attributes may be out of date.
	Accessible pulumi.BoolPtrInput
	// Maximum capacity of the datastore, in megabytes.
	Capacity pulumi.IntPtrInput
	// Map of custom attribute ids to attribute
	// value string to set on datastore resource.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi connections
	// and require vCenter.
	CustomAttributes pulumi.StringMapInput
	// The managed object
	// ID of a datastore cluster to put this datastore in.
	// Conflicts with `folder`.
	DatastoreClusterId pulumi.StringPtrInput
	// The disks to use with the datastore.
	Disks pulumi.StringArrayInput
	// The relative path to a folder to put this datastore in.
	// This is a path relative to the datacenter you are deploying the datastore to.
	// Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
	// The provider will place a datastore named `test` in a datastore folder
	// located at `/dc1/datastore/foo/bar`, with the final inventory path being
	// `/dc1/datastore/foo/bar/test`. Conflicts with
	// `datastoreClusterId`.
	Folder pulumi.StringPtrInput
	// Available space of this datastore, in megabytes.
	FreeSpace pulumi.IntPtrInput
	// The managed object ID of
	// the host to set the datastore up on. Note that this is not necessarily the
	// only host that the datastore will be set up on - see
	// here for more info. Forces a
	// new resource if changed.
	HostSystemId pulumi.StringPtrInput
	// The current maintenance mode state of the datastore.
	MaintenanceMode pulumi.StringPtrInput
	// If `true`, more than one host in the datacenter has
	// been configured with access to the datastore.
	MultipleHostAccess pulumi.BoolPtrInput
	// The name of the datastore. Forces a new resource if
	// changed.
	Name pulumi.StringPtrInput
	// The IDs of any tags to attach to this resource.
	//
	// > **NOTE:** Tagging support is unsupported on direct ESXi connections and
	// requires vCenter 6.0 or higher.
	Tags pulumi.StringArrayInput
	// Total additional storage space, in megabytes,
	// potentially used by all virtual machines on this datastore.
	UncommittedSpace pulumi.IntPtrInput
	// The unique locator for the datastore.
	Url pulumi.StringPtrInput
}

func (VmfsDatastoreState) ElementType() reflect.Type {
	return reflect.TypeOf((*vmfsDatastoreState)(nil)).Elem()
}

type vmfsDatastoreArgs struct {
	// Map of custom attribute ids to attribute
	// value string to set on datastore resource.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi connections
	// and require vCenter.
	CustomAttributes map[string]string `pulumi:"customAttributes"`
	// The managed object
	// ID of a datastore cluster to put this datastore in.
	// Conflicts with `folder`.
	DatastoreClusterId *string `pulumi:"datastoreClusterId"`
	// The disks to use with the datastore.
	Disks []string `pulumi:"disks"`
	// The relative path to a folder to put this datastore in.
	// This is a path relative to the datacenter you are deploying the datastore to.
	// Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
	// The provider will place a datastore named `test` in a datastore folder
	// located at `/dc1/datastore/foo/bar`, with the final inventory path being
	// `/dc1/datastore/foo/bar/test`. Conflicts with
	// `datastoreClusterId`.
	Folder *string `pulumi:"folder"`
	// The managed object ID of
	// the host to set the datastore up on. Note that this is not necessarily the
	// only host that the datastore will be set up on - see
	// here for more info. Forces a
	// new resource if changed.
	HostSystemId string `pulumi:"hostSystemId"`
	// The name of the datastore. Forces a new resource if
	// changed.
	Name *string `pulumi:"name"`
	// The IDs of any tags to attach to this resource.
	//
	// > **NOTE:** Tagging support is unsupported on direct ESXi connections and
	// requires vCenter 6.0 or higher.
	Tags []string `pulumi:"tags"`
}

// The set of arguments for constructing a VmfsDatastore resource.
type VmfsDatastoreArgs struct {
	// Map of custom attribute ids to attribute
	// value string to set on datastore resource.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi connections
	// and require vCenter.
	CustomAttributes pulumi.StringMapInput
	// The managed object
	// ID of a datastore cluster to put this datastore in.
	// Conflicts with `folder`.
	DatastoreClusterId pulumi.StringPtrInput
	// The disks to use with the datastore.
	Disks pulumi.StringArrayInput
	// The relative path to a folder to put this datastore in.
	// This is a path relative to the datacenter you are deploying the datastore to.
	// Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
	// The provider will place a datastore named `test` in a datastore folder
	// located at `/dc1/datastore/foo/bar`, with the final inventory path being
	// `/dc1/datastore/foo/bar/test`. Conflicts with
	// `datastoreClusterId`.
	Folder pulumi.StringPtrInput
	// The managed object ID of
	// the host to set the datastore up on. Note that this is not necessarily the
	// only host that the datastore will be set up on - see
	// here for more info. Forces a
	// new resource if changed.
	HostSystemId pulumi.StringInput
	// The name of the datastore. Forces a new resource if
	// changed.
	Name pulumi.StringPtrInput
	// The IDs of any tags to attach to this resource.
	//
	// > **NOTE:** Tagging support is unsupported on direct ESXi connections and
	// requires vCenter 6.0 or higher.
	Tags pulumi.StringArrayInput
}

func (VmfsDatastoreArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vmfsDatastoreArgs)(nil)).Elem()
}

type VmfsDatastoreInput interface {
	pulumi.Input

	ToVmfsDatastoreOutput() VmfsDatastoreOutput
	ToVmfsDatastoreOutputWithContext(ctx context.Context) VmfsDatastoreOutput
}

func (*VmfsDatastore) ElementType() reflect.Type {
	return reflect.TypeOf((**VmfsDatastore)(nil)).Elem()
}

func (i *VmfsDatastore) ToVmfsDatastoreOutput() VmfsDatastoreOutput {
	return i.ToVmfsDatastoreOutputWithContext(context.Background())
}

func (i *VmfsDatastore) ToVmfsDatastoreOutputWithContext(ctx context.Context) VmfsDatastoreOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmfsDatastoreOutput)
}

// VmfsDatastoreArrayInput is an input type that accepts VmfsDatastoreArray and VmfsDatastoreArrayOutput values.
// You can construct a concrete instance of `VmfsDatastoreArrayInput` via:
//
//	VmfsDatastoreArray{ VmfsDatastoreArgs{...} }
type VmfsDatastoreArrayInput interface {
	pulumi.Input

	ToVmfsDatastoreArrayOutput() VmfsDatastoreArrayOutput
	ToVmfsDatastoreArrayOutputWithContext(context.Context) VmfsDatastoreArrayOutput
}

type VmfsDatastoreArray []VmfsDatastoreInput

func (VmfsDatastoreArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VmfsDatastore)(nil)).Elem()
}

func (i VmfsDatastoreArray) ToVmfsDatastoreArrayOutput() VmfsDatastoreArrayOutput {
	return i.ToVmfsDatastoreArrayOutputWithContext(context.Background())
}

func (i VmfsDatastoreArray) ToVmfsDatastoreArrayOutputWithContext(ctx context.Context) VmfsDatastoreArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmfsDatastoreArrayOutput)
}

// VmfsDatastoreMapInput is an input type that accepts VmfsDatastoreMap and VmfsDatastoreMapOutput values.
// You can construct a concrete instance of `VmfsDatastoreMapInput` via:
//
//	VmfsDatastoreMap{ "key": VmfsDatastoreArgs{...} }
type VmfsDatastoreMapInput interface {
	pulumi.Input

	ToVmfsDatastoreMapOutput() VmfsDatastoreMapOutput
	ToVmfsDatastoreMapOutputWithContext(context.Context) VmfsDatastoreMapOutput
}

type VmfsDatastoreMap map[string]VmfsDatastoreInput

func (VmfsDatastoreMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VmfsDatastore)(nil)).Elem()
}

func (i VmfsDatastoreMap) ToVmfsDatastoreMapOutput() VmfsDatastoreMapOutput {
	return i.ToVmfsDatastoreMapOutputWithContext(context.Background())
}

func (i VmfsDatastoreMap) ToVmfsDatastoreMapOutputWithContext(ctx context.Context) VmfsDatastoreMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VmfsDatastoreMapOutput)
}

type VmfsDatastoreOutput struct{ *pulumi.OutputState }

func (VmfsDatastoreOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VmfsDatastore)(nil)).Elem()
}

func (o VmfsDatastoreOutput) ToVmfsDatastoreOutput() VmfsDatastoreOutput {
	return o
}

func (o VmfsDatastoreOutput) ToVmfsDatastoreOutputWithContext(ctx context.Context) VmfsDatastoreOutput {
	return o
}

// The connectivity status of the datastore. If this is `false`,
// some other computed attributes may be out of date.
func (o VmfsDatastoreOutput) Accessible() pulumi.BoolOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.BoolOutput { return v.Accessible }).(pulumi.BoolOutput)
}

// Maximum capacity of the datastore, in megabytes.
func (o VmfsDatastoreOutput) Capacity() pulumi.IntOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.IntOutput { return v.Capacity }).(pulumi.IntOutput)
}

// Map of custom attribute ids to attribute
// value string to set on datastore resource.
//
// > **NOTE:** Custom attributes are unsupported on direct ESXi connections
// and require vCenter.
func (o VmfsDatastoreOutput) CustomAttributes() pulumi.StringMapOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.StringMapOutput { return v.CustomAttributes }).(pulumi.StringMapOutput)
}

// The managed object
// ID of a datastore cluster to put this datastore in.
// Conflicts with `folder`.
func (o VmfsDatastoreOutput) DatastoreClusterId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.StringPtrOutput { return v.DatastoreClusterId }).(pulumi.StringPtrOutput)
}

// The disks to use with the datastore.
func (o VmfsDatastoreOutput) Disks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.StringArrayOutput { return v.Disks }).(pulumi.StringArrayOutput)
}

// The relative path to a folder to put this datastore in.
// This is a path relative to the datacenter you are deploying the datastore to.
// Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
// The provider will place a datastore named `test` in a datastore folder
// located at `/dc1/datastore/foo/bar`, with the final inventory path being
// `/dc1/datastore/foo/bar/test`. Conflicts with
// `datastoreClusterId`.
func (o VmfsDatastoreOutput) Folder() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.StringPtrOutput { return v.Folder }).(pulumi.StringPtrOutput)
}

// Available space of this datastore, in megabytes.
func (o VmfsDatastoreOutput) FreeSpace() pulumi.IntOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.IntOutput { return v.FreeSpace }).(pulumi.IntOutput)
}

// The managed object ID of
// the host to set the datastore up on. Note that this is not necessarily the
// only host that the datastore will be set up on - see
// here for more info. Forces a
// new resource if changed.
func (o VmfsDatastoreOutput) HostSystemId() pulumi.StringOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.StringOutput { return v.HostSystemId }).(pulumi.StringOutput)
}

// The current maintenance mode state of the datastore.
func (o VmfsDatastoreOutput) MaintenanceMode() pulumi.StringOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.StringOutput { return v.MaintenanceMode }).(pulumi.StringOutput)
}

// If `true`, more than one host in the datacenter has
// been configured with access to the datastore.
func (o VmfsDatastoreOutput) MultipleHostAccess() pulumi.BoolOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.BoolOutput { return v.MultipleHostAccess }).(pulumi.BoolOutput)
}

// The name of the datastore. Forces a new resource if
// changed.
func (o VmfsDatastoreOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The IDs of any tags to attach to this resource.
//
// > **NOTE:** Tagging support is unsupported on direct ESXi connections and
// requires vCenter 6.0 or higher.
func (o VmfsDatastoreOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// Total additional storage space, in megabytes,
// potentially used by all virtual machines on this datastore.
func (o VmfsDatastoreOutput) UncommittedSpace() pulumi.IntOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.IntOutput { return v.UncommittedSpace }).(pulumi.IntOutput)
}

// The unique locator for the datastore.
func (o VmfsDatastoreOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v *VmfsDatastore) pulumi.StringOutput { return v.Url }).(pulumi.StringOutput)
}

type VmfsDatastoreArrayOutput struct{ *pulumi.OutputState }

func (VmfsDatastoreArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VmfsDatastore)(nil)).Elem()
}

func (o VmfsDatastoreArrayOutput) ToVmfsDatastoreArrayOutput() VmfsDatastoreArrayOutput {
	return o
}

func (o VmfsDatastoreArrayOutput) ToVmfsDatastoreArrayOutputWithContext(ctx context.Context) VmfsDatastoreArrayOutput {
	return o
}

func (o VmfsDatastoreArrayOutput) Index(i pulumi.IntInput) VmfsDatastoreOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VmfsDatastore {
		return vs[0].([]*VmfsDatastore)[vs[1].(int)]
	}).(VmfsDatastoreOutput)
}

type VmfsDatastoreMapOutput struct{ *pulumi.OutputState }

func (VmfsDatastoreMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VmfsDatastore)(nil)).Elem()
}

func (o VmfsDatastoreMapOutput) ToVmfsDatastoreMapOutput() VmfsDatastoreMapOutput {
	return o
}

func (o VmfsDatastoreMapOutput) ToVmfsDatastoreMapOutputWithContext(ctx context.Context) VmfsDatastoreMapOutput {
	return o
}

func (o VmfsDatastoreMapOutput) MapIndex(k pulumi.StringInput) VmfsDatastoreOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VmfsDatastore {
		return vs[0].(map[string]*VmfsDatastore)[vs[1].(string)]
	}).(VmfsDatastoreOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VmfsDatastoreInput)(nil)).Elem(), &VmfsDatastore{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmfsDatastoreArrayInput)(nil)).Elem(), VmfsDatastoreArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VmfsDatastoreMapInput)(nil)).Elem(), VmfsDatastoreMap{})
	pulumi.RegisterOutputType(VmfsDatastoreOutput{})
	pulumi.RegisterOutputType(VmfsDatastoreArrayOutput{})
	pulumi.RegisterOutputType(VmfsDatastoreMapOutput{})
}
