// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package vsphere

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// The `.DistributedPortGroup` resource can be used to manage vSphere
// distributed virtual port groups. These port groups are connected to distributed
// virtual switches, which can be managed by the
// [`.DistributedVirtualSwitch`][distributed-virtual-switch] resource.
//
// Distributed port groups can be used as networks for virtual machines, allowing
// VMs to use the networking supplied by a distributed virtual switch (DVS), with
// a set of policies that apply to that individual newtork, if desired.
//
// For an overview on vSphere networking concepts, see [this
// page][ref-vsphere-net-concepts]. For more information on vSphere DVS
// portgroups, see [this page][ref-vsphere-dvportgroup].
//
// [distributed-virtual-switch]: /docs/providers/vsphere/r/distributed_virtual_switch.html
// [ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html
// [ref-vsphere-dvportgroup]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-69933F6E-2442-46CF-AA17-1196CB9A0A09.html
//
// > **NOTE:** This resource requires vCenter and is not available on direct ESXi
// connections.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-vsphere/blob/master/website/docs/r/distributed_port_group.html.markdown.
type DistributedPortGroup struct {
	s *pulumi.ResourceState
}

// NewDistributedPortGroup registers a new resource with the given unique name, arguments, and options.
func NewDistributedPortGroup(ctx *pulumi.Context,
	name string, args *DistributedPortGroupArgs, opts ...pulumi.ResourceOpt) (*DistributedPortGroup, error) {
	if args == nil || args.DistributedVirtualSwitchUuid == nil {
		return nil, errors.New("missing required argument 'DistributedVirtualSwitchUuid'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["activeUplinks"] = nil
		inputs["allowForgedTransmits"] = nil
		inputs["allowMacChanges"] = nil
		inputs["allowPromiscuous"] = nil
		inputs["autoExpand"] = nil
		inputs["blockAllPorts"] = nil
		inputs["blockOverrideAllowed"] = nil
		inputs["checkBeacon"] = nil
		inputs["customAttributes"] = nil
		inputs["description"] = nil
		inputs["directpathGen2Allowed"] = nil
		inputs["distributedVirtualSwitchUuid"] = nil
		inputs["egressShapingAverageBandwidth"] = nil
		inputs["egressShapingBurstSize"] = nil
		inputs["egressShapingEnabled"] = nil
		inputs["egressShapingPeakBandwidth"] = nil
		inputs["failback"] = nil
		inputs["ingressShapingAverageBandwidth"] = nil
		inputs["ingressShapingBurstSize"] = nil
		inputs["ingressShapingEnabled"] = nil
		inputs["ingressShapingPeakBandwidth"] = nil
		inputs["lacpEnabled"] = nil
		inputs["lacpMode"] = nil
		inputs["livePortMovingAllowed"] = nil
		inputs["name"] = nil
		inputs["netflowEnabled"] = nil
		inputs["netflowOverrideAllowed"] = nil
		inputs["networkResourcePoolKey"] = nil
		inputs["networkResourcePoolOverrideAllowed"] = nil
		inputs["notifySwitches"] = nil
		inputs["numberOfPorts"] = nil
		inputs["portConfigResetAtDisconnect"] = nil
		inputs["portNameFormat"] = nil
		inputs["portPrivateSecondaryVlanId"] = nil
		inputs["securityPolicyOverrideAllowed"] = nil
		inputs["shapingOverrideAllowed"] = nil
		inputs["standbyUplinks"] = nil
		inputs["tags"] = nil
		inputs["teamingPolicy"] = nil
		inputs["trafficFilterOverrideAllowed"] = nil
		inputs["txUplink"] = nil
		inputs["type"] = nil
		inputs["uplinkTeamingOverrideAllowed"] = nil
		inputs["vlanId"] = nil
		inputs["vlanOverrideAllowed"] = nil
		inputs["vlanRanges"] = nil
	} else {
		inputs["activeUplinks"] = args.ActiveUplinks
		inputs["allowForgedTransmits"] = args.AllowForgedTransmits
		inputs["allowMacChanges"] = args.AllowMacChanges
		inputs["allowPromiscuous"] = args.AllowPromiscuous
		inputs["autoExpand"] = args.AutoExpand
		inputs["blockAllPorts"] = args.BlockAllPorts
		inputs["blockOverrideAllowed"] = args.BlockOverrideAllowed
		inputs["checkBeacon"] = args.CheckBeacon
		inputs["customAttributes"] = args.CustomAttributes
		inputs["description"] = args.Description
		inputs["directpathGen2Allowed"] = args.DirectpathGen2Allowed
		inputs["distributedVirtualSwitchUuid"] = args.DistributedVirtualSwitchUuid
		inputs["egressShapingAverageBandwidth"] = args.EgressShapingAverageBandwidth
		inputs["egressShapingBurstSize"] = args.EgressShapingBurstSize
		inputs["egressShapingEnabled"] = args.EgressShapingEnabled
		inputs["egressShapingPeakBandwidth"] = args.EgressShapingPeakBandwidth
		inputs["failback"] = args.Failback
		inputs["ingressShapingAverageBandwidth"] = args.IngressShapingAverageBandwidth
		inputs["ingressShapingBurstSize"] = args.IngressShapingBurstSize
		inputs["ingressShapingEnabled"] = args.IngressShapingEnabled
		inputs["ingressShapingPeakBandwidth"] = args.IngressShapingPeakBandwidth
		inputs["lacpEnabled"] = args.LacpEnabled
		inputs["lacpMode"] = args.LacpMode
		inputs["livePortMovingAllowed"] = args.LivePortMovingAllowed
		inputs["name"] = args.Name
		inputs["netflowEnabled"] = args.NetflowEnabled
		inputs["netflowOverrideAllowed"] = args.NetflowOverrideAllowed
		inputs["networkResourcePoolKey"] = args.NetworkResourcePoolKey
		inputs["networkResourcePoolOverrideAllowed"] = args.NetworkResourcePoolOverrideAllowed
		inputs["notifySwitches"] = args.NotifySwitches
		inputs["numberOfPorts"] = args.NumberOfPorts
		inputs["portConfigResetAtDisconnect"] = args.PortConfigResetAtDisconnect
		inputs["portNameFormat"] = args.PortNameFormat
		inputs["portPrivateSecondaryVlanId"] = args.PortPrivateSecondaryVlanId
		inputs["securityPolicyOverrideAllowed"] = args.SecurityPolicyOverrideAllowed
		inputs["shapingOverrideAllowed"] = args.ShapingOverrideAllowed
		inputs["standbyUplinks"] = args.StandbyUplinks
		inputs["tags"] = args.Tags
		inputs["teamingPolicy"] = args.TeamingPolicy
		inputs["trafficFilterOverrideAllowed"] = args.TrafficFilterOverrideAllowed
		inputs["txUplink"] = args.TxUplink
		inputs["type"] = args.Type
		inputs["uplinkTeamingOverrideAllowed"] = args.UplinkTeamingOverrideAllowed
		inputs["vlanId"] = args.VlanId
		inputs["vlanOverrideAllowed"] = args.VlanOverrideAllowed
		inputs["vlanRanges"] = args.VlanRanges
	}
	inputs["configVersion"] = nil
	inputs["key"] = nil
	s, err := ctx.RegisterResource("vsphere:index/distributedPortGroup:DistributedPortGroup", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &DistributedPortGroup{s: s}, nil
}

// GetDistributedPortGroup gets an existing DistributedPortGroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDistributedPortGroup(ctx *pulumi.Context,
	name string, id pulumi.ID, state *DistributedPortGroupState, opts ...pulumi.ResourceOpt) (*DistributedPortGroup, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["activeUplinks"] = state.ActiveUplinks
		inputs["allowForgedTransmits"] = state.AllowForgedTransmits
		inputs["allowMacChanges"] = state.AllowMacChanges
		inputs["allowPromiscuous"] = state.AllowPromiscuous
		inputs["autoExpand"] = state.AutoExpand
		inputs["blockAllPorts"] = state.BlockAllPorts
		inputs["blockOverrideAllowed"] = state.BlockOverrideAllowed
		inputs["checkBeacon"] = state.CheckBeacon
		inputs["configVersion"] = state.ConfigVersion
		inputs["customAttributes"] = state.CustomAttributes
		inputs["description"] = state.Description
		inputs["directpathGen2Allowed"] = state.DirectpathGen2Allowed
		inputs["distributedVirtualSwitchUuid"] = state.DistributedVirtualSwitchUuid
		inputs["egressShapingAverageBandwidth"] = state.EgressShapingAverageBandwidth
		inputs["egressShapingBurstSize"] = state.EgressShapingBurstSize
		inputs["egressShapingEnabled"] = state.EgressShapingEnabled
		inputs["egressShapingPeakBandwidth"] = state.EgressShapingPeakBandwidth
		inputs["failback"] = state.Failback
		inputs["ingressShapingAverageBandwidth"] = state.IngressShapingAverageBandwidth
		inputs["ingressShapingBurstSize"] = state.IngressShapingBurstSize
		inputs["ingressShapingEnabled"] = state.IngressShapingEnabled
		inputs["ingressShapingPeakBandwidth"] = state.IngressShapingPeakBandwidth
		inputs["key"] = state.Key
		inputs["lacpEnabled"] = state.LacpEnabled
		inputs["lacpMode"] = state.LacpMode
		inputs["livePortMovingAllowed"] = state.LivePortMovingAllowed
		inputs["name"] = state.Name
		inputs["netflowEnabled"] = state.NetflowEnabled
		inputs["netflowOverrideAllowed"] = state.NetflowOverrideAllowed
		inputs["networkResourcePoolKey"] = state.NetworkResourcePoolKey
		inputs["networkResourcePoolOverrideAllowed"] = state.NetworkResourcePoolOverrideAllowed
		inputs["notifySwitches"] = state.NotifySwitches
		inputs["numberOfPorts"] = state.NumberOfPorts
		inputs["portConfigResetAtDisconnect"] = state.PortConfigResetAtDisconnect
		inputs["portNameFormat"] = state.PortNameFormat
		inputs["portPrivateSecondaryVlanId"] = state.PortPrivateSecondaryVlanId
		inputs["securityPolicyOverrideAllowed"] = state.SecurityPolicyOverrideAllowed
		inputs["shapingOverrideAllowed"] = state.ShapingOverrideAllowed
		inputs["standbyUplinks"] = state.StandbyUplinks
		inputs["tags"] = state.Tags
		inputs["teamingPolicy"] = state.TeamingPolicy
		inputs["trafficFilterOverrideAllowed"] = state.TrafficFilterOverrideAllowed
		inputs["txUplink"] = state.TxUplink
		inputs["type"] = state.Type
		inputs["uplinkTeamingOverrideAllowed"] = state.UplinkTeamingOverrideAllowed
		inputs["vlanId"] = state.VlanId
		inputs["vlanOverrideAllowed"] = state.VlanOverrideAllowed
		inputs["vlanRanges"] = state.VlanRanges
	}
	s, err := ctx.ReadResource("vsphere:index/distributedPortGroup:DistributedPortGroup", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &DistributedPortGroup{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *DistributedPortGroup) URN() pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *DistributedPortGroup) ID() pulumi.IDOutput {
	return r.s.ID()
}

// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
func (r *DistributedPortGroup) ActiveUplinks() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["activeUplinks"])
}

// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
// that of its own.
func (r *DistributedPortGroup) AllowForgedTransmits() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowForgedTransmits"])
}

// Controls whether or not the Media Access Control (MAC) address can be changed.
func (r *DistributedPortGroup) AllowMacChanges() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowMacChanges"])
}

// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
func (r *DistributedPortGroup) AllowPromiscuous() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowPromiscuous"])
}

// Allows the port group to create additional ports
// past the limit specified in `numberOfPorts` if necessary. Default: `true`.
func (r *DistributedPortGroup) AutoExpand() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["autoExpand"])
}

// Indicates whether to block all ports by default.
func (r *DistributedPortGroup) BlockAllPorts() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["blockAllPorts"])
}

// Allow the [port shutdown
// policy][port-shutdown-policy] to be overridden on an individual port.
func (r *DistributedPortGroup) BlockOverrideAllowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["blockOverrideAllowed"])
}

// Enable beacon probing on the ports this policy applies to.
func (r *DistributedPortGroup) CheckBeacon() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["checkBeacon"])
}

// Version string of the configuration that this spec is trying to change.
func (r *DistributedPortGroup) ConfigVersion() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["configVersion"])
}

// Map of custom attribute ids to attribute
// value string to set for port group. See [here][docs-setting-custom-attributes]
// for a reference on how to set values for custom attributes.
func (r *DistributedPortGroup) CustomAttributes() pulumi.MapOutput {
	return (pulumi.MapOutput)(r.s.State["customAttributes"])
}

// An optional description for the port group.
func (r *DistributedPortGroup) Description() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["description"])
}

// Allow VMDirectPath Gen2 on the ports this policy applies to.
func (r *DistributedPortGroup) DirectpathGen2Allowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["directpathGen2Allowed"])
}

// The ID of the DVS to add the
// port group to. Forces a new resource if changed.
func (r *DistributedPortGroup) DistributedVirtualSwitchUuid() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["distributedVirtualSwitchUuid"])
}

// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
func (r *DistributedPortGroup) EgressShapingAverageBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["egressShapingAverageBandwidth"])
}

// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
func (r *DistributedPortGroup) EgressShapingBurstSize() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["egressShapingBurstSize"])
}

// True if the traffic shaper is enabled for egress traffic on the port.
func (r *DistributedPortGroup) EgressShapingEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["egressShapingEnabled"])
}

// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
func (r *DistributedPortGroup) EgressShapingPeakBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["egressShapingPeakBandwidth"])
}

// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
func (r *DistributedPortGroup) Failback() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["failback"])
}

// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
func (r *DistributedPortGroup) IngressShapingAverageBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["ingressShapingAverageBandwidth"])
}

// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
func (r *DistributedPortGroup) IngressShapingBurstSize() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["ingressShapingBurstSize"])
}

// True if the traffic shaper is enabled for ingress traffic on the port.
func (r *DistributedPortGroup) IngressShapingEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["ingressShapingEnabled"])
}

// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
func (r *DistributedPortGroup) IngressShapingPeakBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["ingressShapingPeakBandwidth"])
}

// The generated UUID of the portgroup.
func (r *DistributedPortGroup) Key() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["key"])
}

// Whether or not to enable LACP on all uplink ports.
func (r *DistributedPortGroup) LacpEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["lacpEnabled"])
}

// The uplink LACP mode to use. Can be one of active or passive.
func (r *DistributedPortGroup) LacpMode() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["lacpMode"])
}

// Allow a port in this port group to be
// moved to another port group while it is connected.
func (r *DistributedPortGroup) LivePortMovingAllowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["livePortMovingAllowed"])
}

// The name of the port group.
func (r *DistributedPortGroup) Name() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["name"])
}

// Indicates whether to enable netflow on all ports.
func (r *DistributedPortGroup) NetflowEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["netflowEnabled"])
}

// Allow the [Netflow
// policy][netflow-policy] on this port group to be overridden on an individual
// port.
func (r *DistributedPortGroup) NetflowOverrideAllowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["netflowOverrideAllowed"])
}

// The key of a network resource pool
// to associate with this port group. The default is `-1`, which implies no
// association.
func (r *DistributedPortGroup) NetworkResourcePoolKey() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["networkResourcePoolKey"])
}

// Allow the network
// resource pool set on this port group to be overridden on an individual port.
func (r *DistributedPortGroup) NetworkResourcePoolOverrideAllowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["networkResourcePoolOverrideAllowed"])
}

// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
func (r *DistributedPortGroup) NotifySwitches() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["notifySwitches"])
}

// The number of ports available on this port
// group. Cannot be decreased below the amount of used ports on the port group.
func (r *DistributedPortGroup) NumberOfPorts() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["numberOfPorts"])
}

// Reset a port's settings to the
// settings defined on this port group policy when the port disconnects.
func (r *DistributedPortGroup) PortConfigResetAtDisconnect() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["portConfigResetAtDisconnect"])
}

// An optional formatting policy for naming of
// the ports in this port group. See the `portNameFormat` attribute listed
// [here][ext-vsphere-portname-format] for details on the format syntax.
func (r *DistributedPortGroup) PortNameFormat() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["portNameFormat"])
}

// The secondary VLAN ID for this port.
func (r *DistributedPortGroup) PortPrivateSecondaryVlanId() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["portPrivateSecondaryVlanId"])
}

// Allow the [security policy
// settings][sec-policy-settings] defined in this port group policy to be
// overridden on an individual port.
func (r *DistributedPortGroup) SecurityPolicyOverrideAllowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["securityPolicyOverrideAllowed"])
}

// Allow the [traffic shaping
// options][traffic-shaping-settings] on this port group policy to be overridden
// on an individual port.
func (r *DistributedPortGroup) ShapingOverrideAllowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["shapingOverrideAllowed"])
}

// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
func (r *DistributedPortGroup) StandbyUplinks() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["standbyUplinks"])
}

// A list of tag IDs to apply to this object.
func (r *DistributedPortGroup) Tags() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["tags"])
}

// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
// failover_explicit, or loadbalance_loadbased.
func (r *DistributedPortGroup) TeamingPolicy() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["teamingPolicy"])
}

// Allow any traffic filters on
// this port group to be overridden on an individual port.
func (r *DistributedPortGroup) TrafficFilterOverrideAllowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["trafficFilterOverrideAllowed"])
}

// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
// forwarded done by the switch.
func (r *DistributedPortGroup) TxUplink() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["txUplink"])
}

// The port group type. Can be one of `earlyBinding` (static
// binding) or `ephemeral`. Default: `earlyBinding`.
func (r *DistributedPortGroup) Type() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["type"])
}

// Allow the [uplink teaming
// options][uplink-teaming-settings] on this port group to be overridden on an
// individual port.
func (r *DistributedPortGroup) UplinkTeamingOverrideAllowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["uplinkTeamingOverrideAllowed"])
}

// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
func (r *DistributedPortGroup) VlanId() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vlanId"])
}

// Allow the [VLAN settings][vlan-settings]
// on this port group to be overridden on an individual port.
func (r *DistributedPortGroup) VlanOverrideAllowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["vlanOverrideAllowed"])
}

// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
func (r *DistributedPortGroup) VlanRanges() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["vlanRanges"])
}

// Input properties used for looking up and filtering DistributedPortGroup resources.
type DistributedPortGroupState struct {
	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks interface{}
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address
	// than that of its own.
	AllowForgedTransmits interface{}
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges interface{}
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous interface{}
	// Allows the port group to create additional ports
	// past the limit specified in `numberOfPorts` if necessary. Default: `true`.
	AutoExpand interface{}
	// Indicates whether to block all ports by default.
	BlockAllPorts interface{}
	// Allow the [port shutdown
	// policy][port-shutdown-policy] to be overridden on an individual port.
	BlockOverrideAllowed interface{}
	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon interface{}
	// Version string of the configuration that this spec is trying to change.
	ConfigVersion interface{}
	// Map of custom attribute ids to attribute
	// value string to set for port group. See [here][docs-setting-custom-attributes]
	// for a reference on how to set values for custom attributes.
	CustomAttributes interface{}
	// An optional description for the port group.
	Description interface{}
	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed interface{}
	// The ID of the DVS to add the
	// port group to. Forces a new resource if changed.
	DistributedVirtualSwitchUuid interface{}
	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth interface{}
	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize interface{}
	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled interface{}
	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth interface{}
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback interface{}
	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth interface{}
	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize interface{}
	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled interface{}
	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth interface{}
	// The generated UUID of the portgroup.
	Key interface{}
	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled interface{}
	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode interface{}
	// Allow a port in this port group to be
	// moved to another port group while it is connected.
	LivePortMovingAllowed interface{}
	// The name of the port group.
	Name interface{}
	// Indicates whether to enable netflow on all ports.
	NetflowEnabled interface{}
	// Allow the [Netflow
	// policy][netflow-policy] on this port group to be overridden on an individual
	// port.
	NetflowOverrideAllowed interface{}
	// The key of a network resource pool
	// to associate with this port group. The default is `-1`, which implies no
	// association.
	NetworkResourcePoolKey interface{}
	// Allow the network
	// resource pool set on this port group to be overridden on an individual port.
	NetworkResourcePoolOverrideAllowed interface{}
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches interface{}
	// The number of ports available on this port
	// group. Cannot be decreased below the amount of used ports on the port group.
	NumberOfPorts interface{}
	// Reset a port's settings to the
	// settings defined on this port group policy when the port disconnects.
	PortConfigResetAtDisconnect interface{}
	// An optional formatting policy for naming of
	// the ports in this port group. See the `portNameFormat` attribute listed
	// [here][ext-vsphere-portname-format] for details on the format syntax.
	PortNameFormat interface{}
	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanId interface{}
	// Allow the [security policy
	// settings][sec-policy-settings] defined in this port group policy to be
	// overridden on an individual port.
	SecurityPolicyOverrideAllowed interface{}
	// Allow the [traffic shaping
	// options][traffic-shaping-settings] on this port group policy to be overridden
	// on an individual port.
	ShapingOverrideAllowed interface{}
	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks interface{}
	// A list of tag IDs to apply to this object.
	Tags interface{}
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
	// failover_explicit, or loadbalance_loadbased.
	TeamingPolicy interface{}
	// Allow any traffic filters on
	// this port group to be overridden on an individual port.
	TrafficFilterOverrideAllowed interface{}
	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
	// forwarded done by the switch.
	TxUplink interface{}
	// The port group type. Can be one of `earlyBinding` (static
	// binding) or `ephemeral`. Default: `earlyBinding`.
	Type interface{}
	// Allow the [uplink teaming
	// options][uplink-teaming-settings] on this port group to be overridden on an
	// individual port.
	UplinkTeamingOverrideAllowed interface{}
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId interface{}
	// Allow the [VLAN settings][vlan-settings]
	// on this port group to be overridden on an individual port.
	VlanOverrideAllowed interface{}
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRanges interface{}
}

// The set of arguments for constructing a DistributedPortGroup resource.
type DistributedPortGroupArgs struct {
	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks interface{}
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address
	// than that of its own.
	AllowForgedTransmits interface{}
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges interface{}
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous interface{}
	// Allows the port group to create additional ports
	// past the limit specified in `numberOfPorts` if necessary. Default: `true`.
	AutoExpand interface{}
	// Indicates whether to block all ports by default.
	BlockAllPorts interface{}
	// Allow the [port shutdown
	// policy][port-shutdown-policy] to be overridden on an individual port.
	BlockOverrideAllowed interface{}
	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon interface{}
	// Map of custom attribute ids to attribute
	// value string to set for port group. See [here][docs-setting-custom-attributes]
	// for a reference on how to set values for custom attributes.
	CustomAttributes interface{}
	// An optional description for the port group.
	Description interface{}
	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed interface{}
	// The ID of the DVS to add the
	// port group to. Forces a new resource if changed.
	DistributedVirtualSwitchUuid interface{}
	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth interface{}
	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize interface{}
	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled interface{}
	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth interface{}
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback interface{}
	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth interface{}
	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize interface{}
	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled interface{}
	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth interface{}
	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled interface{}
	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode interface{}
	// Allow a port in this port group to be
	// moved to another port group while it is connected.
	LivePortMovingAllowed interface{}
	// The name of the port group.
	Name interface{}
	// Indicates whether to enable netflow on all ports.
	NetflowEnabled interface{}
	// Allow the [Netflow
	// policy][netflow-policy] on this port group to be overridden on an individual
	// port.
	NetflowOverrideAllowed interface{}
	// The key of a network resource pool
	// to associate with this port group. The default is `-1`, which implies no
	// association.
	NetworkResourcePoolKey interface{}
	// Allow the network
	// resource pool set on this port group to be overridden on an individual port.
	NetworkResourcePoolOverrideAllowed interface{}
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches interface{}
	// The number of ports available on this port
	// group. Cannot be decreased below the amount of used ports on the port group.
	NumberOfPorts interface{}
	// Reset a port's settings to the
	// settings defined on this port group policy when the port disconnects.
	PortConfigResetAtDisconnect interface{}
	// An optional formatting policy for naming of
	// the ports in this port group. See the `portNameFormat` attribute listed
	// [here][ext-vsphere-portname-format] for details on the format syntax.
	PortNameFormat interface{}
	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanId interface{}
	// Allow the [security policy
	// settings][sec-policy-settings] defined in this port group policy to be
	// overridden on an individual port.
	SecurityPolicyOverrideAllowed interface{}
	// Allow the [traffic shaping
	// options][traffic-shaping-settings] on this port group policy to be overridden
	// on an individual port.
	ShapingOverrideAllowed interface{}
	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks interface{}
	// A list of tag IDs to apply to this object.
	Tags interface{}
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
	// failover_explicit, or loadbalance_loadbased.
	TeamingPolicy interface{}
	// Allow any traffic filters on
	// this port group to be overridden on an individual port.
	TrafficFilterOverrideAllowed interface{}
	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
	// forwarded done by the switch.
	TxUplink interface{}
	// The port group type. Can be one of `earlyBinding` (static
	// binding) or `ephemeral`. Default: `earlyBinding`.
	Type interface{}
	// Allow the [uplink teaming
	// options][uplink-teaming-settings] on this port group to be overridden on an
	// individual port.
	UplinkTeamingOverrideAllowed interface{}
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId interface{}
	// Allow the [VLAN settings][vlan-settings]
	// on this port group to be overridden on an individual port.
	VlanOverrideAllowed interface{}
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRanges interface{}
}
