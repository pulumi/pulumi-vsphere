// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package vsphere

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// The `.HostVirtualSwitch` resource can be used to manage vSphere
// standard switches on an ESXi host. These switches can be used as a backing for
// standard port groups, which can be managed by the
// [`.HostPortGroup`][host-port-group] resource.
// 
// For an overview on vSphere networking concepts, see [this
// page][ref-vsphere-net-concepts].
// 
// [host-port-group]: /docs/providers/vsphere/r/host_port_group.html
// [ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-vsphere/blob/master/website/docs/r/host_virtual_switch.html.markdown.
type HostVirtualSwitch struct {
	s *pulumi.ResourceState
}

// NewHostVirtualSwitch registers a new resource with the given unique name, arguments, and options.
func NewHostVirtualSwitch(ctx *pulumi.Context,
	name string, args *HostVirtualSwitchArgs, opts ...pulumi.ResourceOpt) (*HostVirtualSwitch, error) {
	if args == nil || args.ActiveNics == nil {
		return nil, errors.New("missing required argument 'ActiveNics'")
	}
	if args == nil || args.HostSystemId == nil {
		return nil, errors.New("missing required argument 'HostSystemId'")
	}
	if args == nil || args.NetworkAdapters == nil {
		return nil, errors.New("missing required argument 'NetworkAdapters'")
	}
	if args == nil || args.StandbyNics == nil {
		return nil, errors.New("missing required argument 'StandbyNics'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["activeNics"] = nil
		inputs["allowForgedTransmits"] = nil
		inputs["allowMacChanges"] = nil
		inputs["allowPromiscuous"] = nil
		inputs["beaconInterval"] = nil
		inputs["checkBeacon"] = nil
		inputs["failback"] = nil
		inputs["hostSystemId"] = nil
		inputs["linkDiscoveryOperation"] = nil
		inputs["linkDiscoveryProtocol"] = nil
		inputs["mtu"] = nil
		inputs["name"] = nil
		inputs["networkAdapters"] = nil
		inputs["notifySwitches"] = nil
		inputs["numberOfPorts"] = nil
		inputs["shapingAverageBandwidth"] = nil
		inputs["shapingBurstSize"] = nil
		inputs["shapingEnabled"] = nil
		inputs["shapingPeakBandwidth"] = nil
		inputs["standbyNics"] = nil
		inputs["teamingPolicy"] = nil
	} else {
		inputs["activeNics"] = args.ActiveNics
		inputs["allowForgedTransmits"] = args.AllowForgedTransmits
		inputs["allowMacChanges"] = args.AllowMacChanges
		inputs["allowPromiscuous"] = args.AllowPromiscuous
		inputs["beaconInterval"] = args.BeaconInterval
		inputs["checkBeacon"] = args.CheckBeacon
		inputs["failback"] = args.Failback
		inputs["hostSystemId"] = args.HostSystemId
		inputs["linkDiscoveryOperation"] = args.LinkDiscoveryOperation
		inputs["linkDiscoveryProtocol"] = args.LinkDiscoveryProtocol
		inputs["mtu"] = args.Mtu
		inputs["name"] = args.Name
		inputs["networkAdapters"] = args.NetworkAdapters
		inputs["notifySwitches"] = args.NotifySwitches
		inputs["numberOfPorts"] = args.NumberOfPorts
		inputs["shapingAverageBandwidth"] = args.ShapingAverageBandwidth
		inputs["shapingBurstSize"] = args.ShapingBurstSize
		inputs["shapingEnabled"] = args.ShapingEnabled
		inputs["shapingPeakBandwidth"] = args.ShapingPeakBandwidth
		inputs["standbyNics"] = args.StandbyNics
		inputs["teamingPolicy"] = args.TeamingPolicy
	}
	s, err := ctx.RegisterResource("vsphere:index/hostVirtualSwitch:HostVirtualSwitch", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &HostVirtualSwitch{s: s}, nil
}

// GetHostVirtualSwitch gets an existing HostVirtualSwitch resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetHostVirtualSwitch(ctx *pulumi.Context,
	name string, id pulumi.ID, state *HostVirtualSwitchState, opts ...pulumi.ResourceOpt) (*HostVirtualSwitch, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["activeNics"] = state.ActiveNics
		inputs["allowForgedTransmits"] = state.AllowForgedTransmits
		inputs["allowMacChanges"] = state.AllowMacChanges
		inputs["allowPromiscuous"] = state.AllowPromiscuous
		inputs["beaconInterval"] = state.BeaconInterval
		inputs["checkBeacon"] = state.CheckBeacon
		inputs["failback"] = state.Failback
		inputs["hostSystemId"] = state.HostSystemId
		inputs["linkDiscoveryOperation"] = state.LinkDiscoveryOperation
		inputs["linkDiscoveryProtocol"] = state.LinkDiscoveryProtocol
		inputs["mtu"] = state.Mtu
		inputs["name"] = state.Name
		inputs["networkAdapters"] = state.NetworkAdapters
		inputs["notifySwitches"] = state.NotifySwitches
		inputs["numberOfPorts"] = state.NumberOfPorts
		inputs["shapingAverageBandwidth"] = state.ShapingAverageBandwidth
		inputs["shapingBurstSize"] = state.ShapingBurstSize
		inputs["shapingEnabled"] = state.ShapingEnabled
		inputs["shapingPeakBandwidth"] = state.ShapingPeakBandwidth
		inputs["standbyNics"] = state.StandbyNics
		inputs["teamingPolicy"] = state.TeamingPolicy
	}
	s, err := ctx.ReadResource("vsphere:index/hostVirtualSwitch:HostVirtualSwitch", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &HostVirtualSwitch{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *HostVirtualSwitch) URN() *pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *HostVirtualSwitch) ID() *pulumi.IDOutput {
	return r.s.ID()
}

// The list of active network adapters used for load
// balancing.
func (r *HostVirtualSwitch) ActiveNics() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["activeNics"])
}

// Controls whether or not the virtual
// network adapter is allowed to send network traffic with a different MAC
// address than that of its own. Default: `true`.
func (r *HostVirtualSwitch) AllowForgedTransmits() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["allowForgedTransmits"])
}

// Controls whether or not the Media Access
// Control (MAC) address can be changed. Default: `true`.
func (r *HostVirtualSwitch) AllowMacChanges() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["allowMacChanges"])
}

// Enable promiscuous mode on the network. This
// flag indicates whether or not all traffic is seen on a given port. Default:
// `false`.
func (r *HostVirtualSwitch) AllowPromiscuous() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["allowPromiscuous"])
}

// The interval, in seconds, that a NIC beacon
// packet is sent out. This can be used with `checkBeacon` to
// offer link failure capability beyond link status only. Default: `1`.
func (r *HostVirtualSwitch) BeaconInterval() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["beaconInterval"])
}

// Enable beacon probing - this requires that the
// `beaconInterval` option has been set in the bridge
// options. If this is set to `false`, only link status is used to check for
// failed NICs.  Default: `false`.
func (r *HostVirtualSwitch) CheckBeacon() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["checkBeacon"])
}

// If set to `true`, the teaming policy will re-activate
// failed interfaces higher in precedence when they come back up.  Default:
// `true`.
func (r *HostVirtualSwitch) Failback() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["failback"])
}

// The [managed object ID][docs-about-morefs] of
// the host to set the virtual switch up on. Forces a new resource if changed.
func (r *HostVirtualSwitch) HostSystemId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["hostSystemId"])
}

// Whether to `advertise` or `listen`
// for link discovery traffic. Default: `listen`.
func (r *HostVirtualSwitch) LinkDiscoveryOperation() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["linkDiscoveryOperation"])
}

// The discovery protocol type.  Valid
// types are `cpd` and `lldp`. Default: `cdp`.
func (r *HostVirtualSwitch) LinkDiscoveryProtocol() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["linkDiscoveryProtocol"])
}

// The maximum transmission unit (MTU) for the virtual
// switch. Default: `1500`.
func (r *HostVirtualSwitch) Mtu() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["mtu"])
}

// The name of the virtual switch. Forces a new resource if
// changed.
func (r *HostVirtualSwitch) Name() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["name"])
}

// The network interfaces to bind to the bridge.
func (r *HostVirtualSwitch) NetworkAdapters() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["networkAdapters"])
}

// If set to `true`, the teaming policy will
// notify the broadcast network of a NIC failover, triggering cache updates.
// Default: `true`.
func (r *HostVirtualSwitch) NotifySwitches() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["notifySwitches"])
}

// The number of ports to create with this
// virtual switch. Default: `128`.
func (r *HostVirtualSwitch) NumberOfPorts() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["numberOfPorts"])
}

// The average bandwidth in bits per
// second if traffic shaping is enabled. Default: `0`
func (r *HostVirtualSwitch) ShapingAverageBandwidth() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["shapingAverageBandwidth"])
}

// The maximum burst size allowed in bytes if
// shaping is enabled. Default: `0`
func (r *HostVirtualSwitch) ShapingBurstSize() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["shapingBurstSize"])
}

// Set to `true` to enable the traffic shaper for
// ports managed by this virtual switch. Default: `false`.
func (r *HostVirtualSwitch) ShapingEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["shapingEnabled"])
}

// The peak bandwidth during bursts in
// bits per second if traffic shaping is enabled. Default: `0`
func (r *HostVirtualSwitch) ShapingPeakBandwidth() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["shapingPeakBandwidth"])
}

// The list of standby network adapters used for
// failover.
func (r *HostVirtualSwitch) StandbyNics() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["standbyNics"])
}

// The network adapter teaming policy. Can be one
// of `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
// `failoverExplicit`. Default: `loadbalanceSrcid`.
func (r *HostVirtualSwitch) TeamingPolicy() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["teamingPolicy"])
}

// Input properties used for looking up and filtering HostVirtualSwitch resources.
type HostVirtualSwitchState struct {
	// The list of active network adapters used for load
	// balancing.
	ActiveNics interface{}
	// Controls whether or not the virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own. Default: `true`.
	AllowForgedTransmits interface{}
	// Controls whether or not the Media Access
	// Control (MAC) address can be changed. Default: `true`.
	AllowMacChanges interface{}
	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port. Default:
	// `false`.
	AllowPromiscuous interface{}
	// The interval, in seconds, that a NIC beacon
	// packet is sent out. This can be used with `checkBeacon` to
	// offer link failure capability beyond link status only. Default: `1`.
	BeaconInterval interface{}
	// Enable beacon probing - this requires that the
	// `beaconInterval` option has been set in the bridge
	// options. If this is set to `false`, only link status is used to check for
	// failed NICs.  Default: `false`.
	CheckBeacon interface{}
	// If set to `true`, the teaming policy will re-activate
	// failed interfaces higher in precedence when they come back up.  Default:
	// `true`.
	Failback interface{}
	// The [managed object ID][docs-about-morefs] of
	// the host to set the virtual switch up on. Forces a new resource if changed.
	HostSystemId interface{}
	// Whether to `advertise` or `listen`
	// for link discovery traffic. Default: `listen`.
	LinkDiscoveryOperation interface{}
	// The discovery protocol type.  Valid
	// types are `cpd` and `lldp`. Default: `cdp`.
	LinkDiscoveryProtocol interface{}
	// The maximum transmission unit (MTU) for the virtual
	// switch. Default: `1500`.
	Mtu interface{}
	// The name of the virtual switch. Forces a new resource if
	// changed.
	Name interface{}
	// The network interfaces to bind to the bridge.
	NetworkAdapters interface{}
	// If set to `true`, the teaming policy will
	// notify the broadcast network of a NIC failover, triggering cache updates.
	// Default: `true`.
	NotifySwitches interface{}
	// The number of ports to create with this
	// virtual switch. Default: `128`.
	NumberOfPorts interface{}
	// The average bandwidth in bits per
	// second if traffic shaping is enabled. Default: `0`
	ShapingAverageBandwidth interface{}
	// The maximum burst size allowed in bytes if
	// shaping is enabled. Default: `0`
	ShapingBurstSize interface{}
	// Set to `true` to enable the traffic shaper for
	// ports managed by this virtual switch. Default: `false`.
	ShapingEnabled interface{}
	// The peak bandwidth during bursts in
	// bits per second if traffic shaping is enabled. Default: `0`
	ShapingPeakBandwidth interface{}
	// The list of standby network adapters used for
	// failover.
	StandbyNics interface{}
	// The network adapter teaming policy. Can be one
	// of `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
	// `failoverExplicit`. Default: `loadbalanceSrcid`.
	TeamingPolicy interface{}
}

// The set of arguments for constructing a HostVirtualSwitch resource.
type HostVirtualSwitchArgs struct {
	// The list of active network adapters used for load
	// balancing.
	ActiveNics interface{}
	// Controls whether or not the virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own. Default: `true`.
	AllowForgedTransmits interface{}
	// Controls whether or not the Media Access
	// Control (MAC) address can be changed. Default: `true`.
	AllowMacChanges interface{}
	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port. Default:
	// `false`.
	AllowPromiscuous interface{}
	// The interval, in seconds, that a NIC beacon
	// packet is sent out. This can be used with `checkBeacon` to
	// offer link failure capability beyond link status only. Default: `1`.
	BeaconInterval interface{}
	// Enable beacon probing - this requires that the
	// `beaconInterval` option has been set in the bridge
	// options. If this is set to `false`, only link status is used to check for
	// failed NICs.  Default: `false`.
	CheckBeacon interface{}
	// If set to `true`, the teaming policy will re-activate
	// failed interfaces higher in precedence when they come back up.  Default:
	// `true`.
	Failback interface{}
	// The [managed object ID][docs-about-morefs] of
	// the host to set the virtual switch up on. Forces a new resource if changed.
	HostSystemId interface{}
	// Whether to `advertise` or `listen`
	// for link discovery traffic. Default: `listen`.
	LinkDiscoveryOperation interface{}
	// The discovery protocol type.  Valid
	// types are `cpd` and `lldp`. Default: `cdp`.
	LinkDiscoveryProtocol interface{}
	// The maximum transmission unit (MTU) for the virtual
	// switch. Default: `1500`.
	Mtu interface{}
	// The name of the virtual switch. Forces a new resource if
	// changed.
	Name interface{}
	// The network interfaces to bind to the bridge.
	NetworkAdapters interface{}
	// If set to `true`, the teaming policy will
	// notify the broadcast network of a NIC failover, triggering cache updates.
	// Default: `true`.
	NotifySwitches interface{}
	// The number of ports to create with this
	// virtual switch. Default: `128`.
	NumberOfPorts interface{}
	// The average bandwidth in bits per
	// second if traffic shaping is enabled. Default: `0`
	ShapingAverageBandwidth interface{}
	// The maximum burst size allowed in bytes if
	// shaping is enabled. Default: `0`
	ShapingBurstSize interface{}
	// Set to `true` to enable the traffic shaper for
	// ports managed by this virtual switch. Default: `false`.
	ShapingEnabled interface{}
	// The peak bandwidth during bursts in
	// bits per second if traffic shaping is enabled. Default: `0`
	ShapingPeakBandwidth interface{}
	// The list of standby network adapters used for
	// failover.
	StandbyNics interface{}
	// The network adapter teaming policy. Can be one
	// of `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
	// `failoverExplicit`. Default: `loadbalanceSrcid`.
	TeamingPolicy interface{}
}
