// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vsphere

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type DistributedVirtualSwitch struct {
	pulumi.CustomResourceState

	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks pulumi.StringArrayOutput `pulumi:"activeUplinks"`
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
	// that of its own.
	AllowForgedTransmits pulumi.BoolOutput `pulumi:"allowForgedTransmits"`
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges pulumi.BoolOutput `pulumi:"allowMacChanges"`
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous pulumi.BoolOutput `pulumi:"allowPromiscuous"`
	// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
	BackupnfcMaximumMbit pulumi.IntOutput `pulumi:"backupnfcMaximumMbit"`
	// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
	BackupnfcReservationMbit pulumi.IntOutput `pulumi:"backupnfcReservationMbit"`
	// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
	BackupnfcShareCount pulumi.IntOutput `pulumi:"backupnfcShareCount"`
	// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
	BackupnfcShareLevel pulumi.StringOutput `pulumi:"backupnfcShareLevel"`
	// Indicates whether to block all ports by default.
	BlockAllPorts pulumi.BoolOutput `pulumi:"blockAllPorts"`
	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon pulumi.BoolOutput `pulumi:"checkBeacon"`
	// The current version of the VDS configuration, incremented
	// by subsequent updates to the VDS.
	ConfigVersion pulumi.StringOutput `pulumi:"configVersion"`
	// The detailed contact information for the person
	// who is responsible for the VDS.
	ContactDetail pulumi.StringPtrOutput `pulumi:"contactDetail"`
	// The name of the person who is responsible for the
	// VDS.
	ContactName pulumi.StringPtrOutput `pulumi:"contactName"`
	// Map of custom attribute ids to attribute
	// value strings to set for VDS.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi host connections
	// and requires vCenter Server.
	CustomAttributes pulumi.StringMapOutput `pulumi:"customAttributes"`
	// The ID of the datacenter where the VDS will be
	// created. Forces a new resource if changed.
	DatacenterId pulumi.StringOutput `pulumi:"datacenterId"`
	// A detailed description for the VDS.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed pulumi.BoolOutput `pulumi:"directpathGen2Allowed"`
	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth pulumi.IntOutput `pulumi:"egressShapingAverageBandwidth"`
	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize pulumi.IntOutput `pulumi:"egressShapingBurstSize"`
	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled pulumi.BoolOutput `pulumi:"egressShapingEnabled"`
	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth pulumi.IntOutput `pulumi:"egressShapingPeakBandwidth"`
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback pulumi.BoolOutput `pulumi:"failback"`
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit pulumi.IntOutput `pulumi:"faulttoleranceMaximumMbit"`
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit pulumi.IntOutput `pulumi:"faulttoleranceReservationMbit"`
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount pulumi.IntOutput `pulumi:"faulttoleranceShareCount"`
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel pulumi.StringOutput `pulumi:"faulttoleranceShareLevel"`
	// The folder in which to create the VDS.
	// Forces a new resource if changed.
	Folder pulumi.StringPtrOutput `pulumi:"folder"`
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit pulumi.IntOutput `pulumi:"hbrMaximumMbit"`
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit pulumi.IntOutput `pulumi:"hbrReservationMbit"`
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount pulumi.IntOutput `pulumi:"hbrShareCount"`
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel pulumi.StringOutput `pulumi:"hbrShareLevel"`
	// A host member specification.
	Hosts DistributedVirtualSwitchHostArrayOutput `pulumi:"hosts"`
	// Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings pulumi.BoolPtrOutput `pulumi:"ignoreOtherPvlanMappings"`
	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth pulumi.IntOutput `pulumi:"ingressShapingAverageBandwidth"`
	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize pulumi.IntOutput `pulumi:"ingressShapingBurstSize"`
	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled pulumi.BoolOutput `pulumi:"ingressShapingEnabled"`
	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth pulumi.IntOutput `pulumi:"ingressShapingPeakBandwidth"`
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments.
	Ipv4Address pulumi.StringPtrOutput `pulumi:"ipv4Address"`
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit pulumi.IntOutput `pulumi:"iscsiMaximumMbit"`
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit pulumi.IntOutput `pulumi:"iscsiReservationMbit"`
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount pulumi.IntOutput `pulumi:"iscsiShareCount"`
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel pulumi.StringOutput `pulumi:"iscsiShareLevel"`
	// The Link Aggregation Control Protocol group
	// version to use with the VDS. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion pulumi.StringOutput `pulumi:"lacpApiVersion"`
	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled pulumi.BoolOutput `pulumi:"lacpEnabled"`
	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode pulumi.StringOutput `pulumi:"lacpMode"`
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation pulumi.StringPtrOutput `pulumi:"linkDiscoveryOperation"`
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol pulumi.StringPtrOutput `pulumi:"linkDiscoveryProtocol"`
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit pulumi.IntOutput `pulumi:"managementMaximumMbit"`
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit pulumi.IntOutput `pulumi:"managementReservationMbit"`
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount pulumi.IntOutput `pulumi:"managementShareCount"`
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel pulumi.StringOutput `pulumi:"managementShareLevel"`
	// The maximum transmission unit (MTU) for the VDS.
	MaxMtu pulumi.IntOutput `pulumi:"maxMtu"`
	// The multicast filtering mode to use
	// with the VDS. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode pulumi.StringOutput `pulumi:"multicastFilteringMode"`
	// The name of the VDS.
	Name pulumi.StringOutput `pulumi:"name"`
	// The number of seconds after which active flows are forced to be exported to the collector.
	NetflowActiveFlowTimeout pulumi.IntPtrOutput `pulumi:"netflowActiveFlowTimeout"`
	// IP address for the netflow collector, using IPv4 or IPv6.
	NetflowCollectorIpAddress pulumi.StringPtrOutput `pulumi:"netflowCollectorIpAddress"`
	// The port for the netflow collector.
	NetflowCollectorPort pulumi.IntPtrOutput `pulumi:"netflowCollectorPort"`
	// Indicates whether to enable netflow on all ports.
	NetflowEnabled pulumi.BoolOutput `pulumi:"netflowEnabled"`
	// The number of seconds after which idle flows are forced to be exported to the collector.
	NetflowIdleFlowTimeout pulumi.IntPtrOutput `pulumi:"netflowIdleFlowTimeout"`
	// Whether to limit analysis to traffic that has both source and destination served by the same host.
	NetflowInternalFlowsOnly pulumi.BoolPtrOutput `pulumi:"netflowInternalFlowsOnly"`
	// The observation Domain ID for the netflow collector.
	NetflowObservationDomainId pulumi.IntPtrOutput `pulumi:"netflowObservationDomainId"`
	// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all
	// packets are analyzed.
	NetflowSamplingRate pulumi.IntPtrOutput `pulumi:"netflowSamplingRate"`
	// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
	NetworkResourceControlEnabled pulumi.BoolPtrOutput `pulumi:"networkResourceControlEnabled"`
	// The network I/O control version to use. Can be one of version2 or version3.
	NetworkResourceControlVersion pulumi.StringOutput `pulumi:"networkResourceControlVersion"`
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit pulumi.IntOutput `pulumi:"nfsMaximumMbit"`
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit pulumi.IntOutput `pulumi:"nfsReservationMbit"`
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount pulumi.IntOutput `pulumi:"nfsShareCount"`
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel pulumi.StringOutput `pulumi:"nfsShareLevel"`
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches pulumi.BoolOutput `pulumi:"notifySwitches"`
	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanId pulumi.IntOutput `pulumi:"portPrivateSecondaryVlanId"`
	// A private VLAN (PVLAN) mapping.
	PvlanMappings DistributedVirtualSwitchPvlanMappingArrayOutput `pulumi:"pvlanMappings"`
	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks pulumi.StringArrayOutput `pulumi:"standbyUplinks"`
	// The IDs of any tags to attach to this resource.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
	// failover_explicit, or loadbalance_loadbased.
	TeamingPolicy pulumi.StringOutput `pulumi:"teamingPolicy"`
	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
	// forwarded done by the switch.
	TxUplink pulumi.BoolOutput `pulumi:"txUplink"`
	// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS
	// across hosts.
	Uplinks pulumi.StringArrayOutput `pulumi:"uplinks"`
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit pulumi.IntOutput `pulumi:"vdpMaximumMbit"`
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit pulumi.IntOutput `pulumi:"vdpReservationMbit"`
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount pulumi.IntOutput `pulumi:"vdpShareCount"`
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel pulumi.StringOutput `pulumi:"vdpShareLevel"`
	// The version of the VDS. BY default, a VDS is created
	// at the latest version supported by the vSphere version if not specified.
	// A VDS can be upgraded to a newer version, but can not be downgraded.
	Version pulumi.StringOutput `pulumi:"version"`
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit pulumi.IntOutput `pulumi:"virtualmachineMaximumMbit"`
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit pulumi.IntOutput `pulumi:"virtualmachineReservationMbit"`
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount pulumi.IntOutput `pulumi:"virtualmachineShareCount"`
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel pulumi.StringOutput `pulumi:"virtualmachineShareLevel"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId pulumi.IntOutput `pulumi:"vlanId"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRanges DistributedVirtualSwitchVlanRangeArrayOutput `pulumi:"vlanRanges"`
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit pulumi.IntOutput `pulumi:"vmotionMaximumMbit"`
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit pulumi.IntOutput `pulumi:"vmotionReservationMbit"`
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount pulumi.IntOutput `pulumi:"vmotionShareCount"`
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel pulumi.StringOutput `pulumi:"vmotionShareLevel"`
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit pulumi.IntOutput `pulumi:"vsanMaximumMbit"`
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit pulumi.IntOutput `pulumi:"vsanReservationMbit"`
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount pulumi.IntOutput `pulumi:"vsanShareCount"`
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel pulumi.StringOutput `pulumi:"vsanShareLevel"`
}

// NewDistributedVirtualSwitch registers a new resource with the given unique name, arguments, and options.
func NewDistributedVirtualSwitch(ctx *pulumi.Context,
	name string, args *DistributedVirtualSwitchArgs, opts ...pulumi.ResourceOption) (*DistributedVirtualSwitch, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatacenterId == nil {
		return nil, errors.New("invalid value for required argument 'DatacenterId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DistributedVirtualSwitch
	err := ctx.RegisterResource("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDistributedVirtualSwitch gets an existing DistributedVirtualSwitch resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDistributedVirtualSwitch(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DistributedVirtualSwitchState, opts ...pulumi.ResourceOption) (*DistributedVirtualSwitch, error) {
	var resource DistributedVirtualSwitch
	err := ctx.ReadResource("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DistributedVirtualSwitch resources.
type distributedVirtualSwitchState struct {
	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks []string `pulumi:"activeUplinks"`
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
	// that of its own.
	AllowForgedTransmits *bool `pulumi:"allowForgedTransmits"`
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges *bool `pulumi:"allowMacChanges"`
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous *bool `pulumi:"allowPromiscuous"`
	// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
	BackupnfcMaximumMbit *int `pulumi:"backupnfcMaximumMbit"`
	// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
	BackupnfcReservationMbit *int `pulumi:"backupnfcReservationMbit"`
	// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
	BackupnfcShareCount *int `pulumi:"backupnfcShareCount"`
	// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
	BackupnfcShareLevel *string `pulumi:"backupnfcShareLevel"`
	// Indicates whether to block all ports by default.
	BlockAllPorts *bool `pulumi:"blockAllPorts"`
	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon *bool `pulumi:"checkBeacon"`
	// The current version of the VDS configuration, incremented
	// by subsequent updates to the VDS.
	ConfigVersion *string `pulumi:"configVersion"`
	// The detailed contact information for the person
	// who is responsible for the VDS.
	ContactDetail *string `pulumi:"contactDetail"`
	// The name of the person who is responsible for the
	// VDS.
	ContactName *string `pulumi:"contactName"`
	// Map of custom attribute ids to attribute
	// value strings to set for VDS.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi host connections
	// and requires vCenter Server.
	CustomAttributes map[string]string `pulumi:"customAttributes"`
	// The ID of the datacenter where the VDS will be
	// created. Forces a new resource if changed.
	DatacenterId *string `pulumi:"datacenterId"`
	// A detailed description for the VDS.
	Description *string `pulumi:"description"`
	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed *bool `pulumi:"directpathGen2Allowed"`
	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth *int `pulumi:"egressShapingAverageBandwidth"`
	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize *int `pulumi:"egressShapingBurstSize"`
	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled *bool `pulumi:"egressShapingEnabled"`
	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth *int `pulumi:"egressShapingPeakBandwidth"`
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback *bool `pulumi:"failback"`
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit *int `pulumi:"faulttoleranceMaximumMbit"`
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit *int `pulumi:"faulttoleranceReservationMbit"`
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount *int `pulumi:"faulttoleranceShareCount"`
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel *string `pulumi:"faulttoleranceShareLevel"`
	// The folder in which to create the VDS.
	// Forces a new resource if changed.
	Folder *string `pulumi:"folder"`
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit *int `pulumi:"hbrMaximumMbit"`
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit *int `pulumi:"hbrReservationMbit"`
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount *int `pulumi:"hbrShareCount"`
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel *string `pulumi:"hbrShareLevel"`
	// A host member specification.
	Hosts []DistributedVirtualSwitchHost `pulumi:"hosts"`
	// Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings *bool `pulumi:"ignoreOtherPvlanMappings"`
	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth *int `pulumi:"ingressShapingAverageBandwidth"`
	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize *int `pulumi:"ingressShapingBurstSize"`
	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled *bool `pulumi:"ingressShapingEnabled"`
	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth *int `pulumi:"ingressShapingPeakBandwidth"`
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments.
	Ipv4Address *string `pulumi:"ipv4Address"`
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit *int `pulumi:"iscsiMaximumMbit"`
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit *int `pulumi:"iscsiReservationMbit"`
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount *int `pulumi:"iscsiShareCount"`
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel *string `pulumi:"iscsiShareLevel"`
	// The Link Aggregation Control Protocol group
	// version to use with the VDS. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion *string `pulumi:"lacpApiVersion"`
	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled *bool `pulumi:"lacpEnabled"`
	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode *string `pulumi:"lacpMode"`
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation *string `pulumi:"linkDiscoveryOperation"`
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol *string `pulumi:"linkDiscoveryProtocol"`
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit *int `pulumi:"managementMaximumMbit"`
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit *int `pulumi:"managementReservationMbit"`
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount *int `pulumi:"managementShareCount"`
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel *string `pulumi:"managementShareLevel"`
	// The maximum transmission unit (MTU) for the VDS.
	MaxMtu *int `pulumi:"maxMtu"`
	// The multicast filtering mode to use
	// with the VDS. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode *string `pulumi:"multicastFilteringMode"`
	// The name of the VDS.
	Name *string `pulumi:"name"`
	// The number of seconds after which active flows are forced to be exported to the collector.
	NetflowActiveFlowTimeout *int `pulumi:"netflowActiveFlowTimeout"`
	// IP address for the netflow collector, using IPv4 or IPv6.
	NetflowCollectorIpAddress *string `pulumi:"netflowCollectorIpAddress"`
	// The port for the netflow collector.
	NetflowCollectorPort *int `pulumi:"netflowCollectorPort"`
	// Indicates whether to enable netflow on all ports.
	NetflowEnabled *bool `pulumi:"netflowEnabled"`
	// The number of seconds after which idle flows are forced to be exported to the collector.
	NetflowIdleFlowTimeout *int `pulumi:"netflowIdleFlowTimeout"`
	// Whether to limit analysis to traffic that has both source and destination served by the same host.
	NetflowInternalFlowsOnly *bool `pulumi:"netflowInternalFlowsOnly"`
	// The observation Domain ID for the netflow collector.
	NetflowObservationDomainId *int `pulumi:"netflowObservationDomainId"`
	// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all
	// packets are analyzed.
	NetflowSamplingRate *int `pulumi:"netflowSamplingRate"`
	// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
	NetworkResourceControlEnabled *bool `pulumi:"networkResourceControlEnabled"`
	// The network I/O control version to use. Can be one of version2 or version3.
	NetworkResourceControlVersion *string `pulumi:"networkResourceControlVersion"`
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit *int `pulumi:"nfsMaximumMbit"`
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit *int `pulumi:"nfsReservationMbit"`
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount *int `pulumi:"nfsShareCount"`
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel *string `pulumi:"nfsShareLevel"`
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches *bool `pulumi:"notifySwitches"`
	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanId *int `pulumi:"portPrivateSecondaryVlanId"`
	// A private VLAN (PVLAN) mapping.
	PvlanMappings []DistributedVirtualSwitchPvlanMapping `pulumi:"pvlanMappings"`
	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks []string `pulumi:"standbyUplinks"`
	// The IDs of any tags to attach to this resource.
	Tags []string `pulumi:"tags"`
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
	// failover_explicit, or loadbalance_loadbased.
	TeamingPolicy *string `pulumi:"teamingPolicy"`
	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
	// forwarded done by the switch.
	TxUplink *bool `pulumi:"txUplink"`
	// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS
	// across hosts.
	Uplinks []string `pulumi:"uplinks"`
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit *int `pulumi:"vdpMaximumMbit"`
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit *int `pulumi:"vdpReservationMbit"`
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount *int `pulumi:"vdpShareCount"`
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel *string `pulumi:"vdpShareLevel"`
	// The version of the VDS. BY default, a VDS is created
	// at the latest version supported by the vSphere version if not specified.
	// A VDS can be upgraded to a newer version, but can not be downgraded.
	Version *string `pulumi:"version"`
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit *int `pulumi:"virtualmachineMaximumMbit"`
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit *int `pulumi:"virtualmachineReservationMbit"`
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount *int `pulumi:"virtualmachineShareCount"`
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel *string `pulumi:"virtualmachineShareLevel"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId *int `pulumi:"vlanId"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRanges []DistributedVirtualSwitchVlanRange `pulumi:"vlanRanges"`
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit *int `pulumi:"vmotionMaximumMbit"`
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit *int `pulumi:"vmotionReservationMbit"`
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount *int `pulumi:"vmotionShareCount"`
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel *string `pulumi:"vmotionShareLevel"`
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit *int `pulumi:"vsanMaximumMbit"`
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit *int `pulumi:"vsanReservationMbit"`
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount *int `pulumi:"vsanShareCount"`
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel *string `pulumi:"vsanShareLevel"`
}

type DistributedVirtualSwitchState struct {
	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks pulumi.StringArrayInput
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
	// that of its own.
	AllowForgedTransmits pulumi.BoolPtrInput
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges pulumi.BoolPtrInput
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous pulumi.BoolPtrInput
	// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
	BackupnfcMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
	BackupnfcReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
	BackupnfcShareCount pulumi.IntPtrInput
	// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
	BackupnfcShareLevel pulumi.StringPtrInput
	// Indicates whether to block all ports by default.
	BlockAllPorts pulumi.BoolPtrInput
	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon pulumi.BoolPtrInput
	// The current version of the VDS configuration, incremented
	// by subsequent updates to the VDS.
	ConfigVersion pulumi.StringPtrInput
	// The detailed contact information for the person
	// who is responsible for the VDS.
	ContactDetail pulumi.StringPtrInput
	// The name of the person who is responsible for the
	// VDS.
	ContactName pulumi.StringPtrInput
	// Map of custom attribute ids to attribute
	// value strings to set for VDS.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi host connections
	// and requires vCenter Server.
	CustomAttributes pulumi.StringMapInput
	// The ID of the datacenter where the VDS will be
	// created. Forces a new resource if changed.
	DatacenterId pulumi.StringPtrInput
	// A detailed description for the VDS.
	Description pulumi.StringPtrInput
	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed pulumi.BoolPtrInput
	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth pulumi.IntPtrInput
	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize pulumi.IntPtrInput
	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled pulumi.BoolPtrInput
	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth pulumi.IntPtrInput
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback pulumi.BoolPtrInput
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount pulumi.IntPtrInput
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel pulumi.StringPtrInput
	// The folder in which to create the VDS.
	// Forces a new resource if changed.
	Folder pulumi.StringPtrInput
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount pulumi.IntPtrInput
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel pulumi.StringPtrInput
	// A host member specification.
	Hosts DistributedVirtualSwitchHostArrayInput
	// Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings pulumi.BoolPtrInput
	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth pulumi.IntPtrInput
	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize pulumi.IntPtrInput
	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled pulumi.BoolPtrInput
	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth pulumi.IntPtrInput
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments.
	Ipv4Address pulumi.StringPtrInput
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount pulumi.IntPtrInput
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel pulumi.StringPtrInput
	// The Link Aggregation Control Protocol group
	// version to use with the VDS. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion pulumi.StringPtrInput
	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled pulumi.BoolPtrInput
	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode pulumi.StringPtrInput
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation pulumi.StringPtrInput
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol pulumi.StringPtrInput
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount pulumi.IntPtrInput
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel pulumi.StringPtrInput
	// The maximum transmission unit (MTU) for the VDS.
	MaxMtu pulumi.IntPtrInput
	// The multicast filtering mode to use
	// with the VDS. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode pulumi.StringPtrInput
	// The name of the VDS.
	Name pulumi.StringPtrInput
	// The number of seconds after which active flows are forced to be exported to the collector.
	NetflowActiveFlowTimeout pulumi.IntPtrInput
	// IP address for the netflow collector, using IPv4 or IPv6.
	NetflowCollectorIpAddress pulumi.StringPtrInput
	// The port for the netflow collector.
	NetflowCollectorPort pulumi.IntPtrInput
	// Indicates whether to enable netflow on all ports.
	NetflowEnabled pulumi.BoolPtrInput
	// The number of seconds after which idle flows are forced to be exported to the collector.
	NetflowIdleFlowTimeout pulumi.IntPtrInput
	// Whether to limit analysis to traffic that has both source and destination served by the same host.
	NetflowInternalFlowsOnly pulumi.BoolPtrInput
	// The observation Domain ID for the netflow collector.
	NetflowObservationDomainId pulumi.IntPtrInput
	// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all
	// packets are analyzed.
	NetflowSamplingRate pulumi.IntPtrInput
	// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
	NetworkResourceControlEnabled pulumi.BoolPtrInput
	// The network I/O control version to use. Can be one of version2 or version3.
	NetworkResourceControlVersion pulumi.StringPtrInput
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount pulumi.IntPtrInput
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel pulumi.StringPtrInput
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches pulumi.BoolPtrInput
	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanId pulumi.IntPtrInput
	// A private VLAN (PVLAN) mapping.
	PvlanMappings DistributedVirtualSwitchPvlanMappingArrayInput
	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks pulumi.StringArrayInput
	// The IDs of any tags to attach to this resource.
	Tags pulumi.StringArrayInput
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
	// failover_explicit, or loadbalance_loadbased.
	TeamingPolicy pulumi.StringPtrInput
	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
	// forwarded done by the switch.
	TxUplink pulumi.BoolPtrInput
	// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS
	// across hosts.
	Uplinks pulumi.StringArrayInput
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount pulumi.IntPtrInput
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel pulumi.StringPtrInput
	// The version of the VDS. BY default, a VDS is created
	// at the latest version supported by the vSphere version if not specified.
	// A VDS can be upgraded to a newer version, but can not be downgraded.
	Version pulumi.StringPtrInput
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount pulumi.IntPtrInput
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel pulumi.StringPtrInput
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId pulumi.IntPtrInput
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRanges DistributedVirtualSwitchVlanRangeArrayInput
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount pulumi.IntPtrInput
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel pulumi.StringPtrInput
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount pulumi.IntPtrInput
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel pulumi.StringPtrInput
}

func (DistributedVirtualSwitchState) ElementType() reflect.Type {
	return reflect.TypeOf((*distributedVirtualSwitchState)(nil)).Elem()
}

type distributedVirtualSwitchArgs struct {
	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks []string `pulumi:"activeUplinks"`
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
	// that of its own.
	AllowForgedTransmits *bool `pulumi:"allowForgedTransmits"`
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges *bool `pulumi:"allowMacChanges"`
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous *bool `pulumi:"allowPromiscuous"`
	// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
	BackupnfcMaximumMbit *int `pulumi:"backupnfcMaximumMbit"`
	// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
	BackupnfcReservationMbit *int `pulumi:"backupnfcReservationMbit"`
	// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
	BackupnfcShareCount *int `pulumi:"backupnfcShareCount"`
	// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
	BackupnfcShareLevel *string `pulumi:"backupnfcShareLevel"`
	// Indicates whether to block all ports by default.
	BlockAllPorts *bool `pulumi:"blockAllPorts"`
	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon *bool `pulumi:"checkBeacon"`
	// The detailed contact information for the person
	// who is responsible for the VDS.
	ContactDetail *string `pulumi:"contactDetail"`
	// The name of the person who is responsible for the
	// VDS.
	ContactName *string `pulumi:"contactName"`
	// Map of custom attribute ids to attribute
	// value strings to set for VDS.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi host connections
	// and requires vCenter Server.
	CustomAttributes map[string]string `pulumi:"customAttributes"`
	// The ID of the datacenter where the VDS will be
	// created. Forces a new resource if changed.
	DatacenterId string `pulumi:"datacenterId"`
	// A detailed description for the VDS.
	Description *string `pulumi:"description"`
	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed *bool `pulumi:"directpathGen2Allowed"`
	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth *int `pulumi:"egressShapingAverageBandwidth"`
	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize *int `pulumi:"egressShapingBurstSize"`
	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled *bool `pulumi:"egressShapingEnabled"`
	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth *int `pulumi:"egressShapingPeakBandwidth"`
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback *bool `pulumi:"failback"`
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit *int `pulumi:"faulttoleranceMaximumMbit"`
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit *int `pulumi:"faulttoleranceReservationMbit"`
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount *int `pulumi:"faulttoleranceShareCount"`
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel *string `pulumi:"faulttoleranceShareLevel"`
	// The folder in which to create the VDS.
	// Forces a new resource if changed.
	Folder *string `pulumi:"folder"`
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit *int `pulumi:"hbrMaximumMbit"`
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit *int `pulumi:"hbrReservationMbit"`
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount *int `pulumi:"hbrShareCount"`
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel *string `pulumi:"hbrShareLevel"`
	// A host member specification.
	Hosts []DistributedVirtualSwitchHost `pulumi:"hosts"`
	// Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings *bool `pulumi:"ignoreOtherPvlanMappings"`
	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth *int `pulumi:"ingressShapingAverageBandwidth"`
	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize *int `pulumi:"ingressShapingBurstSize"`
	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled *bool `pulumi:"ingressShapingEnabled"`
	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth *int `pulumi:"ingressShapingPeakBandwidth"`
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments.
	Ipv4Address *string `pulumi:"ipv4Address"`
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit *int `pulumi:"iscsiMaximumMbit"`
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit *int `pulumi:"iscsiReservationMbit"`
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount *int `pulumi:"iscsiShareCount"`
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel *string `pulumi:"iscsiShareLevel"`
	// The Link Aggregation Control Protocol group
	// version to use with the VDS. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion *string `pulumi:"lacpApiVersion"`
	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled *bool `pulumi:"lacpEnabled"`
	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode *string `pulumi:"lacpMode"`
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation *string `pulumi:"linkDiscoveryOperation"`
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol *string `pulumi:"linkDiscoveryProtocol"`
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit *int `pulumi:"managementMaximumMbit"`
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit *int `pulumi:"managementReservationMbit"`
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount *int `pulumi:"managementShareCount"`
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel *string `pulumi:"managementShareLevel"`
	// The maximum transmission unit (MTU) for the VDS.
	MaxMtu *int `pulumi:"maxMtu"`
	// The multicast filtering mode to use
	// with the VDS. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode *string `pulumi:"multicastFilteringMode"`
	// The name of the VDS.
	Name *string `pulumi:"name"`
	// The number of seconds after which active flows are forced to be exported to the collector.
	NetflowActiveFlowTimeout *int `pulumi:"netflowActiveFlowTimeout"`
	// IP address for the netflow collector, using IPv4 or IPv6.
	NetflowCollectorIpAddress *string `pulumi:"netflowCollectorIpAddress"`
	// The port for the netflow collector.
	NetflowCollectorPort *int `pulumi:"netflowCollectorPort"`
	// Indicates whether to enable netflow on all ports.
	NetflowEnabled *bool `pulumi:"netflowEnabled"`
	// The number of seconds after which idle flows are forced to be exported to the collector.
	NetflowIdleFlowTimeout *int `pulumi:"netflowIdleFlowTimeout"`
	// Whether to limit analysis to traffic that has both source and destination served by the same host.
	NetflowInternalFlowsOnly *bool `pulumi:"netflowInternalFlowsOnly"`
	// The observation Domain ID for the netflow collector.
	NetflowObservationDomainId *int `pulumi:"netflowObservationDomainId"`
	// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all
	// packets are analyzed.
	NetflowSamplingRate *int `pulumi:"netflowSamplingRate"`
	// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
	NetworkResourceControlEnabled *bool `pulumi:"networkResourceControlEnabled"`
	// The network I/O control version to use. Can be one of version2 or version3.
	NetworkResourceControlVersion *string `pulumi:"networkResourceControlVersion"`
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit *int `pulumi:"nfsMaximumMbit"`
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit *int `pulumi:"nfsReservationMbit"`
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount *int `pulumi:"nfsShareCount"`
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel *string `pulumi:"nfsShareLevel"`
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches *bool `pulumi:"notifySwitches"`
	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanId *int `pulumi:"portPrivateSecondaryVlanId"`
	// A private VLAN (PVLAN) mapping.
	PvlanMappings []DistributedVirtualSwitchPvlanMapping `pulumi:"pvlanMappings"`
	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks []string `pulumi:"standbyUplinks"`
	// The IDs of any tags to attach to this resource.
	Tags []string `pulumi:"tags"`
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
	// failover_explicit, or loadbalance_loadbased.
	TeamingPolicy *string `pulumi:"teamingPolicy"`
	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
	// forwarded done by the switch.
	TxUplink *bool `pulumi:"txUplink"`
	// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS
	// across hosts.
	Uplinks []string `pulumi:"uplinks"`
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit *int `pulumi:"vdpMaximumMbit"`
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit *int `pulumi:"vdpReservationMbit"`
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount *int `pulumi:"vdpShareCount"`
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel *string `pulumi:"vdpShareLevel"`
	// The version of the VDS. BY default, a VDS is created
	// at the latest version supported by the vSphere version if not specified.
	// A VDS can be upgraded to a newer version, but can not be downgraded.
	Version *string `pulumi:"version"`
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit *int `pulumi:"virtualmachineMaximumMbit"`
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit *int `pulumi:"virtualmachineReservationMbit"`
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount *int `pulumi:"virtualmachineShareCount"`
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel *string `pulumi:"virtualmachineShareLevel"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId *int `pulumi:"vlanId"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRanges []DistributedVirtualSwitchVlanRange `pulumi:"vlanRanges"`
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit *int `pulumi:"vmotionMaximumMbit"`
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit *int `pulumi:"vmotionReservationMbit"`
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount *int `pulumi:"vmotionShareCount"`
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel *string `pulumi:"vmotionShareLevel"`
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit *int `pulumi:"vsanMaximumMbit"`
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit *int `pulumi:"vsanReservationMbit"`
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount *int `pulumi:"vsanShareCount"`
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel *string `pulumi:"vsanShareLevel"`
}

// The set of arguments for constructing a DistributedVirtualSwitch resource.
type DistributedVirtualSwitchArgs struct {
	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks pulumi.StringArrayInput
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
	// that of its own.
	AllowForgedTransmits pulumi.BoolPtrInput
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges pulumi.BoolPtrInput
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous pulumi.BoolPtrInput
	// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
	BackupnfcMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
	BackupnfcReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
	BackupnfcShareCount pulumi.IntPtrInput
	// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
	BackupnfcShareLevel pulumi.StringPtrInput
	// Indicates whether to block all ports by default.
	BlockAllPorts pulumi.BoolPtrInput
	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon pulumi.BoolPtrInput
	// The detailed contact information for the person
	// who is responsible for the VDS.
	ContactDetail pulumi.StringPtrInput
	// The name of the person who is responsible for the
	// VDS.
	ContactName pulumi.StringPtrInput
	// Map of custom attribute ids to attribute
	// value strings to set for VDS.
	//
	// > **NOTE:** Custom attributes are unsupported on direct ESXi host connections
	// and requires vCenter Server.
	CustomAttributes pulumi.StringMapInput
	// The ID of the datacenter where the VDS will be
	// created. Forces a new resource if changed.
	DatacenterId pulumi.StringInput
	// A detailed description for the VDS.
	Description pulumi.StringPtrInput
	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed pulumi.BoolPtrInput
	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth pulumi.IntPtrInput
	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize pulumi.IntPtrInput
	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled pulumi.BoolPtrInput
	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth pulumi.IntPtrInput
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback pulumi.BoolPtrInput
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount pulumi.IntPtrInput
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel pulumi.StringPtrInput
	// The folder in which to create the VDS.
	// Forces a new resource if changed.
	Folder pulumi.StringPtrInput
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount pulumi.IntPtrInput
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel pulumi.StringPtrInput
	// A host member specification.
	Hosts DistributedVirtualSwitchHostArrayInput
	// Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings pulumi.BoolPtrInput
	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth pulumi.IntPtrInput
	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize pulumi.IntPtrInput
	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled pulumi.BoolPtrInput
	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth pulumi.IntPtrInput
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments.
	Ipv4Address pulumi.StringPtrInput
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount pulumi.IntPtrInput
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel pulumi.StringPtrInput
	// The Link Aggregation Control Protocol group
	// version to use with the VDS. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion pulumi.StringPtrInput
	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled pulumi.BoolPtrInput
	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode pulumi.StringPtrInput
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation pulumi.StringPtrInput
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol pulumi.StringPtrInput
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount pulumi.IntPtrInput
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel pulumi.StringPtrInput
	// The maximum transmission unit (MTU) for the VDS.
	MaxMtu pulumi.IntPtrInput
	// The multicast filtering mode to use
	// with the VDS. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode pulumi.StringPtrInput
	// The name of the VDS.
	Name pulumi.StringPtrInput
	// The number of seconds after which active flows are forced to be exported to the collector.
	NetflowActiveFlowTimeout pulumi.IntPtrInput
	// IP address for the netflow collector, using IPv4 or IPv6.
	NetflowCollectorIpAddress pulumi.StringPtrInput
	// The port for the netflow collector.
	NetflowCollectorPort pulumi.IntPtrInput
	// Indicates whether to enable netflow on all ports.
	NetflowEnabled pulumi.BoolPtrInput
	// The number of seconds after which idle flows are forced to be exported to the collector.
	NetflowIdleFlowTimeout pulumi.IntPtrInput
	// Whether to limit analysis to traffic that has both source and destination served by the same host.
	NetflowInternalFlowsOnly pulumi.BoolPtrInput
	// The observation Domain ID for the netflow collector.
	NetflowObservationDomainId pulumi.IntPtrInput
	// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all
	// packets are analyzed.
	NetflowSamplingRate pulumi.IntPtrInput
	// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
	NetworkResourceControlEnabled pulumi.BoolPtrInput
	// The network I/O control version to use. Can be one of version2 or version3.
	NetworkResourceControlVersion pulumi.StringPtrInput
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount pulumi.IntPtrInput
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel pulumi.StringPtrInput
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches pulumi.BoolPtrInput
	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanId pulumi.IntPtrInput
	// A private VLAN (PVLAN) mapping.
	PvlanMappings DistributedVirtualSwitchPvlanMappingArrayInput
	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks pulumi.StringArrayInput
	// The IDs of any tags to attach to this resource.
	Tags pulumi.StringArrayInput
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
	// failover_explicit, or loadbalance_loadbased.
	TeamingPolicy pulumi.StringPtrInput
	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
	// forwarded done by the switch.
	TxUplink pulumi.BoolPtrInput
	// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS
	// across hosts.
	Uplinks pulumi.StringArrayInput
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount pulumi.IntPtrInput
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel pulumi.StringPtrInput
	// The version of the VDS. BY default, a VDS is created
	// at the latest version supported by the vSphere version if not specified.
	// A VDS can be upgraded to a newer version, but can not be downgraded.
	Version pulumi.StringPtrInput
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount pulumi.IntPtrInput
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel pulumi.StringPtrInput
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId pulumi.IntPtrInput
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRanges DistributedVirtualSwitchVlanRangeArrayInput
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount pulumi.IntPtrInput
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel pulumi.StringPtrInput
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount pulumi.IntPtrInput
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel pulumi.StringPtrInput
}

func (DistributedVirtualSwitchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*distributedVirtualSwitchArgs)(nil)).Elem()
}

type DistributedVirtualSwitchInput interface {
	pulumi.Input

	ToDistributedVirtualSwitchOutput() DistributedVirtualSwitchOutput
	ToDistributedVirtualSwitchOutputWithContext(ctx context.Context) DistributedVirtualSwitchOutput
}

func (*DistributedVirtualSwitch) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributedVirtualSwitch)(nil)).Elem()
}

func (i *DistributedVirtualSwitch) ToDistributedVirtualSwitchOutput() DistributedVirtualSwitchOutput {
	return i.ToDistributedVirtualSwitchOutputWithContext(context.Background())
}

func (i *DistributedVirtualSwitch) ToDistributedVirtualSwitchOutputWithContext(ctx context.Context) DistributedVirtualSwitchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributedVirtualSwitchOutput)
}

// DistributedVirtualSwitchArrayInput is an input type that accepts DistributedVirtualSwitchArray and DistributedVirtualSwitchArrayOutput values.
// You can construct a concrete instance of `DistributedVirtualSwitchArrayInput` via:
//
//	DistributedVirtualSwitchArray{ DistributedVirtualSwitchArgs{...} }
type DistributedVirtualSwitchArrayInput interface {
	pulumi.Input

	ToDistributedVirtualSwitchArrayOutput() DistributedVirtualSwitchArrayOutput
	ToDistributedVirtualSwitchArrayOutputWithContext(context.Context) DistributedVirtualSwitchArrayOutput
}

type DistributedVirtualSwitchArray []DistributedVirtualSwitchInput

func (DistributedVirtualSwitchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DistributedVirtualSwitch)(nil)).Elem()
}

func (i DistributedVirtualSwitchArray) ToDistributedVirtualSwitchArrayOutput() DistributedVirtualSwitchArrayOutput {
	return i.ToDistributedVirtualSwitchArrayOutputWithContext(context.Background())
}

func (i DistributedVirtualSwitchArray) ToDistributedVirtualSwitchArrayOutputWithContext(ctx context.Context) DistributedVirtualSwitchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributedVirtualSwitchArrayOutput)
}

// DistributedVirtualSwitchMapInput is an input type that accepts DistributedVirtualSwitchMap and DistributedVirtualSwitchMapOutput values.
// You can construct a concrete instance of `DistributedVirtualSwitchMapInput` via:
//
//	DistributedVirtualSwitchMap{ "key": DistributedVirtualSwitchArgs{...} }
type DistributedVirtualSwitchMapInput interface {
	pulumi.Input

	ToDistributedVirtualSwitchMapOutput() DistributedVirtualSwitchMapOutput
	ToDistributedVirtualSwitchMapOutputWithContext(context.Context) DistributedVirtualSwitchMapOutput
}

type DistributedVirtualSwitchMap map[string]DistributedVirtualSwitchInput

func (DistributedVirtualSwitchMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DistributedVirtualSwitch)(nil)).Elem()
}

func (i DistributedVirtualSwitchMap) ToDistributedVirtualSwitchMapOutput() DistributedVirtualSwitchMapOutput {
	return i.ToDistributedVirtualSwitchMapOutputWithContext(context.Background())
}

func (i DistributedVirtualSwitchMap) ToDistributedVirtualSwitchMapOutputWithContext(ctx context.Context) DistributedVirtualSwitchMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributedVirtualSwitchMapOutput)
}

type DistributedVirtualSwitchOutput struct{ *pulumi.OutputState }

func (DistributedVirtualSwitchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributedVirtualSwitch)(nil)).Elem()
}

func (o DistributedVirtualSwitchOutput) ToDistributedVirtualSwitchOutput() DistributedVirtualSwitchOutput {
	return o
}

func (o DistributedVirtualSwitchOutput) ToDistributedVirtualSwitchOutputWithContext(ctx context.Context) DistributedVirtualSwitchOutput {
	return o
}

// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
func (o DistributedVirtualSwitchOutput) ActiveUplinks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringArrayOutput { return v.ActiveUplinks }).(pulumi.StringArrayOutput)
}

// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
// that of its own.
func (o DistributedVirtualSwitchOutput) AllowForgedTransmits() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.AllowForgedTransmits }).(pulumi.BoolOutput)
}

// Controls whether or not the Media Access Control (MAC) address can be changed.
func (o DistributedVirtualSwitchOutput) AllowMacChanges() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.AllowMacChanges }).(pulumi.BoolOutput)
}

// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
func (o DistributedVirtualSwitchOutput) AllowPromiscuous() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.AllowPromiscuous }).(pulumi.BoolOutput)
}

// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) BackupnfcMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.BackupnfcMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) BackupnfcReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.BackupnfcReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) BackupnfcShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.BackupnfcShareCount }).(pulumi.IntOutput)
}

// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) BackupnfcShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.BackupnfcShareLevel }).(pulumi.StringOutput)
}

// Indicates whether to block all ports by default.
func (o DistributedVirtualSwitchOutput) BlockAllPorts() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.BlockAllPorts }).(pulumi.BoolOutput)
}

// Enable beacon probing on the ports this policy applies to.
func (o DistributedVirtualSwitchOutput) CheckBeacon() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.CheckBeacon }).(pulumi.BoolOutput)
}

// The current version of the VDS configuration, incremented
// by subsequent updates to the VDS.
func (o DistributedVirtualSwitchOutput) ConfigVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.ConfigVersion }).(pulumi.StringOutput)
}

// The detailed contact information for the person
// who is responsible for the VDS.
func (o DistributedVirtualSwitchOutput) ContactDetail() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringPtrOutput { return v.ContactDetail }).(pulumi.StringPtrOutput)
}

// The name of the person who is responsible for the
// VDS.
func (o DistributedVirtualSwitchOutput) ContactName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringPtrOutput { return v.ContactName }).(pulumi.StringPtrOutput)
}

// Map of custom attribute ids to attribute
// value strings to set for VDS.
//
// > **NOTE:** Custom attributes are unsupported on direct ESXi host connections
// and requires vCenter Server.
func (o DistributedVirtualSwitchOutput) CustomAttributes() pulumi.StringMapOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringMapOutput { return v.CustomAttributes }).(pulumi.StringMapOutput)
}

// The ID of the datacenter where the VDS will be
// created. Forces a new resource if changed.
func (o DistributedVirtualSwitchOutput) DatacenterId() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.DatacenterId }).(pulumi.StringOutput)
}

// A detailed description for the VDS.
func (o DistributedVirtualSwitchOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Allow VMDirectPath Gen2 on the ports this policy applies to.
func (o DistributedVirtualSwitchOutput) DirectpathGen2Allowed() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.DirectpathGen2Allowed }).(pulumi.BoolOutput)
}

// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
func (o DistributedVirtualSwitchOutput) EgressShapingAverageBandwidth() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.EgressShapingAverageBandwidth }).(pulumi.IntOutput)
}

// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
func (o DistributedVirtualSwitchOutput) EgressShapingBurstSize() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.EgressShapingBurstSize }).(pulumi.IntOutput)
}

// True if the traffic shaper is enabled for egress traffic on the port.
func (o DistributedVirtualSwitchOutput) EgressShapingEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.EgressShapingEnabled }).(pulumi.BoolOutput)
}

// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
func (o DistributedVirtualSwitchOutput) EgressShapingPeakBandwidth() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.EgressShapingPeakBandwidth }).(pulumi.IntOutput)
}

// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
func (o DistributedVirtualSwitchOutput) Failback() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.Failback }).(pulumi.BoolOutput)
}

// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) FaulttoleranceMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.FaulttoleranceMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) FaulttoleranceReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.FaulttoleranceReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) FaulttoleranceShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.FaulttoleranceShareCount }).(pulumi.IntOutput)
}

// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) FaulttoleranceShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.FaulttoleranceShareLevel }).(pulumi.StringOutput)
}

// The folder in which to create the VDS.
// Forces a new resource if changed.
func (o DistributedVirtualSwitchOutput) Folder() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringPtrOutput { return v.Folder }).(pulumi.StringPtrOutput)
}

// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) HbrMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.HbrMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) HbrReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.HbrReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the hbr traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) HbrShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.HbrShareCount }).(pulumi.IntOutput)
}

// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) HbrShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.HbrShareLevel }).(pulumi.StringOutput)
}

// A host member specification.
func (o DistributedVirtualSwitchOutput) Hosts() DistributedVirtualSwitchHostArrayOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) DistributedVirtualSwitchHostArrayOutput { return v.Hosts }).(DistributedVirtualSwitchHostArrayOutput)
}

// Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.
func (o DistributedVirtualSwitchOutput) IgnoreOtherPvlanMappings() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolPtrOutput { return v.IgnoreOtherPvlanMappings }).(pulumi.BoolPtrOutput)
}

// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
func (o DistributedVirtualSwitchOutput) IngressShapingAverageBandwidth() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.IngressShapingAverageBandwidth }).(pulumi.IntOutput)
}

// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
func (o DistributedVirtualSwitchOutput) IngressShapingBurstSize() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.IngressShapingBurstSize }).(pulumi.IntOutput)
}

// True if the traffic shaper is enabled for ingress traffic on the port.
func (o DistributedVirtualSwitchOutput) IngressShapingEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.IngressShapingEnabled }).(pulumi.BoolOutput)
}

// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
func (o DistributedVirtualSwitchOutput) IngressShapingPeakBandwidth() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.IngressShapingPeakBandwidth }).(pulumi.IntOutput)
}

// An IPv4 address to identify the switch. This is
// mostly useful when used with the Netflow arguments.
func (o DistributedVirtualSwitchOutput) Ipv4Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringPtrOutput { return v.Ipv4Address }).(pulumi.StringPtrOutput)
}

// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) IscsiMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.IscsiMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) IscsiReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.IscsiReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) IscsiShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.IscsiShareCount }).(pulumi.IntOutput)
}

// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) IscsiShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.IscsiShareLevel }).(pulumi.StringOutput)
}

// The Link Aggregation Control Protocol group
// version to use with the VDS. Possible values are `singleLag` and
// `multipleLag`.
func (o DistributedVirtualSwitchOutput) LacpApiVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.LacpApiVersion }).(pulumi.StringOutput)
}

// Whether or not to enable LACP on all uplink ports.
func (o DistributedVirtualSwitchOutput) LacpEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.LacpEnabled }).(pulumi.BoolOutput)
}

// The uplink LACP mode to use. Can be one of active or passive.
func (o DistributedVirtualSwitchOutput) LacpMode() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.LacpMode }).(pulumi.StringOutput)
}

// Whether to `advertise` or `listen`
// for link discovery traffic.
func (o DistributedVirtualSwitchOutput) LinkDiscoveryOperation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringPtrOutput { return v.LinkDiscoveryOperation }).(pulumi.StringPtrOutput)
}

// The discovery protocol type. Valid
// types are `cdp` and `lldp`.
func (o DistributedVirtualSwitchOutput) LinkDiscoveryProtocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringPtrOutput { return v.LinkDiscoveryProtocol }).(pulumi.StringPtrOutput)
}

// The maximum allowed usage for the management traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) ManagementMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.ManagementMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) ManagementReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.ManagementReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the management traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) ManagementShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.ManagementShareCount }).(pulumi.IntOutput)
}

// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) ManagementShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.ManagementShareLevel }).(pulumi.StringOutput)
}

// The maximum transmission unit (MTU) for the VDS.
func (o DistributedVirtualSwitchOutput) MaxMtu() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.MaxMtu }).(pulumi.IntOutput)
}

// The multicast filtering mode to use
// with the VDS. Can be one of `legacyFiltering` or `snooping`.
func (o DistributedVirtualSwitchOutput) MulticastFilteringMode() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.MulticastFilteringMode }).(pulumi.StringOutput)
}

// The name of the VDS.
func (o DistributedVirtualSwitchOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The number of seconds after which active flows are forced to be exported to the collector.
func (o DistributedVirtualSwitchOutput) NetflowActiveFlowTimeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntPtrOutput { return v.NetflowActiveFlowTimeout }).(pulumi.IntPtrOutput)
}

// IP address for the netflow collector, using IPv4 or IPv6.
func (o DistributedVirtualSwitchOutput) NetflowCollectorIpAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringPtrOutput { return v.NetflowCollectorIpAddress }).(pulumi.StringPtrOutput)
}

// The port for the netflow collector.
func (o DistributedVirtualSwitchOutput) NetflowCollectorPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntPtrOutput { return v.NetflowCollectorPort }).(pulumi.IntPtrOutput)
}

// Indicates whether to enable netflow on all ports.
func (o DistributedVirtualSwitchOutput) NetflowEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.NetflowEnabled }).(pulumi.BoolOutput)
}

// The number of seconds after which idle flows are forced to be exported to the collector.
func (o DistributedVirtualSwitchOutput) NetflowIdleFlowTimeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntPtrOutput { return v.NetflowIdleFlowTimeout }).(pulumi.IntPtrOutput)
}

// Whether to limit analysis to traffic that has both source and destination served by the same host.
func (o DistributedVirtualSwitchOutput) NetflowInternalFlowsOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolPtrOutput { return v.NetflowInternalFlowsOnly }).(pulumi.BoolPtrOutput)
}

// The observation Domain ID for the netflow collector.
func (o DistributedVirtualSwitchOutput) NetflowObservationDomainId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntPtrOutput { return v.NetflowObservationDomainId }).(pulumi.IntPtrOutput)
}

// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all
// packets are analyzed.
func (o DistributedVirtualSwitchOutput) NetflowSamplingRate() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntPtrOutput { return v.NetflowSamplingRate }).(pulumi.IntPtrOutput)
}

// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
func (o DistributedVirtualSwitchOutput) NetworkResourceControlEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolPtrOutput { return v.NetworkResourceControlEnabled }).(pulumi.BoolPtrOutput)
}

// The network I/O control version to use. Can be one of version2 or version3.
func (o DistributedVirtualSwitchOutput) NetworkResourceControlVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.NetworkResourceControlVersion }).(pulumi.StringOutput)
}

// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) NfsMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.NfsMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) NfsReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.NfsReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the nfs traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) NfsShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.NfsShareCount }).(pulumi.IntOutput)
}

// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) NfsShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.NfsShareLevel }).(pulumi.StringOutput)
}

// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
func (o DistributedVirtualSwitchOutput) NotifySwitches() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.NotifySwitches }).(pulumi.BoolOutput)
}

// The secondary VLAN ID for this port.
func (o DistributedVirtualSwitchOutput) PortPrivateSecondaryVlanId() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.PortPrivateSecondaryVlanId }).(pulumi.IntOutput)
}

// A private VLAN (PVLAN) mapping.
func (o DistributedVirtualSwitchOutput) PvlanMappings() DistributedVirtualSwitchPvlanMappingArrayOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) DistributedVirtualSwitchPvlanMappingArrayOutput {
		return v.PvlanMappings
	}).(DistributedVirtualSwitchPvlanMappingArrayOutput)
}

// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
func (o DistributedVirtualSwitchOutput) StandbyUplinks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringArrayOutput { return v.StandbyUplinks }).(pulumi.StringArrayOutput)
}

// The IDs of any tags to attach to this resource.
func (o DistributedVirtualSwitchOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,
// failover_explicit, or loadbalance_loadbased.
func (o DistributedVirtualSwitchOutput) TeamingPolicy() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.TeamingPolicy }).(pulumi.StringOutput)
}

// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet
// forwarded done by the switch.
func (o DistributedVirtualSwitchOutput) TxUplink() pulumi.BoolOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.BoolOutput { return v.TxUplink }).(pulumi.BoolOutput)
}

// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS
// across hosts.
func (o DistributedVirtualSwitchOutput) Uplinks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringArrayOutput { return v.Uplinks }).(pulumi.StringArrayOutput)
}

// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) VdpMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VdpMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) VdpReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VdpReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the vdp traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) VdpShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VdpShareCount }).(pulumi.IntOutput)
}

// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) VdpShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.VdpShareLevel }).(pulumi.StringOutput)
}

// The version of the VDS. BY default, a VDS is created
// at the latest version supported by the vSphere version if not specified.
// A VDS can be upgraded to a newer version, but can not be downgraded.
func (o DistributedVirtualSwitchOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.Version }).(pulumi.StringOutput)
}

// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) VirtualmachineMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VirtualmachineMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) VirtualmachineReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VirtualmachineReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) VirtualmachineShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VirtualmachineShareCount }).(pulumi.IntOutput)
}

// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) VirtualmachineShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.VirtualmachineShareLevel }).(pulumi.StringOutput)
}

// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
func (o DistributedVirtualSwitchOutput) VlanId() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VlanId }).(pulumi.IntOutput)
}

// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
func (o DistributedVirtualSwitchOutput) VlanRanges() DistributedVirtualSwitchVlanRangeArrayOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) DistributedVirtualSwitchVlanRangeArrayOutput { return v.VlanRanges }).(DistributedVirtualSwitchVlanRangeArrayOutput)
}

// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) VmotionMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VmotionMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) VmotionReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VmotionReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the vmotion traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) VmotionShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VmotionShareCount }).(pulumi.IntOutput)
}

// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) VmotionShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.VmotionShareLevel }).(pulumi.StringOutput)
}

// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) VsanMaximumMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VsanMaximumMbit }).(pulumi.IntOutput)
}

// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
func (o DistributedVirtualSwitchOutput) VsanReservationMbit() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VsanReservationMbit }).(pulumi.IntOutput)
}

// The amount of shares to allocate to the vsan traffic class for a custom share level.
func (o DistributedVirtualSwitchOutput) VsanShareCount() pulumi.IntOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.IntOutput { return v.VsanShareCount }).(pulumi.IntOutput)
}

// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
func (o DistributedVirtualSwitchOutput) VsanShareLevel() pulumi.StringOutput {
	return o.ApplyT(func(v *DistributedVirtualSwitch) pulumi.StringOutput { return v.VsanShareLevel }).(pulumi.StringOutput)
}

type DistributedVirtualSwitchArrayOutput struct{ *pulumi.OutputState }

func (DistributedVirtualSwitchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DistributedVirtualSwitch)(nil)).Elem()
}

func (o DistributedVirtualSwitchArrayOutput) ToDistributedVirtualSwitchArrayOutput() DistributedVirtualSwitchArrayOutput {
	return o
}

func (o DistributedVirtualSwitchArrayOutput) ToDistributedVirtualSwitchArrayOutputWithContext(ctx context.Context) DistributedVirtualSwitchArrayOutput {
	return o
}

func (o DistributedVirtualSwitchArrayOutput) Index(i pulumi.IntInput) DistributedVirtualSwitchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DistributedVirtualSwitch {
		return vs[0].([]*DistributedVirtualSwitch)[vs[1].(int)]
	}).(DistributedVirtualSwitchOutput)
}

type DistributedVirtualSwitchMapOutput struct{ *pulumi.OutputState }

func (DistributedVirtualSwitchMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DistributedVirtualSwitch)(nil)).Elem()
}

func (o DistributedVirtualSwitchMapOutput) ToDistributedVirtualSwitchMapOutput() DistributedVirtualSwitchMapOutput {
	return o
}

func (o DistributedVirtualSwitchMapOutput) ToDistributedVirtualSwitchMapOutputWithContext(ctx context.Context) DistributedVirtualSwitchMapOutput {
	return o
}

func (o DistributedVirtualSwitchMapOutput) MapIndex(k pulumi.StringInput) DistributedVirtualSwitchOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DistributedVirtualSwitch {
		return vs[0].(map[string]*DistributedVirtualSwitch)[vs[1].(string)]
	}).(DistributedVirtualSwitchOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DistributedVirtualSwitchInput)(nil)).Elem(), &DistributedVirtualSwitch{})
	pulumi.RegisterInputType(reflect.TypeOf((*DistributedVirtualSwitchArrayInput)(nil)).Elem(), DistributedVirtualSwitchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DistributedVirtualSwitchMapInput)(nil)).Elem(), DistributedVirtualSwitchMap{})
	pulumi.RegisterOutputType(DistributedVirtualSwitchOutput{})
	pulumi.RegisterOutputType(DistributedVirtualSwitchArrayOutput{})
	pulumi.RegisterOutputType(DistributedVirtualSwitchMapOutput{})
}
