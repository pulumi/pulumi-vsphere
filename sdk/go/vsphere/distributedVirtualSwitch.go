// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package vsphere

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type DistributedVirtualSwitch struct {
	pulumi.CustomResourceState

	// A list of active uplinks to be used in load
	// balancing. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	ActiveUplinks pulumi.StringArrayOutput `pulumi:"activeUplinks"`
	// Controls whether or not a virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own.
	AllowForgedTransmits pulumi.BoolOutput `pulumi:"allowForgedTransmits"`
	// Controls whether or not the Media Access
	// Control (MAC) address can be changed.
	AllowMacChanges pulumi.BoolOutput `pulumi:"allowMacChanges"`
	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous pulumi.BoolOutput `pulumi:"allowPromiscuous"`
	// Shuts down all ports in the port groups that
	// this policy applies to, effectively blocking all network access to connected
	// virtual devices.
	BlockAllPorts pulumi.BoolOutput `pulumi:"blockAllPorts"`
	// Enables beacon probing as an additional measure
	// to detect NIC failure.
	CheckBeacon pulumi.BoolOutput `pulumi:"checkBeacon"`
	// The version string of the configuration that this spec is trying to change.
	ConfigVersion pulumi.StringOutput `pulumi:"configVersion"`
	// The detailed contact information for the person
	// who is responsible for the DVS.
	ContactDetail pulumi.StringPtrOutput `pulumi:"contactDetail"`
	// The name of the person who is responsible for the
	// DVS.
	ContactName pulumi.StringPtrOutput `pulumi:"contactName"`
	// Map of custom attribute ids to attribute
	// value strings to set for virtual switch.
	CustomAttributes pulumi.StringMapOutput `pulumi:"customAttributes"`
	// The ID of the datacenter where the distributed
	// virtual switch will be created. Forces a new resource if changed.
	DatacenterId pulumi.StringOutput `pulumi:"datacenterId"`
	// A detailed description for the DVS.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Allow VMDirectPath Gen2 for the ports
	// for which this policy applies to.
	DirectpathGen2Allowed pulumi.BoolOutput `pulumi:"directpathGen2Allowed"`
	// The average bandwidth in bits
	// per second if egress traffic shaping is enabled on the port.
	EgressShapingAverageBandwidth pulumi.IntOutput `pulumi:"egressShapingAverageBandwidth"`
	// The maximum burst size allowed in
	// bytes if egress traffic shaping is enabled on the port.
	EgressShapingBurstSize pulumi.IntOutput `pulumi:"egressShapingBurstSize"`
	// `true` if the traffic shaper is enabled
	// on the port for egress traffic.
	EgressShapingEnabled pulumi.BoolOutput `pulumi:"egressShapingEnabled"`
	// The peak bandwidth during bursts
	// in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth pulumi.IntOutput `pulumi:"egressShapingPeakBandwidth"`
	// If `true`, the teaming policy will re-activate failed
	// uplinks higher in precedence when they come back up.
	Failback pulumi.BoolOutput `pulumi:"failback"`
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit pulumi.IntOutput `pulumi:"faulttoleranceMaximumMbit"`
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit pulumi.IntOutput `pulumi:"faulttoleranceReservationMbit"`
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount pulumi.IntOutput `pulumi:"faulttoleranceShareCount"`
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel pulumi.StringOutput `pulumi:"faulttoleranceShareLevel"`
	// The folder to create the DVS in. Forces a new resource
	// if changed.
	Folder pulumi.StringPtrOutput `pulumi:"folder"`
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit pulumi.IntOutput `pulumi:"hbrMaximumMbit"`
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit pulumi.IntOutput `pulumi:"hbrReservationMbit"`
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount pulumi.IntOutput `pulumi:"hbrShareCount"`
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel pulumi.StringOutput `pulumi:"hbrShareLevel"`
	// Use the `host` block to declare a host specification. The
	// options are:
	Hosts DistributedVirtualSwitchHostArrayOutput `pulumi:"hosts"`
	// Whether to ignore existing PVLAN
	// mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings pulumi.BoolPtrOutput `pulumi:"ignoreOtherPvlanMappings"`
	// The average bandwidth in
	// bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingAverageBandwidth pulumi.IntOutput `pulumi:"ingressShapingAverageBandwidth"`
	// The maximum burst size allowed in
	// bytes if ingress traffic shaping is enabled on the port.
	IngressShapingBurstSize pulumi.IntOutput `pulumi:"ingressShapingBurstSize"`
	// `true` if the traffic shaper is
	// enabled on the port for ingress traffic.
	IngressShapingEnabled pulumi.BoolOutput `pulumi:"ingressShapingEnabled"`
	// The peak bandwidth during
	// bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth pulumi.IntOutput `pulumi:"ingressShapingPeakBandwidth"`
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments found
	// below.
	Ipv4Address pulumi.StringPtrOutput `pulumi:"ipv4Address"`
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit pulumi.IntOutput `pulumi:"iscsiMaximumMbit"`
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit pulumi.IntOutput `pulumi:"iscsiReservationMbit"`
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount pulumi.IntOutput `pulumi:"iscsiShareCount"`
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel pulumi.StringOutput `pulumi:"iscsiShareLevel"`
	// The Link Aggregation Control Protocol group
	// version to use with the switch. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion pulumi.StringOutput `pulumi:"lacpApiVersion"`
	// Enables LACP for the ports that this policy
	// applies to.
	LacpEnabled pulumi.BoolOutput `pulumi:"lacpEnabled"`
	// The LACP mode. Can be one of `active` or `passive`.
	LacpMode pulumi.StringOutput `pulumi:"lacpMode"`
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation pulumi.StringPtrOutput `pulumi:"linkDiscoveryOperation"`
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol pulumi.StringPtrOutput `pulumi:"linkDiscoveryProtocol"`
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit pulumi.IntOutput `pulumi:"managementMaximumMbit"`
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit pulumi.IntOutput `pulumi:"managementReservationMbit"`
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount pulumi.IntOutput `pulumi:"managementShareCount"`
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel pulumi.StringOutput `pulumi:"managementShareLevel"`
	// The maximum transmission unit (MTU) for the virtual
	// switch.
	MaxMtu pulumi.IntOutput `pulumi:"maxMtu"`
	// The multicast filtering mode to use
	// with the switch. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode pulumi.StringOutput `pulumi:"multicastFilteringMode"`
	// The name of the distributed virtual switch.
	Name pulumi.StringOutput `pulumi:"name"`
	// The number of seconds after which
	// active flows are forced to be exported to the collector. Allowed range is
	// `60` to `3600`. Default: `60`.
	NetflowActiveFlowTimeout pulumi.IntPtrOutput `pulumi:"netflowActiveFlowTimeout"`
	// IP address for the Netflow
	// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
	// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
	NetflowCollectorIpAddress pulumi.StringPtrOutput `pulumi:"netflowCollectorIpAddress"`
	// Port for the Netflow collector. This
	// must be set before Netflow can be enabled.
	NetflowCollectorPort pulumi.IntPtrOutput `pulumi:"netflowCollectorPort"`
	// Enables Netflow on all ports that this policy
	// applies to.
	NetflowEnabled pulumi.BoolOutput `pulumi:"netflowEnabled"`
	// The number of seconds after which
	// idle flows are forced to be exported to the collector. Allowed range is `10`
	// to `600`. Default: `15`.
	NetflowIdleFlowTimeout pulumi.IntPtrOutput `pulumi:"netflowIdleFlowTimeout"`
	// Whether to limit analysis to
	// traffic that has both source and destination served by the same host.
	// Default: `false`.
	NetflowInternalFlowsOnly pulumi.BoolPtrOutput `pulumi:"netflowInternalFlowsOnly"`
	// The observation domain ID for
	// the Netflow collector.
	NetflowObservationDomainId pulumi.IntPtrOutput `pulumi:"netflowObservationDomainId"`
	// The ratio of total number of packets to
	// the number of packets analyzed. The default is `0`, which indicates that the
	// switch should analyze all packets. The maximum value is `1000`, which
	// indicates an analysis rate of 0.001%.
	NetflowSamplingRate pulumi.IntPtrOutput `pulumi:"netflowSamplingRate"`
	// Set to `true` to enable
	// network I/O control. Default: `false`.
	NetworkResourceControlEnabled pulumi.BoolPtrOutput `pulumi:"networkResourceControlEnabled"`
	// The version of network I/O
	// control to use. Can be one of `version2` or `version3`. Default: `version2`.
	NetworkResourceControlVersion pulumi.StringOutput `pulumi:"networkResourceControlVersion"`
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit pulumi.IntOutput `pulumi:"nfsMaximumMbit"`
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit pulumi.IntOutput `pulumi:"nfsReservationMbit"`
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount pulumi.IntOutput `pulumi:"nfsShareCount"`
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel pulumi.StringOutput `pulumi:"nfsShareLevel"`
	// If `true`, the teaming policy will notify the
	// broadcast network of an uplink failover, triggering cache updates.
	NotifySwitches pulumi.BoolOutput `pulumi:"notifySwitches"`
	// Used to define a secondary VLAN
	// ID when using private VLANs.
	PortPrivateSecondaryVlanId pulumi.IntOutput `pulumi:"portPrivateSecondaryVlanId"`
	// Use the `pvlanMapping` block to declare a
	// private VLAN mapping. The options are:
	PvlanMappings DistributedVirtualSwitchPvlanMappingArrayOutput `pulumi:"pvlanMappings"`
	// A list of standby uplinks to be used in
	// failover. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	StandbyUplinks pulumi.StringArrayOutput `pulumi:"standbyUplinks"`
	// The IDs of any tags to attach to this resource.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// The uplink teaming policy. Can be one of
	// `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
	// `failoverExplicit`.
	TeamingPolicy pulumi.StringOutput `pulumi:"teamingPolicy"`
	// Forward all traffic transmitted by ports for which
	// this policy applies to its DVS uplinks.
	TxUplink pulumi.BoolOutput `pulumi:"txUplink"`
	// A list of strings that uniquely identifies the names
	// of the uplinks on the DVS across hosts. The number of items in this list
	// controls the number of uplinks that exist on the DVS, in addition to the
	// names.  See here for an example on how to
	// use this option.
	Uplinks pulumi.StringArrayOutput `pulumi:"uplinks"`
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit pulumi.IntOutput `pulumi:"vdpMaximumMbit"`
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit pulumi.IntOutput `pulumi:"vdpReservationMbit"`
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount pulumi.IntOutput `pulumi:"vdpShareCount"`
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel pulumi.StringOutput `pulumi:"vdpShareLevel"`
	// - The version of the DVS to create. The default is to
	//   create the DVS at the latest version supported by the version of vSphere
	//   being used. A DVS can be upgraded to another version, but cannot be
	//   downgraded.
	Version pulumi.StringOutput `pulumi:"version"`
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit pulumi.IntOutput `pulumi:"virtualmachineMaximumMbit"`
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit pulumi.IntOutput `pulumi:"virtualmachineReservationMbit"`
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount pulumi.IntOutput `pulumi:"virtualmachineShareCount"`
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel pulumi.StringOutput `pulumi:"virtualmachineShareLevel"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId pulumi.IntOutput `pulumi:"vlanId"`
	// Used to denote VLAN trunking. Use the `minVlan`
	// and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
	// `vlanRange` definitions are allowed, but they must not overlap. Example
	// below:
	VlanRanges DistributedVirtualSwitchVlanRangeArrayOutput `pulumi:"vlanRanges"`
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit pulumi.IntOutput `pulumi:"vmotionMaximumMbit"`
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit pulumi.IntOutput `pulumi:"vmotionReservationMbit"`
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount pulumi.IntOutput `pulumi:"vmotionShareCount"`
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel pulumi.StringOutput `pulumi:"vmotionShareLevel"`
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit pulumi.IntOutput `pulumi:"vsanMaximumMbit"`
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit pulumi.IntOutput `pulumi:"vsanReservationMbit"`
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount pulumi.IntOutput `pulumi:"vsanShareCount"`
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel pulumi.StringOutput `pulumi:"vsanShareLevel"`
}

// NewDistributedVirtualSwitch registers a new resource with the given unique name, arguments, and options.
func NewDistributedVirtualSwitch(ctx *pulumi.Context,
	name string, args *DistributedVirtualSwitchArgs, opts ...pulumi.ResourceOption) (*DistributedVirtualSwitch, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatacenterId == nil {
		return nil, errors.New("invalid value for required argument 'DatacenterId'")
	}
	var resource DistributedVirtualSwitch
	err := ctx.RegisterResource("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDistributedVirtualSwitch gets an existing DistributedVirtualSwitch resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDistributedVirtualSwitch(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DistributedVirtualSwitchState, opts ...pulumi.ResourceOption) (*DistributedVirtualSwitch, error) {
	var resource DistributedVirtualSwitch
	err := ctx.ReadResource("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DistributedVirtualSwitch resources.
type distributedVirtualSwitchState struct {
	// A list of active uplinks to be used in load
	// balancing. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	ActiveUplinks []string `pulumi:"activeUplinks"`
	// Controls whether or not a virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own.
	AllowForgedTransmits *bool `pulumi:"allowForgedTransmits"`
	// Controls whether or not the Media Access
	// Control (MAC) address can be changed.
	AllowMacChanges *bool `pulumi:"allowMacChanges"`
	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous *bool `pulumi:"allowPromiscuous"`
	// Shuts down all ports in the port groups that
	// this policy applies to, effectively blocking all network access to connected
	// virtual devices.
	BlockAllPorts *bool `pulumi:"blockAllPorts"`
	// Enables beacon probing as an additional measure
	// to detect NIC failure.
	CheckBeacon *bool `pulumi:"checkBeacon"`
	// The version string of the configuration that this spec is trying to change.
	ConfigVersion *string `pulumi:"configVersion"`
	// The detailed contact information for the person
	// who is responsible for the DVS.
	ContactDetail *string `pulumi:"contactDetail"`
	// The name of the person who is responsible for the
	// DVS.
	ContactName *string `pulumi:"contactName"`
	// Map of custom attribute ids to attribute
	// value strings to set for virtual switch.
	CustomAttributes map[string]string `pulumi:"customAttributes"`
	// The ID of the datacenter where the distributed
	// virtual switch will be created. Forces a new resource if changed.
	DatacenterId *string `pulumi:"datacenterId"`
	// A detailed description for the DVS.
	Description *string `pulumi:"description"`
	// Allow VMDirectPath Gen2 for the ports
	// for which this policy applies to.
	DirectpathGen2Allowed *bool `pulumi:"directpathGen2Allowed"`
	// The average bandwidth in bits
	// per second if egress traffic shaping is enabled on the port.
	EgressShapingAverageBandwidth *int `pulumi:"egressShapingAverageBandwidth"`
	// The maximum burst size allowed in
	// bytes if egress traffic shaping is enabled on the port.
	EgressShapingBurstSize *int `pulumi:"egressShapingBurstSize"`
	// `true` if the traffic shaper is enabled
	// on the port for egress traffic.
	EgressShapingEnabled *bool `pulumi:"egressShapingEnabled"`
	// The peak bandwidth during bursts
	// in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth *int `pulumi:"egressShapingPeakBandwidth"`
	// If `true`, the teaming policy will re-activate failed
	// uplinks higher in precedence when they come back up.
	Failback *bool `pulumi:"failback"`
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit *int `pulumi:"faulttoleranceMaximumMbit"`
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit *int `pulumi:"faulttoleranceReservationMbit"`
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount *int `pulumi:"faulttoleranceShareCount"`
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel *string `pulumi:"faulttoleranceShareLevel"`
	// The folder to create the DVS in. Forces a new resource
	// if changed.
	Folder *string `pulumi:"folder"`
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit *int `pulumi:"hbrMaximumMbit"`
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit *int `pulumi:"hbrReservationMbit"`
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount *int `pulumi:"hbrShareCount"`
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel *string `pulumi:"hbrShareLevel"`
	// Use the `host` block to declare a host specification. The
	// options are:
	Hosts []DistributedVirtualSwitchHost `pulumi:"hosts"`
	// Whether to ignore existing PVLAN
	// mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings *bool `pulumi:"ignoreOtherPvlanMappings"`
	// The average bandwidth in
	// bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingAverageBandwidth *int `pulumi:"ingressShapingAverageBandwidth"`
	// The maximum burst size allowed in
	// bytes if ingress traffic shaping is enabled on the port.
	IngressShapingBurstSize *int `pulumi:"ingressShapingBurstSize"`
	// `true` if the traffic shaper is
	// enabled on the port for ingress traffic.
	IngressShapingEnabled *bool `pulumi:"ingressShapingEnabled"`
	// The peak bandwidth during
	// bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth *int `pulumi:"ingressShapingPeakBandwidth"`
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments found
	// below.
	Ipv4Address *string `pulumi:"ipv4Address"`
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit *int `pulumi:"iscsiMaximumMbit"`
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit *int `pulumi:"iscsiReservationMbit"`
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount *int `pulumi:"iscsiShareCount"`
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel *string `pulumi:"iscsiShareLevel"`
	// The Link Aggregation Control Protocol group
	// version to use with the switch. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion *string `pulumi:"lacpApiVersion"`
	// Enables LACP for the ports that this policy
	// applies to.
	LacpEnabled *bool `pulumi:"lacpEnabled"`
	// The LACP mode. Can be one of `active` or `passive`.
	LacpMode *string `pulumi:"lacpMode"`
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation *string `pulumi:"linkDiscoveryOperation"`
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol *string `pulumi:"linkDiscoveryProtocol"`
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit *int `pulumi:"managementMaximumMbit"`
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit *int `pulumi:"managementReservationMbit"`
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount *int `pulumi:"managementShareCount"`
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel *string `pulumi:"managementShareLevel"`
	// The maximum transmission unit (MTU) for the virtual
	// switch.
	MaxMtu *int `pulumi:"maxMtu"`
	// The multicast filtering mode to use
	// with the switch. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode *string `pulumi:"multicastFilteringMode"`
	// The name of the distributed virtual switch.
	Name *string `pulumi:"name"`
	// The number of seconds after which
	// active flows are forced to be exported to the collector. Allowed range is
	// `60` to `3600`. Default: `60`.
	NetflowActiveFlowTimeout *int `pulumi:"netflowActiveFlowTimeout"`
	// IP address for the Netflow
	// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
	// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
	NetflowCollectorIpAddress *string `pulumi:"netflowCollectorIpAddress"`
	// Port for the Netflow collector. This
	// must be set before Netflow can be enabled.
	NetflowCollectorPort *int `pulumi:"netflowCollectorPort"`
	// Enables Netflow on all ports that this policy
	// applies to.
	NetflowEnabled *bool `pulumi:"netflowEnabled"`
	// The number of seconds after which
	// idle flows are forced to be exported to the collector. Allowed range is `10`
	// to `600`. Default: `15`.
	NetflowIdleFlowTimeout *int `pulumi:"netflowIdleFlowTimeout"`
	// Whether to limit analysis to
	// traffic that has both source and destination served by the same host.
	// Default: `false`.
	NetflowInternalFlowsOnly *bool `pulumi:"netflowInternalFlowsOnly"`
	// The observation domain ID for
	// the Netflow collector.
	NetflowObservationDomainId *int `pulumi:"netflowObservationDomainId"`
	// The ratio of total number of packets to
	// the number of packets analyzed. The default is `0`, which indicates that the
	// switch should analyze all packets. The maximum value is `1000`, which
	// indicates an analysis rate of 0.001%.
	NetflowSamplingRate *int `pulumi:"netflowSamplingRate"`
	// Set to `true` to enable
	// network I/O control. Default: `false`.
	NetworkResourceControlEnabled *bool `pulumi:"networkResourceControlEnabled"`
	// The version of network I/O
	// control to use. Can be one of `version2` or `version3`. Default: `version2`.
	NetworkResourceControlVersion *string `pulumi:"networkResourceControlVersion"`
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit *int `pulumi:"nfsMaximumMbit"`
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit *int `pulumi:"nfsReservationMbit"`
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount *int `pulumi:"nfsShareCount"`
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel *string `pulumi:"nfsShareLevel"`
	// If `true`, the teaming policy will notify the
	// broadcast network of an uplink failover, triggering cache updates.
	NotifySwitches *bool `pulumi:"notifySwitches"`
	// Used to define a secondary VLAN
	// ID when using private VLANs.
	PortPrivateSecondaryVlanId *int `pulumi:"portPrivateSecondaryVlanId"`
	// Use the `pvlanMapping` block to declare a
	// private VLAN mapping. The options are:
	PvlanMappings []DistributedVirtualSwitchPvlanMapping `pulumi:"pvlanMappings"`
	// A list of standby uplinks to be used in
	// failover. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	StandbyUplinks []string `pulumi:"standbyUplinks"`
	// The IDs of any tags to attach to this resource.
	Tags []string `pulumi:"tags"`
	// The uplink teaming policy. Can be one of
	// `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
	// `failoverExplicit`.
	TeamingPolicy *string `pulumi:"teamingPolicy"`
	// Forward all traffic transmitted by ports for which
	// this policy applies to its DVS uplinks.
	TxUplink *bool `pulumi:"txUplink"`
	// A list of strings that uniquely identifies the names
	// of the uplinks on the DVS across hosts. The number of items in this list
	// controls the number of uplinks that exist on the DVS, in addition to the
	// names.  See here for an example on how to
	// use this option.
	Uplinks []string `pulumi:"uplinks"`
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit *int `pulumi:"vdpMaximumMbit"`
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit *int `pulumi:"vdpReservationMbit"`
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount *int `pulumi:"vdpShareCount"`
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel *string `pulumi:"vdpShareLevel"`
	// - The version of the DVS to create. The default is to
	//   create the DVS at the latest version supported by the version of vSphere
	//   being used. A DVS can be upgraded to another version, but cannot be
	//   downgraded.
	Version *string `pulumi:"version"`
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit *int `pulumi:"virtualmachineMaximumMbit"`
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit *int `pulumi:"virtualmachineReservationMbit"`
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount *int `pulumi:"virtualmachineShareCount"`
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel *string `pulumi:"virtualmachineShareLevel"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId *int `pulumi:"vlanId"`
	// Used to denote VLAN trunking. Use the `minVlan`
	// and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
	// `vlanRange` definitions are allowed, but they must not overlap. Example
	// below:
	VlanRanges []DistributedVirtualSwitchVlanRange `pulumi:"vlanRanges"`
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit *int `pulumi:"vmotionMaximumMbit"`
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit *int `pulumi:"vmotionReservationMbit"`
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount *int `pulumi:"vmotionShareCount"`
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel *string `pulumi:"vmotionShareLevel"`
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit *int `pulumi:"vsanMaximumMbit"`
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit *int `pulumi:"vsanReservationMbit"`
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount *int `pulumi:"vsanShareCount"`
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel *string `pulumi:"vsanShareLevel"`
}

type DistributedVirtualSwitchState struct {
	// A list of active uplinks to be used in load
	// balancing. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	ActiveUplinks pulumi.StringArrayInput
	// Controls whether or not a virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own.
	AllowForgedTransmits pulumi.BoolPtrInput
	// Controls whether or not the Media Access
	// Control (MAC) address can be changed.
	AllowMacChanges pulumi.BoolPtrInput
	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous pulumi.BoolPtrInput
	// Shuts down all ports in the port groups that
	// this policy applies to, effectively blocking all network access to connected
	// virtual devices.
	BlockAllPorts pulumi.BoolPtrInput
	// Enables beacon probing as an additional measure
	// to detect NIC failure.
	CheckBeacon pulumi.BoolPtrInput
	// The version string of the configuration that this spec is trying to change.
	ConfigVersion pulumi.StringPtrInput
	// The detailed contact information for the person
	// who is responsible for the DVS.
	ContactDetail pulumi.StringPtrInput
	// The name of the person who is responsible for the
	// DVS.
	ContactName pulumi.StringPtrInput
	// Map of custom attribute ids to attribute
	// value strings to set for virtual switch.
	CustomAttributes pulumi.StringMapInput
	// The ID of the datacenter where the distributed
	// virtual switch will be created. Forces a new resource if changed.
	DatacenterId pulumi.StringPtrInput
	// A detailed description for the DVS.
	Description pulumi.StringPtrInput
	// Allow VMDirectPath Gen2 for the ports
	// for which this policy applies to.
	DirectpathGen2Allowed pulumi.BoolPtrInput
	// The average bandwidth in bits
	// per second if egress traffic shaping is enabled on the port.
	EgressShapingAverageBandwidth pulumi.IntPtrInput
	// The maximum burst size allowed in
	// bytes if egress traffic shaping is enabled on the port.
	EgressShapingBurstSize pulumi.IntPtrInput
	// `true` if the traffic shaper is enabled
	// on the port for egress traffic.
	EgressShapingEnabled pulumi.BoolPtrInput
	// The peak bandwidth during bursts
	// in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth pulumi.IntPtrInput
	// If `true`, the teaming policy will re-activate failed
	// uplinks higher in precedence when they come back up.
	Failback pulumi.BoolPtrInput
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount pulumi.IntPtrInput
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel pulumi.StringPtrInput
	// The folder to create the DVS in. Forces a new resource
	// if changed.
	Folder pulumi.StringPtrInput
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount pulumi.IntPtrInput
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel pulumi.StringPtrInput
	// Use the `host` block to declare a host specification. The
	// options are:
	Hosts DistributedVirtualSwitchHostArrayInput
	// Whether to ignore existing PVLAN
	// mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings pulumi.BoolPtrInput
	// The average bandwidth in
	// bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingAverageBandwidth pulumi.IntPtrInput
	// The maximum burst size allowed in
	// bytes if ingress traffic shaping is enabled on the port.
	IngressShapingBurstSize pulumi.IntPtrInput
	// `true` if the traffic shaper is
	// enabled on the port for ingress traffic.
	IngressShapingEnabled pulumi.BoolPtrInput
	// The peak bandwidth during
	// bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth pulumi.IntPtrInput
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments found
	// below.
	Ipv4Address pulumi.StringPtrInput
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount pulumi.IntPtrInput
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel pulumi.StringPtrInput
	// The Link Aggregation Control Protocol group
	// version to use with the switch. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion pulumi.StringPtrInput
	// Enables LACP for the ports that this policy
	// applies to.
	LacpEnabled pulumi.BoolPtrInput
	// The LACP mode. Can be one of `active` or `passive`.
	LacpMode pulumi.StringPtrInput
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation pulumi.StringPtrInput
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol pulumi.StringPtrInput
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount pulumi.IntPtrInput
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel pulumi.StringPtrInput
	// The maximum transmission unit (MTU) for the virtual
	// switch.
	MaxMtu pulumi.IntPtrInput
	// The multicast filtering mode to use
	// with the switch. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode pulumi.StringPtrInput
	// The name of the distributed virtual switch.
	Name pulumi.StringPtrInput
	// The number of seconds after which
	// active flows are forced to be exported to the collector. Allowed range is
	// `60` to `3600`. Default: `60`.
	NetflowActiveFlowTimeout pulumi.IntPtrInput
	// IP address for the Netflow
	// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
	// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
	NetflowCollectorIpAddress pulumi.StringPtrInput
	// Port for the Netflow collector. This
	// must be set before Netflow can be enabled.
	NetflowCollectorPort pulumi.IntPtrInput
	// Enables Netflow on all ports that this policy
	// applies to.
	NetflowEnabled pulumi.BoolPtrInput
	// The number of seconds after which
	// idle flows are forced to be exported to the collector. Allowed range is `10`
	// to `600`. Default: `15`.
	NetflowIdleFlowTimeout pulumi.IntPtrInput
	// Whether to limit analysis to
	// traffic that has both source and destination served by the same host.
	// Default: `false`.
	NetflowInternalFlowsOnly pulumi.BoolPtrInput
	// The observation domain ID for
	// the Netflow collector.
	NetflowObservationDomainId pulumi.IntPtrInput
	// The ratio of total number of packets to
	// the number of packets analyzed. The default is `0`, which indicates that the
	// switch should analyze all packets. The maximum value is `1000`, which
	// indicates an analysis rate of 0.001%.
	NetflowSamplingRate pulumi.IntPtrInput
	// Set to `true` to enable
	// network I/O control. Default: `false`.
	NetworkResourceControlEnabled pulumi.BoolPtrInput
	// The version of network I/O
	// control to use. Can be one of `version2` or `version3`. Default: `version2`.
	NetworkResourceControlVersion pulumi.StringPtrInput
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount pulumi.IntPtrInput
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel pulumi.StringPtrInput
	// If `true`, the teaming policy will notify the
	// broadcast network of an uplink failover, triggering cache updates.
	NotifySwitches pulumi.BoolPtrInput
	// Used to define a secondary VLAN
	// ID when using private VLANs.
	PortPrivateSecondaryVlanId pulumi.IntPtrInput
	// Use the `pvlanMapping` block to declare a
	// private VLAN mapping. The options are:
	PvlanMappings DistributedVirtualSwitchPvlanMappingArrayInput
	// A list of standby uplinks to be used in
	// failover. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	StandbyUplinks pulumi.StringArrayInput
	// The IDs of any tags to attach to this resource.
	Tags pulumi.StringArrayInput
	// The uplink teaming policy. Can be one of
	// `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
	// `failoverExplicit`.
	TeamingPolicy pulumi.StringPtrInput
	// Forward all traffic transmitted by ports for which
	// this policy applies to its DVS uplinks.
	TxUplink pulumi.BoolPtrInput
	// A list of strings that uniquely identifies the names
	// of the uplinks on the DVS across hosts. The number of items in this list
	// controls the number of uplinks that exist on the DVS, in addition to the
	// names.  See here for an example on how to
	// use this option.
	Uplinks pulumi.StringArrayInput
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount pulumi.IntPtrInput
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel pulumi.StringPtrInput
	// - The version of the DVS to create. The default is to
	//   create the DVS at the latest version supported by the version of vSphere
	//   being used. A DVS can be upgraded to another version, but cannot be
	//   downgraded.
	Version pulumi.StringPtrInput
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount pulumi.IntPtrInput
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel pulumi.StringPtrInput
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId pulumi.IntPtrInput
	// Used to denote VLAN trunking. Use the `minVlan`
	// and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
	// `vlanRange` definitions are allowed, but they must not overlap. Example
	// below:
	VlanRanges DistributedVirtualSwitchVlanRangeArrayInput
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount pulumi.IntPtrInput
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel pulumi.StringPtrInput
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount pulumi.IntPtrInput
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel pulumi.StringPtrInput
}

func (DistributedVirtualSwitchState) ElementType() reflect.Type {
	return reflect.TypeOf((*distributedVirtualSwitchState)(nil)).Elem()
}

type distributedVirtualSwitchArgs struct {
	// A list of active uplinks to be used in load
	// balancing. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	ActiveUplinks []string `pulumi:"activeUplinks"`
	// Controls whether or not a virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own.
	AllowForgedTransmits *bool `pulumi:"allowForgedTransmits"`
	// Controls whether or not the Media Access
	// Control (MAC) address can be changed.
	AllowMacChanges *bool `pulumi:"allowMacChanges"`
	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous *bool `pulumi:"allowPromiscuous"`
	// Shuts down all ports in the port groups that
	// this policy applies to, effectively blocking all network access to connected
	// virtual devices.
	BlockAllPorts *bool `pulumi:"blockAllPorts"`
	// Enables beacon probing as an additional measure
	// to detect NIC failure.
	CheckBeacon *bool `pulumi:"checkBeacon"`
	// The detailed contact information for the person
	// who is responsible for the DVS.
	ContactDetail *string `pulumi:"contactDetail"`
	// The name of the person who is responsible for the
	// DVS.
	ContactName *string `pulumi:"contactName"`
	// Map of custom attribute ids to attribute
	// value strings to set for virtual switch.
	CustomAttributes map[string]string `pulumi:"customAttributes"`
	// The ID of the datacenter where the distributed
	// virtual switch will be created. Forces a new resource if changed.
	DatacenterId string `pulumi:"datacenterId"`
	// A detailed description for the DVS.
	Description *string `pulumi:"description"`
	// Allow VMDirectPath Gen2 for the ports
	// for which this policy applies to.
	DirectpathGen2Allowed *bool `pulumi:"directpathGen2Allowed"`
	// The average bandwidth in bits
	// per second if egress traffic shaping is enabled on the port.
	EgressShapingAverageBandwidth *int `pulumi:"egressShapingAverageBandwidth"`
	// The maximum burst size allowed in
	// bytes if egress traffic shaping is enabled on the port.
	EgressShapingBurstSize *int `pulumi:"egressShapingBurstSize"`
	// `true` if the traffic shaper is enabled
	// on the port for egress traffic.
	EgressShapingEnabled *bool `pulumi:"egressShapingEnabled"`
	// The peak bandwidth during bursts
	// in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth *int `pulumi:"egressShapingPeakBandwidth"`
	// If `true`, the teaming policy will re-activate failed
	// uplinks higher in precedence when they come back up.
	Failback *bool `pulumi:"failback"`
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit *int `pulumi:"faulttoleranceMaximumMbit"`
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit *int `pulumi:"faulttoleranceReservationMbit"`
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount *int `pulumi:"faulttoleranceShareCount"`
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel *string `pulumi:"faulttoleranceShareLevel"`
	// The folder to create the DVS in. Forces a new resource
	// if changed.
	Folder *string `pulumi:"folder"`
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit *int `pulumi:"hbrMaximumMbit"`
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit *int `pulumi:"hbrReservationMbit"`
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount *int `pulumi:"hbrShareCount"`
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel *string `pulumi:"hbrShareLevel"`
	// Use the `host` block to declare a host specification. The
	// options are:
	Hosts []DistributedVirtualSwitchHost `pulumi:"hosts"`
	// Whether to ignore existing PVLAN
	// mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings *bool `pulumi:"ignoreOtherPvlanMappings"`
	// The average bandwidth in
	// bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingAverageBandwidth *int `pulumi:"ingressShapingAverageBandwidth"`
	// The maximum burst size allowed in
	// bytes if ingress traffic shaping is enabled on the port.
	IngressShapingBurstSize *int `pulumi:"ingressShapingBurstSize"`
	// `true` if the traffic shaper is
	// enabled on the port for ingress traffic.
	IngressShapingEnabled *bool `pulumi:"ingressShapingEnabled"`
	// The peak bandwidth during
	// bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth *int `pulumi:"ingressShapingPeakBandwidth"`
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments found
	// below.
	Ipv4Address *string `pulumi:"ipv4Address"`
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit *int `pulumi:"iscsiMaximumMbit"`
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit *int `pulumi:"iscsiReservationMbit"`
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount *int `pulumi:"iscsiShareCount"`
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel *string `pulumi:"iscsiShareLevel"`
	// The Link Aggregation Control Protocol group
	// version to use with the switch. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion *string `pulumi:"lacpApiVersion"`
	// Enables LACP for the ports that this policy
	// applies to.
	LacpEnabled *bool `pulumi:"lacpEnabled"`
	// The LACP mode. Can be one of `active` or `passive`.
	LacpMode *string `pulumi:"lacpMode"`
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation *string `pulumi:"linkDiscoveryOperation"`
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol *string `pulumi:"linkDiscoveryProtocol"`
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit *int `pulumi:"managementMaximumMbit"`
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit *int `pulumi:"managementReservationMbit"`
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount *int `pulumi:"managementShareCount"`
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel *string `pulumi:"managementShareLevel"`
	// The maximum transmission unit (MTU) for the virtual
	// switch.
	MaxMtu *int `pulumi:"maxMtu"`
	// The multicast filtering mode to use
	// with the switch. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode *string `pulumi:"multicastFilteringMode"`
	// The name of the distributed virtual switch.
	Name *string `pulumi:"name"`
	// The number of seconds after which
	// active flows are forced to be exported to the collector. Allowed range is
	// `60` to `3600`. Default: `60`.
	NetflowActiveFlowTimeout *int `pulumi:"netflowActiveFlowTimeout"`
	// IP address for the Netflow
	// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
	// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
	NetflowCollectorIpAddress *string `pulumi:"netflowCollectorIpAddress"`
	// Port for the Netflow collector. This
	// must be set before Netflow can be enabled.
	NetflowCollectorPort *int `pulumi:"netflowCollectorPort"`
	// Enables Netflow on all ports that this policy
	// applies to.
	NetflowEnabled *bool `pulumi:"netflowEnabled"`
	// The number of seconds after which
	// idle flows are forced to be exported to the collector. Allowed range is `10`
	// to `600`. Default: `15`.
	NetflowIdleFlowTimeout *int `pulumi:"netflowIdleFlowTimeout"`
	// Whether to limit analysis to
	// traffic that has both source and destination served by the same host.
	// Default: `false`.
	NetflowInternalFlowsOnly *bool `pulumi:"netflowInternalFlowsOnly"`
	// The observation domain ID for
	// the Netflow collector.
	NetflowObservationDomainId *int `pulumi:"netflowObservationDomainId"`
	// The ratio of total number of packets to
	// the number of packets analyzed. The default is `0`, which indicates that the
	// switch should analyze all packets. The maximum value is `1000`, which
	// indicates an analysis rate of 0.001%.
	NetflowSamplingRate *int `pulumi:"netflowSamplingRate"`
	// Set to `true` to enable
	// network I/O control. Default: `false`.
	NetworkResourceControlEnabled *bool `pulumi:"networkResourceControlEnabled"`
	// The version of network I/O
	// control to use. Can be one of `version2` or `version3`. Default: `version2`.
	NetworkResourceControlVersion *string `pulumi:"networkResourceControlVersion"`
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit *int `pulumi:"nfsMaximumMbit"`
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit *int `pulumi:"nfsReservationMbit"`
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount *int `pulumi:"nfsShareCount"`
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel *string `pulumi:"nfsShareLevel"`
	// If `true`, the teaming policy will notify the
	// broadcast network of an uplink failover, triggering cache updates.
	NotifySwitches *bool `pulumi:"notifySwitches"`
	// Used to define a secondary VLAN
	// ID when using private VLANs.
	PortPrivateSecondaryVlanId *int `pulumi:"portPrivateSecondaryVlanId"`
	// Use the `pvlanMapping` block to declare a
	// private VLAN mapping. The options are:
	PvlanMappings []DistributedVirtualSwitchPvlanMapping `pulumi:"pvlanMappings"`
	// A list of standby uplinks to be used in
	// failover. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	StandbyUplinks []string `pulumi:"standbyUplinks"`
	// The IDs of any tags to attach to this resource.
	Tags []string `pulumi:"tags"`
	// The uplink teaming policy. Can be one of
	// `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
	// `failoverExplicit`.
	TeamingPolicy *string `pulumi:"teamingPolicy"`
	// Forward all traffic transmitted by ports for which
	// this policy applies to its DVS uplinks.
	TxUplink *bool `pulumi:"txUplink"`
	// A list of strings that uniquely identifies the names
	// of the uplinks on the DVS across hosts. The number of items in this list
	// controls the number of uplinks that exist on the DVS, in addition to the
	// names.  See here for an example on how to
	// use this option.
	Uplinks []string `pulumi:"uplinks"`
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit *int `pulumi:"vdpMaximumMbit"`
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit *int `pulumi:"vdpReservationMbit"`
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount *int `pulumi:"vdpShareCount"`
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel *string `pulumi:"vdpShareLevel"`
	// - The version of the DVS to create. The default is to
	//   create the DVS at the latest version supported by the version of vSphere
	//   being used. A DVS can be upgraded to another version, but cannot be
	//   downgraded.
	Version *string `pulumi:"version"`
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit *int `pulumi:"virtualmachineMaximumMbit"`
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit *int `pulumi:"virtualmachineReservationMbit"`
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount *int `pulumi:"virtualmachineShareCount"`
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel *string `pulumi:"virtualmachineShareLevel"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId *int `pulumi:"vlanId"`
	// Used to denote VLAN trunking. Use the `minVlan`
	// and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
	// `vlanRange` definitions are allowed, but they must not overlap. Example
	// below:
	VlanRanges []DistributedVirtualSwitchVlanRange `pulumi:"vlanRanges"`
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit *int `pulumi:"vmotionMaximumMbit"`
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit *int `pulumi:"vmotionReservationMbit"`
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount *int `pulumi:"vmotionShareCount"`
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel *string `pulumi:"vmotionShareLevel"`
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit *int `pulumi:"vsanMaximumMbit"`
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit *int `pulumi:"vsanReservationMbit"`
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount *int `pulumi:"vsanShareCount"`
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel *string `pulumi:"vsanShareLevel"`
}

// The set of arguments for constructing a DistributedVirtualSwitch resource.
type DistributedVirtualSwitchArgs struct {
	// A list of active uplinks to be used in load
	// balancing. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	ActiveUplinks pulumi.StringArrayInput
	// Controls whether or not a virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own.
	AllowForgedTransmits pulumi.BoolPtrInput
	// Controls whether or not the Media Access
	// Control (MAC) address can be changed.
	AllowMacChanges pulumi.BoolPtrInput
	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous pulumi.BoolPtrInput
	// Shuts down all ports in the port groups that
	// this policy applies to, effectively blocking all network access to connected
	// virtual devices.
	BlockAllPorts pulumi.BoolPtrInput
	// Enables beacon probing as an additional measure
	// to detect NIC failure.
	CheckBeacon pulumi.BoolPtrInput
	// The detailed contact information for the person
	// who is responsible for the DVS.
	ContactDetail pulumi.StringPtrInput
	// The name of the person who is responsible for the
	// DVS.
	ContactName pulumi.StringPtrInput
	// Map of custom attribute ids to attribute
	// value strings to set for virtual switch.
	CustomAttributes pulumi.StringMapInput
	// The ID of the datacenter where the distributed
	// virtual switch will be created. Forces a new resource if changed.
	DatacenterId pulumi.StringInput
	// A detailed description for the DVS.
	Description pulumi.StringPtrInput
	// Allow VMDirectPath Gen2 for the ports
	// for which this policy applies to.
	DirectpathGen2Allowed pulumi.BoolPtrInput
	// The average bandwidth in bits
	// per second if egress traffic shaping is enabled on the port.
	EgressShapingAverageBandwidth pulumi.IntPtrInput
	// The maximum burst size allowed in
	// bytes if egress traffic shaping is enabled on the port.
	EgressShapingBurstSize pulumi.IntPtrInput
	// `true` if the traffic shaper is enabled
	// on the port for egress traffic.
	EgressShapingEnabled pulumi.BoolPtrInput
	// The peak bandwidth during bursts
	// in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth pulumi.IntPtrInput
	// If `true`, the teaming policy will re-activate failed
	// uplinks higher in precedence when they come back up.
	Failback pulumi.BoolPtrInput
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount pulumi.IntPtrInput
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel pulumi.StringPtrInput
	// The folder to create the DVS in. Forces a new resource
	// if changed.
	Folder pulumi.StringPtrInput
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount pulumi.IntPtrInput
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel pulumi.StringPtrInput
	// Use the `host` block to declare a host specification. The
	// options are:
	Hosts DistributedVirtualSwitchHostArrayInput
	// Whether to ignore existing PVLAN
	// mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings pulumi.BoolPtrInput
	// The average bandwidth in
	// bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingAverageBandwidth pulumi.IntPtrInput
	// The maximum burst size allowed in
	// bytes if ingress traffic shaping is enabled on the port.
	IngressShapingBurstSize pulumi.IntPtrInput
	// `true` if the traffic shaper is
	// enabled on the port for ingress traffic.
	IngressShapingEnabled pulumi.BoolPtrInput
	// The peak bandwidth during
	// bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth pulumi.IntPtrInput
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments found
	// below.
	Ipv4Address pulumi.StringPtrInput
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount pulumi.IntPtrInput
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel pulumi.StringPtrInput
	// The Link Aggregation Control Protocol group
	// version to use with the switch. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion pulumi.StringPtrInput
	// Enables LACP for the ports that this policy
	// applies to.
	LacpEnabled pulumi.BoolPtrInput
	// The LACP mode. Can be one of `active` or `passive`.
	LacpMode pulumi.StringPtrInput
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation pulumi.StringPtrInput
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol pulumi.StringPtrInput
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount pulumi.IntPtrInput
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel pulumi.StringPtrInput
	// The maximum transmission unit (MTU) for the virtual
	// switch.
	MaxMtu pulumi.IntPtrInput
	// The multicast filtering mode to use
	// with the switch. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode pulumi.StringPtrInput
	// The name of the distributed virtual switch.
	Name pulumi.StringPtrInput
	// The number of seconds after which
	// active flows are forced to be exported to the collector. Allowed range is
	// `60` to `3600`. Default: `60`.
	NetflowActiveFlowTimeout pulumi.IntPtrInput
	// IP address for the Netflow
	// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
	// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
	NetflowCollectorIpAddress pulumi.StringPtrInput
	// Port for the Netflow collector. This
	// must be set before Netflow can be enabled.
	NetflowCollectorPort pulumi.IntPtrInput
	// Enables Netflow on all ports that this policy
	// applies to.
	NetflowEnabled pulumi.BoolPtrInput
	// The number of seconds after which
	// idle flows are forced to be exported to the collector. Allowed range is `10`
	// to `600`. Default: `15`.
	NetflowIdleFlowTimeout pulumi.IntPtrInput
	// Whether to limit analysis to
	// traffic that has both source and destination served by the same host.
	// Default: `false`.
	NetflowInternalFlowsOnly pulumi.BoolPtrInput
	// The observation domain ID for
	// the Netflow collector.
	NetflowObservationDomainId pulumi.IntPtrInput
	// The ratio of total number of packets to
	// the number of packets analyzed. The default is `0`, which indicates that the
	// switch should analyze all packets. The maximum value is `1000`, which
	// indicates an analysis rate of 0.001%.
	NetflowSamplingRate pulumi.IntPtrInput
	// Set to `true` to enable
	// network I/O control. Default: `false`.
	NetworkResourceControlEnabled pulumi.BoolPtrInput
	// The version of network I/O
	// control to use. Can be one of `version2` or `version3`. Default: `version2`.
	NetworkResourceControlVersion pulumi.StringPtrInput
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount pulumi.IntPtrInput
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel pulumi.StringPtrInput
	// If `true`, the teaming policy will notify the
	// broadcast network of an uplink failover, triggering cache updates.
	NotifySwitches pulumi.BoolPtrInput
	// Used to define a secondary VLAN
	// ID when using private VLANs.
	PortPrivateSecondaryVlanId pulumi.IntPtrInput
	// Use the `pvlanMapping` block to declare a
	// private VLAN mapping. The options are:
	PvlanMappings DistributedVirtualSwitchPvlanMappingArrayInput
	// A list of standby uplinks to be used in
	// failover. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	StandbyUplinks pulumi.StringArrayInput
	// The IDs of any tags to attach to this resource.
	Tags pulumi.StringArrayInput
	// The uplink teaming policy. Can be one of
	// `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
	// `failoverExplicit`.
	TeamingPolicy pulumi.StringPtrInput
	// Forward all traffic transmitted by ports for which
	// this policy applies to its DVS uplinks.
	TxUplink pulumi.BoolPtrInput
	// A list of strings that uniquely identifies the names
	// of the uplinks on the DVS across hosts. The number of items in this list
	// controls the number of uplinks that exist on the DVS, in addition to the
	// names.  See here for an example on how to
	// use this option.
	Uplinks pulumi.StringArrayInput
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount pulumi.IntPtrInput
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel pulumi.StringPtrInput
	// - The version of the DVS to create. The default is to
	//   create the DVS at the latest version supported by the version of vSphere
	//   being used. A DVS can be upgraded to another version, but cannot be
	//   downgraded.
	Version pulumi.StringPtrInput
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount pulumi.IntPtrInput
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel pulumi.StringPtrInput
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId pulumi.IntPtrInput
	// Used to denote VLAN trunking. Use the `minVlan`
	// and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
	// `vlanRange` definitions are allowed, but they must not overlap. Example
	// below:
	VlanRanges DistributedVirtualSwitchVlanRangeArrayInput
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount pulumi.IntPtrInput
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel pulumi.StringPtrInput
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit pulumi.IntPtrInput
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit pulumi.IntPtrInput
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount pulumi.IntPtrInput
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel pulumi.StringPtrInput
}

func (DistributedVirtualSwitchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*distributedVirtualSwitchArgs)(nil)).Elem()
}

type DistributedVirtualSwitchInput interface {
	pulumi.Input

	ToDistributedVirtualSwitchOutput() DistributedVirtualSwitchOutput
	ToDistributedVirtualSwitchOutputWithContext(ctx context.Context) DistributedVirtualSwitchOutput
}

func (*DistributedVirtualSwitch) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributedVirtualSwitch)(nil))
}

func (i *DistributedVirtualSwitch) ToDistributedVirtualSwitchOutput() DistributedVirtualSwitchOutput {
	return i.ToDistributedVirtualSwitchOutputWithContext(context.Background())
}

func (i *DistributedVirtualSwitch) ToDistributedVirtualSwitchOutputWithContext(ctx context.Context) DistributedVirtualSwitchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributedVirtualSwitchOutput)
}

func (i *DistributedVirtualSwitch) ToDistributedVirtualSwitchPtrOutput() DistributedVirtualSwitchPtrOutput {
	return i.ToDistributedVirtualSwitchPtrOutputWithContext(context.Background())
}

func (i *DistributedVirtualSwitch) ToDistributedVirtualSwitchPtrOutputWithContext(ctx context.Context) DistributedVirtualSwitchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributedVirtualSwitchPtrOutput)
}

type DistributedVirtualSwitchPtrInput interface {
	pulumi.Input

	ToDistributedVirtualSwitchPtrOutput() DistributedVirtualSwitchPtrOutput
	ToDistributedVirtualSwitchPtrOutputWithContext(ctx context.Context) DistributedVirtualSwitchPtrOutput
}

type distributedVirtualSwitchPtrType DistributedVirtualSwitchArgs

func (*distributedVirtualSwitchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributedVirtualSwitch)(nil))
}

func (i *distributedVirtualSwitchPtrType) ToDistributedVirtualSwitchPtrOutput() DistributedVirtualSwitchPtrOutput {
	return i.ToDistributedVirtualSwitchPtrOutputWithContext(context.Background())
}

func (i *distributedVirtualSwitchPtrType) ToDistributedVirtualSwitchPtrOutputWithContext(ctx context.Context) DistributedVirtualSwitchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributedVirtualSwitchPtrOutput)
}

// DistributedVirtualSwitchArrayInput is an input type that accepts DistributedVirtualSwitchArray and DistributedVirtualSwitchArrayOutput values.
// You can construct a concrete instance of `DistributedVirtualSwitchArrayInput` via:
//
//          DistributedVirtualSwitchArray{ DistributedVirtualSwitchArgs{...} }
type DistributedVirtualSwitchArrayInput interface {
	pulumi.Input

	ToDistributedVirtualSwitchArrayOutput() DistributedVirtualSwitchArrayOutput
	ToDistributedVirtualSwitchArrayOutputWithContext(context.Context) DistributedVirtualSwitchArrayOutput
}

type DistributedVirtualSwitchArray []DistributedVirtualSwitchInput

func (DistributedVirtualSwitchArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*DistributedVirtualSwitch)(nil))
}

func (i DistributedVirtualSwitchArray) ToDistributedVirtualSwitchArrayOutput() DistributedVirtualSwitchArrayOutput {
	return i.ToDistributedVirtualSwitchArrayOutputWithContext(context.Background())
}

func (i DistributedVirtualSwitchArray) ToDistributedVirtualSwitchArrayOutputWithContext(ctx context.Context) DistributedVirtualSwitchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributedVirtualSwitchArrayOutput)
}

// DistributedVirtualSwitchMapInput is an input type that accepts DistributedVirtualSwitchMap and DistributedVirtualSwitchMapOutput values.
// You can construct a concrete instance of `DistributedVirtualSwitchMapInput` via:
//
//          DistributedVirtualSwitchMap{ "key": DistributedVirtualSwitchArgs{...} }
type DistributedVirtualSwitchMapInput interface {
	pulumi.Input

	ToDistributedVirtualSwitchMapOutput() DistributedVirtualSwitchMapOutput
	ToDistributedVirtualSwitchMapOutputWithContext(context.Context) DistributedVirtualSwitchMapOutput
}

type DistributedVirtualSwitchMap map[string]DistributedVirtualSwitchInput

func (DistributedVirtualSwitchMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*DistributedVirtualSwitch)(nil))
}

func (i DistributedVirtualSwitchMap) ToDistributedVirtualSwitchMapOutput() DistributedVirtualSwitchMapOutput {
	return i.ToDistributedVirtualSwitchMapOutputWithContext(context.Background())
}

func (i DistributedVirtualSwitchMap) ToDistributedVirtualSwitchMapOutputWithContext(ctx context.Context) DistributedVirtualSwitchMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DistributedVirtualSwitchMapOutput)
}

type DistributedVirtualSwitchOutput struct {
	*pulumi.OutputState
}

func (DistributedVirtualSwitchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DistributedVirtualSwitch)(nil))
}

func (o DistributedVirtualSwitchOutput) ToDistributedVirtualSwitchOutput() DistributedVirtualSwitchOutput {
	return o
}

func (o DistributedVirtualSwitchOutput) ToDistributedVirtualSwitchOutputWithContext(ctx context.Context) DistributedVirtualSwitchOutput {
	return o
}

func (o DistributedVirtualSwitchOutput) ToDistributedVirtualSwitchPtrOutput() DistributedVirtualSwitchPtrOutput {
	return o.ToDistributedVirtualSwitchPtrOutputWithContext(context.Background())
}

func (o DistributedVirtualSwitchOutput) ToDistributedVirtualSwitchPtrOutputWithContext(ctx context.Context) DistributedVirtualSwitchPtrOutput {
	return o.ApplyT(func(v DistributedVirtualSwitch) *DistributedVirtualSwitch {
		return &v
	}).(DistributedVirtualSwitchPtrOutput)
}

type DistributedVirtualSwitchPtrOutput struct {
	*pulumi.OutputState
}

func (DistributedVirtualSwitchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DistributedVirtualSwitch)(nil))
}

func (o DistributedVirtualSwitchPtrOutput) ToDistributedVirtualSwitchPtrOutput() DistributedVirtualSwitchPtrOutput {
	return o
}

func (o DistributedVirtualSwitchPtrOutput) ToDistributedVirtualSwitchPtrOutputWithContext(ctx context.Context) DistributedVirtualSwitchPtrOutput {
	return o
}

type DistributedVirtualSwitchArrayOutput struct{ *pulumi.OutputState }

func (DistributedVirtualSwitchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DistributedVirtualSwitch)(nil))
}

func (o DistributedVirtualSwitchArrayOutput) ToDistributedVirtualSwitchArrayOutput() DistributedVirtualSwitchArrayOutput {
	return o
}

func (o DistributedVirtualSwitchArrayOutput) ToDistributedVirtualSwitchArrayOutputWithContext(ctx context.Context) DistributedVirtualSwitchArrayOutput {
	return o
}

func (o DistributedVirtualSwitchArrayOutput) Index(i pulumi.IntInput) DistributedVirtualSwitchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DistributedVirtualSwitch {
		return vs[0].([]DistributedVirtualSwitch)[vs[1].(int)]
	}).(DistributedVirtualSwitchOutput)
}

type DistributedVirtualSwitchMapOutput struct{ *pulumi.OutputState }

func (DistributedVirtualSwitchMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]DistributedVirtualSwitch)(nil))
}

func (o DistributedVirtualSwitchMapOutput) ToDistributedVirtualSwitchMapOutput() DistributedVirtualSwitchMapOutput {
	return o
}

func (o DistributedVirtualSwitchMapOutput) ToDistributedVirtualSwitchMapOutputWithContext(ctx context.Context) DistributedVirtualSwitchMapOutput {
	return o
}

func (o DistributedVirtualSwitchMapOutput) MapIndex(k pulumi.StringInput) DistributedVirtualSwitchOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) DistributedVirtualSwitch {
		return vs[0].(map[string]DistributedVirtualSwitch)[vs[1].(string)]
	}).(DistributedVirtualSwitchOutput)
}

func init() {
	pulumi.RegisterOutputType(DistributedVirtualSwitchOutput{})
	pulumi.RegisterOutputType(DistributedVirtualSwitchPtrOutput{})
	pulumi.RegisterOutputType(DistributedVirtualSwitchArrayOutput{})
	pulumi.RegisterOutputType(DistributedVirtualSwitchMapOutput{})
}
