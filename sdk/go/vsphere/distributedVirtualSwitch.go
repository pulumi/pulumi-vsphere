// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package vsphere

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// The `.DistributedVirtualSwitch` resource can be used to manage VMware
// Distributed Virtual Switches.
//
// An essential component of a distributed, scalable VMware datacenter, the
// vSphere Distributed Virtual Switch (DVS) provides centralized management and
// monitoring of the networking configuration of all the hosts that are associated
// with the switch. In addition to adding port groups (see the
// [`.DistributedPortGroup`][distributed-port-group] resource) that can
// be used as networks for virtual machines, a DVS can be configured to perform
// advanced high availability, traffic shaping, network monitoring, and more.
//
// For an overview on vSphere networking concepts, see [this
// page][ref-vsphere-net-concepts]. For more information on vSphere DVS, see [this
// page][ref-vsphere-dvs].
//
// [distributed-port-group]: /docs/providers/vsphere/r/distributed_port_group.html
// [ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html
// [ref-vsphere-dvs]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-375B45C7-684C-4C51-BA3C-70E48DFABF04.html
//
// > **NOTE:** This resource requires vCenter and is not available on direct ESXi
// connections.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-vsphere/blob/master/website/docs/r/distributed_virtual_switch.html.markdown.
type DistributedVirtualSwitch struct {
	s *pulumi.ResourceState
}

// NewDistributedVirtualSwitch registers a new resource with the given unique name, arguments, and options.
func NewDistributedVirtualSwitch(ctx *pulumi.Context,
	name string, args *DistributedVirtualSwitchArgs, opts ...pulumi.ResourceOpt) (*DistributedVirtualSwitch, error) {
	if args == nil || args.DatacenterId == nil {
		return nil, errors.New("missing required argument 'DatacenterId'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["activeUplinks"] = nil
		inputs["allowForgedTransmits"] = nil
		inputs["allowMacChanges"] = nil
		inputs["allowPromiscuous"] = nil
		inputs["blockAllPorts"] = nil
		inputs["checkBeacon"] = nil
		inputs["contactDetail"] = nil
		inputs["contactName"] = nil
		inputs["customAttributes"] = nil
		inputs["datacenterId"] = nil
		inputs["description"] = nil
		inputs["directpathGen2Allowed"] = nil
		inputs["egressShapingAverageBandwidth"] = nil
		inputs["egressShapingBurstSize"] = nil
		inputs["egressShapingEnabled"] = nil
		inputs["egressShapingPeakBandwidth"] = nil
		inputs["failback"] = nil
		inputs["faulttoleranceMaximumMbit"] = nil
		inputs["faulttoleranceReservationMbit"] = nil
		inputs["faulttoleranceShareCount"] = nil
		inputs["faulttoleranceShareLevel"] = nil
		inputs["folder"] = nil
		inputs["hbrMaximumMbit"] = nil
		inputs["hbrReservationMbit"] = nil
		inputs["hbrShareCount"] = nil
		inputs["hbrShareLevel"] = nil
		inputs["hosts"] = nil
		inputs["ingressShapingAverageBandwidth"] = nil
		inputs["ingressShapingBurstSize"] = nil
		inputs["ingressShapingEnabled"] = nil
		inputs["ingressShapingPeakBandwidth"] = nil
		inputs["ipv4Address"] = nil
		inputs["iscsiMaximumMbit"] = nil
		inputs["iscsiReservationMbit"] = nil
		inputs["iscsiShareCount"] = nil
		inputs["iscsiShareLevel"] = nil
		inputs["lacpApiVersion"] = nil
		inputs["lacpEnabled"] = nil
		inputs["lacpMode"] = nil
		inputs["linkDiscoveryOperation"] = nil
		inputs["linkDiscoveryProtocol"] = nil
		inputs["managementMaximumMbit"] = nil
		inputs["managementReservationMbit"] = nil
		inputs["managementShareCount"] = nil
		inputs["managementShareLevel"] = nil
		inputs["maxMtu"] = nil
		inputs["multicastFilteringMode"] = nil
		inputs["name"] = nil
		inputs["netflowActiveFlowTimeout"] = nil
		inputs["netflowCollectorIpAddress"] = nil
		inputs["netflowCollectorPort"] = nil
		inputs["netflowEnabled"] = nil
		inputs["netflowIdleFlowTimeout"] = nil
		inputs["netflowInternalFlowsOnly"] = nil
		inputs["netflowObservationDomainId"] = nil
		inputs["netflowSamplingRate"] = nil
		inputs["networkResourceControlEnabled"] = nil
		inputs["networkResourceControlVersion"] = nil
		inputs["nfsMaximumMbit"] = nil
		inputs["nfsReservationMbit"] = nil
		inputs["nfsShareCount"] = nil
		inputs["nfsShareLevel"] = nil
		inputs["notifySwitches"] = nil
		inputs["portPrivateSecondaryVlanId"] = nil
		inputs["standbyUplinks"] = nil
		inputs["tags"] = nil
		inputs["teamingPolicy"] = nil
		inputs["txUplink"] = nil
		inputs["uplinks"] = nil
		inputs["vdpMaximumMbit"] = nil
		inputs["vdpReservationMbit"] = nil
		inputs["vdpShareCount"] = nil
		inputs["vdpShareLevel"] = nil
		inputs["version"] = nil
		inputs["virtualmachineMaximumMbit"] = nil
		inputs["virtualmachineReservationMbit"] = nil
		inputs["virtualmachineShareCount"] = nil
		inputs["virtualmachineShareLevel"] = nil
		inputs["vlanId"] = nil
		inputs["vlanRanges"] = nil
		inputs["vmotionMaximumMbit"] = nil
		inputs["vmotionReservationMbit"] = nil
		inputs["vmotionShareCount"] = nil
		inputs["vmotionShareLevel"] = nil
		inputs["vsanMaximumMbit"] = nil
		inputs["vsanReservationMbit"] = nil
		inputs["vsanShareCount"] = nil
		inputs["vsanShareLevel"] = nil
	} else {
		inputs["activeUplinks"] = args.ActiveUplinks
		inputs["allowForgedTransmits"] = args.AllowForgedTransmits
		inputs["allowMacChanges"] = args.AllowMacChanges
		inputs["allowPromiscuous"] = args.AllowPromiscuous
		inputs["blockAllPorts"] = args.BlockAllPorts
		inputs["checkBeacon"] = args.CheckBeacon
		inputs["contactDetail"] = args.ContactDetail
		inputs["contactName"] = args.ContactName
		inputs["customAttributes"] = args.CustomAttributes
		inputs["datacenterId"] = args.DatacenterId
		inputs["description"] = args.Description
		inputs["directpathGen2Allowed"] = args.DirectpathGen2Allowed
		inputs["egressShapingAverageBandwidth"] = args.EgressShapingAverageBandwidth
		inputs["egressShapingBurstSize"] = args.EgressShapingBurstSize
		inputs["egressShapingEnabled"] = args.EgressShapingEnabled
		inputs["egressShapingPeakBandwidth"] = args.EgressShapingPeakBandwidth
		inputs["failback"] = args.Failback
		inputs["faulttoleranceMaximumMbit"] = args.FaulttoleranceMaximumMbit
		inputs["faulttoleranceReservationMbit"] = args.FaulttoleranceReservationMbit
		inputs["faulttoleranceShareCount"] = args.FaulttoleranceShareCount
		inputs["faulttoleranceShareLevel"] = args.FaulttoleranceShareLevel
		inputs["folder"] = args.Folder
		inputs["hbrMaximumMbit"] = args.HbrMaximumMbit
		inputs["hbrReservationMbit"] = args.HbrReservationMbit
		inputs["hbrShareCount"] = args.HbrShareCount
		inputs["hbrShareLevel"] = args.HbrShareLevel
		inputs["hosts"] = args.Hosts
		inputs["ingressShapingAverageBandwidth"] = args.IngressShapingAverageBandwidth
		inputs["ingressShapingBurstSize"] = args.IngressShapingBurstSize
		inputs["ingressShapingEnabled"] = args.IngressShapingEnabled
		inputs["ingressShapingPeakBandwidth"] = args.IngressShapingPeakBandwidth
		inputs["ipv4Address"] = args.Ipv4Address
		inputs["iscsiMaximumMbit"] = args.IscsiMaximumMbit
		inputs["iscsiReservationMbit"] = args.IscsiReservationMbit
		inputs["iscsiShareCount"] = args.IscsiShareCount
		inputs["iscsiShareLevel"] = args.IscsiShareLevel
		inputs["lacpApiVersion"] = args.LacpApiVersion
		inputs["lacpEnabled"] = args.LacpEnabled
		inputs["lacpMode"] = args.LacpMode
		inputs["linkDiscoveryOperation"] = args.LinkDiscoveryOperation
		inputs["linkDiscoveryProtocol"] = args.LinkDiscoveryProtocol
		inputs["managementMaximumMbit"] = args.ManagementMaximumMbit
		inputs["managementReservationMbit"] = args.ManagementReservationMbit
		inputs["managementShareCount"] = args.ManagementShareCount
		inputs["managementShareLevel"] = args.ManagementShareLevel
		inputs["maxMtu"] = args.MaxMtu
		inputs["multicastFilteringMode"] = args.MulticastFilteringMode
		inputs["name"] = args.Name
		inputs["netflowActiveFlowTimeout"] = args.NetflowActiveFlowTimeout
		inputs["netflowCollectorIpAddress"] = args.NetflowCollectorIpAddress
		inputs["netflowCollectorPort"] = args.NetflowCollectorPort
		inputs["netflowEnabled"] = args.NetflowEnabled
		inputs["netflowIdleFlowTimeout"] = args.NetflowIdleFlowTimeout
		inputs["netflowInternalFlowsOnly"] = args.NetflowInternalFlowsOnly
		inputs["netflowObservationDomainId"] = args.NetflowObservationDomainId
		inputs["netflowSamplingRate"] = args.NetflowSamplingRate
		inputs["networkResourceControlEnabled"] = args.NetworkResourceControlEnabled
		inputs["networkResourceControlVersion"] = args.NetworkResourceControlVersion
		inputs["nfsMaximumMbit"] = args.NfsMaximumMbit
		inputs["nfsReservationMbit"] = args.NfsReservationMbit
		inputs["nfsShareCount"] = args.NfsShareCount
		inputs["nfsShareLevel"] = args.NfsShareLevel
		inputs["notifySwitches"] = args.NotifySwitches
		inputs["portPrivateSecondaryVlanId"] = args.PortPrivateSecondaryVlanId
		inputs["standbyUplinks"] = args.StandbyUplinks
		inputs["tags"] = args.Tags
		inputs["teamingPolicy"] = args.TeamingPolicy
		inputs["txUplink"] = args.TxUplink
		inputs["uplinks"] = args.Uplinks
		inputs["vdpMaximumMbit"] = args.VdpMaximumMbit
		inputs["vdpReservationMbit"] = args.VdpReservationMbit
		inputs["vdpShareCount"] = args.VdpShareCount
		inputs["vdpShareLevel"] = args.VdpShareLevel
		inputs["version"] = args.Version
		inputs["virtualmachineMaximumMbit"] = args.VirtualmachineMaximumMbit
		inputs["virtualmachineReservationMbit"] = args.VirtualmachineReservationMbit
		inputs["virtualmachineShareCount"] = args.VirtualmachineShareCount
		inputs["virtualmachineShareLevel"] = args.VirtualmachineShareLevel
		inputs["vlanId"] = args.VlanId
		inputs["vlanRanges"] = args.VlanRanges
		inputs["vmotionMaximumMbit"] = args.VmotionMaximumMbit
		inputs["vmotionReservationMbit"] = args.VmotionReservationMbit
		inputs["vmotionShareCount"] = args.VmotionShareCount
		inputs["vmotionShareLevel"] = args.VmotionShareLevel
		inputs["vsanMaximumMbit"] = args.VsanMaximumMbit
		inputs["vsanReservationMbit"] = args.VsanReservationMbit
		inputs["vsanShareCount"] = args.VsanShareCount
		inputs["vsanShareLevel"] = args.VsanShareLevel
	}
	inputs["configVersion"] = nil
	s, err := ctx.RegisterResource("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &DistributedVirtualSwitch{s: s}, nil
}

// GetDistributedVirtualSwitch gets an existing DistributedVirtualSwitch resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDistributedVirtualSwitch(ctx *pulumi.Context,
	name string, id pulumi.ID, state *DistributedVirtualSwitchState, opts ...pulumi.ResourceOpt) (*DistributedVirtualSwitch, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["activeUplinks"] = state.ActiveUplinks
		inputs["allowForgedTransmits"] = state.AllowForgedTransmits
		inputs["allowMacChanges"] = state.AllowMacChanges
		inputs["allowPromiscuous"] = state.AllowPromiscuous
		inputs["blockAllPorts"] = state.BlockAllPorts
		inputs["checkBeacon"] = state.CheckBeacon
		inputs["configVersion"] = state.ConfigVersion
		inputs["contactDetail"] = state.ContactDetail
		inputs["contactName"] = state.ContactName
		inputs["customAttributes"] = state.CustomAttributes
		inputs["datacenterId"] = state.DatacenterId
		inputs["description"] = state.Description
		inputs["directpathGen2Allowed"] = state.DirectpathGen2Allowed
		inputs["egressShapingAverageBandwidth"] = state.EgressShapingAverageBandwidth
		inputs["egressShapingBurstSize"] = state.EgressShapingBurstSize
		inputs["egressShapingEnabled"] = state.EgressShapingEnabled
		inputs["egressShapingPeakBandwidth"] = state.EgressShapingPeakBandwidth
		inputs["failback"] = state.Failback
		inputs["faulttoleranceMaximumMbit"] = state.FaulttoleranceMaximumMbit
		inputs["faulttoleranceReservationMbit"] = state.FaulttoleranceReservationMbit
		inputs["faulttoleranceShareCount"] = state.FaulttoleranceShareCount
		inputs["faulttoleranceShareLevel"] = state.FaulttoleranceShareLevel
		inputs["folder"] = state.Folder
		inputs["hbrMaximumMbit"] = state.HbrMaximumMbit
		inputs["hbrReservationMbit"] = state.HbrReservationMbit
		inputs["hbrShareCount"] = state.HbrShareCount
		inputs["hbrShareLevel"] = state.HbrShareLevel
		inputs["hosts"] = state.Hosts
		inputs["ingressShapingAverageBandwidth"] = state.IngressShapingAverageBandwidth
		inputs["ingressShapingBurstSize"] = state.IngressShapingBurstSize
		inputs["ingressShapingEnabled"] = state.IngressShapingEnabled
		inputs["ingressShapingPeakBandwidth"] = state.IngressShapingPeakBandwidth
		inputs["ipv4Address"] = state.Ipv4Address
		inputs["iscsiMaximumMbit"] = state.IscsiMaximumMbit
		inputs["iscsiReservationMbit"] = state.IscsiReservationMbit
		inputs["iscsiShareCount"] = state.IscsiShareCount
		inputs["iscsiShareLevel"] = state.IscsiShareLevel
		inputs["lacpApiVersion"] = state.LacpApiVersion
		inputs["lacpEnabled"] = state.LacpEnabled
		inputs["lacpMode"] = state.LacpMode
		inputs["linkDiscoveryOperation"] = state.LinkDiscoveryOperation
		inputs["linkDiscoveryProtocol"] = state.LinkDiscoveryProtocol
		inputs["managementMaximumMbit"] = state.ManagementMaximumMbit
		inputs["managementReservationMbit"] = state.ManagementReservationMbit
		inputs["managementShareCount"] = state.ManagementShareCount
		inputs["managementShareLevel"] = state.ManagementShareLevel
		inputs["maxMtu"] = state.MaxMtu
		inputs["multicastFilteringMode"] = state.MulticastFilteringMode
		inputs["name"] = state.Name
		inputs["netflowActiveFlowTimeout"] = state.NetflowActiveFlowTimeout
		inputs["netflowCollectorIpAddress"] = state.NetflowCollectorIpAddress
		inputs["netflowCollectorPort"] = state.NetflowCollectorPort
		inputs["netflowEnabled"] = state.NetflowEnabled
		inputs["netflowIdleFlowTimeout"] = state.NetflowIdleFlowTimeout
		inputs["netflowInternalFlowsOnly"] = state.NetflowInternalFlowsOnly
		inputs["netflowObservationDomainId"] = state.NetflowObservationDomainId
		inputs["netflowSamplingRate"] = state.NetflowSamplingRate
		inputs["networkResourceControlEnabled"] = state.NetworkResourceControlEnabled
		inputs["networkResourceControlVersion"] = state.NetworkResourceControlVersion
		inputs["nfsMaximumMbit"] = state.NfsMaximumMbit
		inputs["nfsReservationMbit"] = state.NfsReservationMbit
		inputs["nfsShareCount"] = state.NfsShareCount
		inputs["nfsShareLevel"] = state.NfsShareLevel
		inputs["notifySwitches"] = state.NotifySwitches
		inputs["portPrivateSecondaryVlanId"] = state.PortPrivateSecondaryVlanId
		inputs["standbyUplinks"] = state.StandbyUplinks
		inputs["tags"] = state.Tags
		inputs["teamingPolicy"] = state.TeamingPolicy
		inputs["txUplink"] = state.TxUplink
		inputs["uplinks"] = state.Uplinks
		inputs["vdpMaximumMbit"] = state.VdpMaximumMbit
		inputs["vdpReservationMbit"] = state.VdpReservationMbit
		inputs["vdpShareCount"] = state.VdpShareCount
		inputs["vdpShareLevel"] = state.VdpShareLevel
		inputs["version"] = state.Version
		inputs["virtualmachineMaximumMbit"] = state.VirtualmachineMaximumMbit
		inputs["virtualmachineReservationMbit"] = state.VirtualmachineReservationMbit
		inputs["virtualmachineShareCount"] = state.VirtualmachineShareCount
		inputs["virtualmachineShareLevel"] = state.VirtualmachineShareLevel
		inputs["vlanId"] = state.VlanId
		inputs["vlanRanges"] = state.VlanRanges
		inputs["vmotionMaximumMbit"] = state.VmotionMaximumMbit
		inputs["vmotionReservationMbit"] = state.VmotionReservationMbit
		inputs["vmotionShareCount"] = state.VmotionShareCount
		inputs["vmotionShareLevel"] = state.VmotionShareLevel
		inputs["vsanMaximumMbit"] = state.VsanMaximumMbit
		inputs["vsanReservationMbit"] = state.VsanReservationMbit
		inputs["vsanShareCount"] = state.VsanShareCount
		inputs["vsanShareLevel"] = state.VsanShareLevel
	}
	s, err := ctx.ReadResource("vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &DistributedVirtualSwitch{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *DistributedVirtualSwitch) URN() pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *DistributedVirtualSwitch) ID() pulumi.IDOutput {
	return r.s.ID()
}

// A list of active uplinks to be used in load
// balancing. These uplinks need to match the definitions in the
// `uplinks` DVS argument. See
// here for more details.
func (r *DistributedVirtualSwitch) ActiveUplinks() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["activeUplinks"])
}

// Controls whether or not a virtual
// network adapter is allowed to send network traffic with a different MAC
// address than that of its own.
func (r *DistributedVirtualSwitch) AllowForgedTransmits() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowForgedTransmits"])
}

// Controls whether or not the Media Access
// Control (MAC) address can be changed.
func (r *DistributedVirtualSwitch) AllowMacChanges() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowMacChanges"])
}

// Enable promiscuous mode on the network. This
// flag indicates whether or not all traffic is seen on a given port.
func (r *DistributedVirtualSwitch) AllowPromiscuous() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowPromiscuous"])
}

// Shuts down all ports in the port groups that
// this policy applies to, effectively blocking all network access to connected
// virtual devices.
func (r *DistributedVirtualSwitch) BlockAllPorts() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["blockAllPorts"])
}

// Enables beacon probing as an additional measure
// to detect NIC failure.
func (r *DistributedVirtualSwitch) CheckBeacon() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["checkBeacon"])
}

// The version string of the configuration that this spec is trying to change.
func (r *DistributedVirtualSwitch) ConfigVersion() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["configVersion"])
}

// The detailed contact information for the person
// who is responsible for the DVS.
func (r *DistributedVirtualSwitch) ContactDetail() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["contactDetail"])
}

// The name of the person who is responsible for the
// DVS.
func (r *DistributedVirtualSwitch) ContactName() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["contactName"])
}

// Map of custom attribute ids to attribute
// value strings to set for virtual switch. See
// [here][docs-setting-custom-attributes] for a reference on how to set values
// for custom attributes.
func (r *DistributedVirtualSwitch) CustomAttributes() pulumi.MapOutput {
	return (pulumi.MapOutput)(r.s.State["customAttributes"])
}

// The ID of the datacenter where the distributed
// virtual switch will be created. Forces a new resource if changed.
func (r *DistributedVirtualSwitch) DatacenterId() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["datacenterId"])
}

// A detailed description for the DVS.
func (r *DistributedVirtualSwitch) Description() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["description"])
}

// Allow VMDirectPath Gen2 for the ports
// for which this policy applies to.
func (r *DistributedVirtualSwitch) DirectpathGen2Allowed() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["directpathGen2Allowed"])
}

// The average bandwidth in bits
// per second if egress traffic shaping is enabled on the port.
func (r *DistributedVirtualSwitch) EgressShapingAverageBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["egressShapingAverageBandwidth"])
}

// The maximum burst size allowed in
// bytes if egress traffic shaping is enabled on the port.
func (r *DistributedVirtualSwitch) EgressShapingBurstSize() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["egressShapingBurstSize"])
}

// `true` if the traffic shaper is enabled
// on the port for egress traffic.
func (r *DistributedVirtualSwitch) EgressShapingEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["egressShapingEnabled"])
}

// The peak bandwidth during bursts
// in bits per second if egress traffic shaping is enabled on the port.
func (r *DistributedVirtualSwitch) EgressShapingPeakBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["egressShapingPeakBandwidth"])
}

// If `true`, the teaming policy will re-activate failed
// uplinks higher in precedence when they come back up.
func (r *DistributedVirtualSwitch) Failback() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["failback"])
}

// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) FaulttoleranceMaximumMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["faulttoleranceMaximumMbit"])
}

// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) FaulttoleranceReservationMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["faulttoleranceReservationMbit"])
}

// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
func (r *DistributedVirtualSwitch) FaulttoleranceShareCount() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["faulttoleranceShareCount"])
}

// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
func (r *DistributedVirtualSwitch) FaulttoleranceShareLevel() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["faulttoleranceShareLevel"])
}

// The folder to create the DVS in. Forces a new resource
// if changed.
func (r *DistributedVirtualSwitch) Folder() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["folder"])
}

// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) HbrMaximumMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["hbrMaximumMbit"])
}

// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) HbrReservationMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["hbrReservationMbit"])
}

// The amount of shares to allocate to the hbr traffic class for a custom share level.
func (r *DistributedVirtualSwitch) HbrShareCount() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["hbrShareCount"])
}

// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
func (r *DistributedVirtualSwitch) HbrShareLevel() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["hbrShareLevel"])
}

// Use the `host` block to declare a host specification. The
// options are:
func (r *DistributedVirtualSwitch) Hosts() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["hosts"])
}

// The average bandwidth in
// bits per second if ingress traffic shaping is enabled on the port.
func (r *DistributedVirtualSwitch) IngressShapingAverageBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["ingressShapingAverageBandwidth"])
}

// The maximum burst size allowed in
// bytes if ingress traffic shaping is enabled on the port.
func (r *DistributedVirtualSwitch) IngressShapingBurstSize() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["ingressShapingBurstSize"])
}

// `true` if the traffic shaper is
// enabled on the port for ingress traffic.
func (r *DistributedVirtualSwitch) IngressShapingEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["ingressShapingEnabled"])
}

// The peak bandwidth during
// bursts in bits per second if ingress traffic shaping is enabled on the port.
func (r *DistributedVirtualSwitch) IngressShapingPeakBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["ingressShapingPeakBandwidth"])
}

// An IPv4 address to identify the switch. This is
// mostly useful when used with the Netflow arguments found
// below.
func (r *DistributedVirtualSwitch) Ipv4Address() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["ipv4Address"])
}

// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) IscsiMaximumMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["iscsiMaximumMbit"])
}

// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) IscsiReservationMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["iscsiReservationMbit"])
}

// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
func (r *DistributedVirtualSwitch) IscsiShareCount() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["iscsiShareCount"])
}

// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
func (r *DistributedVirtualSwitch) IscsiShareLevel() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["iscsiShareLevel"])
}

// The Link Aggregation Control Protocol group
// version to use with the switch. Possible values are `singleLag` and
// `multipleLag`.
func (r *DistributedVirtualSwitch) LacpApiVersion() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["lacpApiVersion"])
}

// Enables LACP for the ports that this policy
// applies to.
func (r *DistributedVirtualSwitch) LacpEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["lacpEnabled"])
}

// The LACP mode. Can be one of `active` or `passive`.
func (r *DistributedVirtualSwitch) LacpMode() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["lacpMode"])
}

// Whether to `advertise` or `listen`
// for link discovery traffic.
func (r *DistributedVirtualSwitch) LinkDiscoveryOperation() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["linkDiscoveryOperation"])
}

// The discovery protocol type. Valid
// types are `cdp` and `lldp`.
func (r *DistributedVirtualSwitch) LinkDiscoveryProtocol() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["linkDiscoveryProtocol"])
}

// The maximum allowed usage for the management traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) ManagementMaximumMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["managementMaximumMbit"])
}

// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) ManagementReservationMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["managementReservationMbit"])
}

// The amount of shares to allocate to the management traffic class for a custom share level.
func (r *DistributedVirtualSwitch) ManagementShareCount() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["managementShareCount"])
}

// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
func (r *DistributedVirtualSwitch) ManagementShareLevel() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["managementShareLevel"])
}

// The maximum transmission unit (MTU) for the virtual
// switch.
func (r *DistributedVirtualSwitch) MaxMtu() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["maxMtu"])
}

// The multicast filtering mode to use
// with the switch. Can be one of `legacyFiltering` or `snooping`.
func (r *DistributedVirtualSwitch) MulticastFilteringMode() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["multicastFilteringMode"])
}

// The name of the distributed virtual switch.
func (r *DistributedVirtualSwitch) Name() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["name"])
}

// The number of seconds after which
// active flows are forced to be exported to the collector. Allowed range is
// `60` to `3600`. Default: `60`.
func (r *DistributedVirtualSwitch) NetflowActiveFlowTimeout() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["netflowActiveFlowTimeout"])
}

// IP address for the Netflow
// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
func (r *DistributedVirtualSwitch) NetflowCollectorIpAddress() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["netflowCollectorIpAddress"])
}

// Port for the Netflow collector. This
// must be set before Netflow can be enabled.
func (r *DistributedVirtualSwitch) NetflowCollectorPort() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["netflowCollectorPort"])
}

// Enables Netflow on all ports that this policy
// applies to.
func (r *DistributedVirtualSwitch) NetflowEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["netflowEnabled"])
}

// The number of seconds after which
// idle flows are forced to be exported to the collector. Allowed range is `10`
// to `600`. Default: `15`.
func (r *DistributedVirtualSwitch) NetflowIdleFlowTimeout() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["netflowIdleFlowTimeout"])
}

// Whether to limit analysis to
// traffic that has both source and destination served by the same host.
// Default: `false`.
func (r *DistributedVirtualSwitch) NetflowInternalFlowsOnly() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["netflowInternalFlowsOnly"])
}

// The observation domain ID for
// the Netflow collector.
func (r *DistributedVirtualSwitch) NetflowObservationDomainId() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["netflowObservationDomainId"])
}

// The ratio of total number of packets to
// the number of packets analyzed. The default is `0`, which indicates that the
// switch should analyze all packets. The maximum value is `1000`, which
// indicates an analysis rate of 0.001%.
func (r *DistributedVirtualSwitch) NetflowSamplingRate() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["netflowSamplingRate"])
}

// Set to `true` to enable
// network I/O control. Default: `false`.
func (r *DistributedVirtualSwitch) NetworkResourceControlEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["networkResourceControlEnabled"])
}

// The version of network I/O
// control to use. Can be one of `version2` or `version3`. Default: `version2`.
func (r *DistributedVirtualSwitch) NetworkResourceControlVersion() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["networkResourceControlVersion"])
}

// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) NfsMaximumMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["nfsMaximumMbit"])
}

// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) NfsReservationMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["nfsReservationMbit"])
}

// The amount of shares to allocate to the nfs traffic class for a custom share level.
func (r *DistributedVirtualSwitch) NfsShareCount() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["nfsShareCount"])
}

// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
func (r *DistributedVirtualSwitch) NfsShareLevel() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["nfsShareLevel"])
}

// If `true`, the teaming policy will notify the
// broadcast network of an uplink failover, triggering cache updates.
func (r *DistributedVirtualSwitch) NotifySwitches() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["notifySwitches"])
}

// Used to define a secondary VLAN
// ID when using private VLANs.
func (r *DistributedVirtualSwitch) PortPrivateSecondaryVlanId() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["portPrivateSecondaryVlanId"])
}

// A list of standby uplinks to be used in
// failover. These uplinks need to match the definitions in the
// `uplinks` DVS argument. See
// here for more details.
func (r *DistributedVirtualSwitch) StandbyUplinks() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["standbyUplinks"])
}

// The IDs of any tags to attach to this resource. See
// [here][docs-applying-tags] for a reference on how to apply tags.
func (r *DistributedVirtualSwitch) Tags() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["tags"])
}

// The uplink teaming policy. Can be one of
// `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
// `failoverExplicit`.
func (r *DistributedVirtualSwitch) TeamingPolicy() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["teamingPolicy"])
}

// Forward all traffic transmitted by ports for which
// this policy applies to its DVS uplinks.
func (r *DistributedVirtualSwitch) TxUplink() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["txUplink"])
}

// A list of strings that uniquely identifies the names
// of the uplinks on the DVS across hosts. The number of items in this list
// controls the number of uplinks that exist on the DVS, in addition to the
// names.  See here for an example on how to
// use this option.
func (r *DistributedVirtualSwitch) Uplinks() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["uplinks"])
}

// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) VdpMaximumMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vdpMaximumMbit"])
}

// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) VdpReservationMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vdpReservationMbit"])
}

// The amount of shares to allocate to the vdp traffic class for a custom share level.
func (r *DistributedVirtualSwitch) VdpShareCount() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vdpShareCount"])
}

// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
func (r *DistributedVirtualSwitch) VdpShareLevel() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["vdpShareLevel"])
}

// - The version of the DVS to create. The default is to
// create the DVS at the latest version supported by the version of vSphere
// being used. A DVS can be upgraded to another version, but cannot be
// downgraded.
func (r *DistributedVirtualSwitch) Version() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["version"])
}

// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) VirtualmachineMaximumMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["virtualmachineMaximumMbit"])
}

// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) VirtualmachineReservationMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["virtualmachineReservationMbit"])
}

// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
func (r *DistributedVirtualSwitch) VirtualmachineShareCount() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["virtualmachineShareCount"])
}

// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
func (r *DistributedVirtualSwitch) VirtualmachineShareLevel() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["virtualmachineShareLevel"])
}

// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
func (r *DistributedVirtualSwitch) VlanId() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vlanId"])
}

// Used to denote VLAN trunking. Use the `minVlan`
// and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
// `vlanRange` definitions are allowed, but they must not overlap. Example
// below:
func (r *DistributedVirtualSwitch) VlanRanges() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["vlanRanges"])
}

// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) VmotionMaximumMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vmotionMaximumMbit"])
}

// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) VmotionReservationMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vmotionReservationMbit"])
}

// The amount of shares to allocate to the vmotion traffic class for a custom share level.
func (r *DistributedVirtualSwitch) VmotionShareCount() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vmotionShareCount"])
}

// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
func (r *DistributedVirtualSwitch) VmotionShareLevel() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["vmotionShareLevel"])
}

// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) VsanMaximumMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vsanMaximumMbit"])
}

// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
func (r *DistributedVirtualSwitch) VsanReservationMbit() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vsanReservationMbit"])
}

// The amount of shares to allocate to the vsan traffic class for a custom share level.
func (r *DistributedVirtualSwitch) VsanShareCount() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vsanShareCount"])
}

// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
func (r *DistributedVirtualSwitch) VsanShareLevel() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["vsanShareLevel"])
}

// Input properties used for looking up and filtering DistributedVirtualSwitch resources.
type DistributedVirtualSwitchState struct {
	// A list of active uplinks to be used in load
	// balancing. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	ActiveUplinks interface{}
	// Controls whether or not a virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own.
	AllowForgedTransmits interface{}
	// Controls whether or not the Media Access
	// Control (MAC) address can be changed.
	AllowMacChanges interface{}
	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous interface{}
	// Shuts down all ports in the port groups that
	// this policy applies to, effectively blocking all network access to connected
	// virtual devices.
	BlockAllPorts interface{}
	// Enables beacon probing as an additional measure
	// to detect NIC failure.
	CheckBeacon interface{}
	// The version string of the configuration that this spec is trying to change.
	ConfigVersion interface{}
	// The detailed contact information for the person
	// who is responsible for the DVS.
	ContactDetail interface{}
	// The name of the person who is responsible for the
	// DVS.
	ContactName interface{}
	// Map of custom attribute ids to attribute
	// value strings to set for virtual switch. See
	// [here][docs-setting-custom-attributes] for a reference on how to set values
	// for custom attributes.
	CustomAttributes interface{}
	// The ID of the datacenter where the distributed
	// virtual switch will be created. Forces a new resource if changed.
	DatacenterId interface{}
	// A detailed description for the DVS.
	Description interface{}
	// Allow VMDirectPath Gen2 for the ports
	// for which this policy applies to.
	DirectpathGen2Allowed interface{}
	// The average bandwidth in bits
	// per second if egress traffic shaping is enabled on the port.
	EgressShapingAverageBandwidth interface{}
	// The maximum burst size allowed in
	// bytes if egress traffic shaping is enabled on the port.
	EgressShapingBurstSize interface{}
	// `true` if the traffic shaper is enabled
	// on the port for egress traffic.
	EgressShapingEnabled interface{}
	// The peak bandwidth during bursts
	// in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth interface{}
	// If `true`, the teaming policy will re-activate failed
	// uplinks higher in precedence when they come back up.
	Failback interface{}
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit interface{}
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount interface{}
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel interface{}
	// The folder to create the DVS in. Forces a new resource
	// if changed.
	Folder interface{}
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit interface{}
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount interface{}
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel interface{}
	// Use the `host` block to declare a host specification. The
	// options are:
	Hosts interface{}
	// The average bandwidth in
	// bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingAverageBandwidth interface{}
	// The maximum burst size allowed in
	// bytes if ingress traffic shaping is enabled on the port.
	IngressShapingBurstSize interface{}
	// `true` if the traffic shaper is
	// enabled on the port for ingress traffic.
	IngressShapingEnabled interface{}
	// The peak bandwidth during
	// bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth interface{}
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments found
	// below.
	Ipv4Address interface{}
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit interface{}
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount interface{}
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel interface{}
	// The Link Aggregation Control Protocol group
	// version to use with the switch. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion interface{}
	// Enables LACP for the ports that this policy
	// applies to.
	LacpEnabled interface{}
	// The LACP mode. Can be one of `active` or `passive`.
	LacpMode interface{}
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation interface{}
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol interface{}
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit interface{}
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount interface{}
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel interface{}
	// The maximum transmission unit (MTU) for the virtual
	// switch.
	MaxMtu interface{}
	// The multicast filtering mode to use
	// with the switch. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode interface{}
	// The name of the distributed virtual switch.
	Name interface{}
	// The number of seconds after which
	// active flows are forced to be exported to the collector. Allowed range is
	// `60` to `3600`. Default: `60`.
	NetflowActiveFlowTimeout interface{}
	// IP address for the Netflow
	// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
	// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
	NetflowCollectorIpAddress interface{}
	// Port for the Netflow collector. This
	// must be set before Netflow can be enabled.
	NetflowCollectorPort interface{}
	// Enables Netflow on all ports that this policy
	// applies to.
	NetflowEnabled interface{}
	// The number of seconds after which
	// idle flows are forced to be exported to the collector. Allowed range is `10`
	// to `600`. Default: `15`.
	NetflowIdleFlowTimeout interface{}
	// Whether to limit analysis to
	// traffic that has both source and destination served by the same host.
	// Default: `false`.
	NetflowInternalFlowsOnly interface{}
	// The observation domain ID for
	// the Netflow collector.
	NetflowObservationDomainId interface{}
	// The ratio of total number of packets to
	// the number of packets analyzed. The default is `0`, which indicates that the
	// switch should analyze all packets. The maximum value is `1000`, which
	// indicates an analysis rate of 0.001%.
	NetflowSamplingRate interface{}
	// Set to `true` to enable
	// network I/O control. Default: `false`.
	NetworkResourceControlEnabled interface{}
	// The version of network I/O
	// control to use. Can be one of `version2` or `version3`. Default: `version2`.
	NetworkResourceControlVersion interface{}
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit interface{}
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount interface{}
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel interface{}
	// If `true`, the teaming policy will notify the
	// broadcast network of an uplink failover, triggering cache updates.
	NotifySwitches interface{}
	// Used to define a secondary VLAN
	// ID when using private VLANs.
	PortPrivateSecondaryVlanId interface{}
	// A list of standby uplinks to be used in
	// failover. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	StandbyUplinks interface{}
	// The IDs of any tags to attach to this resource. See
	// [here][docs-applying-tags] for a reference on how to apply tags.
	Tags interface{}
	// The uplink teaming policy. Can be one of
	// `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
	// `failoverExplicit`.
	TeamingPolicy interface{}
	// Forward all traffic transmitted by ports for which
	// this policy applies to its DVS uplinks.
	TxUplink interface{}
	// A list of strings that uniquely identifies the names
	// of the uplinks on the DVS across hosts. The number of items in this list
	// controls the number of uplinks that exist on the DVS, in addition to the
	// names.  See here for an example on how to
	// use this option.
	Uplinks interface{}
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit interface{}
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount interface{}
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel interface{}
	// - The version of the DVS to create. The default is to
	// create the DVS at the latest version supported by the version of vSphere
	// being used. A DVS can be upgraded to another version, but cannot be
	// downgraded.
	Version interface{}
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit interface{}
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount interface{}
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel interface{}
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId interface{}
	// Used to denote VLAN trunking. Use the `minVlan`
	// and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
	// `vlanRange` definitions are allowed, but they must not overlap. Example
	// below:
	VlanRanges interface{}
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit interface{}
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount interface{}
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel interface{}
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit interface{}
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount interface{}
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel interface{}
}

// The set of arguments for constructing a DistributedVirtualSwitch resource.
type DistributedVirtualSwitchArgs struct {
	// A list of active uplinks to be used in load
	// balancing. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	ActiveUplinks interface{}
	// Controls whether or not a virtual
	// network adapter is allowed to send network traffic with a different MAC
	// address than that of its own.
	AllowForgedTransmits interface{}
	// Controls whether or not the Media Access
	// Control (MAC) address can be changed.
	AllowMacChanges interface{}
	// Enable promiscuous mode on the network. This
	// flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous interface{}
	// Shuts down all ports in the port groups that
	// this policy applies to, effectively blocking all network access to connected
	// virtual devices.
	BlockAllPorts interface{}
	// Enables beacon probing as an additional measure
	// to detect NIC failure.
	CheckBeacon interface{}
	// The detailed contact information for the person
	// who is responsible for the DVS.
	ContactDetail interface{}
	// The name of the person who is responsible for the
	// DVS.
	ContactName interface{}
	// Map of custom attribute ids to attribute
	// value strings to set for virtual switch. See
	// [here][docs-setting-custom-attributes] for a reference on how to set values
	// for custom attributes.
	CustomAttributes interface{}
	// The ID of the datacenter where the distributed
	// virtual switch will be created. Forces a new resource if changed.
	DatacenterId interface{}
	// A detailed description for the DVS.
	Description interface{}
	// Allow VMDirectPath Gen2 for the ports
	// for which this policy applies to.
	DirectpathGen2Allowed interface{}
	// The average bandwidth in bits
	// per second if egress traffic shaping is enabled on the port.
	EgressShapingAverageBandwidth interface{}
	// The maximum burst size allowed in
	// bytes if egress traffic shaping is enabled on the port.
	EgressShapingBurstSize interface{}
	// `true` if the traffic shaper is enabled
	// on the port for egress traffic.
	EgressShapingEnabled interface{}
	// The peak bandwidth during bursts
	// in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth interface{}
	// If `true`, the teaming policy will re-activate failed
	// uplinks higher in precedence when they come back up.
	Failback interface{}
	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit interface{}
	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount interface{}
	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel interface{}
	// The folder to create the DVS in. Forces a new resource
	// if changed.
	Folder interface{}
	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit interface{}
	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount interface{}
	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel interface{}
	// Use the `host` block to declare a host specification. The
	// options are:
	Hosts interface{}
	// The average bandwidth in
	// bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingAverageBandwidth interface{}
	// The maximum burst size allowed in
	// bytes if ingress traffic shaping is enabled on the port.
	IngressShapingBurstSize interface{}
	// `true` if the traffic shaper is
	// enabled on the port for ingress traffic.
	IngressShapingEnabled interface{}
	// The peak bandwidth during
	// bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth interface{}
	// An IPv4 address to identify the switch. This is
	// mostly useful when used with the Netflow arguments found
	// below.
	Ipv4Address interface{}
	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	IscsiMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	IscsiReservationMbit interface{}
	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	IscsiShareCount interface{}
	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	IscsiShareLevel interface{}
	// The Link Aggregation Control Protocol group
	// version to use with the switch. Possible values are `singleLag` and
	// `multipleLag`.
	LacpApiVersion interface{}
	// Enables LACP for the ports that this policy
	// applies to.
	LacpEnabled interface{}
	// The LACP mode. Can be one of `active` or `passive`.
	LacpMode interface{}
	// Whether to `advertise` or `listen`
	// for link discovery traffic.
	LinkDiscoveryOperation interface{}
	// The discovery protocol type. Valid
	// types are `cdp` and `lldp`.
	LinkDiscoveryProtocol interface{}
	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit interface{}
	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount interface{}
	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel interface{}
	// The maximum transmission unit (MTU) for the virtual
	// switch.
	MaxMtu interface{}
	// The multicast filtering mode to use
	// with the switch. Can be one of `legacyFiltering` or `snooping`.
	MulticastFilteringMode interface{}
	// The name of the distributed virtual switch.
	Name interface{}
	// The number of seconds after which
	// active flows are forced to be exported to the collector. Allowed range is
	// `60` to `3600`. Default: `60`.
	NetflowActiveFlowTimeout interface{}
	// IP address for the Netflow
	// collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
	// Switch Version 6.0 or later. Must be set before Netflow can be enabled.
	NetflowCollectorIpAddress interface{}
	// Port for the Netflow collector. This
	// must be set before Netflow can be enabled.
	NetflowCollectorPort interface{}
	// Enables Netflow on all ports that this policy
	// applies to.
	NetflowEnabled interface{}
	// The number of seconds after which
	// idle flows are forced to be exported to the collector. Allowed range is `10`
	// to `600`. Default: `15`.
	NetflowIdleFlowTimeout interface{}
	// Whether to limit analysis to
	// traffic that has both source and destination served by the same host.
	// Default: `false`.
	NetflowInternalFlowsOnly interface{}
	// The observation domain ID for
	// the Netflow collector.
	NetflowObservationDomainId interface{}
	// The ratio of total number of packets to
	// the number of packets analyzed. The default is `0`, which indicates that the
	// switch should analyze all packets. The maximum value is `1000`, which
	// indicates an analysis rate of 0.001%.
	NetflowSamplingRate interface{}
	// Set to `true` to enable
	// network I/O control. Default: `false`.
	NetworkResourceControlEnabled interface{}
	// The version of network I/O
	// control to use. Can be one of `version2` or `version3`. Default: `version2`.
	NetworkResourceControlVersion interface{}
	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NfsMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NfsReservationMbit interface{}
	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NfsShareCount interface{}
	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NfsShareLevel interface{}
	// If `true`, the teaming policy will notify the
	// broadcast network of an uplink failover, triggering cache updates.
	NotifySwitches interface{}
	// Used to define a secondary VLAN
	// ID when using private VLANs.
	PortPrivateSecondaryVlanId interface{}
	// A list of standby uplinks to be used in
	// failover. These uplinks need to match the definitions in the
	// `uplinks` DVS argument. See
	// here for more details.
	StandbyUplinks interface{}
	// The IDs of any tags to attach to this resource. See
	// [here][docs-applying-tags] for a reference on how to apply tags.
	Tags interface{}
	// The uplink teaming policy. Can be one of
	// `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
	// `failoverExplicit`.
	TeamingPolicy interface{}
	// Forward all traffic transmitted by ports for which
	// this policy applies to its DVS uplinks.
	TxUplink interface{}
	// A list of strings that uniquely identifies the names
	// of the uplinks on the DVS across hosts. The number of items in this list
	// controls the number of uplinks that exist on the DVS, in addition to the
	// names.  See here for an example on how to
	// use this option.
	Uplinks interface{}
	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit interface{}
	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount interface{}
	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel interface{}
	// - The version of the DVS to create. The default is to
	// create the DVS at the latest version supported by the version of vSphere
	// being used. A DVS can be upgraded to another version, but cannot be
	// downgraded.
	Version interface{}
	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit interface{}
	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount interface{}
	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel interface{}
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanId interface{}
	// Used to denote VLAN trunking. Use the `minVlan`
	// and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
	// `vlanRange` definitions are allowed, but they must not overlap. Example
	// below:
	VlanRanges interface{}
	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit interface{}
	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount interface{}
	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel interface{}
	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit interface{}
	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit interface{}
	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount interface{}
	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel interface{}
}
