// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package vsphere

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// The `.HostPortGroup` resource can be used to manage vSphere standard
// port groups on an ESXi host. These port groups are connected to standard
// virtual switches, which can be managed by the
// [`.HostVirtualSwitch`][host-virtual-switch] resource.
//
// For an overview on vSphere networking concepts, see [this page][ref-vsphere-net-concepts].
//
// [host-virtual-switch]: /docs/providers/vsphere/r/host_virtual_switch.html
// [ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-vsphere/blob/master/website/docs/r/host_port_group.html.markdown.
type HostPortGroup struct {
	s *pulumi.ResourceState
}

// NewHostPortGroup registers a new resource with the given unique name, arguments, and options.
func NewHostPortGroup(ctx *pulumi.Context,
	name string, args *HostPortGroupArgs, opts ...pulumi.ResourceOpt) (*HostPortGroup, error) {
	if args == nil || args.HostSystemId == nil {
		return nil, errors.New("missing required argument 'HostSystemId'")
	}
	if args == nil || args.VirtualSwitchName == nil {
		return nil, errors.New("missing required argument 'VirtualSwitchName'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["activeNics"] = nil
		inputs["allowForgedTransmits"] = nil
		inputs["allowMacChanges"] = nil
		inputs["allowPromiscuous"] = nil
		inputs["checkBeacon"] = nil
		inputs["failback"] = nil
		inputs["hostSystemId"] = nil
		inputs["name"] = nil
		inputs["notifySwitches"] = nil
		inputs["shapingAverageBandwidth"] = nil
		inputs["shapingBurstSize"] = nil
		inputs["shapingEnabled"] = nil
		inputs["shapingPeakBandwidth"] = nil
		inputs["standbyNics"] = nil
		inputs["teamingPolicy"] = nil
		inputs["virtualSwitchName"] = nil
		inputs["vlanId"] = nil
	} else {
		inputs["activeNics"] = args.ActiveNics
		inputs["allowForgedTransmits"] = args.AllowForgedTransmits
		inputs["allowMacChanges"] = args.AllowMacChanges
		inputs["allowPromiscuous"] = args.AllowPromiscuous
		inputs["checkBeacon"] = args.CheckBeacon
		inputs["failback"] = args.Failback
		inputs["hostSystemId"] = args.HostSystemId
		inputs["name"] = args.Name
		inputs["notifySwitches"] = args.NotifySwitches
		inputs["shapingAverageBandwidth"] = args.ShapingAverageBandwidth
		inputs["shapingBurstSize"] = args.ShapingBurstSize
		inputs["shapingEnabled"] = args.ShapingEnabled
		inputs["shapingPeakBandwidth"] = args.ShapingPeakBandwidth
		inputs["standbyNics"] = args.StandbyNics
		inputs["teamingPolicy"] = args.TeamingPolicy
		inputs["virtualSwitchName"] = args.VirtualSwitchName
		inputs["vlanId"] = args.VlanId
	}
	inputs["computedPolicy"] = nil
	inputs["key"] = nil
	inputs["ports"] = nil
	s, err := ctx.RegisterResource("vsphere:index/hostPortGroup:HostPortGroup", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &HostPortGroup{s: s}, nil
}

// GetHostPortGroup gets an existing HostPortGroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetHostPortGroup(ctx *pulumi.Context,
	name string, id pulumi.ID, state *HostPortGroupState, opts ...pulumi.ResourceOpt) (*HostPortGroup, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["activeNics"] = state.ActiveNics
		inputs["allowForgedTransmits"] = state.AllowForgedTransmits
		inputs["allowMacChanges"] = state.AllowMacChanges
		inputs["allowPromiscuous"] = state.AllowPromiscuous
		inputs["checkBeacon"] = state.CheckBeacon
		inputs["computedPolicy"] = state.ComputedPolicy
		inputs["failback"] = state.Failback
		inputs["hostSystemId"] = state.HostSystemId
		inputs["key"] = state.Key
		inputs["name"] = state.Name
		inputs["notifySwitches"] = state.NotifySwitches
		inputs["ports"] = state.Ports
		inputs["shapingAverageBandwidth"] = state.ShapingAverageBandwidth
		inputs["shapingBurstSize"] = state.ShapingBurstSize
		inputs["shapingEnabled"] = state.ShapingEnabled
		inputs["shapingPeakBandwidth"] = state.ShapingPeakBandwidth
		inputs["standbyNics"] = state.StandbyNics
		inputs["teamingPolicy"] = state.TeamingPolicy
		inputs["virtualSwitchName"] = state.VirtualSwitchName
		inputs["vlanId"] = state.VlanId
	}
	s, err := ctx.ReadResource("vsphere:index/hostPortGroup:HostPortGroup", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &HostPortGroup{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *HostPortGroup) URN() pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *HostPortGroup) ID() pulumi.IDOutput {
	return r.s.ID()
}

// List of active network adapters used for load balancing.
func (r *HostPortGroup) ActiveNics() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["activeNics"])
}

// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than
// that of its own.
func (r *HostPortGroup) AllowForgedTransmits() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowForgedTransmits"])
}

// Controls whether or not the Media Access Control (MAC) address can be changed.
func (r *HostPortGroup) AllowMacChanges() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowMacChanges"])
}

// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
func (r *HostPortGroup) AllowPromiscuous() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["allowPromiscuous"])
}

// Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used
// only.
func (r *HostPortGroup) CheckBeacon() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["checkBeacon"])
}

// A map with a full set of the [policy
// options][host-vswitch-policy-options] computed from defaults and overrides,
// explaining the effective policy for this port group.
func (r *HostPortGroup) ComputedPolicy() pulumi.MapOutput {
	return (pulumi.MapOutput)(r.s.State["computedPolicy"])
}

// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
func (r *HostPortGroup) Failback() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["failback"])
}

// The [managed object ID][docs-about-morefs] of
// the host to set the port group up on. Forces a new resource if changed.
func (r *HostPortGroup) HostSystemId() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["hostSystemId"])
}

// The key for this port group as returned from the vSphere API.
func (r *HostPortGroup) Key() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["key"])
}

// The name of the port group.  Forces a new resource if
// changed.
func (r *HostPortGroup) Name() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["name"])
}

// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
func (r *HostPortGroup) NotifySwitches() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["notifySwitches"])
}

// A list of ports that currently exist and are used on this port group.
func (r *HostPortGroup) Ports() pulumi.Output {
	return r.s.State["ports"]
}

// The average bandwidth in bits per second if traffic shaping is enabled.
func (r *HostPortGroup) ShapingAverageBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["shapingAverageBandwidth"])
}

// The maximum burst size allowed in bytes if traffic shaping is enabled.
func (r *HostPortGroup) ShapingBurstSize() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["shapingBurstSize"])
}

// Enable traffic shaping on this virtual switch or port group.
func (r *HostPortGroup) ShapingEnabled() pulumi.BoolOutput {
	return (pulumi.BoolOutput)(r.s.State["shapingEnabled"])
}

// The peak bandwidth during bursts in bits per second if traffic shaping is enabled.
func (r *HostPortGroup) ShapingPeakBandwidth() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["shapingPeakBandwidth"])
}

// List of standby network adapters used for failover.
func (r *HostPortGroup) StandbyNics() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["standbyNics"])
}

// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or
// failover_explicit.
func (r *HostPortGroup) TeamingPolicy() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["teamingPolicy"])
}

// The name of the virtual switch to bind
// this port group to. Forces a new resource if changed.
func (r *HostPortGroup) VirtualSwitchName() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["virtualSwitchName"])
}

// The VLAN ID/trunk mode for this port group.  An ID of
// `0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an
// ID of `4095` enables trunk mode, allowing the guest to manage its own
// tagging. Default: `0`.
func (r *HostPortGroup) VlanId() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["vlanId"])
}

// Input properties used for looking up and filtering HostPortGroup resources.
type HostPortGroupState struct {
	// List of active network adapters used for load balancing.
	ActiveNics interface{}
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address
	// than that of its own.
	AllowForgedTransmits interface{}
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges interface{}
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous interface{}
	// Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used
	// only.
	CheckBeacon interface{}
	// A map with a full set of the [policy
	// options][host-vswitch-policy-options] computed from defaults and overrides,
	// explaining the effective policy for this port group.
	ComputedPolicy interface{}
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback interface{}
	// The [managed object ID][docs-about-morefs] of
	// the host to set the port group up on. Forces a new resource if changed.
	HostSystemId interface{}
	// The key for this port group as returned from the vSphere API.
	Key interface{}
	// The name of the port group.  Forces a new resource if
	// changed.
	Name interface{}
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches interface{}
	// A list of ports that currently exist and are used on this port group.
	Ports interface{}
	// The average bandwidth in bits per second if traffic shaping is enabled.
	ShapingAverageBandwidth interface{}
	// The maximum burst size allowed in bytes if traffic shaping is enabled.
	ShapingBurstSize interface{}
	// Enable traffic shaping on this virtual switch or port group.
	ShapingEnabled interface{}
	// The peak bandwidth during bursts in bits per second if traffic shaping is enabled.
	ShapingPeakBandwidth interface{}
	// List of standby network adapters used for failover.
	StandbyNics interface{}
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or
	// failover_explicit.
	TeamingPolicy interface{}
	// The name of the virtual switch to bind
	// this port group to. Forces a new resource if changed.
	VirtualSwitchName interface{}
	// The VLAN ID/trunk mode for this port group.  An ID of
	// `0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an
	// ID of `4095` enables trunk mode, allowing the guest to manage its own
	// tagging. Default: `0`.
	VlanId interface{}
}

// The set of arguments for constructing a HostPortGroup resource.
type HostPortGroupArgs struct {
	// List of active network adapters used for load balancing.
	ActiveNics interface{}
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address
	// than that of its own.
	AllowForgedTransmits interface{}
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges interface{}
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous interface{}
	// Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used
	// only.
	CheckBeacon interface{}
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback interface{}
	// The [managed object ID][docs-about-morefs] of
	// the host to set the port group up on. Forces a new resource if changed.
	HostSystemId interface{}
	// The name of the port group.  Forces a new resource if
	// changed.
	Name interface{}
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches interface{}
	// The average bandwidth in bits per second if traffic shaping is enabled.
	ShapingAverageBandwidth interface{}
	// The maximum burst size allowed in bytes if traffic shaping is enabled.
	ShapingBurstSize interface{}
	// Enable traffic shaping on this virtual switch or port group.
	ShapingEnabled interface{}
	// The peak bandwidth during bursts in bits per second if traffic shaping is enabled.
	ShapingPeakBandwidth interface{}
	// List of standby network adapters used for failover.
	StandbyNics interface{}
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or
	// failover_explicit.
	TeamingPolicy interface{}
	// The name of the virtual switch to bind
	// this port group to. Forces a new resource if changed.
	VirtualSwitchName interface{}
	// The VLAN ID/trunk mode for this port group.  An ID of
	// `0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an
	// ID of `4095` enables trunk mode, allowing the guest to manage its own
	// tagging. Default: `0`.
	VlanId interface{}
}
