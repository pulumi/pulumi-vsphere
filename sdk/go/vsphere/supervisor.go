// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vsphere

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource for configuring Workload Management.
//
// ## Example Usage
//
// ### S
//
// **Enable Workload Management on a compute cluster**
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			vmClass, err := vsphere.NewVirtualMachineClass(ctx, "vm_class", &vsphere.VirtualMachineClassArgs{
//				Name:   pulumi.String("custom-class"),
//				Cpus:   pulumi.Int(4),
//				Memory: pulumi.Int(4096),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = vsphere.NewSupervisor(ctx, "supervisor", &vsphere.SupervisorArgs{
//				Cluster:        pulumi.String("<compute_cluster_id>"),
//				StoragePolicy:  pulumi.String("<storage_policy_name>"),
//				ContentLibrary: pulumi.String("<content_library_id>"),
//				MainDns:        pulumi.StringArray("10.0.0.250"),
//				WorkerDns:      pulumi.StringArray("10.0.0.250"),
//				EdgeCluster:    pulumi.String("<edge_cluster_id>"),
//				DvsUuid:        pulumi.String("<distributed_switch_uuid>"),
//				SizingHint:     pulumi.String("MEDIUM"),
//				ManagementNetwork: &vsphere.SupervisorManagementNetworkArgs{
//					Network:         pulumi.String("<portgroup_id>"),
//					SubnetMask:      pulumi.String("255.255.255.0"),
//					StartingAddress: pulumi.String("10.0.0.150"),
//					Gateway:         pulumi.String("10.0.0.250"),
//					AddressCount:    pulumi.Int(5),
//				},
//				IngressCidrs: vsphere.SupervisorIngressCidrArray{
//					&vsphere.SupervisorIngressCidrArgs{
//						Address: pulumi.String("10.10.10.0"),
//						Prefix:  pulumi.Int(24),
//					},
//				},
//				EgressCidrs: vsphere.SupervisorEgressCidrArray{
//					&vsphere.SupervisorEgressCidrArgs{
//						Address: pulumi.String("10.10.11.0"),
//						Prefix:  pulumi.Int(24),
//					},
//				},
//				PodCidrs: vsphere.SupervisorPodCidrArray{
//					&vsphere.SupervisorPodCidrArgs{
//						Address: pulumi.String("10.244.10.0"),
//						Prefix:  pulumi.Int(23),
//					},
//				},
//				ServiceCidr: &vsphere.SupervisorServiceCidrArgs{
//					Address: pulumi.String("10.10.12.0"),
//					Prefix:  pulumi.Int(24),
//				},
//				SearchDomains: pulumi.String("vsphere.local"),
//				Namespaces: vsphere.SupervisorNamespaceArray{
//					&vsphere.SupervisorNamespaceArgs{
//						Name:             pulumi.String("custom-namespace"),
//						ContentLibraries: pulumi.StringArray{},
//						VmClasses: pulumi.StringArray{
//							vmClass.ID(),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Supervisor struct {
	pulumi.CustomResourceState

	// The identifier of the compute cluster.
	Cluster pulumi.StringOutput `pulumi:"cluster"`
	// The identifier of the subscribed content library.
	ContentLibrary pulumi.StringOutput `pulumi:"contentLibrary"`
	// The UUID of the distributed switch.
	DvsUuid pulumi.StringOutput `pulumi:"dvsUuid"`
	// The identifier of the NSX Edge Cluster.
	EdgeCluster pulumi.StringOutput `pulumi:"edgeCluster"`
	// CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.
	EgressCidrs SupervisorEgressCidrArrayOutput `pulumi:"egressCidrs"`
	// CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.
	IngressCidrs SupervisorIngressCidrArrayOutput `pulumi:"ingressCidrs"`
	// The list of addresses of the primary DNS servers.
	MainDns pulumi.StringArrayOutput `pulumi:"mainDns"`
	// The list of addresses of the primary NTP servers.
	MainNtps pulumi.StringArrayOutput `pulumi:"mainNtps"`
	// The configuration for the management network which the control plane VMs will be connected to.
	// * * `network` - ID of the network. (e.g. a distributed port group).
	// * * `startingAddress` - Starting address of the management network range.
	// * * `subnetMask` - Subnet mask.
	// * * `gateway` - Gateway IP address.
	// * * `addressCount` - Number of addresses to allocate. Starts from `startingAddress`
	ManagementNetwork SupervisorManagementNetworkOutput `pulumi:"managementNetwork"`
	// The list of namespaces to create in the Supervisor cluster
	Namespaces SupervisorNamespaceArrayOutput `pulumi:"namespaces"`
	// CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.
	PodCidrs SupervisorPodCidrArrayOutput `pulumi:"podCidrs"`
	// List of DNS search domains.
	SearchDomains pulumi.StringOutput `pulumi:"searchDomains"`
	// CIDR block from which Kubernetes allocates service cluster IP addresses.
	ServiceCidr SupervisorServiceCidrOutput `pulumi:"serviceCidr"`
	// The size of the Kubernetes API server.
	SizingHint pulumi.StringOutput `pulumi:"sizingHint"`
	// The name of the storage policy.
	StoragePolicy pulumi.StringOutput `pulumi:"storagePolicy"`
	// The list of addresses of the DNS servers to use for the worker nodes.
	WorkerDns pulumi.StringArrayOutput `pulumi:"workerDns"`
	// The list of addresses of the NTP servers to use for the worker nodes.
	WorkerNtps pulumi.StringArrayOutput `pulumi:"workerNtps"`
}

// NewSupervisor registers a new resource with the given unique name, arguments, and options.
func NewSupervisor(ctx *pulumi.Context,
	name string, args *SupervisorArgs, opts ...pulumi.ResourceOption) (*Supervisor, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Cluster == nil {
		return nil, errors.New("invalid value for required argument 'Cluster'")
	}
	if args.ContentLibrary == nil {
		return nil, errors.New("invalid value for required argument 'ContentLibrary'")
	}
	if args.DvsUuid == nil {
		return nil, errors.New("invalid value for required argument 'DvsUuid'")
	}
	if args.EdgeCluster == nil {
		return nil, errors.New("invalid value for required argument 'EdgeCluster'")
	}
	if args.EgressCidrs == nil {
		return nil, errors.New("invalid value for required argument 'EgressCidrs'")
	}
	if args.IngressCidrs == nil {
		return nil, errors.New("invalid value for required argument 'IngressCidrs'")
	}
	if args.MainDns == nil {
		return nil, errors.New("invalid value for required argument 'MainDns'")
	}
	if args.MainNtps == nil {
		return nil, errors.New("invalid value for required argument 'MainNtps'")
	}
	if args.ManagementNetwork == nil {
		return nil, errors.New("invalid value for required argument 'ManagementNetwork'")
	}
	if args.PodCidrs == nil {
		return nil, errors.New("invalid value for required argument 'PodCidrs'")
	}
	if args.SearchDomains == nil {
		return nil, errors.New("invalid value for required argument 'SearchDomains'")
	}
	if args.ServiceCidr == nil {
		return nil, errors.New("invalid value for required argument 'ServiceCidr'")
	}
	if args.SizingHint == nil {
		return nil, errors.New("invalid value for required argument 'SizingHint'")
	}
	if args.StoragePolicy == nil {
		return nil, errors.New("invalid value for required argument 'StoragePolicy'")
	}
	if args.WorkerDns == nil {
		return nil, errors.New("invalid value for required argument 'WorkerDns'")
	}
	if args.WorkerNtps == nil {
		return nil, errors.New("invalid value for required argument 'WorkerNtps'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Supervisor
	err := ctx.RegisterResource("vsphere:index/supervisor:Supervisor", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSupervisor gets an existing Supervisor resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSupervisor(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SupervisorState, opts ...pulumi.ResourceOption) (*Supervisor, error) {
	var resource Supervisor
	err := ctx.ReadResource("vsphere:index/supervisor:Supervisor", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Supervisor resources.
type supervisorState struct {
	// The identifier of the compute cluster.
	Cluster *string `pulumi:"cluster"`
	// The identifier of the subscribed content library.
	ContentLibrary *string `pulumi:"contentLibrary"`
	// The UUID of the distributed switch.
	DvsUuid *string `pulumi:"dvsUuid"`
	// The identifier of the NSX Edge Cluster.
	EdgeCluster *string `pulumi:"edgeCluster"`
	// CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.
	EgressCidrs []SupervisorEgressCidr `pulumi:"egressCidrs"`
	// CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.
	IngressCidrs []SupervisorIngressCidr `pulumi:"ingressCidrs"`
	// The list of addresses of the primary DNS servers.
	MainDns []string `pulumi:"mainDns"`
	// The list of addresses of the primary NTP servers.
	MainNtps []string `pulumi:"mainNtps"`
	// The configuration for the management network which the control plane VMs will be connected to.
	// * * `network` - ID of the network. (e.g. a distributed port group).
	// * * `startingAddress` - Starting address of the management network range.
	// * * `subnetMask` - Subnet mask.
	// * * `gateway` - Gateway IP address.
	// * * `addressCount` - Number of addresses to allocate. Starts from `startingAddress`
	ManagementNetwork *SupervisorManagementNetwork `pulumi:"managementNetwork"`
	// The list of namespaces to create in the Supervisor cluster
	Namespaces []SupervisorNamespace `pulumi:"namespaces"`
	// CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.
	PodCidrs []SupervisorPodCidr `pulumi:"podCidrs"`
	// List of DNS search domains.
	SearchDomains *string `pulumi:"searchDomains"`
	// CIDR block from which Kubernetes allocates service cluster IP addresses.
	ServiceCidr *SupervisorServiceCidr `pulumi:"serviceCidr"`
	// The size of the Kubernetes API server.
	SizingHint *string `pulumi:"sizingHint"`
	// The name of the storage policy.
	StoragePolicy *string `pulumi:"storagePolicy"`
	// The list of addresses of the DNS servers to use for the worker nodes.
	WorkerDns []string `pulumi:"workerDns"`
	// The list of addresses of the NTP servers to use for the worker nodes.
	WorkerNtps []string `pulumi:"workerNtps"`
}

type SupervisorState struct {
	// The identifier of the compute cluster.
	Cluster pulumi.StringPtrInput
	// The identifier of the subscribed content library.
	ContentLibrary pulumi.StringPtrInput
	// The UUID of the distributed switch.
	DvsUuid pulumi.StringPtrInput
	// The identifier of the NSX Edge Cluster.
	EdgeCluster pulumi.StringPtrInput
	// CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.
	EgressCidrs SupervisorEgressCidrArrayInput
	// CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.
	IngressCidrs SupervisorIngressCidrArrayInput
	// The list of addresses of the primary DNS servers.
	MainDns pulumi.StringArrayInput
	// The list of addresses of the primary NTP servers.
	MainNtps pulumi.StringArrayInput
	// The configuration for the management network which the control plane VMs will be connected to.
	// * * `network` - ID of the network. (e.g. a distributed port group).
	// * * `startingAddress` - Starting address of the management network range.
	// * * `subnetMask` - Subnet mask.
	// * * `gateway` - Gateway IP address.
	// * * `addressCount` - Number of addresses to allocate. Starts from `startingAddress`
	ManagementNetwork SupervisorManagementNetworkPtrInput
	// The list of namespaces to create in the Supervisor cluster
	Namespaces SupervisorNamespaceArrayInput
	// CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.
	PodCidrs SupervisorPodCidrArrayInput
	// List of DNS search domains.
	SearchDomains pulumi.StringPtrInput
	// CIDR block from which Kubernetes allocates service cluster IP addresses.
	ServiceCidr SupervisorServiceCidrPtrInput
	// The size of the Kubernetes API server.
	SizingHint pulumi.StringPtrInput
	// The name of the storage policy.
	StoragePolicy pulumi.StringPtrInput
	// The list of addresses of the DNS servers to use for the worker nodes.
	WorkerDns pulumi.StringArrayInput
	// The list of addresses of the NTP servers to use for the worker nodes.
	WorkerNtps pulumi.StringArrayInput
}

func (SupervisorState) ElementType() reflect.Type {
	return reflect.TypeOf((*supervisorState)(nil)).Elem()
}

type supervisorArgs struct {
	// The identifier of the compute cluster.
	Cluster string `pulumi:"cluster"`
	// The identifier of the subscribed content library.
	ContentLibrary string `pulumi:"contentLibrary"`
	// The UUID of the distributed switch.
	DvsUuid string `pulumi:"dvsUuid"`
	// The identifier of the NSX Edge Cluster.
	EdgeCluster string `pulumi:"edgeCluster"`
	// CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.
	EgressCidrs []SupervisorEgressCidr `pulumi:"egressCidrs"`
	// CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.
	IngressCidrs []SupervisorIngressCidr `pulumi:"ingressCidrs"`
	// The list of addresses of the primary DNS servers.
	MainDns []string `pulumi:"mainDns"`
	// The list of addresses of the primary NTP servers.
	MainNtps []string `pulumi:"mainNtps"`
	// The configuration for the management network which the control plane VMs will be connected to.
	// * * `network` - ID of the network. (e.g. a distributed port group).
	// * * `startingAddress` - Starting address of the management network range.
	// * * `subnetMask` - Subnet mask.
	// * * `gateway` - Gateway IP address.
	// * * `addressCount` - Number of addresses to allocate. Starts from `startingAddress`
	ManagementNetwork SupervisorManagementNetwork `pulumi:"managementNetwork"`
	// The list of namespaces to create in the Supervisor cluster
	Namespaces []SupervisorNamespace `pulumi:"namespaces"`
	// CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.
	PodCidrs []SupervisorPodCidr `pulumi:"podCidrs"`
	// List of DNS search domains.
	SearchDomains string `pulumi:"searchDomains"`
	// CIDR block from which Kubernetes allocates service cluster IP addresses.
	ServiceCidr SupervisorServiceCidr `pulumi:"serviceCidr"`
	// The size of the Kubernetes API server.
	SizingHint string `pulumi:"sizingHint"`
	// The name of the storage policy.
	StoragePolicy string `pulumi:"storagePolicy"`
	// The list of addresses of the DNS servers to use for the worker nodes.
	WorkerDns []string `pulumi:"workerDns"`
	// The list of addresses of the NTP servers to use for the worker nodes.
	WorkerNtps []string `pulumi:"workerNtps"`
}

// The set of arguments for constructing a Supervisor resource.
type SupervisorArgs struct {
	// The identifier of the compute cluster.
	Cluster pulumi.StringInput
	// The identifier of the subscribed content library.
	ContentLibrary pulumi.StringInput
	// The UUID of the distributed switch.
	DvsUuid pulumi.StringInput
	// The identifier of the NSX Edge Cluster.
	EdgeCluster pulumi.StringInput
	// CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.
	EgressCidrs SupervisorEgressCidrArrayInput
	// CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.
	IngressCidrs SupervisorIngressCidrArrayInput
	// The list of addresses of the primary DNS servers.
	MainDns pulumi.StringArrayInput
	// The list of addresses of the primary NTP servers.
	MainNtps pulumi.StringArrayInput
	// The configuration for the management network which the control plane VMs will be connected to.
	// * * `network` - ID of the network. (e.g. a distributed port group).
	// * * `startingAddress` - Starting address of the management network range.
	// * * `subnetMask` - Subnet mask.
	// * * `gateway` - Gateway IP address.
	// * * `addressCount` - Number of addresses to allocate. Starts from `startingAddress`
	ManagementNetwork SupervisorManagementNetworkInput
	// The list of namespaces to create in the Supervisor cluster
	Namespaces SupervisorNamespaceArrayInput
	// CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.
	PodCidrs SupervisorPodCidrArrayInput
	// List of DNS search domains.
	SearchDomains pulumi.StringInput
	// CIDR block from which Kubernetes allocates service cluster IP addresses.
	ServiceCidr SupervisorServiceCidrInput
	// The size of the Kubernetes API server.
	SizingHint pulumi.StringInput
	// The name of the storage policy.
	StoragePolicy pulumi.StringInput
	// The list of addresses of the DNS servers to use for the worker nodes.
	WorkerDns pulumi.StringArrayInput
	// The list of addresses of the NTP servers to use for the worker nodes.
	WorkerNtps pulumi.StringArrayInput
}

func (SupervisorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*supervisorArgs)(nil)).Elem()
}

type SupervisorInput interface {
	pulumi.Input

	ToSupervisorOutput() SupervisorOutput
	ToSupervisorOutputWithContext(ctx context.Context) SupervisorOutput
}

func (*Supervisor) ElementType() reflect.Type {
	return reflect.TypeOf((**Supervisor)(nil)).Elem()
}

func (i *Supervisor) ToSupervisorOutput() SupervisorOutput {
	return i.ToSupervisorOutputWithContext(context.Background())
}

func (i *Supervisor) ToSupervisorOutputWithContext(ctx context.Context) SupervisorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SupervisorOutput)
}

// SupervisorArrayInput is an input type that accepts SupervisorArray and SupervisorArrayOutput values.
// You can construct a concrete instance of `SupervisorArrayInput` via:
//
//	SupervisorArray{ SupervisorArgs{...} }
type SupervisorArrayInput interface {
	pulumi.Input

	ToSupervisorArrayOutput() SupervisorArrayOutput
	ToSupervisorArrayOutputWithContext(context.Context) SupervisorArrayOutput
}

type SupervisorArray []SupervisorInput

func (SupervisorArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Supervisor)(nil)).Elem()
}

func (i SupervisorArray) ToSupervisorArrayOutput() SupervisorArrayOutput {
	return i.ToSupervisorArrayOutputWithContext(context.Background())
}

func (i SupervisorArray) ToSupervisorArrayOutputWithContext(ctx context.Context) SupervisorArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SupervisorArrayOutput)
}

// SupervisorMapInput is an input type that accepts SupervisorMap and SupervisorMapOutput values.
// You can construct a concrete instance of `SupervisorMapInput` via:
//
//	SupervisorMap{ "key": SupervisorArgs{...} }
type SupervisorMapInput interface {
	pulumi.Input

	ToSupervisorMapOutput() SupervisorMapOutput
	ToSupervisorMapOutputWithContext(context.Context) SupervisorMapOutput
}

type SupervisorMap map[string]SupervisorInput

func (SupervisorMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Supervisor)(nil)).Elem()
}

func (i SupervisorMap) ToSupervisorMapOutput() SupervisorMapOutput {
	return i.ToSupervisorMapOutputWithContext(context.Background())
}

func (i SupervisorMap) ToSupervisorMapOutputWithContext(ctx context.Context) SupervisorMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SupervisorMapOutput)
}

type SupervisorOutput struct{ *pulumi.OutputState }

func (SupervisorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Supervisor)(nil)).Elem()
}

func (o SupervisorOutput) ToSupervisorOutput() SupervisorOutput {
	return o
}

func (o SupervisorOutput) ToSupervisorOutputWithContext(ctx context.Context) SupervisorOutput {
	return o
}

// The identifier of the compute cluster.
func (o SupervisorOutput) Cluster() pulumi.StringOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringOutput { return v.Cluster }).(pulumi.StringOutput)
}

// The identifier of the subscribed content library.
func (o SupervisorOutput) ContentLibrary() pulumi.StringOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringOutput { return v.ContentLibrary }).(pulumi.StringOutput)
}

// The UUID of the distributed switch.
func (o SupervisorOutput) DvsUuid() pulumi.StringOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringOutput { return v.DvsUuid }).(pulumi.StringOutput)
}

// The identifier of the NSX Edge Cluster.
func (o SupervisorOutput) EdgeCluster() pulumi.StringOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringOutput { return v.EdgeCluster }).(pulumi.StringOutput)
}

// CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.
func (o SupervisorOutput) EgressCidrs() SupervisorEgressCidrArrayOutput {
	return o.ApplyT(func(v *Supervisor) SupervisorEgressCidrArrayOutput { return v.EgressCidrs }).(SupervisorEgressCidrArrayOutput)
}

// CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.
func (o SupervisorOutput) IngressCidrs() SupervisorIngressCidrArrayOutput {
	return o.ApplyT(func(v *Supervisor) SupervisorIngressCidrArrayOutput { return v.IngressCidrs }).(SupervisorIngressCidrArrayOutput)
}

// The list of addresses of the primary DNS servers.
func (o SupervisorOutput) MainDns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringArrayOutput { return v.MainDns }).(pulumi.StringArrayOutput)
}

// The list of addresses of the primary NTP servers.
func (o SupervisorOutput) MainNtps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringArrayOutput { return v.MainNtps }).(pulumi.StringArrayOutput)
}

// The configuration for the management network which the control plane VMs will be connected to.
// * * `network` - ID of the network. (e.g. a distributed port group).
// * * `startingAddress` - Starting address of the management network range.
// * * `subnetMask` - Subnet mask.
// * * `gateway` - Gateway IP address.
// * * `addressCount` - Number of addresses to allocate. Starts from `startingAddress`
func (o SupervisorOutput) ManagementNetwork() SupervisorManagementNetworkOutput {
	return o.ApplyT(func(v *Supervisor) SupervisorManagementNetworkOutput { return v.ManagementNetwork }).(SupervisorManagementNetworkOutput)
}

// The list of namespaces to create in the Supervisor cluster
func (o SupervisorOutput) Namespaces() SupervisorNamespaceArrayOutput {
	return o.ApplyT(func(v *Supervisor) SupervisorNamespaceArrayOutput { return v.Namespaces }).(SupervisorNamespaceArrayOutput)
}

// CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.
func (o SupervisorOutput) PodCidrs() SupervisorPodCidrArrayOutput {
	return o.ApplyT(func(v *Supervisor) SupervisorPodCidrArrayOutput { return v.PodCidrs }).(SupervisorPodCidrArrayOutput)
}

// List of DNS search domains.
func (o SupervisorOutput) SearchDomains() pulumi.StringOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringOutput { return v.SearchDomains }).(pulumi.StringOutput)
}

// CIDR block from which Kubernetes allocates service cluster IP addresses.
func (o SupervisorOutput) ServiceCidr() SupervisorServiceCidrOutput {
	return o.ApplyT(func(v *Supervisor) SupervisorServiceCidrOutput { return v.ServiceCidr }).(SupervisorServiceCidrOutput)
}

// The size of the Kubernetes API server.
func (o SupervisorOutput) SizingHint() pulumi.StringOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringOutput { return v.SizingHint }).(pulumi.StringOutput)
}

// The name of the storage policy.
func (o SupervisorOutput) StoragePolicy() pulumi.StringOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringOutput { return v.StoragePolicy }).(pulumi.StringOutput)
}

// The list of addresses of the DNS servers to use for the worker nodes.
func (o SupervisorOutput) WorkerDns() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringArrayOutput { return v.WorkerDns }).(pulumi.StringArrayOutput)
}

// The list of addresses of the NTP servers to use for the worker nodes.
func (o SupervisorOutput) WorkerNtps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Supervisor) pulumi.StringArrayOutput { return v.WorkerNtps }).(pulumi.StringArrayOutput)
}

type SupervisorArrayOutput struct{ *pulumi.OutputState }

func (SupervisorArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Supervisor)(nil)).Elem()
}

func (o SupervisorArrayOutput) ToSupervisorArrayOutput() SupervisorArrayOutput {
	return o
}

func (o SupervisorArrayOutput) ToSupervisorArrayOutputWithContext(ctx context.Context) SupervisorArrayOutput {
	return o
}

func (o SupervisorArrayOutput) Index(i pulumi.IntInput) SupervisorOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Supervisor {
		return vs[0].([]*Supervisor)[vs[1].(int)]
	}).(SupervisorOutput)
}

type SupervisorMapOutput struct{ *pulumi.OutputState }

func (SupervisorMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Supervisor)(nil)).Elem()
}

func (o SupervisorMapOutput) ToSupervisorMapOutput() SupervisorMapOutput {
	return o
}

func (o SupervisorMapOutput) ToSupervisorMapOutputWithContext(ctx context.Context) SupervisorMapOutput {
	return o
}

func (o SupervisorMapOutput) MapIndex(k pulumi.StringInput) SupervisorOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Supervisor {
		return vs[0].(map[string]*Supervisor)[vs[1].(string)]
	}).(SupervisorOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SupervisorInput)(nil)).Elem(), &Supervisor{})
	pulumi.RegisterInputType(reflect.TypeOf((*SupervisorArrayInput)(nil)).Elem(), SupervisorArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SupervisorMapInput)(nil)).Elem(), SupervisorMap{})
	pulumi.RegisterOutputType(SupervisorOutput{})
	pulumi.RegisterOutputType(SupervisorArrayOutput{})
	pulumi.RegisterOutputType(SupervisorMapOutput{})
}
