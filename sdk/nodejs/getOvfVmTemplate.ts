// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * The `vsphere.getOvfVmTemplate` data source can be used to submit an OVF to
 * vSphere and extract its hardware settings in a form that can be then used as
 * inputs for a `vsphere.VirtualMachine` resource.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as std from "@pulumi/std";
 * import * as vsphere from "@pulumi/vsphere";
 *
 * const datacenter = vsphere.getDatacenter({
 *     name: "dc-01",
 * });
 * const datastore = datacenter.then(datacenter => vsphere.getDatastore({
 *     name: "datastore-01",
 *     datacenterId: datacenter.id,
 * }));
 * const cluster = datacenter.then(datacenter => vsphere.getComputeCluster({
 *     name: "cluster-01",
 *     datacenterId: datacenter.id,
 * }));
 * const _default = Promise.all([cluster, datacenter]).then(([cluster, datacenter]) => vsphere.getResourcePool({
 *     name: std.index.format({
 *         input: "%s%s",
 *         args: [
 *             cluster.name,
 *             "/Resources",
 *         ],
 *     }).result,
 *     datacenterId: datacenter.id,
 * }));
 * const host = datacenter.then(datacenter => vsphere.getHost({
 *     name: "esxi-01.example.com",
 *     datacenterId: datacenter.id,
 * }));
 * const network = datacenter.then(datacenter => vsphere.getNetwork({
 *     name: "172.16.11.0",
 *     datacenterId: datacenter.id,
 * }));
 * //# Remote OVF/OVA Source
 * const ovfRemote = Promise.all([_default, datastore, host, network]).then(([_default, datastore, host, network]) => vsphere.getOvfVmTemplate({
 *     name: "ubuntu-server-cloud-image-01",
 *     diskProvisioning: "thin",
 *     resourcePoolId: _default.id,
 *     datastoreId: datastore.id,
 *     hostSystemId: host.id,
 *     remoteOvfUrl: "https://cloud-images.ubuntu.com/releases/xx.xx/release/ubuntu-xx.xx-server-cloudimg-amd64.ova",
 *     ovfNetworkMap: {
 *         "VM Network": network.id,
 *     },
 * }));
 * //# Local OVF/OVA Source
 * const ovfLocal = Promise.all([_default, datastore, host, network]).then(([_default, datastore, host, network]) => vsphere.getOvfVmTemplate({
 *     name: "ubuntu-server-cloud-image-02",
 *     diskProvisioning: "thin",
 *     resourcePoolId: _default.id,
 *     datastoreId: datastore.id,
 *     hostSystemId: host.id,
 *     localOvfPath: "/Volume/Storage/OVA/ubuntu-xx-xx-server-cloudimg-amd64.ova",
 *     ovfNetworkMap: {
 *         "VM Network": network.id,
 *     },
 * }));
 * //# Deployment of VM from Remote OVF
 * const vmFromRemoteOvf = new vsphere.VirtualMachine("vmFromRemoteOvf", {
 *     networkInterfaces: .map(entry => ({
 *         networkId: entry.value,
 *     })),
 *     name: "ubuntu-server-cloud-image-01",
 *     datacenterId: datacenter.then(datacenter => datacenter.id),
 *     datastoreId: datastore.then(datastore => datastore.id),
 *     hostSystemId: host.then(host => host.id),
 *     resourcePoolId: _default.then(_default => _default.id),
 *     numCpus: ovfRemote.then(ovfRemote => ovfRemote.numCpus),
 *     numCoresPerSocket: ovfRemote.then(ovfRemote => ovfRemote.numCoresPerSocket),
 *     memory: ovfRemote.then(ovfRemote => ovfRemote.memory),
 *     guestId: ovfRemote.then(ovfRemote => ovfRemote.guestId),
 *     firmware: ovfRemote.then(ovfRemote => ovfRemote.firmware),
 *     scsiType: ovfRemote.then(ovfRemote => ovfRemote.scsiType),
 *     waitForGuestNetTimeout: 0,
 *     waitForGuestIpTimeout: 0,
 *     ovfDeploy: {
 *         remoteOvfUrl: "https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.ova",
 *         ovfNetworkMap: ovfRemote.then(ovfRemote => ovfRemote.ovfNetworkMap),
 *     },
 *     cdroms: [{
 *         clientDevice: true,
 *     }],
 *     vapp: {
 *         properties: {
 *             hostname: remoteOvfName,
 *             "instance-id": remoteOvfUuid,
 *             "public-keys": remoteOvfPublicKeys,
 *             password: remoteOvfPassword,
 *             "user-data": std.index.base64encode({
 *                 input: remoteOvfUserData,
 *             }).result,
 *         },
 *     },
 * });
 * //# Deployment of VM from Local OVF
 * const vmFromLocalOvf = new vsphere.VirtualMachine("vmFromLocalOvf", {
 *     networkInterfaces: .map(entry => ({
 *         networkId: entry.value,
 *     })),
 *     name: "ubuntu-server-cloud-image-02",
 *     datacenterId: datacenter.then(datacenter => datacenter.id),
 *     datastoreId: datastore.then(datastore => datastore.id),
 *     hostSystemId: host.then(host => host.id),
 *     resourcePoolId: _default.then(_default => _default.id),
 *     numCpus: ovfLocal.then(ovfLocal => ovfLocal.numCpus),
 *     numCoresPerSocket: ovfLocal.then(ovfLocal => ovfLocal.numCoresPerSocket),
 *     memory: ovfLocal.then(ovfLocal => ovfLocal.memory),
 *     guestId: ovfLocal.then(ovfLocal => ovfLocal.guestId),
 *     firmware: ovfLocal.then(ovfLocal => ovfLocal.firmware),
 *     scsiType: ovfLocal.then(ovfLocal => ovfLocal.scsiType),
 *     waitForGuestNetTimeout: 0,
 *     waitForGuestIpTimeout: 0,
 *     ovfDeploy: {
 *         allowUnverifiedSslCert: false,
 *         localOvfPath: ovfLocal.then(ovfLocal => ovfLocal.localOvfPath),
 *         diskProvisioning: ovfLocal.then(ovfLocal => ovfLocal.diskProvisioning),
 *         ovfNetworkMap: ovfLocal.then(ovfLocal => ovfLocal.ovfNetworkMap),
 *     },
 *     cdroms: [{
 *         clientDevice: true,
 *     }],
 *     vapp: {
 *         properties: {
 *             hostname: localOvfName,
 *             "instance-id": localOvfUuid,
 *             "public-keys": localOvfPublicKeys,
 *             password: localOvfPassword,
 *             "user-data": std.index.base64encode({
 *                 input: localOvfUserData,
 *             }).result,
 *         },
 *     },
 * });
 * ```
 */
export function getOvfVmTemplate(args: GetOvfVmTemplateArgs, opts?: pulumi.InvokeOptions): Promise<GetOvfVmTemplateResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("vsphere:index/getOvfVmTemplate:getOvfVmTemplate", {
        "allowUnverifiedSslCert": args.allowUnverifiedSslCert,
        "datastoreId": args.datastoreId,
        "deploymentOption": args.deploymentOption,
        "diskProvisioning": args.diskProvisioning,
        "enableHiddenProperties": args.enableHiddenProperties,
        "folder": args.folder,
        "hostSystemId": args.hostSystemId,
        "ipAllocationPolicy": args.ipAllocationPolicy,
        "ipProtocol": args.ipProtocol,
        "localOvfPath": args.localOvfPath,
        "name": args.name,
        "ovfNetworkMap": args.ovfNetworkMap,
        "remoteOvfUrl": args.remoteOvfUrl,
        "resourcePoolId": args.resourcePoolId,
    }, opts);
}

/**
 * A collection of arguments for invoking getOvfVmTemplate.
 */
export interface GetOvfVmTemplateArgs {
    /**
     * Allow unverified SSL certificates
     * when deploying OVF/OVA from a URL.
     */
    allowUnverifiedSslCert?: boolean;
    /**
     * The ID of the virtual machine's datastore. The
     * virtual machine configuration is placed here, along with any virtual disks
     * that are created without datastores.
     */
    datastoreId?: string;
    /**
     * The key of the chosen deployment option. If
     * empty, the default option is chosen.
     */
    deploymentOption?: string;
    /**
     * The disk provisioning type. If set, all the
     * disks included in the OVF/OVA will have the same specified policy. Can be
     * one of `thin`, `thick`, or `eagerZeroedThick`.
     */
    diskProvisioning?: string;
    /**
     * Allow properties with
     * `ovf:userConfigurable=false` to be set.
     */
    enableHiddenProperties?: boolean;
    /**
     * The name of the folder in which to place the virtual
     * machine.
     */
    folder?: string;
    /**
     * The ID of the ESXi host system to deploy the
     * virtual machine.
     */
    hostSystemId: string;
    /**
     * The IP allocation policy.
     */
    ipAllocationPolicy?: string;
    /**
     * The IP protocol.
     */
    ipProtocol?: string;
    /**
     * The absolute path to the OVF/OVA file on the
     * local system. When deploying from an OVF, ensure all necessary files such as
     * the `.vmdk` files are present in the same directory as the OVF.
     */
    localOvfPath?: string;
    /**
     * Name of the virtual machine to create.
     */
    name: string;
    /**
     * The mapping of name of network identifiers
     * from the OVF descriptor to network UUID in the environment.
     */
    ovfNetworkMap?: {[key: string]: string};
    /**
     * URL of the remote OVF/OVA file to be deployed.
     *
     * > **NOTE:** Either `localOvfPath` or `remoteOvfUrl` is required, both can
     * not be empty.
     */
    remoteOvfUrl?: string;
    /**
     * The ID of a resource pool in which to place
     * the virtual machine.
     */
    resourcePoolId: string;
}

/**
 * A collection of values returned by getOvfVmTemplate.
 */
export interface GetOvfVmTemplateResult {
    readonly allowUnverifiedSslCert?: boolean;
    /**
     * An alternate guest operating system name.
     */
    readonly alternateGuestName: string;
    /**
     * A description of the virtual machine.
     */
    readonly annotation: string;
    /**
     * Allow CPUs to be added to the virtual machine while
     * powered on.
     */
    readonly cpuHotAddEnabled: boolean;
    /**
     * Allow CPUs to be removed from the virtual machine
     * while powered on.
     */
    readonly cpuHotRemoveEnabled: boolean;
    readonly cpuPerformanceCountersEnabled: boolean;
    readonly datastoreId?: string;
    readonly deploymentOption?: string;
    readonly diskProvisioning?: string;
    readonly enableHiddenProperties?: boolean;
    /**
     * The firmware to use on the virtual machine.
     */
    readonly firmware: string;
    readonly folder?: string;
    /**
     * The ID for the guest operating system
     */
    readonly guestId: string;
    readonly hostSystemId: string;
    /**
     * The provider-assigned unique ID for this managed resource.
     */
    readonly id: string;
    readonly ideControllerCount: number;
    readonly ipAllocationPolicy?: string;
    readonly ipProtocol?: string;
    readonly localOvfPath?: string;
    /**
     * The size of the virtual machine memory, in MB.
     */
    readonly memory: number;
    /**
     * Allow memory to be added to the virtual machine
     * while powered on.
     */
    readonly memoryHotAddEnabled: boolean;
    readonly name: string;
    /**
     * Enable nested hardware virtualization on the virtual
     * machine, facilitating nested virtualization in the guest.
     */
    readonly nestedHvEnabled: boolean;
    /**
     * The number of cores per virtual CPU in the virtual
     * machine.
     */
    readonly numCoresPerSocket: number;
    /**
     * The number of virtual CPUs to assign to the virtual machine.
     */
    readonly numCpus: number;
    readonly ovfNetworkMap?: {[key: string]: string};
    readonly remoteOvfUrl?: string;
    readonly resourcePoolId: string;
    readonly sataControllerCount: number;
    readonly scsiControllerCount: number;
    readonly scsiType: string;
    /**
     * The swap file placement policy for the virtual
     * machine.
     */
    readonly swapPlacementPolicy: string;
}
/**
 * The `vsphere.getOvfVmTemplate` data source can be used to submit an OVF to
 * vSphere and extract its hardware settings in a form that can be then used as
 * inputs for a `vsphere.VirtualMachine` resource.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as std from "@pulumi/std";
 * import * as vsphere from "@pulumi/vsphere";
 *
 * const datacenter = vsphere.getDatacenter({
 *     name: "dc-01",
 * });
 * const datastore = datacenter.then(datacenter => vsphere.getDatastore({
 *     name: "datastore-01",
 *     datacenterId: datacenter.id,
 * }));
 * const cluster = datacenter.then(datacenter => vsphere.getComputeCluster({
 *     name: "cluster-01",
 *     datacenterId: datacenter.id,
 * }));
 * const _default = Promise.all([cluster, datacenter]).then(([cluster, datacenter]) => vsphere.getResourcePool({
 *     name: std.index.format({
 *         input: "%s%s",
 *         args: [
 *             cluster.name,
 *             "/Resources",
 *         ],
 *     }).result,
 *     datacenterId: datacenter.id,
 * }));
 * const host = datacenter.then(datacenter => vsphere.getHost({
 *     name: "esxi-01.example.com",
 *     datacenterId: datacenter.id,
 * }));
 * const network = datacenter.then(datacenter => vsphere.getNetwork({
 *     name: "172.16.11.0",
 *     datacenterId: datacenter.id,
 * }));
 * //# Remote OVF/OVA Source
 * const ovfRemote = Promise.all([_default, datastore, host, network]).then(([_default, datastore, host, network]) => vsphere.getOvfVmTemplate({
 *     name: "ubuntu-server-cloud-image-01",
 *     diskProvisioning: "thin",
 *     resourcePoolId: _default.id,
 *     datastoreId: datastore.id,
 *     hostSystemId: host.id,
 *     remoteOvfUrl: "https://cloud-images.ubuntu.com/releases/xx.xx/release/ubuntu-xx.xx-server-cloudimg-amd64.ova",
 *     ovfNetworkMap: {
 *         "VM Network": network.id,
 *     },
 * }));
 * //# Local OVF/OVA Source
 * const ovfLocal = Promise.all([_default, datastore, host, network]).then(([_default, datastore, host, network]) => vsphere.getOvfVmTemplate({
 *     name: "ubuntu-server-cloud-image-02",
 *     diskProvisioning: "thin",
 *     resourcePoolId: _default.id,
 *     datastoreId: datastore.id,
 *     hostSystemId: host.id,
 *     localOvfPath: "/Volume/Storage/OVA/ubuntu-xx-xx-server-cloudimg-amd64.ova",
 *     ovfNetworkMap: {
 *         "VM Network": network.id,
 *     },
 * }));
 * //# Deployment of VM from Remote OVF
 * const vmFromRemoteOvf = new vsphere.VirtualMachine("vmFromRemoteOvf", {
 *     networkInterfaces: .map(entry => ({
 *         networkId: entry.value,
 *     })),
 *     name: "ubuntu-server-cloud-image-01",
 *     datacenterId: datacenter.then(datacenter => datacenter.id),
 *     datastoreId: datastore.then(datastore => datastore.id),
 *     hostSystemId: host.then(host => host.id),
 *     resourcePoolId: _default.then(_default => _default.id),
 *     numCpus: ovfRemote.then(ovfRemote => ovfRemote.numCpus),
 *     numCoresPerSocket: ovfRemote.then(ovfRemote => ovfRemote.numCoresPerSocket),
 *     memory: ovfRemote.then(ovfRemote => ovfRemote.memory),
 *     guestId: ovfRemote.then(ovfRemote => ovfRemote.guestId),
 *     firmware: ovfRemote.then(ovfRemote => ovfRemote.firmware),
 *     scsiType: ovfRemote.then(ovfRemote => ovfRemote.scsiType),
 *     waitForGuestNetTimeout: 0,
 *     waitForGuestIpTimeout: 0,
 *     ovfDeploy: {
 *         remoteOvfUrl: "https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.ova",
 *         ovfNetworkMap: ovfRemote.then(ovfRemote => ovfRemote.ovfNetworkMap),
 *     },
 *     cdroms: [{
 *         clientDevice: true,
 *     }],
 *     vapp: {
 *         properties: {
 *             hostname: remoteOvfName,
 *             "instance-id": remoteOvfUuid,
 *             "public-keys": remoteOvfPublicKeys,
 *             password: remoteOvfPassword,
 *             "user-data": std.index.base64encode({
 *                 input: remoteOvfUserData,
 *             }).result,
 *         },
 *     },
 * });
 * //# Deployment of VM from Local OVF
 * const vmFromLocalOvf = new vsphere.VirtualMachine("vmFromLocalOvf", {
 *     networkInterfaces: .map(entry => ({
 *         networkId: entry.value,
 *     })),
 *     name: "ubuntu-server-cloud-image-02",
 *     datacenterId: datacenter.then(datacenter => datacenter.id),
 *     datastoreId: datastore.then(datastore => datastore.id),
 *     hostSystemId: host.then(host => host.id),
 *     resourcePoolId: _default.then(_default => _default.id),
 *     numCpus: ovfLocal.then(ovfLocal => ovfLocal.numCpus),
 *     numCoresPerSocket: ovfLocal.then(ovfLocal => ovfLocal.numCoresPerSocket),
 *     memory: ovfLocal.then(ovfLocal => ovfLocal.memory),
 *     guestId: ovfLocal.then(ovfLocal => ovfLocal.guestId),
 *     firmware: ovfLocal.then(ovfLocal => ovfLocal.firmware),
 *     scsiType: ovfLocal.then(ovfLocal => ovfLocal.scsiType),
 *     waitForGuestNetTimeout: 0,
 *     waitForGuestIpTimeout: 0,
 *     ovfDeploy: {
 *         allowUnverifiedSslCert: false,
 *         localOvfPath: ovfLocal.then(ovfLocal => ovfLocal.localOvfPath),
 *         diskProvisioning: ovfLocal.then(ovfLocal => ovfLocal.diskProvisioning),
 *         ovfNetworkMap: ovfLocal.then(ovfLocal => ovfLocal.ovfNetworkMap),
 *     },
 *     cdroms: [{
 *         clientDevice: true,
 *     }],
 *     vapp: {
 *         properties: {
 *             hostname: localOvfName,
 *             "instance-id": localOvfUuid,
 *             "public-keys": localOvfPublicKeys,
 *             password: localOvfPassword,
 *             "user-data": std.index.base64encode({
 *                 input: localOvfUserData,
 *             }).result,
 *         },
 *     },
 * });
 * ```
 */
export function getOvfVmTemplateOutput(args: GetOvfVmTemplateOutputArgs, opts?: pulumi.InvokeOutputOptions): pulumi.Output<GetOvfVmTemplateResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invokeOutput("vsphere:index/getOvfVmTemplate:getOvfVmTemplate", {
        "allowUnverifiedSslCert": args.allowUnverifiedSslCert,
        "datastoreId": args.datastoreId,
        "deploymentOption": args.deploymentOption,
        "diskProvisioning": args.diskProvisioning,
        "enableHiddenProperties": args.enableHiddenProperties,
        "folder": args.folder,
        "hostSystemId": args.hostSystemId,
        "ipAllocationPolicy": args.ipAllocationPolicy,
        "ipProtocol": args.ipProtocol,
        "localOvfPath": args.localOvfPath,
        "name": args.name,
        "ovfNetworkMap": args.ovfNetworkMap,
        "remoteOvfUrl": args.remoteOvfUrl,
        "resourcePoolId": args.resourcePoolId,
    }, opts);
}

/**
 * A collection of arguments for invoking getOvfVmTemplate.
 */
export interface GetOvfVmTemplateOutputArgs {
    /**
     * Allow unverified SSL certificates
     * when deploying OVF/OVA from a URL.
     */
    allowUnverifiedSslCert?: pulumi.Input<boolean>;
    /**
     * The ID of the virtual machine's datastore. The
     * virtual machine configuration is placed here, along with any virtual disks
     * that are created without datastores.
     */
    datastoreId?: pulumi.Input<string>;
    /**
     * The key of the chosen deployment option. If
     * empty, the default option is chosen.
     */
    deploymentOption?: pulumi.Input<string>;
    /**
     * The disk provisioning type. If set, all the
     * disks included in the OVF/OVA will have the same specified policy. Can be
     * one of `thin`, `thick`, or `eagerZeroedThick`.
     */
    diskProvisioning?: pulumi.Input<string>;
    /**
     * Allow properties with
     * `ovf:userConfigurable=false` to be set.
     */
    enableHiddenProperties?: pulumi.Input<boolean>;
    /**
     * The name of the folder in which to place the virtual
     * machine.
     */
    folder?: pulumi.Input<string>;
    /**
     * The ID of the ESXi host system to deploy the
     * virtual machine.
     */
    hostSystemId: pulumi.Input<string>;
    /**
     * The IP allocation policy.
     */
    ipAllocationPolicy?: pulumi.Input<string>;
    /**
     * The IP protocol.
     */
    ipProtocol?: pulumi.Input<string>;
    /**
     * The absolute path to the OVF/OVA file on the
     * local system. When deploying from an OVF, ensure all necessary files such as
     * the `.vmdk` files are present in the same directory as the OVF.
     */
    localOvfPath?: pulumi.Input<string>;
    /**
     * Name of the virtual machine to create.
     */
    name: pulumi.Input<string>;
    /**
     * The mapping of name of network identifiers
     * from the OVF descriptor to network UUID in the environment.
     */
    ovfNetworkMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * URL of the remote OVF/OVA file to be deployed.
     *
     * > **NOTE:** Either `localOvfPath` or `remoteOvfUrl` is required, both can
     * not be empty.
     */
    remoteOvfUrl?: pulumi.Input<string>;
    /**
     * The ID of a resource pool in which to place
     * the virtual machine.
     */
    resourcePoolId: pulumi.Input<string>;
}
