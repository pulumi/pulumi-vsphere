// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * The `vsphere.DistributedVirtualSwitch` resource can be used to manage vSphere
 * Distributed Switches (VDS).
 *
 * An essential component of a distributed, scalable vSphere infrastructure, the
 * VDS provides centralized management and monitoring of the networking
 * configuration for all the hosts that are associated with the switch.
 * In addition to adding distributed port groups
 * (see the `vsphere.DistributedPortGroup` resource)
 * that can be used as networks for virtual machines, a VDS can be configured to
 * perform advanced high availability, traffic shaping, network monitoring, etc.
 *
 * For an overview on vSphere networking concepts, see
 * [this page][ref-vsphere-net-concepts].
 *
 * For more information on the VDS, see [this page][ref-vsphere-vds].
 *
 * [ref-vsphere-net-concepts]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches/dvport-groups.html
 * [ref-vsphere-vds]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches.html
 *
 * > **NOTE:** This resource requires vCenter and is not available on
 * direct ESXi host connections.
 *
 * ## Example Usage
 *
 * The following example below demonstrates a "standard" example of configuring a
 * VDS in a 3-node vSphere datacenter named `dc1`, across 4 NICs with two being
 * used as active, and two being used as passive. Note that the NIC failover order
 * propagates to any port groups configured on this VDS and can be overridden.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as vsphere from "@pulumi/vsphere";
 *
 * const config = new pulumi.Config();
 * const hosts = config.getObject<any>("hosts") || [
 *     "esxi-01.example.com",
 *     "esxi-02.example.com",
 *     "esxi-03.example.com",
 * ];
 * const networkInterfaces = config.getObject<any>("networkInterfaces") || [
 *     "vmnic0",
 *     "vmnic1",
 *     "vmnic2",
 *     "vmnic3",
 * ];
 * const datacenter = vsphere.getDatacenter({
 *     name: "dc-01",
 * });
 * const host = (new Array(hosts.length)).map((_, i) => i).map(__index => (vsphere.getHost({
 *     name: hosts[__index],
 *     datacenterId: _arg0_.id,
 * })));
 * const vds = new vsphere.DistributedVirtualSwitch("vds", {
 *     name: "vds-01",
 *     datacenterId: datacenter.then(datacenter => datacenter.id),
 *     uplinks: [
 *         "uplink1",
 *         "uplink2",
 *         "uplink3",
 *         "uplink4",
 *     ],
 *     activeUplinks: [
 *         "uplink1",
 *         "uplink2",
 *     ],
 *     standbyUplinks: [
 *         "uplink3",
 *         "uplink4",
 *     ],
 *     hosts: [
 *         {
 *             hostSystemId: host[0].then(host => host.id),
 *             devices: [networkInterfaces],
 *         },
 *         {
 *             hostSystemId: host[1].then(host => host.id),
 *             devices: [networkInterfaces],
 *         },
 *         {
 *             hostSystemId: host[2].then(host => host.id),
 *             devices: [networkInterfaces],
 *         },
 *     ],
 * });
 * ```
 *
 * ### Uplink name and count control
 *
 * The following abridged example below demonstrates how you can manage the number
 * of uplinks, and the name of the uplinks via the `uplinks` parameter.
 *
 * Note that if you change the uplink naming and count after creating the VDS, you
 * may need to explicitly specify `activeUplinks` and `standbyUplinks` as these
 * values are saved to state after creation, regardless of being
 * specified in config, and will drift if not modified, causing errors.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as vsphere from "@pulumi/vsphere";
 *
 * const vds = new vsphere.DistributedVirtualSwitch("vds", {
 *     name: "vds-01",
 *     datacenterId: datacenter.id,
 *     uplinks: [
 *         "uplink1",
 *         "uplink2",
 *     ],
 *     activeUplinks: ["uplink1"],
 *     standbyUplinks: ["uplink2"],
 * });
 * ```
 *
 * > **NOTE:** The default uplink names when a VDS is created are `uplink1`
 * through to `uplink4`, however this default is not guaranteed to be stable and
 * you are encouraged to set your own.
 *
 * ## Import
 *
 * An existing VDS can be imported into this resource via the path
 *
 * to the VDS, via the following command:
 *
 * [docs-import]: https://developer.hashicorp.com/terraform/cli/import
 *
 * ```sh
 * $ pulumi import vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch vds /dc-01/network/vds-01
 * ```
 *
 * The above would import the VDS named `vds-01` that is located in the `dc-01`
 *
 * datacenter.
 */
export class DistributedVirtualSwitch extends pulumi.CustomResource {
    /**
     * Get an existing DistributedVirtualSwitch resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DistributedVirtualSwitchState, opts?: pulumi.CustomResourceOptions): DistributedVirtualSwitch {
        return new DistributedVirtualSwitch(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch';

    /**
     * Returns true if the given object is an instance of DistributedVirtualSwitch.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DistributedVirtualSwitch {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DistributedVirtualSwitch.__pulumiType;
    }

    /**
     * List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     */
    declare public readonly activeUplinks: pulumi.Output<string[]>;
    /**
     * Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
     */
    declare public readonly allowForgedTransmits: pulumi.Output<boolean>;
    /**
     * Controls whether or not the Media Access Control (MAC) address can be changed.
     */
    declare public readonly allowMacChanges: pulumi.Output<boolean>;
    /**
     * Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
     */
    declare public readonly allowPromiscuous: pulumi.Output<boolean>;
    /**
     * The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     */
    declare public readonly backupnfcMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     */
    declare public readonly backupnfcReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     */
    declare public readonly backupnfcShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly backupnfcShareLevel: pulumi.Output<string>;
    /**
     * Indicates whether to block all ports by default.
     */
    declare public readonly blockAllPorts: pulumi.Output<boolean>;
    /**
     * Enable beacon probing on the ports this policy applies to.
     */
    declare public readonly checkBeacon: pulumi.Output<boolean>;
    /**
     * The current version of the VDS configuration, incremented
     * by subsequent updates to the VDS.
     */
    declare public /*out*/ readonly configVersion: pulumi.Output<string>;
    /**
     * The detailed contact information for the person
     * who is responsible for the VDS.
     */
    declare public readonly contactDetail: pulumi.Output<string | undefined>;
    /**
     * The name of the person who is responsible for the
     * VDS.
     */
    declare public readonly contactName: pulumi.Output<string | undefined>;
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for VDS.
     *
     * > **NOTE:** Custom attributes are unsupported on direct ESXi host connections
     * and requires vCenter Server.
     */
    declare public readonly customAttributes: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The ID of the datacenter where the VDS will be
     * created. Forces a new resource if changed.
     */
    declare public readonly datacenterId: pulumi.Output<string>;
    /**
     * A detailed description for the VDS.
     */
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * Allow VMDirectPath Gen2 on the ports this policy applies to.
     */
    declare public readonly directpathGen2Allowed: pulumi.Output<boolean>;
    /**
     * The average egress bandwidth in bits per second if egress shaping is enabled on the port.
     */
    declare public readonly egressShapingAverageBandwidth: pulumi.Output<number>;
    /**
     * The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
     */
    declare public readonly egressShapingBurstSize: pulumi.Output<number>;
    /**
     * True if the traffic shaper is enabled for egress traffic on the port.
     */
    declare public readonly egressShapingEnabled: pulumi.Output<boolean>;
    /**
     * The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
     */
    declare public readonly egressShapingPeakBandwidth: pulumi.Output<number>;
    /**
     * If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
     */
    declare public readonly failback: pulumi.Output<boolean>;
    /**
     * The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     */
    declare public readonly faulttoleranceMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     */
    declare public readonly faulttoleranceReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     */
    declare public readonly faulttoleranceShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly faulttoleranceShareLevel: pulumi.Output<string>;
    /**
     * The folder in which to create the VDS.
     * Forces a new resource if changed.
     */
    declare public readonly folder: pulumi.Output<string | undefined>;
    /**
     * The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     */
    declare public readonly hbrMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     */
    declare public readonly hbrReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the hbr traffic class for a custom share level.
     */
    declare public readonly hbrShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly hbrShareLevel: pulumi.Output<string>;
    /**
     * A host member specification.
     */
    declare public readonly hosts: pulumi.Output<outputs.DistributedVirtualSwitchHost[] | undefined>;
    /**
     * Whether to ignore existing PVLAN mappings not managed by this resource.
     */
    declare public readonly ignoreOtherPvlanMappings: pulumi.Output<boolean | undefined>;
    /**
     * The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
     */
    declare public readonly ingressShapingAverageBandwidth: pulumi.Output<number>;
    /**
     * The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
     */
    declare public readonly ingressShapingBurstSize: pulumi.Output<number>;
    /**
     * True if the traffic shaper is enabled for ingress traffic on the port.
     */
    declare public readonly ingressShapingEnabled: pulumi.Output<boolean>;
    /**
     * The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
     */
    declare public readonly ingressShapingPeakBandwidth: pulumi.Output<number>;
    /**
     * An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments.
     */
    declare public readonly ipv4Address: pulumi.Output<string | undefined>;
    /**
     * The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     */
    declare public readonly iscsiMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     */
    declare public readonly iscsiReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     */
    declare public readonly iscsiShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly iscsiShareLevel: pulumi.Output<string>;
    /**
     * The Link Aggregation Control Protocol group
     * version to use with the VDS. Possible values are `singleLag` and
     * `multipleLag`.
     */
    declare public readonly lacpApiVersion: pulumi.Output<string>;
    /**
     * Whether or not to enable LACP on all uplink ports.
     */
    declare public readonly lacpEnabled: pulumi.Output<boolean>;
    /**
     * The uplink LACP mode to use. Can be one of active or passive.
     */
    declare public readonly lacpMode: pulumi.Output<string>;
    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic.
     */
    declare public readonly linkDiscoveryOperation: pulumi.Output<string | undefined>;
    /**
     * The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     */
    declare public readonly linkDiscoveryProtocol: pulumi.Output<string | undefined>;
    /**
     * The maximum allowed usage for the management traffic class, in Mbits/sec.
     */
    declare public readonly managementMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     */
    declare public readonly managementReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the management traffic class for a custom share level.
     */
    declare public readonly managementShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly managementShareLevel: pulumi.Output<string>;
    /**
     * The maximum transmission unit (MTU) for the VDS.
     */
    declare public readonly maxMtu: pulumi.Output<number>;
    /**
     * The multicast filtering mode to use
     * with the VDS. Can be one of `legacyFiltering` or `snooping`.
     */
    declare public readonly multicastFilteringMode: pulumi.Output<string>;
    /**
     * The name of the VDS.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * The number of seconds after which active flows are forced to be exported to the collector.
     */
    declare public readonly netflowActiveFlowTimeout: pulumi.Output<number | undefined>;
    /**
     * IP address for the netflow collector, using IPv4 or IPv6.
     */
    declare public readonly netflowCollectorIpAddress: pulumi.Output<string | undefined>;
    /**
     * The port for the netflow collector.
     */
    declare public readonly netflowCollectorPort: pulumi.Output<number | undefined>;
    /**
     * Indicates whether to enable netflow on all ports.
     */
    declare public readonly netflowEnabled: pulumi.Output<boolean>;
    /**
     * The number of seconds after which idle flows are forced to be exported to the collector.
     */
    declare public readonly netflowIdleFlowTimeout: pulumi.Output<number | undefined>;
    /**
     * Whether to limit analysis to traffic that has both source and destination served by the same host.
     */
    declare public readonly netflowInternalFlowsOnly: pulumi.Output<boolean | undefined>;
    /**
     * The observation Domain ID for the netflow collector.
     */
    declare public readonly netflowObservationDomainId: pulumi.Output<number | undefined>;
    /**
     * The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed.
     */
    declare public readonly netflowSamplingRate: pulumi.Output<number | undefined>;
    /**
     * Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
     */
    declare public readonly networkResourceControlEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The network I/O control version to use. Can be one of version2 or version3.
     */
    declare public readonly networkResourceControlVersion: pulumi.Output<string>;
    /**
     * The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     */
    declare public readonly nfsMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     */
    declare public readonly nfsReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the nfs traffic class for a custom share level.
     */
    declare public readonly nfsShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly nfsShareLevel: pulumi.Output<string>;
    /**
     * If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
     */
    declare public readonly notifySwitches: pulumi.Output<boolean>;
    /**
     * The secondary VLAN ID for this port.
     */
    declare public readonly portPrivateSecondaryVlanId: pulumi.Output<number>;
    /**
     * A private VLAN (PVLAN) mapping.
     */
    declare public readonly pvlanMappings: pulumi.Output<outputs.DistributedVirtualSwitchPvlanMapping[] | undefined>;
    /**
     * List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     */
    declare public readonly standbyUplinks: pulumi.Output<string[]>;
    /**
     * The IDs of any tags to attach to this resource.
     */
    declare public readonly tags: pulumi.Output<string[] | undefined>;
    /**
     * The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
     */
    declare public readonly teamingPolicy: pulumi.Output<string>;
    /**
     * If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
     */
    declare public readonly txUplink: pulumi.Output<boolean>;
    /**
     * A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.
     */
    declare public readonly uplinks: pulumi.Output<string[]>;
    /**
     * The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     */
    declare public readonly vdpMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     */
    declare public readonly vdpReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the vdp traffic class for a custom share level.
     */
    declare public readonly vdpShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly vdpShareLevel: pulumi.Output<string>;
    /**
     * The version of the VDS. By default, a VDS is created
     * at the latest version supported by the vSphere version if not specified.
     * A VDS can be upgraded to a newer version, but can not be downgraded.
     */
    declare public readonly version: pulumi.Output<string>;
    /**
     * The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     */
    declare public readonly virtualmachineMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     */
    declare public readonly virtualmachineReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     */
    declare public readonly virtualmachineShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly virtualmachineShareLevel: pulumi.Output<string>;
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     */
    declare public readonly vlanId: pulumi.Output<number>;
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     */
    declare public readonly vlanRanges: pulumi.Output<outputs.DistributedVirtualSwitchVlanRange[]>;
    /**
     * The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     */
    declare public readonly vmotionMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     */
    declare public readonly vmotionReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the vmotion traffic class for a custom share level.
     */
    declare public readonly vmotionShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly vmotionShareLevel: pulumi.Output<string>;
    /**
     * The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     */
    declare public readonly vsanMaximumMbit: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     */
    declare public readonly vsanReservationMbit: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the vsan traffic class for a custom share level.
     */
    declare public readonly vsanShareCount: pulumi.Output<number>;
    /**
     * The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     */
    declare public readonly vsanShareLevel: pulumi.Output<string>;

    /**
     * Create a DistributedVirtualSwitch resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: DistributedVirtualSwitchArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DistributedVirtualSwitchArgs | DistributedVirtualSwitchState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DistributedVirtualSwitchState | undefined;
            resourceInputs["activeUplinks"] = state?.activeUplinks;
            resourceInputs["allowForgedTransmits"] = state?.allowForgedTransmits;
            resourceInputs["allowMacChanges"] = state?.allowMacChanges;
            resourceInputs["allowPromiscuous"] = state?.allowPromiscuous;
            resourceInputs["backupnfcMaximumMbit"] = state?.backupnfcMaximumMbit;
            resourceInputs["backupnfcReservationMbit"] = state?.backupnfcReservationMbit;
            resourceInputs["backupnfcShareCount"] = state?.backupnfcShareCount;
            resourceInputs["backupnfcShareLevel"] = state?.backupnfcShareLevel;
            resourceInputs["blockAllPorts"] = state?.blockAllPorts;
            resourceInputs["checkBeacon"] = state?.checkBeacon;
            resourceInputs["configVersion"] = state?.configVersion;
            resourceInputs["contactDetail"] = state?.contactDetail;
            resourceInputs["contactName"] = state?.contactName;
            resourceInputs["customAttributes"] = state?.customAttributes;
            resourceInputs["datacenterId"] = state?.datacenterId;
            resourceInputs["description"] = state?.description;
            resourceInputs["directpathGen2Allowed"] = state?.directpathGen2Allowed;
            resourceInputs["egressShapingAverageBandwidth"] = state?.egressShapingAverageBandwidth;
            resourceInputs["egressShapingBurstSize"] = state?.egressShapingBurstSize;
            resourceInputs["egressShapingEnabled"] = state?.egressShapingEnabled;
            resourceInputs["egressShapingPeakBandwidth"] = state?.egressShapingPeakBandwidth;
            resourceInputs["failback"] = state?.failback;
            resourceInputs["faulttoleranceMaximumMbit"] = state?.faulttoleranceMaximumMbit;
            resourceInputs["faulttoleranceReservationMbit"] = state?.faulttoleranceReservationMbit;
            resourceInputs["faulttoleranceShareCount"] = state?.faulttoleranceShareCount;
            resourceInputs["faulttoleranceShareLevel"] = state?.faulttoleranceShareLevel;
            resourceInputs["folder"] = state?.folder;
            resourceInputs["hbrMaximumMbit"] = state?.hbrMaximumMbit;
            resourceInputs["hbrReservationMbit"] = state?.hbrReservationMbit;
            resourceInputs["hbrShareCount"] = state?.hbrShareCount;
            resourceInputs["hbrShareLevel"] = state?.hbrShareLevel;
            resourceInputs["hosts"] = state?.hosts;
            resourceInputs["ignoreOtherPvlanMappings"] = state?.ignoreOtherPvlanMappings;
            resourceInputs["ingressShapingAverageBandwidth"] = state?.ingressShapingAverageBandwidth;
            resourceInputs["ingressShapingBurstSize"] = state?.ingressShapingBurstSize;
            resourceInputs["ingressShapingEnabled"] = state?.ingressShapingEnabled;
            resourceInputs["ingressShapingPeakBandwidth"] = state?.ingressShapingPeakBandwidth;
            resourceInputs["ipv4Address"] = state?.ipv4Address;
            resourceInputs["iscsiMaximumMbit"] = state?.iscsiMaximumMbit;
            resourceInputs["iscsiReservationMbit"] = state?.iscsiReservationMbit;
            resourceInputs["iscsiShareCount"] = state?.iscsiShareCount;
            resourceInputs["iscsiShareLevel"] = state?.iscsiShareLevel;
            resourceInputs["lacpApiVersion"] = state?.lacpApiVersion;
            resourceInputs["lacpEnabled"] = state?.lacpEnabled;
            resourceInputs["lacpMode"] = state?.lacpMode;
            resourceInputs["linkDiscoveryOperation"] = state?.linkDiscoveryOperation;
            resourceInputs["linkDiscoveryProtocol"] = state?.linkDiscoveryProtocol;
            resourceInputs["managementMaximumMbit"] = state?.managementMaximumMbit;
            resourceInputs["managementReservationMbit"] = state?.managementReservationMbit;
            resourceInputs["managementShareCount"] = state?.managementShareCount;
            resourceInputs["managementShareLevel"] = state?.managementShareLevel;
            resourceInputs["maxMtu"] = state?.maxMtu;
            resourceInputs["multicastFilteringMode"] = state?.multicastFilteringMode;
            resourceInputs["name"] = state?.name;
            resourceInputs["netflowActiveFlowTimeout"] = state?.netflowActiveFlowTimeout;
            resourceInputs["netflowCollectorIpAddress"] = state?.netflowCollectorIpAddress;
            resourceInputs["netflowCollectorPort"] = state?.netflowCollectorPort;
            resourceInputs["netflowEnabled"] = state?.netflowEnabled;
            resourceInputs["netflowIdleFlowTimeout"] = state?.netflowIdleFlowTimeout;
            resourceInputs["netflowInternalFlowsOnly"] = state?.netflowInternalFlowsOnly;
            resourceInputs["netflowObservationDomainId"] = state?.netflowObservationDomainId;
            resourceInputs["netflowSamplingRate"] = state?.netflowSamplingRate;
            resourceInputs["networkResourceControlEnabled"] = state?.networkResourceControlEnabled;
            resourceInputs["networkResourceControlVersion"] = state?.networkResourceControlVersion;
            resourceInputs["nfsMaximumMbit"] = state?.nfsMaximumMbit;
            resourceInputs["nfsReservationMbit"] = state?.nfsReservationMbit;
            resourceInputs["nfsShareCount"] = state?.nfsShareCount;
            resourceInputs["nfsShareLevel"] = state?.nfsShareLevel;
            resourceInputs["notifySwitches"] = state?.notifySwitches;
            resourceInputs["portPrivateSecondaryVlanId"] = state?.portPrivateSecondaryVlanId;
            resourceInputs["pvlanMappings"] = state?.pvlanMappings;
            resourceInputs["standbyUplinks"] = state?.standbyUplinks;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["teamingPolicy"] = state?.teamingPolicy;
            resourceInputs["txUplink"] = state?.txUplink;
            resourceInputs["uplinks"] = state?.uplinks;
            resourceInputs["vdpMaximumMbit"] = state?.vdpMaximumMbit;
            resourceInputs["vdpReservationMbit"] = state?.vdpReservationMbit;
            resourceInputs["vdpShareCount"] = state?.vdpShareCount;
            resourceInputs["vdpShareLevel"] = state?.vdpShareLevel;
            resourceInputs["version"] = state?.version;
            resourceInputs["virtualmachineMaximumMbit"] = state?.virtualmachineMaximumMbit;
            resourceInputs["virtualmachineReservationMbit"] = state?.virtualmachineReservationMbit;
            resourceInputs["virtualmachineShareCount"] = state?.virtualmachineShareCount;
            resourceInputs["virtualmachineShareLevel"] = state?.virtualmachineShareLevel;
            resourceInputs["vlanId"] = state?.vlanId;
            resourceInputs["vlanRanges"] = state?.vlanRanges;
            resourceInputs["vmotionMaximumMbit"] = state?.vmotionMaximumMbit;
            resourceInputs["vmotionReservationMbit"] = state?.vmotionReservationMbit;
            resourceInputs["vmotionShareCount"] = state?.vmotionShareCount;
            resourceInputs["vmotionShareLevel"] = state?.vmotionShareLevel;
            resourceInputs["vsanMaximumMbit"] = state?.vsanMaximumMbit;
            resourceInputs["vsanReservationMbit"] = state?.vsanReservationMbit;
            resourceInputs["vsanShareCount"] = state?.vsanShareCount;
            resourceInputs["vsanShareLevel"] = state?.vsanShareLevel;
        } else {
            const args = argsOrState as DistributedVirtualSwitchArgs | undefined;
            if (args?.datacenterId === undefined && !opts.urn) {
                throw new Error("Missing required property 'datacenterId'");
            }
            resourceInputs["activeUplinks"] = args?.activeUplinks;
            resourceInputs["allowForgedTransmits"] = args?.allowForgedTransmits;
            resourceInputs["allowMacChanges"] = args?.allowMacChanges;
            resourceInputs["allowPromiscuous"] = args?.allowPromiscuous;
            resourceInputs["backupnfcMaximumMbit"] = args?.backupnfcMaximumMbit;
            resourceInputs["backupnfcReservationMbit"] = args?.backupnfcReservationMbit;
            resourceInputs["backupnfcShareCount"] = args?.backupnfcShareCount;
            resourceInputs["backupnfcShareLevel"] = args?.backupnfcShareLevel;
            resourceInputs["blockAllPorts"] = args?.blockAllPorts;
            resourceInputs["checkBeacon"] = args?.checkBeacon;
            resourceInputs["contactDetail"] = args?.contactDetail;
            resourceInputs["contactName"] = args?.contactName;
            resourceInputs["customAttributes"] = args?.customAttributes;
            resourceInputs["datacenterId"] = args?.datacenterId;
            resourceInputs["description"] = args?.description;
            resourceInputs["directpathGen2Allowed"] = args?.directpathGen2Allowed;
            resourceInputs["egressShapingAverageBandwidth"] = args?.egressShapingAverageBandwidth;
            resourceInputs["egressShapingBurstSize"] = args?.egressShapingBurstSize;
            resourceInputs["egressShapingEnabled"] = args?.egressShapingEnabled;
            resourceInputs["egressShapingPeakBandwidth"] = args?.egressShapingPeakBandwidth;
            resourceInputs["failback"] = args?.failback;
            resourceInputs["faulttoleranceMaximumMbit"] = args?.faulttoleranceMaximumMbit;
            resourceInputs["faulttoleranceReservationMbit"] = args?.faulttoleranceReservationMbit;
            resourceInputs["faulttoleranceShareCount"] = args?.faulttoleranceShareCount;
            resourceInputs["faulttoleranceShareLevel"] = args?.faulttoleranceShareLevel;
            resourceInputs["folder"] = args?.folder;
            resourceInputs["hbrMaximumMbit"] = args?.hbrMaximumMbit;
            resourceInputs["hbrReservationMbit"] = args?.hbrReservationMbit;
            resourceInputs["hbrShareCount"] = args?.hbrShareCount;
            resourceInputs["hbrShareLevel"] = args?.hbrShareLevel;
            resourceInputs["hosts"] = args?.hosts;
            resourceInputs["ignoreOtherPvlanMappings"] = args?.ignoreOtherPvlanMappings;
            resourceInputs["ingressShapingAverageBandwidth"] = args?.ingressShapingAverageBandwidth;
            resourceInputs["ingressShapingBurstSize"] = args?.ingressShapingBurstSize;
            resourceInputs["ingressShapingEnabled"] = args?.ingressShapingEnabled;
            resourceInputs["ingressShapingPeakBandwidth"] = args?.ingressShapingPeakBandwidth;
            resourceInputs["ipv4Address"] = args?.ipv4Address;
            resourceInputs["iscsiMaximumMbit"] = args?.iscsiMaximumMbit;
            resourceInputs["iscsiReservationMbit"] = args?.iscsiReservationMbit;
            resourceInputs["iscsiShareCount"] = args?.iscsiShareCount;
            resourceInputs["iscsiShareLevel"] = args?.iscsiShareLevel;
            resourceInputs["lacpApiVersion"] = args?.lacpApiVersion;
            resourceInputs["lacpEnabled"] = args?.lacpEnabled;
            resourceInputs["lacpMode"] = args?.lacpMode;
            resourceInputs["linkDiscoveryOperation"] = args?.linkDiscoveryOperation;
            resourceInputs["linkDiscoveryProtocol"] = args?.linkDiscoveryProtocol;
            resourceInputs["managementMaximumMbit"] = args?.managementMaximumMbit;
            resourceInputs["managementReservationMbit"] = args?.managementReservationMbit;
            resourceInputs["managementShareCount"] = args?.managementShareCount;
            resourceInputs["managementShareLevel"] = args?.managementShareLevel;
            resourceInputs["maxMtu"] = args?.maxMtu;
            resourceInputs["multicastFilteringMode"] = args?.multicastFilteringMode;
            resourceInputs["name"] = args?.name;
            resourceInputs["netflowActiveFlowTimeout"] = args?.netflowActiveFlowTimeout;
            resourceInputs["netflowCollectorIpAddress"] = args?.netflowCollectorIpAddress;
            resourceInputs["netflowCollectorPort"] = args?.netflowCollectorPort;
            resourceInputs["netflowEnabled"] = args?.netflowEnabled;
            resourceInputs["netflowIdleFlowTimeout"] = args?.netflowIdleFlowTimeout;
            resourceInputs["netflowInternalFlowsOnly"] = args?.netflowInternalFlowsOnly;
            resourceInputs["netflowObservationDomainId"] = args?.netflowObservationDomainId;
            resourceInputs["netflowSamplingRate"] = args?.netflowSamplingRate;
            resourceInputs["networkResourceControlEnabled"] = args?.networkResourceControlEnabled;
            resourceInputs["networkResourceControlVersion"] = args?.networkResourceControlVersion;
            resourceInputs["nfsMaximumMbit"] = args?.nfsMaximumMbit;
            resourceInputs["nfsReservationMbit"] = args?.nfsReservationMbit;
            resourceInputs["nfsShareCount"] = args?.nfsShareCount;
            resourceInputs["nfsShareLevel"] = args?.nfsShareLevel;
            resourceInputs["notifySwitches"] = args?.notifySwitches;
            resourceInputs["portPrivateSecondaryVlanId"] = args?.portPrivateSecondaryVlanId;
            resourceInputs["pvlanMappings"] = args?.pvlanMappings;
            resourceInputs["standbyUplinks"] = args?.standbyUplinks;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["teamingPolicy"] = args?.teamingPolicy;
            resourceInputs["txUplink"] = args?.txUplink;
            resourceInputs["uplinks"] = args?.uplinks;
            resourceInputs["vdpMaximumMbit"] = args?.vdpMaximumMbit;
            resourceInputs["vdpReservationMbit"] = args?.vdpReservationMbit;
            resourceInputs["vdpShareCount"] = args?.vdpShareCount;
            resourceInputs["vdpShareLevel"] = args?.vdpShareLevel;
            resourceInputs["version"] = args?.version;
            resourceInputs["virtualmachineMaximumMbit"] = args?.virtualmachineMaximumMbit;
            resourceInputs["virtualmachineReservationMbit"] = args?.virtualmachineReservationMbit;
            resourceInputs["virtualmachineShareCount"] = args?.virtualmachineShareCount;
            resourceInputs["virtualmachineShareLevel"] = args?.virtualmachineShareLevel;
            resourceInputs["vlanId"] = args?.vlanId;
            resourceInputs["vlanRanges"] = args?.vlanRanges;
            resourceInputs["vmotionMaximumMbit"] = args?.vmotionMaximumMbit;
            resourceInputs["vmotionReservationMbit"] = args?.vmotionReservationMbit;
            resourceInputs["vmotionShareCount"] = args?.vmotionShareCount;
            resourceInputs["vmotionShareLevel"] = args?.vmotionShareLevel;
            resourceInputs["vsanMaximumMbit"] = args?.vsanMaximumMbit;
            resourceInputs["vsanReservationMbit"] = args?.vsanReservationMbit;
            resourceInputs["vsanShareCount"] = args?.vsanShareCount;
            resourceInputs["vsanShareLevel"] = args?.vsanShareLevel;
            resourceInputs["configVersion"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(DistributedVirtualSwitch.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering DistributedVirtualSwitch resources.
 */
export interface DistributedVirtualSwitchState {
    /**
     * List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     */
    activeUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
     */
    allowForgedTransmits?: pulumi.Input<boolean>;
    /**
     * Controls whether or not the Media Access Control (MAC) address can be changed.
     */
    allowMacChanges?: pulumi.Input<boolean>;
    /**
     * Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
     */
    allowPromiscuous?: pulumi.Input<boolean>;
    /**
     * The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     */
    backupnfcMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     */
    backupnfcReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     */
    backupnfcShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     */
    backupnfcShareLevel?: pulumi.Input<string>;
    /**
     * Indicates whether to block all ports by default.
     */
    blockAllPorts?: pulumi.Input<boolean>;
    /**
     * Enable beacon probing on the ports this policy applies to.
     */
    checkBeacon?: pulumi.Input<boolean>;
    /**
     * The current version of the VDS configuration, incremented
     * by subsequent updates to the VDS.
     */
    configVersion?: pulumi.Input<string>;
    /**
     * The detailed contact information for the person
     * who is responsible for the VDS.
     */
    contactDetail?: pulumi.Input<string>;
    /**
     * The name of the person who is responsible for the
     * VDS.
     */
    contactName?: pulumi.Input<string>;
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for VDS.
     *
     * > **NOTE:** Custom attributes are unsupported on direct ESXi host connections
     * and requires vCenter Server.
     */
    customAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The ID of the datacenter where the VDS will be
     * created. Forces a new resource if changed.
     */
    datacenterId?: pulumi.Input<string>;
    /**
     * A detailed description for the VDS.
     */
    description?: pulumi.Input<string>;
    /**
     * Allow VMDirectPath Gen2 on the ports this policy applies to.
     */
    directpathGen2Allowed?: pulumi.Input<boolean>;
    /**
     * The average egress bandwidth in bits per second if egress shaping is enabled on the port.
     */
    egressShapingAverageBandwidth?: pulumi.Input<number>;
    /**
     * The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
     */
    egressShapingBurstSize?: pulumi.Input<number>;
    /**
     * True if the traffic shaper is enabled for egress traffic on the port.
     */
    egressShapingEnabled?: pulumi.Input<boolean>;
    /**
     * The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
     */
    egressShapingPeakBandwidth?: pulumi.Input<number>;
    /**
     * If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
     */
    failback?: pulumi.Input<boolean>;
    /**
     * The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     */
    faulttoleranceMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     */
    faulttoleranceReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     */
    faulttoleranceShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     */
    faulttoleranceShareLevel?: pulumi.Input<string>;
    /**
     * The folder in which to create the VDS.
     * Forces a new resource if changed.
     */
    folder?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     */
    hbrMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     */
    hbrReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the hbr traffic class for a custom share level.
     */
    hbrShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     */
    hbrShareLevel?: pulumi.Input<string>;
    /**
     * A host member specification.
     */
    hosts?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchHost>[]>;
    /**
     * Whether to ignore existing PVLAN mappings not managed by this resource.
     */
    ignoreOtherPvlanMappings?: pulumi.Input<boolean>;
    /**
     * The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
     */
    ingressShapingAverageBandwidth?: pulumi.Input<number>;
    /**
     * The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
     */
    ingressShapingBurstSize?: pulumi.Input<number>;
    /**
     * True if the traffic shaper is enabled for ingress traffic on the port.
     */
    ingressShapingEnabled?: pulumi.Input<boolean>;
    /**
     * The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
     */
    ingressShapingPeakBandwidth?: pulumi.Input<number>;
    /**
     * An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments.
     */
    ipv4Address?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     */
    iscsiMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     */
    iscsiReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     */
    iscsiShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     */
    iscsiShareLevel?: pulumi.Input<string>;
    /**
     * The Link Aggregation Control Protocol group
     * version to use with the VDS. Possible values are `singleLag` and
     * `multipleLag`.
     */
    lacpApiVersion?: pulumi.Input<string>;
    /**
     * Whether or not to enable LACP on all uplink ports.
     */
    lacpEnabled?: pulumi.Input<boolean>;
    /**
     * The uplink LACP mode to use. Can be one of active or passive.
     */
    lacpMode?: pulumi.Input<string>;
    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic.
     */
    linkDiscoveryOperation?: pulumi.Input<string>;
    /**
     * The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     */
    linkDiscoveryProtocol?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the management traffic class, in Mbits/sec.
     */
    managementMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     */
    managementReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the management traffic class for a custom share level.
     */
    managementShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     */
    managementShareLevel?: pulumi.Input<string>;
    /**
     * The maximum transmission unit (MTU) for the VDS.
     */
    maxMtu?: pulumi.Input<number>;
    /**
     * The multicast filtering mode to use
     * with the VDS. Can be one of `legacyFiltering` or `snooping`.
     */
    multicastFilteringMode?: pulumi.Input<string>;
    /**
     * The name of the VDS.
     */
    name?: pulumi.Input<string>;
    /**
     * The number of seconds after which active flows are forced to be exported to the collector.
     */
    netflowActiveFlowTimeout?: pulumi.Input<number>;
    /**
     * IP address for the netflow collector, using IPv4 or IPv6.
     */
    netflowCollectorIpAddress?: pulumi.Input<string>;
    /**
     * The port for the netflow collector.
     */
    netflowCollectorPort?: pulumi.Input<number>;
    /**
     * Indicates whether to enable netflow on all ports.
     */
    netflowEnabled?: pulumi.Input<boolean>;
    /**
     * The number of seconds after which idle flows are forced to be exported to the collector.
     */
    netflowIdleFlowTimeout?: pulumi.Input<number>;
    /**
     * Whether to limit analysis to traffic that has both source and destination served by the same host.
     */
    netflowInternalFlowsOnly?: pulumi.Input<boolean>;
    /**
     * The observation Domain ID for the netflow collector.
     */
    netflowObservationDomainId?: pulumi.Input<number>;
    /**
     * The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed.
     */
    netflowSamplingRate?: pulumi.Input<number>;
    /**
     * Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
     */
    networkResourceControlEnabled?: pulumi.Input<boolean>;
    /**
     * The network I/O control version to use. Can be one of version2 or version3.
     */
    networkResourceControlVersion?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     */
    nfsMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     */
    nfsReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the nfs traffic class for a custom share level.
     */
    nfsShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     */
    nfsShareLevel?: pulumi.Input<string>;
    /**
     * If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
     */
    notifySwitches?: pulumi.Input<boolean>;
    /**
     * The secondary VLAN ID for this port.
     */
    portPrivateSecondaryVlanId?: pulumi.Input<number>;
    /**
     * A private VLAN (PVLAN) mapping.
     */
    pvlanMappings?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchPvlanMapping>[]>;
    /**
     * List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     */
    standbyUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The IDs of any tags to attach to this resource.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
     */
    teamingPolicy?: pulumi.Input<string>;
    /**
     * If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
     */
    txUplink?: pulumi.Input<boolean>;
    /**
     * A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.
     */
    uplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     */
    vdpMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     */
    vdpReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vdp traffic class for a custom share level.
     */
    vdpShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     */
    vdpShareLevel?: pulumi.Input<string>;
    /**
     * The version of the VDS. By default, a VDS is created
     * at the latest version supported by the vSphere version if not specified.
     * A VDS can be upgraded to a newer version, but can not be downgraded.
     */
    version?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     */
    virtualmachineMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     */
    virtualmachineReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     */
    virtualmachineShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     */
    virtualmachineShareLevel?: pulumi.Input<string>;
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     */
    vlanId?: pulumi.Input<number>;
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     */
    vlanRanges?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchVlanRange>[]>;
    /**
     * The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     */
    vmotionMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     */
    vmotionReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vmotion traffic class for a custom share level.
     */
    vmotionShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     */
    vmotionShareLevel?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     */
    vsanMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     */
    vsanReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vsan traffic class for a custom share level.
     */
    vsanShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     */
    vsanShareLevel?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a DistributedVirtualSwitch resource.
 */
export interface DistributedVirtualSwitchArgs {
    /**
     * List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     */
    activeUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
     */
    allowForgedTransmits?: pulumi.Input<boolean>;
    /**
     * Controls whether or not the Media Access Control (MAC) address can be changed.
     */
    allowMacChanges?: pulumi.Input<boolean>;
    /**
     * Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
     */
    allowPromiscuous?: pulumi.Input<boolean>;
    /**
     * The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     */
    backupnfcMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     */
    backupnfcReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     */
    backupnfcShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     */
    backupnfcShareLevel?: pulumi.Input<string>;
    /**
     * Indicates whether to block all ports by default.
     */
    blockAllPorts?: pulumi.Input<boolean>;
    /**
     * Enable beacon probing on the ports this policy applies to.
     */
    checkBeacon?: pulumi.Input<boolean>;
    /**
     * The detailed contact information for the person
     * who is responsible for the VDS.
     */
    contactDetail?: pulumi.Input<string>;
    /**
     * The name of the person who is responsible for the
     * VDS.
     */
    contactName?: pulumi.Input<string>;
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for VDS.
     *
     * > **NOTE:** Custom attributes are unsupported on direct ESXi host connections
     * and requires vCenter Server.
     */
    customAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The ID of the datacenter where the VDS will be
     * created. Forces a new resource if changed.
     */
    datacenterId: pulumi.Input<string>;
    /**
     * A detailed description for the VDS.
     */
    description?: pulumi.Input<string>;
    /**
     * Allow VMDirectPath Gen2 on the ports this policy applies to.
     */
    directpathGen2Allowed?: pulumi.Input<boolean>;
    /**
     * The average egress bandwidth in bits per second if egress shaping is enabled on the port.
     */
    egressShapingAverageBandwidth?: pulumi.Input<number>;
    /**
     * The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
     */
    egressShapingBurstSize?: pulumi.Input<number>;
    /**
     * True if the traffic shaper is enabled for egress traffic on the port.
     */
    egressShapingEnabled?: pulumi.Input<boolean>;
    /**
     * The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
     */
    egressShapingPeakBandwidth?: pulumi.Input<number>;
    /**
     * If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
     */
    failback?: pulumi.Input<boolean>;
    /**
     * The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     */
    faulttoleranceMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     */
    faulttoleranceReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     */
    faulttoleranceShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     */
    faulttoleranceShareLevel?: pulumi.Input<string>;
    /**
     * The folder in which to create the VDS.
     * Forces a new resource if changed.
     */
    folder?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     */
    hbrMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     */
    hbrReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the hbr traffic class for a custom share level.
     */
    hbrShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     */
    hbrShareLevel?: pulumi.Input<string>;
    /**
     * A host member specification.
     */
    hosts?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchHost>[]>;
    /**
     * Whether to ignore existing PVLAN mappings not managed by this resource.
     */
    ignoreOtherPvlanMappings?: pulumi.Input<boolean>;
    /**
     * The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
     */
    ingressShapingAverageBandwidth?: pulumi.Input<number>;
    /**
     * The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
     */
    ingressShapingBurstSize?: pulumi.Input<number>;
    /**
     * True if the traffic shaper is enabled for ingress traffic on the port.
     */
    ingressShapingEnabled?: pulumi.Input<boolean>;
    /**
     * The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
     */
    ingressShapingPeakBandwidth?: pulumi.Input<number>;
    /**
     * An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments.
     */
    ipv4Address?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     */
    iscsiMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     */
    iscsiReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     */
    iscsiShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     */
    iscsiShareLevel?: pulumi.Input<string>;
    /**
     * The Link Aggregation Control Protocol group
     * version to use with the VDS. Possible values are `singleLag` and
     * `multipleLag`.
     */
    lacpApiVersion?: pulumi.Input<string>;
    /**
     * Whether or not to enable LACP on all uplink ports.
     */
    lacpEnabled?: pulumi.Input<boolean>;
    /**
     * The uplink LACP mode to use. Can be one of active or passive.
     */
    lacpMode?: pulumi.Input<string>;
    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic.
     */
    linkDiscoveryOperation?: pulumi.Input<string>;
    /**
     * The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     */
    linkDiscoveryProtocol?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the management traffic class, in Mbits/sec.
     */
    managementMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     */
    managementReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the management traffic class for a custom share level.
     */
    managementShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     */
    managementShareLevel?: pulumi.Input<string>;
    /**
     * The maximum transmission unit (MTU) for the VDS.
     */
    maxMtu?: pulumi.Input<number>;
    /**
     * The multicast filtering mode to use
     * with the VDS. Can be one of `legacyFiltering` or `snooping`.
     */
    multicastFilteringMode?: pulumi.Input<string>;
    /**
     * The name of the VDS.
     */
    name?: pulumi.Input<string>;
    /**
     * The number of seconds after which active flows are forced to be exported to the collector.
     */
    netflowActiveFlowTimeout?: pulumi.Input<number>;
    /**
     * IP address for the netflow collector, using IPv4 or IPv6.
     */
    netflowCollectorIpAddress?: pulumi.Input<string>;
    /**
     * The port for the netflow collector.
     */
    netflowCollectorPort?: pulumi.Input<number>;
    /**
     * Indicates whether to enable netflow on all ports.
     */
    netflowEnabled?: pulumi.Input<boolean>;
    /**
     * The number of seconds after which idle flows are forced to be exported to the collector.
     */
    netflowIdleFlowTimeout?: pulumi.Input<number>;
    /**
     * Whether to limit analysis to traffic that has both source and destination served by the same host.
     */
    netflowInternalFlowsOnly?: pulumi.Input<boolean>;
    /**
     * The observation Domain ID for the netflow collector.
     */
    netflowObservationDomainId?: pulumi.Input<number>;
    /**
     * The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed.
     */
    netflowSamplingRate?: pulumi.Input<number>;
    /**
     * Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
     */
    networkResourceControlEnabled?: pulumi.Input<boolean>;
    /**
     * The network I/O control version to use. Can be one of version2 or version3.
     */
    networkResourceControlVersion?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     */
    nfsMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     */
    nfsReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the nfs traffic class for a custom share level.
     */
    nfsShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     */
    nfsShareLevel?: pulumi.Input<string>;
    /**
     * If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
     */
    notifySwitches?: pulumi.Input<boolean>;
    /**
     * The secondary VLAN ID for this port.
     */
    portPrivateSecondaryVlanId?: pulumi.Input<number>;
    /**
     * A private VLAN (PVLAN) mapping.
     */
    pvlanMappings?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchPvlanMapping>[]>;
    /**
     * List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
     */
    standbyUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The IDs of any tags to attach to this resource.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
     */
    teamingPolicy?: pulumi.Input<string>;
    /**
     * If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
     */
    txUplink?: pulumi.Input<boolean>;
    /**
     * A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.
     */
    uplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     */
    vdpMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     */
    vdpReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vdp traffic class for a custom share level.
     */
    vdpShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     */
    vdpShareLevel?: pulumi.Input<string>;
    /**
     * The version of the VDS. By default, a VDS is created
     * at the latest version supported by the vSphere version if not specified.
     * A VDS can be upgraded to a newer version, but can not be downgraded.
     */
    version?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     */
    virtualmachineMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     */
    virtualmachineReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     */
    virtualmachineShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     */
    virtualmachineShareLevel?: pulumi.Input<string>;
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     */
    vlanId?: pulumi.Input<number>;
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     */
    vlanRanges?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchVlanRange>[]>;
    /**
     * The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     */
    vmotionMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     */
    vmotionReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vmotion traffic class for a custom share level.
     */
    vmotionShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     */
    vmotionShareLevel?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     */
    vsanMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     */
    vsanReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vsan traffic class for a custom share level.
     */
    vsanShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     */
    vsanShareLevel?: pulumi.Input<string>;
}
