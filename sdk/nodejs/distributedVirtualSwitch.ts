// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "./types";
import * as utilities from "./utilities";

export class DistributedVirtualSwitch extends pulumi.CustomResource {
    /**
     * Get an existing DistributedVirtualSwitch resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DistributedVirtualSwitchState, opts?: pulumi.CustomResourceOptions): DistributedVirtualSwitch {
        return new DistributedVirtualSwitch(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch';

    /**
     * Returns true if the given object is an instance of DistributedVirtualSwitch.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DistributedVirtualSwitch {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DistributedVirtualSwitch.__pulumiType;
    }

    /**
     * A list of active uplinks to be used in load
     * balancing. These uplinks need to match the definitions in the
     * `uplinks` DVS argument. See
     * here for more details.
     */
    public readonly activeUplinks!: pulumi.Output<string[]>;
    /**
     * Controls whether or not a virtual
     * network adapter is allowed to send network traffic with a different MAC
     * address than that of its own.
     */
    public readonly allowForgedTransmits!: pulumi.Output<boolean>;
    /**
     * Controls whether or not the Media Access
     * Control (MAC) address can be changed.
     */
    public readonly allowMacChanges!: pulumi.Output<boolean>;
    /**
     * Enable promiscuous mode on the network. This
     * flag indicates whether or not all traffic is seen on a given port.
     */
    public readonly allowPromiscuous!: pulumi.Output<boolean>;
    /**
     * The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     */
    public readonly backupnfcMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     */
    public readonly backupnfcReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     */
    public readonly backupnfcShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly backupnfcShareLevel!: pulumi.Output<string>;
    /**
     * Shuts down all ports in the port groups that
     * this policy applies to, effectively blocking all network access to connected
     * virtual devices.
     */
    public readonly blockAllPorts!: pulumi.Output<boolean>;
    /**
     * Enables beacon probing as an additional measure
     * to detect NIC failure.
     */
    public readonly checkBeacon!: pulumi.Output<boolean>;
    /**
     * The version string of the configuration that this spec is trying to change.
     */
    public /*out*/ readonly configVersion!: pulumi.Output<string>;
    /**
     * The detailed contact information for the person
     * who is responsible for the DVS.
     */
    public readonly contactDetail!: pulumi.Output<string | undefined>;
    /**
     * The name of the person who is responsible for the
     * DVS.
     */
    public readonly contactName!: pulumi.Output<string | undefined>;
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for virtual switch.
     */
    public readonly customAttributes!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The ID of the datacenter where the distributed
     * virtual switch will be created. Forces a new resource if changed.
     */
    public readonly datacenterId!: pulumi.Output<string>;
    /**
     * A detailed description for the DVS.
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * Allow VMDirectPath Gen2 for the ports
     * for which this policy applies to.
     */
    public readonly directpathGen2Allowed!: pulumi.Output<boolean>;
    /**
     * The average bandwidth in bits
     * per second if egress traffic shaping is enabled on the port.
     */
    public readonly egressShapingAverageBandwidth!: pulumi.Output<number>;
    /**
     * The maximum burst size allowed in
     * bytes if egress traffic shaping is enabled on the port.
     */
    public readonly egressShapingBurstSize!: pulumi.Output<number>;
    /**
     * `true` if the traffic shaper is enabled
     * on the port for egress traffic.
     */
    public readonly egressShapingEnabled!: pulumi.Output<boolean>;
    /**
     * The peak bandwidth during bursts
     * in bits per second if egress traffic shaping is enabled on the port.
     */
    public readonly egressShapingPeakBandwidth!: pulumi.Output<number>;
    /**
     * If `true`, the teaming policy will re-activate failed
     * uplinks higher in precedence when they come back up.
     */
    public readonly failback!: pulumi.Output<boolean>;
    /**
     * The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     */
    public readonly faulttoleranceMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     */
    public readonly faulttoleranceReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     */
    public readonly faulttoleranceShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly faulttoleranceShareLevel!: pulumi.Output<string>;
    /**
     * The folder to create the DVS in. Forces a new resource
     * if changed.
     */
    public readonly folder!: pulumi.Output<string | undefined>;
    /**
     * The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     */
    public readonly hbrMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     */
    public readonly hbrReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the hbr traffic class for a custom share level.
     */
    public readonly hbrShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly hbrShareLevel!: pulumi.Output<string>;
    /**
     * Use the `host` block to declare a host specification. The
     * options are:
     */
    public readonly hosts!: pulumi.Output<outputs.DistributedVirtualSwitchHost[] | undefined>;
    /**
     * Whether to ignore existing PVLAN
     * mappings not managed by this resource. Defaults to false.
     */
    public readonly ignoreOtherPvlanMappings!: pulumi.Output<boolean | undefined>;
    /**
     * The average bandwidth in
     * bits per second if ingress traffic shaping is enabled on the port.
     */
    public readonly ingressShapingAverageBandwidth!: pulumi.Output<number>;
    /**
     * The maximum burst size allowed in
     * bytes if ingress traffic shaping is enabled on the port.
     */
    public readonly ingressShapingBurstSize!: pulumi.Output<number>;
    /**
     * `true` if the traffic shaper is
     * enabled on the port for ingress traffic.
     */
    public readonly ingressShapingEnabled!: pulumi.Output<boolean>;
    /**
     * The peak bandwidth during
     * bursts in bits per second if ingress traffic shaping is enabled on the port.
     */
    public readonly ingressShapingPeakBandwidth!: pulumi.Output<number>;
    /**
     * An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments found
     * below.
     */
    public readonly ipv4Address!: pulumi.Output<string | undefined>;
    /**
     * The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     */
    public readonly iscsiMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     */
    public readonly iscsiReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     */
    public readonly iscsiShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly iscsiShareLevel!: pulumi.Output<string>;
    /**
     * The Link Aggregation Control Protocol group
     * version to use with the switch. Possible values are `singleLag` and
     * `multipleLag`.
     */
    public readonly lacpApiVersion!: pulumi.Output<string>;
    /**
     * Enables LACP for the ports that this policy
     * applies to.
     */
    public readonly lacpEnabled!: pulumi.Output<boolean>;
    /**
     * The LACP mode. Can be one of `active` or `passive`.
     */
    public readonly lacpMode!: pulumi.Output<string>;
    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic.
     */
    public readonly linkDiscoveryOperation!: pulumi.Output<string | undefined>;
    /**
     * The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     */
    public readonly linkDiscoveryProtocol!: pulumi.Output<string | undefined>;
    /**
     * The maximum allowed usage for the management traffic class, in Mbits/sec.
     */
    public readonly managementMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     */
    public readonly managementReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the management traffic class for a custom share level.
     */
    public readonly managementShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly managementShareLevel!: pulumi.Output<string>;
    /**
     * The maximum transmission unit (MTU) for the virtual
     * switch.
     */
    public readonly maxMtu!: pulumi.Output<number>;
    /**
     * The multicast filtering mode to use
     * with the switch. Can be one of `legacyFiltering` or `snooping`.
     */
    public readonly multicastFilteringMode!: pulumi.Output<string>;
    /**
     * The name of the distributed virtual switch.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * The number of seconds after which
     * active flows are forced to be exported to the collector. Allowed range is
     * `60` to `3600`. Default: `60`.
     */
    public readonly netflowActiveFlowTimeout!: pulumi.Output<number | undefined>;
    /**
     * IP address for the Netflow
     * collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
     * Switch Version 6.0 or later. Must be set before Netflow can be enabled.
     */
    public readonly netflowCollectorIpAddress!: pulumi.Output<string | undefined>;
    /**
     * Port for the Netflow collector. This
     * must be set before Netflow can be enabled.
     */
    public readonly netflowCollectorPort!: pulumi.Output<number | undefined>;
    /**
     * Enables Netflow on all ports that this policy
     * applies to.
     */
    public readonly netflowEnabled!: pulumi.Output<boolean>;
    /**
     * The number of seconds after which
     * idle flows are forced to be exported to the collector. Allowed range is `10`
     * to `600`. Default: `15`.
     */
    public readonly netflowIdleFlowTimeout!: pulumi.Output<number | undefined>;
    /**
     * Whether to limit analysis to
     * traffic that has both source and destination served by the same host.
     * Default: `false`.
     */
    public readonly netflowInternalFlowsOnly!: pulumi.Output<boolean | undefined>;
    /**
     * The observation domain ID for
     * the Netflow collector.
     */
    public readonly netflowObservationDomainId!: pulumi.Output<number | undefined>;
    /**
     * The ratio of total number of packets to
     * the number of packets analyzed. The default is `0`, which indicates that the
     * switch should analyze all packets. The maximum value is `1000`, which
     * indicates an analysis rate of 0.001%.
     */
    public readonly netflowSamplingRate!: pulumi.Output<number | undefined>;
    /**
     * Set to `true` to enable
     * network I/O control. Default: `false`.
     */
    public readonly networkResourceControlEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * The version of network I/O
     * control to use. Can be one of `version2` or `version3`. Default: `version2`.
     */
    public readonly networkResourceControlVersion!: pulumi.Output<string>;
    /**
     * The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     */
    public readonly nfsMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     */
    public readonly nfsReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the nfs traffic class for a custom share level.
     */
    public readonly nfsShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly nfsShareLevel!: pulumi.Output<string>;
    /**
     * If `true`, the teaming policy will notify the
     * broadcast network of an uplink failover, triggering cache updates.
     */
    public readonly notifySwitches!: pulumi.Output<boolean>;
    /**
     * Used to define a secondary VLAN
     * ID when using private VLANs.
     */
    public readonly portPrivateSecondaryVlanId!: pulumi.Output<number>;
    /**
     * Use the `pvlanMapping` block to declare a
     * private VLAN mapping. The options are:
     */
    public readonly pvlanMappings!: pulumi.Output<outputs.DistributedVirtualSwitchPvlanMapping[] | undefined>;
    /**
     * A list of standby uplinks to be used in
     * failover. These uplinks need to match the definitions in the
     * `uplinks` DVS argument. See
     * here for more details.
     */
    public readonly standbyUplinks!: pulumi.Output<string[]>;
    /**
     * The IDs of any tags to attach to this resource.
     */
    public readonly tags!: pulumi.Output<string[] | undefined>;
    /**
     * The uplink teaming policy. Can be one of
     * `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
     * `failoverExplicit`.
     */
    public readonly teamingPolicy!: pulumi.Output<string>;
    /**
     * Forward all traffic transmitted by ports for which
     * this policy applies to its DVS uplinks.
     */
    public readonly txUplink!: pulumi.Output<boolean>;
    /**
     * A list of strings that uniquely identifies the names
     * of the uplinks on the DVS across hosts. The number of items in this list
     * controls the number of uplinks that exist on the DVS, in addition to the
     * names.  See here for an example on how to
     * use this option.
     */
    public readonly uplinks!: pulumi.Output<string[]>;
    /**
     * The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     */
    public readonly vdpMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     */
    public readonly vdpReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the vdp traffic class for a custom share level.
     */
    public readonly vdpShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly vdpShareLevel!: pulumi.Output<string>;
    /**
     * - The version of the DVS to create. The default is to
     * create the DVS at the latest version supported by the version of vSphere
     * being used. A DVS can be upgraded to another version, but cannot be
     * downgraded.
     */
    public readonly version!: pulumi.Output<string>;
    /**
     * The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     */
    public readonly virtualmachineMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     */
    public readonly virtualmachineReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     */
    public readonly virtualmachineShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly virtualmachineShareLevel!: pulumi.Output<string>;
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     */
    public readonly vlanId!: pulumi.Output<number>;
    /**
     * Used to denote VLAN trunking. Use the `minVlan`
     * and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
     * `vlanRange` definitions are allowed, but they must not overlap. Example
     * below:
     */
    public readonly vlanRanges!: pulumi.Output<outputs.DistributedVirtualSwitchVlanRange[]>;
    /**
     * The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     */
    public readonly vmotionMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     */
    public readonly vmotionReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the vmotion traffic class for a custom share level.
     */
    public readonly vmotionShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly vmotionShareLevel!: pulumi.Output<string>;
    /**
     * The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     */
    public readonly vsanMaximumMbit!: pulumi.Output<number>;
    /**
     * The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     */
    public readonly vsanReservationMbit!: pulumi.Output<number>;
    /**
     * The amount of shares to allocate to the vsan traffic class for a custom share level.
     */
    public readonly vsanShareCount!: pulumi.Output<number>;
    /**
     * The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     */
    public readonly vsanShareLevel!: pulumi.Output<string>;

    /**
     * Create a DistributedVirtualSwitch resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: DistributedVirtualSwitchArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DistributedVirtualSwitchArgs | DistributedVirtualSwitchState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DistributedVirtualSwitchState | undefined;
            resourceInputs["activeUplinks"] = state ? state.activeUplinks : undefined;
            resourceInputs["allowForgedTransmits"] = state ? state.allowForgedTransmits : undefined;
            resourceInputs["allowMacChanges"] = state ? state.allowMacChanges : undefined;
            resourceInputs["allowPromiscuous"] = state ? state.allowPromiscuous : undefined;
            resourceInputs["backupnfcMaximumMbit"] = state ? state.backupnfcMaximumMbit : undefined;
            resourceInputs["backupnfcReservationMbit"] = state ? state.backupnfcReservationMbit : undefined;
            resourceInputs["backupnfcShareCount"] = state ? state.backupnfcShareCount : undefined;
            resourceInputs["backupnfcShareLevel"] = state ? state.backupnfcShareLevel : undefined;
            resourceInputs["blockAllPorts"] = state ? state.blockAllPorts : undefined;
            resourceInputs["checkBeacon"] = state ? state.checkBeacon : undefined;
            resourceInputs["configVersion"] = state ? state.configVersion : undefined;
            resourceInputs["contactDetail"] = state ? state.contactDetail : undefined;
            resourceInputs["contactName"] = state ? state.contactName : undefined;
            resourceInputs["customAttributes"] = state ? state.customAttributes : undefined;
            resourceInputs["datacenterId"] = state ? state.datacenterId : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["directpathGen2Allowed"] = state ? state.directpathGen2Allowed : undefined;
            resourceInputs["egressShapingAverageBandwidth"] = state ? state.egressShapingAverageBandwidth : undefined;
            resourceInputs["egressShapingBurstSize"] = state ? state.egressShapingBurstSize : undefined;
            resourceInputs["egressShapingEnabled"] = state ? state.egressShapingEnabled : undefined;
            resourceInputs["egressShapingPeakBandwidth"] = state ? state.egressShapingPeakBandwidth : undefined;
            resourceInputs["failback"] = state ? state.failback : undefined;
            resourceInputs["faulttoleranceMaximumMbit"] = state ? state.faulttoleranceMaximumMbit : undefined;
            resourceInputs["faulttoleranceReservationMbit"] = state ? state.faulttoleranceReservationMbit : undefined;
            resourceInputs["faulttoleranceShareCount"] = state ? state.faulttoleranceShareCount : undefined;
            resourceInputs["faulttoleranceShareLevel"] = state ? state.faulttoleranceShareLevel : undefined;
            resourceInputs["folder"] = state ? state.folder : undefined;
            resourceInputs["hbrMaximumMbit"] = state ? state.hbrMaximumMbit : undefined;
            resourceInputs["hbrReservationMbit"] = state ? state.hbrReservationMbit : undefined;
            resourceInputs["hbrShareCount"] = state ? state.hbrShareCount : undefined;
            resourceInputs["hbrShareLevel"] = state ? state.hbrShareLevel : undefined;
            resourceInputs["hosts"] = state ? state.hosts : undefined;
            resourceInputs["ignoreOtherPvlanMappings"] = state ? state.ignoreOtherPvlanMappings : undefined;
            resourceInputs["ingressShapingAverageBandwidth"] = state ? state.ingressShapingAverageBandwidth : undefined;
            resourceInputs["ingressShapingBurstSize"] = state ? state.ingressShapingBurstSize : undefined;
            resourceInputs["ingressShapingEnabled"] = state ? state.ingressShapingEnabled : undefined;
            resourceInputs["ingressShapingPeakBandwidth"] = state ? state.ingressShapingPeakBandwidth : undefined;
            resourceInputs["ipv4Address"] = state ? state.ipv4Address : undefined;
            resourceInputs["iscsiMaximumMbit"] = state ? state.iscsiMaximumMbit : undefined;
            resourceInputs["iscsiReservationMbit"] = state ? state.iscsiReservationMbit : undefined;
            resourceInputs["iscsiShareCount"] = state ? state.iscsiShareCount : undefined;
            resourceInputs["iscsiShareLevel"] = state ? state.iscsiShareLevel : undefined;
            resourceInputs["lacpApiVersion"] = state ? state.lacpApiVersion : undefined;
            resourceInputs["lacpEnabled"] = state ? state.lacpEnabled : undefined;
            resourceInputs["lacpMode"] = state ? state.lacpMode : undefined;
            resourceInputs["linkDiscoveryOperation"] = state ? state.linkDiscoveryOperation : undefined;
            resourceInputs["linkDiscoveryProtocol"] = state ? state.linkDiscoveryProtocol : undefined;
            resourceInputs["managementMaximumMbit"] = state ? state.managementMaximumMbit : undefined;
            resourceInputs["managementReservationMbit"] = state ? state.managementReservationMbit : undefined;
            resourceInputs["managementShareCount"] = state ? state.managementShareCount : undefined;
            resourceInputs["managementShareLevel"] = state ? state.managementShareLevel : undefined;
            resourceInputs["maxMtu"] = state ? state.maxMtu : undefined;
            resourceInputs["multicastFilteringMode"] = state ? state.multicastFilteringMode : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["netflowActiveFlowTimeout"] = state ? state.netflowActiveFlowTimeout : undefined;
            resourceInputs["netflowCollectorIpAddress"] = state ? state.netflowCollectorIpAddress : undefined;
            resourceInputs["netflowCollectorPort"] = state ? state.netflowCollectorPort : undefined;
            resourceInputs["netflowEnabled"] = state ? state.netflowEnabled : undefined;
            resourceInputs["netflowIdleFlowTimeout"] = state ? state.netflowIdleFlowTimeout : undefined;
            resourceInputs["netflowInternalFlowsOnly"] = state ? state.netflowInternalFlowsOnly : undefined;
            resourceInputs["netflowObservationDomainId"] = state ? state.netflowObservationDomainId : undefined;
            resourceInputs["netflowSamplingRate"] = state ? state.netflowSamplingRate : undefined;
            resourceInputs["networkResourceControlEnabled"] = state ? state.networkResourceControlEnabled : undefined;
            resourceInputs["networkResourceControlVersion"] = state ? state.networkResourceControlVersion : undefined;
            resourceInputs["nfsMaximumMbit"] = state ? state.nfsMaximumMbit : undefined;
            resourceInputs["nfsReservationMbit"] = state ? state.nfsReservationMbit : undefined;
            resourceInputs["nfsShareCount"] = state ? state.nfsShareCount : undefined;
            resourceInputs["nfsShareLevel"] = state ? state.nfsShareLevel : undefined;
            resourceInputs["notifySwitches"] = state ? state.notifySwitches : undefined;
            resourceInputs["portPrivateSecondaryVlanId"] = state ? state.portPrivateSecondaryVlanId : undefined;
            resourceInputs["pvlanMappings"] = state ? state.pvlanMappings : undefined;
            resourceInputs["standbyUplinks"] = state ? state.standbyUplinks : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["teamingPolicy"] = state ? state.teamingPolicy : undefined;
            resourceInputs["txUplink"] = state ? state.txUplink : undefined;
            resourceInputs["uplinks"] = state ? state.uplinks : undefined;
            resourceInputs["vdpMaximumMbit"] = state ? state.vdpMaximumMbit : undefined;
            resourceInputs["vdpReservationMbit"] = state ? state.vdpReservationMbit : undefined;
            resourceInputs["vdpShareCount"] = state ? state.vdpShareCount : undefined;
            resourceInputs["vdpShareLevel"] = state ? state.vdpShareLevel : undefined;
            resourceInputs["version"] = state ? state.version : undefined;
            resourceInputs["virtualmachineMaximumMbit"] = state ? state.virtualmachineMaximumMbit : undefined;
            resourceInputs["virtualmachineReservationMbit"] = state ? state.virtualmachineReservationMbit : undefined;
            resourceInputs["virtualmachineShareCount"] = state ? state.virtualmachineShareCount : undefined;
            resourceInputs["virtualmachineShareLevel"] = state ? state.virtualmachineShareLevel : undefined;
            resourceInputs["vlanId"] = state ? state.vlanId : undefined;
            resourceInputs["vlanRanges"] = state ? state.vlanRanges : undefined;
            resourceInputs["vmotionMaximumMbit"] = state ? state.vmotionMaximumMbit : undefined;
            resourceInputs["vmotionReservationMbit"] = state ? state.vmotionReservationMbit : undefined;
            resourceInputs["vmotionShareCount"] = state ? state.vmotionShareCount : undefined;
            resourceInputs["vmotionShareLevel"] = state ? state.vmotionShareLevel : undefined;
            resourceInputs["vsanMaximumMbit"] = state ? state.vsanMaximumMbit : undefined;
            resourceInputs["vsanReservationMbit"] = state ? state.vsanReservationMbit : undefined;
            resourceInputs["vsanShareCount"] = state ? state.vsanShareCount : undefined;
            resourceInputs["vsanShareLevel"] = state ? state.vsanShareLevel : undefined;
        } else {
            const args = argsOrState as DistributedVirtualSwitchArgs | undefined;
            if ((!args || args.datacenterId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'datacenterId'");
            }
            resourceInputs["activeUplinks"] = args ? args.activeUplinks : undefined;
            resourceInputs["allowForgedTransmits"] = args ? args.allowForgedTransmits : undefined;
            resourceInputs["allowMacChanges"] = args ? args.allowMacChanges : undefined;
            resourceInputs["allowPromiscuous"] = args ? args.allowPromiscuous : undefined;
            resourceInputs["backupnfcMaximumMbit"] = args ? args.backupnfcMaximumMbit : undefined;
            resourceInputs["backupnfcReservationMbit"] = args ? args.backupnfcReservationMbit : undefined;
            resourceInputs["backupnfcShareCount"] = args ? args.backupnfcShareCount : undefined;
            resourceInputs["backupnfcShareLevel"] = args ? args.backupnfcShareLevel : undefined;
            resourceInputs["blockAllPorts"] = args ? args.blockAllPorts : undefined;
            resourceInputs["checkBeacon"] = args ? args.checkBeacon : undefined;
            resourceInputs["contactDetail"] = args ? args.contactDetail : undefined;
            resourceInputs["contactName"] = args ? args.contactName : undefined;
            resourceInputs["customAttributes"] = args ? args.customAttributes : undefined;
            resourceInputs["datacenterId"] = args ? args.datacenterId : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["directpathGen2Allowed"] = args ? args.directpathGen2Allowed : undefined;
            resourceInputs["egressShapingAverageBandwidth"] = args ? args.egressShapingAverageBandwidth : undefined;
            resourceInputs["egressShapingBurstSize"] = args ? args.egressShapingBurstSize : undefined;
            resourceInputs["egressShapingEnabled"] = args ? args.egressShapingEnabled : undefined;
            resourceInputs["egressShapingPeakBandwidth"] = args ? args.egressShapingPeakBandwidth : undefined;
            resourceInputs["failback"] = args ? args.failback : undefined;
            resourceInputs["faulttoleranceMaximumMbit"] = args ? args.faulttoleranceMaximumMbit : undefined;
            resourceInputs["faulttoleranceReservationMbit"] = args ? args.faulttoleranceReservationMbit : undefined;
            resourceInputs["faulttoleranceShareCount"] = args ? args.faulttoleranceShareCount : undefined;
            resourceInputs["faulttoleranceShareLevel"] = args ? args.faulttoleranceShareLevel : undefined;
            resourceInputs["folder"] = args ? args.folder : undefined;
            resourceInputs["hbrMaximumMbit"] = args ? args.hbrMaximumMbit : undefined;
            resourceInputs["hbrReservationMbit"] = args ? args.hbrReservationMbit : undefined;
            resourceInputs["hbrShareCount"] = args ? args.hbrShareCount : undefined;
            resourceInputs["hbrShareLevel"] = args ? args.hbrShareLevel : undefined;
            resourceInputs["hosts"] = args ? args.hosts : undefined;
            resourceInputs["ignoreOtherPvlanMappings"] = args ? args.ignoreOtherPvlanMappings : undefined;
            resourceInputs["ingressShapingAverageBandwidth"] = args ? args.ingressShapingAverageBandwidth : undefined;
            resourceInputs["ingressShapingBurstSize"] = args ? args.ingressShapingBurstSize : undefined;
            resourceInputs["ingressShapingEnabled"] = args ? args.ingressShapingEnabled : undefined;
            resourceInputs["ingressShapingPeakBandwidth"] = args ? args.ingressShapingPeakBandwidth : undefined;
            resourceInputs["ipv4Address"] = args ? args.ipv4Address : undefined;
            resourceInputs["iscsiMaximumMbit"] = args ? args.iscsiMaximumMbit : undefined;
            resourceInputs["iscsiReservationMbit"] = args ? args.iscsiReservationMbit : undefined;
            resourceInputs["iscsiShareCount"] = args ? args.iscsiShareCount : undefined;
            resourceInputs["iscsiShareLevel"] = args ? args.iscsiShareLevel : undefined;
            resourceInputs["lacpApiVersion"] = args ? args.lacpApiVersion : undefined;
            resourceInputs["lacpEnabled"] = args ? args.lacpEnabled : undefined;
            resourceInputs["lacpMode"] = args ? args.lacpMode : undefined;
            resourceInputs["linkDiscoveryOperation"] = args ? args.linkDiscoveryOperation : undefined;
            resourceInputs["linkDiscoveryProtocol"] = args ? args.linkDiscoveryProtocol : undefined;
            resourceInputs["managementMaximumMbit"] = args ? args.managementMaximumMbit : undefined;
            resourceInputs["managementReservationMbit"] = args ? args.managementReservationMbit : undefined;
            resourceInputs["managementShareCount"] = args ? args.managementShareCount : undefined;
            resourceInputs["managementShareLevel"] = args ? args.managementShareLevel : undefined;
            resourceInputs["maxMtu"] = args ? args.maxMtu : undefined;
            resourceInputs["multicastFilteringMode"] = args ? args.multicastFilteringMode : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["netflowActiveFlowTimeout"] = args ? args.netflowActiveFlowTimeout : undefined;
            resourceInputs["netflowCollectorIpAddress"] = args ? args.netflowCollectorIpAddress : undefined;
            resourceInputs["netflowCollectorPort"] = args ? args.netflowCollectorPort : undefined;
            resourceInputs["netflowEnabled"] = args ? args.netflowEnabled : undefined;
            resourceInputs["netflowIdleFlowTimeout"] = args ? args.netflowIdleFlowTimeout : undefined;
            resourceInputs["netflowInternalFlowsOnly"] = args ? args.netflowInternalFlowsOnly : undefined;
            resourceInputs["netflowObservationDomainId"] = args ? args.netflowObservationDomainId : undefined;
            resourceInputs["netflowSamplingRate"] = args ? args.netflowSamplingRate : undefined;
            resourceInputs["networkResourceControlEnabled"] = args ? args.networkResourceControlEnabled : undefined;
            resourceInputs["networkResourceControlVersion"] = args ? args.networkResourceControlVersion : undefined;
            resourceInputs["nfsMaximumMbit"] = args ? args.nfsMaximumMbit : undefined;
            resourceInputs["nfsReservationMbit"] = args ? args.nfsReservationMbit : undefined;
            resourceInputs["nfsShareCount"] = args ? args.nfsShareCount : undefined;
            resourceInputs["nfsShareLevel"] = args ? args.nfsShareLevel : undefined;
            resourceInputs["notifySwitches"] = args ? args.notifySwitches : undefined;
            resourceInputs["portPrivateSecondaryVlanId"] = args ? args.portPrivateSecondaryVlanId : undefined;
            resourceInputs["pvlanMappings"] = args ? args.pvlanMappings : undefined;
            resourceInputs["standbyUplinks"] = args ? args.standbyUplinks : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["teamingPolicy"] = args ? args.teamingPolicy : undefined;
            resourceInputs["txUplink"] = args ? args.txUplink : undefined;
            resourceInputs["uplinks"] = args ? args.uplinks : undefined;
            resourceInputs["vdpMaximumMbit"] = args ? args.vdpMaximumMbit : undefined;
            resourceInputs["vdpReservationMbit"] = args ? args.vdpReservationMbit : undefined;
            resourceInputs["vdpShareCount"] = args ? args.vdpShareCount : undefined;
            resourceInputs["vdpShareLevel"] = args ? args.vdpShareLevel : undefined;
            resourceInputs["version"] = args ? args.version : undefined;
            resourceInputs["virtualmachineMaximumMbit"] = args ? args.virtualmachineMaximumMbit : undefined;
            resourceInputs["virtualmachineReservationMbit"] = args ? args.virtualmachineReservationMbit : undefined;
            resourceInputs["virtualmachineShareCount"] = args ? args.virtualmachineShareCount : undefined;
            resourceInputs["virtualmachineShareLevel"] = args ? args.virtualmachineShareLevel : undefined;
            resourceInputs["vlanId"] = args ? args.vlanId : undefined;
            resourceInputs["vlanRanges"] = args ? args.vlanRanges : undefined;
            resourceInputs["vmotionMaximumMbit"] = args ? args.vmotionMaximumMbit : undefined;
            resourceInputs["vmotionReservationMbit"] = args ? args.vmotionReservationMbit : undefined;
            resourceInputs["vmotionShareCount"] = args ? args.vmotionShareCount : undefined;
            resourceInputs["vmotionShareLevel"] = args ? args.vmotionShareLevel : undefined;
            resourceInputs["vsanMaximumMbit"] = args ? args.vsanMaximumMbit : undefined;
            resourceInputs["vsanReservationMbit"] = args ? args.vsanReservationMbit : undefined;
            resourceInputs["vsanShareCount"] = args ? args.vsanShareCount : undefined;
            resourceInputs["vsanShareLevel"] = args ? args.vsanShareLevel : undefined;
            resourceInputs["configVersion"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(DistributedVirtualSwitch.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering DistributedVirtualSwitch resources.
 */
export interface DistributedVirtualSwitchState {
    /**
     * A list of active uplinks to be used in load
     * balancing. These uplinks need to match the definitions in the
     * `uplinks` DVS argument. See
     * here for more details.
     */
    activeUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Controls whether or not a virtual
     * network adapter is allowed to send network traffic with a different MAC
     * address than that of its own.
     */
    allowForgedTransmits?: pulumi.Input<boolean>;
    /**
     * Controls whether or not the Media Access
     * Control (MAC) address can be changed.
     */
    allowMacChanges?: pulumi.Input<boolean>;
    /**
     * Enable promiscuous mode on the network. This
     * flag indicates whether or not all traffic is seen on a given port.
     */
    allowPromiscuous?: pulumi.Input<boolean>;
    /**
     * The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     */
    backupnfcMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     */
    backupnfcReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     */
    backupnfcShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     */
    backupnfcShareLevel?: pulumi.Input<string>;
    /**
     * Shuts down all ports in the port groups that
     * this policy applies to, effectively blocking all network access to connected
     * virtual devices.
     */
    blockAllPorts?: pulumi.Input<boolean>;
    /**
     * Enables beacon probing as an additional measure
     * to detect NIC failure.
     */
    checkBeacon?: pulumi.Input<boolean>;
    /**
     * The version string of the configuration that this spec is trying to change.
     */
    configVersion?: pulumi.Input<string>;
    /**
     * The detailed contact information for the person
     * who is responsible for the DVS.
     */
    contactDetail?: pulumi.Input<string>;
    /**
     * The name of the person who is responsible for the
     * DVS.
     */
    contactName?: pulumi.Input<string>;
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for virtual switch.
     */
    customAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The ID of the datacenter where the distributed
     * virtual switch will be created. Forces a new resource if changed.
     */
    datacenterId?: pulumi.Input<string>;
    /**
     * A detailed description for the DVS.
     */
    description?: pulumi.Input<string>;
    /**
     * Allow VMDirectPath Gen2 for the ports
     * for which this policy applies to.
     */
    directpathGen2Allowed?: pulumi.Input<boolean>;
    /**
     * The average bandwidth in bits
     * per second if egress traffic shaping is enabled on the port.
     */
    egressShapingAverageBandwidth?: pulumi.Input<number>;
    /**
     * The maximum burst size allowed in
     * bytes if egress traffic shaping is enabled on the port.
     */
    egressShapingBurstSize?: pulumi.Input<number>;
    /**
     * `true` if the traffic shaper is enabled
     * on the port for egress traffic.
     */
    egressShapingEnabled?: pulumi.Input<boolean>;
    /**
     * The peak bandwidth during bursts
     * in bits per second if egress traffic shaping is enabled on the port.
     */
    egressShapingPeakBandwidth?: pulumi.Input<number>;
    /**
     * If `true`, the teaming policy will re-activate failed
     * uplinks higher in precedence when they come back up.
     */
    failback?: pulumi.Input<boolean>;
    /**
     * The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     */
    faulttoleranceMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     */
    faulttoleranceReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     */
    faulttoleranceShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     */
    faulttoleranceShareLevel?: pulumi.Input<string>;
    /**
     * The folder to create the DVS in. Forces a new resource
     * if changed.
     */
    folder?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     */
    hbrMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     */
    hbrReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the hbr traffic class for a custom share level.
     */
    hbrShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     */
    hbrShareLevel?: pulumi.Input<string>;
    /**
     * Use the `host` block to declare a host specification. The
     * options are:
     */
    hosts?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchHost>[]>;
    /**
     * Whether to ignore existing PVLAN
     * mappings not managed by this resource. Defaults to false.
     */
    ignoreOtherPvlanMappings?: pulumi.Input<boolean>;
    /**
     * The average bandwidth in
     * bits per second if ingress traffic shaping is enabled on the port.
     */
    ingressShapingAverageBandwidth?: pulumi.Input<number>;
    /**
     * The maximum burst size allowed in
     * bytes if ingress traffic shaping is enabled on the port.
     */
    ingressShapingBurstSize?: pulumi.Input<number>;
    /**
     * `true` if the traffic shaper is
     * enabled on the port for ingress traffic.
     */
    ingressShapingEnabled?: pulumi.Input<boolean>;
    /**
     * The peak bandwidth during
     * bursts in bits per second if ingress traffic shaping is enabled on the port.
     */
    ingressShapingPeakBandwidth?: pulumi.Input<number>;
    /**
     * An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments found
     * below.
     */
    ipv4Address?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     */
    iscsiMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     */
    iscsiReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     */
    iscsiShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     */
    iscsiShareLevel?: pulumi.Input<string>;
    /**
     * The Link Aggregation Control Protocol group
     * version to use with the switch. Possible values are `singleLag` and
     * `multipleLag`.
     */
    lacpApiVersion?: pulumi.Input<string>;
    /**
     * Enables LACP for the ports that this policy
     * applies to.
     */
    lacpEnabled?: pulumi.Input<boolean>;
    /**
     * The LACP mode. Can be one of `active` or `passive`.
     */
    lacpMode?: pulumi.Input<string>;
    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic.
     */
    linkDiscoveryOperation?: pulumi.Input<string>;
    /**
     * The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     */
    linkDiscoveryProtocol?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the management traffic class, in Mbits/sec.
     */
    managementMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     */
    managementReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the management traffic class for a custom share level.
     */
    managementShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     */
    managementShareLevel?: pulumi.Input<string>;
    /**
     * The maximum transmission unit (MTU) for the virtual
     * switch.
     */
    maxMtu?: pulumi.Input<number>;
    /**
     * The multicast filtering mode to use
     * with the switch. Can be one of `legacyFiltering` or `snooping`.
     */
    multicastFilteringMode?: pulumi.Input<string>;
    /**
     * The name of the distributed virtual switch.
     */
    name?: pulumi.Input<string>;
    /**
     * The number of seconds after which
     * active flows are forced to be exported to the collector. Allowed range is
     * `60` to `3600`. Default: `60`.
     */
    netflowActiveFlowTimeout?: pulumi.Input<number>;
    /**
     * IP address for the Netflow
     * collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
     * Switch Version 6.0 or later. Must be set before Netflow can be enabled.
     */
    netflowCollectorIpAddress?: pulumi.Input<string>;
    /**
     * Port for the Netflow collector. This
     * must be set before Netflow can be enabled.
     */
    netflowCollectorPort?: pulumi.Input<number>;
    /**
     * Enables Netflow on all ports that this policy
     * applies to.
     */
    netflowEnabled?: pulumi.Input<boolean>;
    /**
     * The number of seconds after which
     * idle flows are forced to be exported to the collector. Allowed range is `10`
     * to `600`. Default: `15`.
     */
    netflowIdleFlowTimeout?: pulumi.Input<number>;
    /**
     * Whether to limit analysis to
     * traffic that has both source and destination served by the same host.
     * Default: `false`.
     */
    netflowInternalFlowsOnly?: pulumi.Input<boolean>;
    /**
     * The observation domain ID for
     * the Netflow collector.
     */
    netflowObservationDomainId?: pulumi.Input<number>;
    /**
     * The ratio of total number of packets to
     * the number of packets analyzed. The default is `0`, which indicates that the
     * switch should analyze all packets. The maximum value is `1000`, which
     * indicates an analysis rate of 0.001%.
     */
    netflowSamplingRate?: pulumi.Input<number>;
    /**
     * Set to `true` to enable
     * network I/O control. Default: `false`.
     */
    networkResourceControlEnabled?: pulumi.Input<boolean>;
    /**
     * The version of network I/O
     * control to use. Can be one of `version2` or `version3`. Default: `version2`.
     */
    networkResourceControlVersion?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     */
    nfsMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     */
    nfsReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the nfs traffic class for a custom share level.
     */
    nfsShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     */
    nfsShareLevel?: pulumi.Input<string>;
    /**
     * If `true`, the teaming policy will notify the
     * broadcast network of an uplink failover, triggering cache updates.
     */
    notifySwitches?: pulumi.Input<boolean>;
    /**
     * Used to define a secondary VLAN
     * ID when using private VLANs.
     */
    portPrivateSecondaryVlanId?: pulumi.Input<number>;
    /**
     * Use the `pvlanMapping` block to declare a
     * private VLAN mapping. The options are:
     */
    pvlanMappings?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchPvlanMapping>[]>;
    /**
     * A list of standby uplinks to be used in
     * failover. These uplinks need to match the definitions in the
     * `uplinks` DVS argument. See
     * here for more details.
     */
    standbyUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The IDs of any tags to attach to this resource.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The uplink teaming policy. Can be one of
     * `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
     * `failoverExplicit`.
     */
    teamingPolicy?: pulumi.Input<string>;
    /**
     * Forward all traffic transmitted by ports for which
     * this policy applies to its DVS uplinks.
     */
    txUplink?: pulumi.Input<boolean>;
    /**
     * A list of strings that uniquely identifies the names
     * of the uplinks on the DVS across hosts. The number of items in this list
     * controls the number of uplinks that exist on the DVS, in addition to the
     * names.  See here for an example on how to
     * use this option.
     */
    uplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     */
    vdpMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     */
    vdpReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vdp traffic class for a custom share level.
     */
    vdpShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     */
    vdpShareLevel?: pulumi.Input<string>;
    /**
     * - The version of the DVS to create. The default is to
     * create the DVS at the latest version supported by the version of vSphere
     * being used. A DVS can be upgraded to another version, but cannot be
     * downgraded.
     */
    version?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     */
    virtualmachineMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     */
    virtualmachineReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     */
    virtualmachineShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     */
    virtualmachineShareLevel?: pulumi.Input<string>;
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     */
    vlanId?: pulumi.Input<number>;
    /**
     * Used to denote VLAN trunking. Use the `minVlan`
     * and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
     * `vlanRange` definitions are allowed, but they must not overlap. Example
     * below:
     */
    vlanRanges?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchVlanRange>[]>;
    /**
     * The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     */
    vmotionMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     */
    vmotionReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vmotion traffic class for a custom share level.
     */
    vmotionShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     */
    vmotionShareLevel?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     */
    vsanMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     */
    vsanReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vsan traffic class for a custom share level.
     */
    vsanShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     */
    vsanShareLevel?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a DistributedVirtualSwitch resource.
 */
export interface DistributedVirtualSwitchArgs {
    /**
     * A list of active uplinks to be used in load
     * balancing. These uplinks need to match the definitions in the
     * `uplinks` DVS argument. See
     * here for more details.
     */
    activeUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Controls whether or not a virtual
     * network adapter is allowed to send network traffic with a different MAC
     * address than that of its own.
     */
    allowForgedTransmits?: pulumi.Input<boolean>;
    /**
     * Controls whether or not the Media Access
     * Control (MAC) address can be changed.
     */
    allowMacChanges?: pulumi.Input<boolean>;
    /**
     * Enable promiscuous mode on the network. This
     * flag indicates whether or not all traffic is seen on a given port.
     */
    allowPromiscuous?: pulumi.Input<boolean>;
    /**
     * The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
     */
    backupnfcMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
     */
    backupnfcReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the backupNfc traffic class for a custom share level.
     */
    backupnfcShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
     */
    backupnfcShareLevel?: pulumi.Input<string>;
    /**
     * Shuts down all ports in the port groups that
     * this policy applies to, effectively blocking all network access to connected
     * virtual devices.
     */
    blockAllPorts?: pulumi.Input<boolean>;
    /**
     * Enables beacon probing as an additional measure
     * to detect NIC failure.
     */
    checkBeacon?: pulumi.Input<boolean>;
    /**
     * The detailed contact information for the person
     * who is responsible for the DVS.
     */
    contactDetail?: pulumi.Input<string>;
    /**
     * The name of the person who is responsible for the
     * DVS.
     */
    contactName?: pulumi.Input<string>;
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for virtual switch.
     */
    customAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The ID of the datacenter where the distributed
     * virtual switch will be created. Forces a new resource if changed.
     */
    datacenterId: pulumi.Input<string>;
    /**
     * A detailed description for the DVS.
     */
    description?: pulumi.Input<string>;
    /**
     * Allow VMDirectPath Gen2 for the ports
     * for which this policy applies to.
     */
    directpathGen2Allowed?: pulumi.Input<boolean>;
    /**
     * The average bandwidth in bits
     * per second if egress traffic shaping is enabled on the port.
     */
    egressShapingAverageBandwidth?: pulumi.Input<number>;
    /**
     * The maximum burst size allowed in
     * bytes if egress traffic shaping is enabled on the port.
     */
    egressShapingBurstSize?: pulumi.Input<number>;
    /**
     * `true` if the traffic shaper is enabled
     * on the port for egress traffic.
     */
    egressShapingEnabled?: pulumi.Input<boolean>;
    /**
     * The peak bandwidth during bursts
     * in bits per second if egress traffic shaping is enabled on the port.
     */
    egressShapingPeakBandwidth?: pulumi.Input<number>;
    /**
     * If `true`, the teaming policy will re-activate failed
     * uplinks higher in precedence when they come back up.
     */
    failback?: pulumi.Input<boolean>;
    /**
     * The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
     */
    faulttoleranceMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
     */
    faulttoleranceReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
     */
    faulttoleranceShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
     */
    faulttoleranceShareLevel?: pulumi.Input<string>;
    /**
     * The folder to create the DVS in. Forces a new resource
     * if changed.
     */
    folder?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the hbr traffic class, in Mbits/sec.
     */
    hbrMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
     */
    hbrReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the hbr traffic class for a custom share level.
     */
    hbrShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
     */
    hbrShareLevel?: pulumi.Input<string>;
    /**
     * Use the `host` block to declare a host specification. The
     * options are:
     */
    hosts?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchHost>[]>;
    /**
     * Whether to ignore existing PVLAN
     * mappings not managed by this resource. Defaults to false.
     */
    ignoreOtherPvlanMappings?: pulumi.Input<boolean>;
    /**
     * The average bandwidth in
     * bits per second if ingress traffic shaping is enabled on the port.
     */
    ingressShapingAverageBandwidth?: pulumi.Input<number>;
    /**
     * The maximum burst size allowed in
     * bytes if ingress traffic shaping is enabled on the port.
     */
    ingressShapingBurstSize?: pulumi.Input<number>;
    /**
     * `true` if the traffic shaper is
     * enabled on the port for ingress traffic.
     */
    ingressShapingEnabled?: pulumi.Input<boolean>;
    /**
     * The peak bandwidth during
     * bursts in bits per second if ingress traffic shaping is enabled on the port.
     */
    ingressShapingPeakBandwidth?: pulumi.Input<number>;
    /**
     * An IPv4 address to identify the switch. This is
     * mostly useful when used with the Netflow arguments found
     * below.
     */
    ipv4Address?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
     */
    iscsiMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
     */
    iscsiReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the iSCSI traffic class for a custom share level.
     */
    iscsiShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
     */
    iscsiShareLevel?: pulumi.Input<string>;
    /**
     * The Link Aggregation Control Protocol group
     * version to use with the switch. Possible values are `singleLag` and
     * `multipleLag`.
     */
    lacpApiVersion?: pulumi.Input<string>;
    /**
     * Enables LACP for the ports that this policy
     * applies to.
     */
    lacpEnabled?: pulumi.Input<boolean>;
    /**
     * The LACP mode. Can be one of `active` or `passive`.
     */
    lacpMode?: pulumi.Input<string>;
    /**
     * Whether to `advertise` or `listen`
     * for link discovery traffic.
     */
    linkDiscoveryOperation?: pulumi.Input<string>;
    /**
     * The discovery protocol type. Valid
     * types are `cdp` and `lldp`.
     */
    linkDiscoveryProtocol?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the management traffic class, in Mbits/sec.
     */
    managementMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
     */
    managementReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the management traffic class for a custom share level.
     */
    managementShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
     */
    managementShareLevel?: pulumi.Input<string>;
    /**
     * The maximum transmission unit (MTU) for the virtual
     * switch.
     */
    maxMtu?: pulumi.Input<number>;
    /**
     * The multicast filtering mode to use
     * with the switch. Can be one of `legacyFiltering` or `snooping`.
     */
    multicastFilteringMode?: pulumi.Input<string>;
    /**
     * The name of the distributed virtual switch.
     */
    name?: pulumi.Input<string>;
    /**
     * The number of seconds after which
     * active flows are forced to be exported to the collector. Allowed range is
     * `60` to `3600`. Default: `60`.
     */
    netflowActiveFlowTimeout?: pulumi.Input<number>;
    /**
     * IP address for the Netflow
     * collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed
     * Switch Version 6.0 or later. Must be set before Netflow can be enabled.
     */
    netflowCollectorIpAddress?: pulumi.Input<string>;
    /**
     * Port for the Netflow collector. This
     * must be set before Netflow can be enabled.
     */
    netflowCollectorPort?: pulumi.Input<number>;
    /**
     * Enables Netflow on all ports that this policy
     * applies to.
     */
    netflowEnabled?: pulumi.Input<boolean>;
    /**
     * The number of seconds after which
     * idle flows are forced to be exported to the collector. Allowed range is `10`
     * to `600`. Default: `15`.
     */
    netflowIdleFlowTimeout?: pulumi.Input<number>;
    /**
     * Whether to limit analysis to
     * traffic that has both source and destination served by the same host.
     * Default: `false`.
     */
    netflowInternalFlowsOnly?: pulumi.Input<boolean>;
    /**
     * The observation domain ID for
     * the Netflow collector.
     */
    netflowObservationDomainId?: pulumi.Input<number>;
    /**
     * The ratio of total number of packets to
     * the number of packets analyzed. The default is `0`, which indicates that the
     * switch should analyze all packets. The maximum value is `1000`, which
     * indicates an analysis rate of 0.001%.
     */
    netflowSamplingRate?: pulumi.Input<number>;
    /**
     * Set to `true` to enable
     * network I/O control. Default: `false`.
     */
    networkResourceControlEnabled?: pulumi.Input<boolean>;
    /**
     * The version of network I/O
     * control to use. Can be one of `version2` or `version3`. Default: `version2`.
     */
    networkResourceControlVersion?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the nfs traffic class, in Mbits/sec.
     */
    nfsMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
     */
    nfsReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the nfs traffic class for a custom share level.
     */
    nfsShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
     */
    nfsShareLevel?: pulumi.Input<string>;
    /**
     * If `true`, the teaming policy will notify the
     * broadcast network of an uplink failover, triggering cache updates.
     */
    notifySwitches?: pulumi.Input<boolean>;
    /**
     * Used to define a secondary VLAN
     * ID when using private VLANs.
     */
    portPrivateSecondaryVlanId?: pulumi.Input<number>;
    /**
     * Use the `pvlanMapping` block to declare a
     * private VLAN mapping. The options are:
     */
    pvlanMappings?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchPvlanMapping>[]>;
    /**
     * A list of standby uplinks to be used in
     * failover. These uplinks need to match the definitions in the
     * `uplinks` DVS argument. See
     * here for more details.
     */
    standbyUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The IDs of any tags to attach to this resource.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The uplink teaming policy. Can be one of
     * `loadbalanceIp`, `loadbalanceSrcmac`, `loadbalanceSrcid`, or
     * `failoverExplicit`.
     */
    teamingPolicy?: pulumi.Input<string>;
    /**
     * Forward all traffic transmitted by ports for which
     * this policy applies to its DVS uplinks.
     */
    txUplink?: pulumi.Input<boolean>;
    /**
     * A list of strings that uniquely identifies the names
     * of the uplinks on the DVS across hosts. The number of items in this list
     * controls the number of uplinks that exist on the DVS, in addition to the
     * names.  See here for an example on how to
     * use this option.
     */
    uplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum allowed usage for the vdp traffic class, in Mbits/sec.
     */
    vdpMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
     */
    vdpReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vdp traffic class for a custom share level.
     */
    vdpShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
     */
    vdpShareLevel?: pulumi.Input<string>;
    /**
     * - The version of the DVS to create. The default is to
     * create the DVS at the latest version supported by the version of vSphere
     * being used. A DVS can be upgraded to another version, but cannot be
     * downgraded.
     */
    version?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
     */
    virtualmachineMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
     */
    virtualmachineReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
     */
    virtualmachineShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
     */
    virtualmachineShareLevel?: pulumi.Input<string>;
    /**
     * The VLAN ID for single VLAN mode. 0 denotes no VLAN.
     */
    vlanId?: pulumi.Input<number>;
    /**
     * Used to denote VLAN trunking. Use the `minVlan`
     * and `maxVlan` sub-arguments to define the tagged VLAN range. Multiple
     * `vlanRange` definitions are allowed, but they must not overlap. Example
     * below:
     */
    vlanRanges?: pulumi.Input<pulumi.Input<inputs.DistributedVirtualSwitchVlanRange>[]>;
    /**
     * The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
     */
    vmotionMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
     */
    vmotionReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vmotion traffic class for a custom share level.
     */
    vmotionShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
     */
    vmotionShareLevel?: pulumi.Input<string>;
    /**
     * The maximum allowed usage for the vsan traffic class, in Mbits/sec.
     */
    vsanMaximumMbit?: pulumi.Input<number>;
    /**
     * The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
     */
    vsanReservationMbit?: pulumi.Input<number>;
    /**
     * The amount of shares to allocate to the vsan traffic class for a custom share level.
     */
    vsanShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
     */
    vsanShareLevel?: pulumi.Input<string>;
}
