// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * The `vsphere_virtual_machine` resource can be used to manage the complex
 * lifecycle of a virtual machine. It supports management of disk, network
 * interface, and CDROM devices, creation from scratch or cloning from template,
 * and migration through both host and storage vMotion.
 * 
 * For more details on working with virtual machines in vSphere, see [this
 * page][vmware-docs-vm-management].
 * 
 * [vmware-docs-vm-management]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-55238059-912E-411F-A0E9-A7A536972A91.html
 * 
 * ## About Working with Virtual Machines in Terraform
 * 
 * A high degree of control and flexibility is afforded to a vSphere user when it
 * comes to how to configure, deploy, and manage virtual machines - much more
 * control than given in a traditional cloud provider. As such, Terraform has to
 * make some decisions on how to manage the virtual machines it creates and
 * manages. This section documents things you need to know about your virtual
 * machine configuration that you should consider when setting up virtual
 * machines, creating templates to clone from, or migrating from previous versions
 * of this resource.
 * 
 * ### Disks
 * 
 * The `vsphere_virtual_machine` resource currently only supports standard
 * VMDK-backed virtual disks - it does not support other special kinds of disk
 * devices like RDM disks.
 * 
 * Disks are managed by an arbitrary label supplied to the `label`
 * attribute of a `disk` block. This is separate from the
 * automatic naming that vSphere picks for you when creating a virtual machine.
 * Control over a virtual disk's name is not supported unless you are attaching an
 * external disk with the `attach` attribute.
 * 
 * Virtual disks can be SCSI disks only. The SCSI controllers managed by Terraform
 * can vary, depending on the value supplied to
 * `scsi_controller_count`. This also dictates the
 * controllers that are checked when looking for disks during a cloning process.
 * By default, this value is `1`, meaning that you can have up to 15 disks
 * configured on a virtual machine. These are all configured with the controller
 * type defined by the `scsi_type` setting. If you are cloning from
 * a template, devices will be added or re-configured as necessary.
 * 
 * When cloning from a template, you must specify disks of either the same or
 * greater size than the disks in the source template when creating a traditional
 * clone, or exactly the same size when cloning from snapshot (also known as a
 * linked clone). For more details, see the section on creating a virtual machine
 * from a template.
 * 
 * A maximum of 60 virtual disks can be configured when the
 * `scsi_controller_count` setting is configured to its
 * maximum of `4` controllers. See the disk options section for
 * more details.
 * 
 * ### Customization and network waiters
 * 
 * Terraform waits during various parts of a virtual machine deployment to ensure
 * that it is in a correct expected state before proceeding. These happen when a
 * VM is created, or also when it's updated, depending on the waiter.
 * 
 * Two waiters of note are:
 * 
 * * **The customization waiter:** This waiter watches events in vSphere to
 *   monitor when customization on a virtual machine completes during VM creation.
 *   Depending on your vSphere or VM configuration it may be necessary to change
 *   the timeout or turn it off. This can be controlled by the
 *   `timeout` setting in the customization
 *   settings block.
 * * **The network waiter:** This waiter waits for interfaces to show up on a
 *   guest virtual machine close to the end of both VM creation and update. This
 *   waiter is necessary to ensure that correct IP information gets reported to
 *   the guest virtual machine, mainly to facilitate the availability of a valid,
 *   reachable default IP address for any [provisioners][tf-docs-provisioners].
 *   The behavior of the waiter can be controlled with the
 *   `wait_for_guest_net_timeout`,
 *   `wait_for_guest_net_routable`,
 *   `wait_for_guest_ip_timeout`, and
 *   `ignored_guest_ips` settings.
 * 
 * [tf-docs-provisioners]: /docs/provisioners/index.html
 * 
 * ### Migrating from a previous version of this resource
 * 
 * > **NOTE:** This section only applies to versions of this resource available
 * in versions v0.4.2 of this provider or earlier.
 * 
 * The path for migrating to the current version of this resource is very similar
 * to the import path, with the exception that the `terraform
 * import` command does not need to be run. See that section for details on what
 * is required before you run `terraform plan` on a state that requires migration.
 * 
 * A successful migration usually only results in a configuration-only diff - that
 * is, Terraform reconciles some configuration settings that cannot be set during
 * the migration process with state. In this event, no reconfiguration operations
 * are sent to the vSphere server during the next `terraform apply`.  See the
 * importing section for more details.
 * 
 * ## Example Usage
 * 
 * ### Creating a virtual machine from scratch
 * 
 * The following block contains all that is necessary to create a new virtual
 * machine, with a single disk and network interface. 
 * 
 * The resource makes use of the following data sources to do its job:
 * [`vsphere_datacenter`][tf-vsphere-datacenter] to locate the datacenter,
 * [`vsphere_datastore`][tf-vsphere-datastore] to locate the default datastore to
 * put the virtual machine in, [`vsphere_resource_pool`][tf-vsphere-resource-pool]
 * to locate a resource pool located in a cluster or standalone host, and
 * [`vsphere_network`][tf-vsphere-network] to locate a network.
 * 
 * [tf-vsphere-datacenter]: /docs/providers/vsphere/d/datacenter.html
 * [tf-vsphere-datastore]: /docs/providers/vsphere/d/datastore.html
 * [tf-vsphere-resource-pool]: /docs/providers/vsphere/d/resource_pool.html
 * [tf-vsphere-network]: /docs/providers/vsphere/d/network.html
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as vsphere from "@pulumi/vsphere";
 * 
 * const dc = pulumi.output(vsphere.getDatacenter({
 *     name: "dc1",
 * }));
 * const cluster = dc.apply(dc => vsphere.getComputeCluster({
 *     datacenterId: dc.id,
 *     name: "cluster1",
 * }));
 * const datastore = dc.apply(dc => vsphere.getDatastore({
 *     datacenterId: dc.id,
 *     name: "datastore1",
 * }));
 * const network = dc.apply(dc => vsphere.getNetwork({
 *     datacenterId: dc.id,
 *     name: "public",
 * }));
 * const vm = new vsphere.VirtualMachine("vm", {
 *     datastoreId: datastore.id,
 *     disks: [{
 *         label: "disk0",
 *         size: 20,
 *     }],
 *     guestId: "other3xLinux64Guest",
 *     memory: 1024,
 *     networkInterfaces: [{
 *         networkId: network.id,
 *     }],
 *     numCpus: 2,
 *     resourcePoolId: cluster.resourcePoolId,
 * });
 * ```
 * 
 * ### Cloning and customization example
 * 
 * Building on the above example, the below configuration creates a VM by cloning
 * it from a template, fetched via the
 * [`vsphere_virtual_machine`][tf-vsphere-virtual-machine-ds] data source. This
 * allows us to locate the UUID of the template we want to clone, along with
 * settings for network interface type, SCSI bus type (especially important on
 * Windows machines), and disk attributes.
 * 
 * [tf-vsphere-virtual-machine-ds]: /docs/providers/vsphere/d/virtual_machine.html
 * 
 * > **NOTE:** Cloning requires vCenter and is not supported on direct ESXi
 * connections.
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as vsphere from "@pulumi/vsphere";
 * 
 * const dc = pulumi.output(vsphere.getDatacenter({
 *     name: "dc1",
 * }));
 * const cluster = dc.apply(dc => vsphere.getComputeCluster({
 *     datacenterId: dc.id,
 *     name: "cluster1",
 * }));
 * const datastore = dc.apply(dc => vsphere.getDatastore({
 *     datacenterId: dc.id,
 *     name: "datastore1",
 * }));
 * const network = dc.apply(dc => vsphere.getNetwork({
 *     datacenterId: dc.id,
 *     name: "public",
 * }));
 * const template = dc.apply(dc => vsphere.getVirtualMachine({
 *     datacenterId: dc.id,
 *     name: "ubuntu-16.04",
 * }));
 * const vm = new vsphere.VirtualMachine("vm", {
 *     clone: {
 *         customize: {
 *             ipv4Gateway: "10.0.0.1",
 *             linuxOptions: {
 *                 domain: "test.internal",
 *                 hostName: "terraform-test",
 *             },
 *             networkInterfaces: [{
 *                 ipv4Address: "10.0.0.10",
 *                 ipv4Netmask: 24,
 *             }],
 *         },
 *         templateUuid: template.id,
 *     },
 *     datastoreId: datastore.id,
 *     disks: [{
 *         eagerlyScrub: template.disks[0].eagerlyScrub,
 *         label: "disk0",
 *         size: template.disks[0].size,
 *         thinProvisioned: template.disks[0].thinProvisioned,
 *     }],
 *     guestId: template.guestId,
 *     memory: 1024,
 *     networkInterfaces: [{
 *         adapterType: template.apply(template => template.networkInterfaceTypes[0]),
 *         networkId: network.id,
 *     }],
 *     numCpus: 2,
 *     resourcePoolId: cluster.resourcePoolId,
 *     scsiType: template.scsiType,
 * });
 * ```
 * 
 * ### Cloning from an OVF/OVA-created template with vApp properties
 * 
 * This alternate example details how to clone a VM from a template that came from
 * an OVF/OVA file. This leverages the resource's vApp
 * properties capabilities to
 * set appropriate keys that control various configuration settings on the virtual
 * machine or virtual appliance. In this scenario, using `customize` is not
 * recommended as the functionality has tendency to overlap.
 * 
 * > **NOTE:** Neither the `vsphere_virtual_machine` resource nor the vSphere
 * provider supports importing of OVA or OVF files as this is a workflow that is
 * fundamentally not the domain of Terraform. The supported path for deployment in
 * Terraform is to first import the virtual machine into a template that has not
 * been powered on, and then clone from that template. This can be accomplished
 * with [Packer][ext-packer-io], [govc][ext-govc]'s `import.ovf` and `import.ova`
 * subcommands, or [ovftool][ext-ovftool].
 * 
 * [ext-packer-io]: https://www.packer.io/
 * [ext-govc]: https://github.com/vmware/govmomi/tree/master/govc
 * [ext-ovftool]: https://code.vmware.com/web/dp/tool/ovf
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as vsphere from "@pulumi/vsphere";
 * 
 * const dc = pulumi.output(vsphere.getDatacenter({
 *     name: "dc1",
 * }));
 * const cluster = dc.apply(dc => vsphere.getComputeCluster({
 *     datacenterId: dc.id,
 *     name: "cluster1",
 * }));
 * const datastore = dc.apply(dc => vsphere.getDatastore({
 *     datacenterId: dc.id,
 *     name: "datastore1",
 * }));
 * const network = dc.apply(dc => vsphere.getNetwork({
 *     datacenterId: dc.id,
 *     name: "public",
 * }));
 * const tempateFromOvf = dc.apply(dc => vsphere.getVirtualMachine({
 *     datacenterId: dc.id,
 *     name: "template_from_ovf",
 * }));
 * const vm = new vsphere.VirtualMachine("vm", {
 *     clone: {
 *         templateUuid: vsphere_virtual_machine_template_from_ovf.id,
 *     },
 *     datastoreId: datastore.id,
 *     disks: [{
 *         eagerlyScrub: vsphere_virtual_machine_template.disks.0.eagerlyScrub,
 *         name: "disk0",
 *         size: vsphere_virtual_machine_template.disks.0.size,
 *         thinProvisioned: vsphere_virtual_machine_template.disks.0.thinProvisioned,
 *     }],
 *     guestId: vsphere_virtual_machine_template.guestId,
 *     memory: 1024,
 *     networkInterfaces: [{
 *         adapterType: vsphere_virtual_machine_template.networkInterfaceTypes.apply(networkInterfaceTypes => networkInterfaceTypes[0]),
 *         networkId: network.id,
 *     }],
 *     numCpus: 2,
 *     resourcePoolId: cluster.resourcePoolId,
 *     scsiType: vsphere_virtual_machine_template.scsiType,
 *     vapp: {
 *         properties: {
 *             "guestinfo.dns.server.0": "10.0.0.10",
 *             "guestinfo.hostname": "terraform-test.foobar.local",
 *             "guestinfo.interface.0.ip.0.address": "10.0.0.100/24",
 *             "guestinfo.interface.0.name": "ens192",
 *             "guestinfo.interface.0.route.0.destination": "0.0.0.0/0",
 *             "guestinfo.interface.0.route.0.gateway": "10.0.0.1",
 *         },
 *     },
 * });
 * ```
 * 
 * ### Using Storage DRS
 * 
 * The `vsphere_virtual_machine` resource also supports Storage DRS, allowing the
 * assignment of virtual machines to datastore clusters. When assigned to a
 * datastore cluster, changes to a virtual machine's underlying datastores are
 * ignored unless disks drift outside of the datastore cluster. The example below
 * makes use of the [`vsphere_datastore_cluster` data
 * source][tf-vsphere-datastore-cluster-data-source], and the
 * `datastore_cluster_id` configuration setting. Note
 * that the [`vsphere_datastore_cluster`
 * resource][tf-vsphere-datastore-cluster-resource] also exists to allow for
 * management of datastore clusters directly in Terraform.
 * 
 * [tf-vsphere-datastore-cluster-data-source]: /docs/providers/vsphere/d/datastore_cluster.html
 * [tf-vsphere-datastore-cluster-resource]: /docs/providers/vsphere/r/datastore_cluster.html
 * 
 * > **NOTE:** When managing datastore clusters, member datastores, and virtual
 * machines within the same Terraform configuration, race conditions can apply.
 * This is because datastore clusters must be created before datastores can be
 * assigned to them, and the respective `vsphere_virtual_machine` resources will
 * no longer have an implicit dependency on the specific datastore resources. Use
 * [`depends_on`][tf-docs-depends-on] to create an explicit dependency on the
 * datastores in the cluster, or manage datastore clusters and datastores in a
 * separate configuration.
 * 
 * [tf-docs-depends-on]: /docs/configuration/resources.html#depends_on
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as vsphere from "@pulumi/vsphere";
 * 
 * const dc = pulumi.output(vsphere.getDatacenter({
 *     name: "dc1",
 * }));
 * const cluster = dc.apply(dc => vsphere.getComputeCluster({
 *     datacenterId: dc.id,
 *     name: "cluster1",
 * }));
 * const datastoreCluster = dc.apply(dc => vsphere.getDatastoreCluster({
 *     datacenterId: dc.id,
 *     name: "datastore-cluster1",
 * }));
 * const network = dc.apply(dc => vsphere.getNetwork({
 *     datacenterId: dc.id,
 *     name: "public",
 * }));
 * const vm = new vsphere.VirtualMachine("vm", {
 *     datastoreClusterId: datastoreCluster.id,
 *     disks: [{
 *         label: "disk0",
 *         size: 20,
 *     }],
 *     guestId: "other3xLinux64Guest",
 *     memory: 1024,
 *     networkInterfaces: [{
 *         networkId: network.id,
 *     }],
 *     numCpus: 2,
 *     resourcePoolId: cluster.resourcePoolId,
 * });
 * ```
 * 
 * ## Creating a Virtual Machine from a Template
 * 
 * The `clone` block can be used to create a new virtual machine from an existing
 * virtual machine or template. The resource supports both making a complete copy
 * of a virtual machine, or cloning from a snapshot (otherwise known as a linked
 * clone).
 * 
 * See the cloning and customization
 * example for a usage synopsis.
 * 
 * > **NOTE:** Changing any option in `clone` after creation forces a new
 * resource.
 * 
 * > **NOTE:** Cloning requires vCenter and is not supported on direct ESXi
 * connections.
 * 
 * The options available in the `clone` block are:
 * 
 * * `template_uuid` - (Required) The UUID of the source virtual machine or
 *   template.
 * * `linked_clone` - (Optional) Clone this virtual machine from a snapshot.
 *   Templates must have a single snapshot only in order to be eligible. Default:
 *   `false`.
 * * `timeout` - (Optional) The timeout, in minutes, to wait for the virtual
 *   machine clone to complete. Default: 30 minutes.
 * * `customize` - (Optional) The customization spec for this clone. This allows
 *   the user to configure the virtual machine post-clone. For more details, see
 *   virtual machine customization.
 * 
 * ### Additional requirements and notes for cloning
 * 
 * Note that when cloning from a template, there are additional requirements in
 * both the resource configuration and source template:
 * 
 * * The virtual machine must not be powered on at the time of cloning.
 * * All disks on the virtual machine must be SCSI disks.
 * * You must specify at least the same number of `disk` devices as there are
 *   disks that exist in the template. These devices are ordered and lined up by
 *   the `unit_number` attribute. Additional disks can be added past this.
 * * The `size` of a virtual disk must be at least the same size as its
 *   counterpart disk in the template.
 * * When using `linked_clone`, the `size`, `thin_provisioned`, and
 *   `eagerly_scrub` settings for each disk must be an exact match to the
 *   individual disk's counterpart in the source template.
 * * The `scsi_controller_count` setting should be
 *   configured as necessary to cover all of the disks on the template. For best
 *   results, only configure this setting for the amount of controllers you will
 *   need to cover your disk quantity and bandwidth needs, and configure your
 *   template accordingly. For most workloads, this setting should be kept at its
 *   default of `1`, and all disks in the template should reside on the single,
 *   primary controller.
 * * Some operating systems (such as Windows) do not respond well to a change in
 *   disk controller type, so when using such OSes, take care to ensure that
 *   `scsi_type` is set to an exact match of the template's controller set. For
 *   maximum compatibility, make sure the SCSI controllers on the source template
 *   are all the same type.
 * 
 * To ease the gathering of some of these options, you can use the
 * [`vsphere_virtual_machine` data source][tf-vsphere-virtual-machine-ds], which
 * will give you disk attributes, network interface types, SCSI bus types, and
 * also the guest ID of the source template.  See the cloning and customization
 * example for usage details.
 * 
 * ## Virtual Machine Migration
 * 
 * The `vsphere_virtual_machine` resource supports live migration (otherwise known
 * as vMotion) both on the host and storage level. One can migrate the entire VM
 * to another host, cluster, resource pool, or datastore, and migrate or pin a
 * single disk to a specific datastore.
 * 
 * ### Host, cluster, and resource pool migration 
 * 
 * To migrate the virtual machine to another host or resource pool, change the
 * `host_system_id` or `resource_pool_id` to the manged object IDs of the new host
 * or resource pool accordingly. To change the virtual machine's cluster or
 * standalone host, select a resource pool within the specific target.
 * 
 * The same rules apply for migration as they do for VM creation - any host
 * specified needs to be a part of the resource pool supplied. Also keep in mind
 * the implications of moving the virtual machine to a resource pool in another
 * cluster or standalone host, namely ensuring that all hosts in the cluster (or
 * the single standalone host) have access to the datastore that the virtual
 * machine is in.
 * 
 * ## Importing 
 * 
 * ### Additional requirements and notes for importing
 * 
 * Many of the same requirements for
 * cloning apply to importing,
 * although since importing writes directly to state, a lot of these rules cannot
 * be enforced at import time, so every effort should be made to ensure the
 * correctness of the configuration before the import.
 * 
 * In addition to these rules, the following extra rules apply to importing:
 * 
 * * Disks need to have their `label` argument assigned in a convention
 *   matching `diskN`, starting with disk number 0, based on each disk's order on
 *   the SCSI bus. As an example, a disk on SCSI controller 0 with a unit number
 *   of 0 would be labeled `disk0`, a disk on the same controller with a unit
 *   number of 1 would be `disk1`, but the next disk, which is on SCSI controller
 *   1 with a unit number of 0, still becomes `disk2`.
 * * Disks always get imported with `keep_on_remove` enabled
 *   until the first `terraform apply` runs, which will remove the setting for
 *   known disks. This is an extra safeguard against naming or accounting mistakes
 *   in the disk configuration.
 * * The `scsi_controller_count` for the resource is set
 *   to the number of contiguous SCSI controllers found, starting with the SCSI
 *   controller at bus number 0. If no SCSI controllers are found, the VM is not
 *   eligible for import. To ensure maximum compatibility, make sure your virtual
 *   machine has the exact number of SCSI controllers it needs, and set
 *   `scsi_controller_count` accordingly.
 * 
 * After importing, you should run `terraform plan`. Unless you have changed
 * anything else in configuration that would be causing other attributes to
 * change, the only difference should be configuration-only changes, usually
 * comprising of:
 * 
 * * The `imported` flag will transition from `true` to `false`.
 * * `keep_on_remove` of known disks will transition from
 *   `true` to `false`. 
 * * Configuration supplied in the `clone` block, if present, will be
 *   persisted to state. This initial persistence operation does not perform any
 *   cloning or customization actions, nor does it force a new resource. After the
 *   first apply operation, further changes to `clone` will force a new resource
 *   as per normal operation.
 * 
 * > **NOTE:** Further to the above, do not make any configuration changes to
 * `clone` after importing or upgrading from a legacy version of the provider
 * before doing an initial `terraform apply` as these changes will not correctly
 * force a new resource, and your changes will have persisted to state, preventing
 * further plans from correctly triggering a diff.
 * 
 * These changes only update Terraform state when applied, hence it is safe to run
 * when the virtual machine is running. If more settings are being modified, you
 * may need to plan maintenance accordingly for any necessary re-configuration of
 * the virtual machine.
 */
export class VirtualMachine extends pulumi.CustomResource {
    /**
     * Get an existing VirtualMachine resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: VirtualMachineState, opts?: pulumi.CustomResourceOptions): VirtualMachine {
        return new VirtualMachine(name, <any>state, { ...opts, id: id });
    }

    /**
     * The guest name for the operating system
     * when `guest_id` is `other` or `other-64`.
     */
    public readonly alternateGuestName: pulumi.Output<string | undefined>;
    /**
     * A user-provided description of the virtual machine.
     * The default is no annotation.
     */
    public readonly annotation: pulumi.Output<string | undefined>;
    /**
     * The number of milliseconds to wait before starting
     * the boot sequence. The default is no delay.
     */
    public readonly bootDelay: pulumi.Output<number | undefined>;
    /**
     * The number of milliseconds to wait before
     * retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
     * Default: `10000` (10 seconds).
     */
    public readonly bootRetryDelay: pulumi.Output<number | undefined>;
    /**
     * If set to true, a virtual machine that
     * fails to boot will try again after the delay defined in `boot_retry_delay`.
     * Default: `false`.
     */
    public readonly bootRetryEnabled: pulumi.Output<boolean | undefined>;
    /**
     * A specification for a CDROM device on this virtual
     * machine. See CDROM options below.
     */
    public readonly cdrom: pulumi.Output<{ clientDevice?: boolean, datastoreId?: string, deviceAddress: string, key: number, path?: string } | undefined>;
    /**
     * A unique identifier for a given version of the last
     * configuration applied, such the timestamp of the last update to the
     * configuration.
     */
    public /*out*/ readonly changeVersion: pulumi.Output<string>;
    /**
     * When specified, the VM will be created as a clone of a
     * specified template. Optional customization options can be submitted as well.
     * See creating a virtual machine from a
     * template for more details.
     */
    public readonly clone: pulumi.Output<{ customize?: { dnsServerLists?: string[], dnsSuffixLists?: string[], ipv4Gateway?: string, ipv6Gateway?: string, linuxOptions?: { domain: string, hostName: string, hwClockUtc?: boolean, timeZone?: string }, networkInterfaces?: { dnsDomain?: string, dnsServerLists?: string[], ipv4Address?: string, ipv4Netmask?: number, ipv6Address?: string, ipv6Netmask?: number }[], timeout?: number, windowsOptions?: { adminPassword?: string, autoLogon?: boolean, autoLogonCount?: number, computerName: string, domainAdminPassword?: string, domainAdminUser?: string, fullName?: string, joinDomain?: string, organizationName?: string, productKey?: string, runOnceCommandLists?: string[], timeZone?: number, workgroup?: string }, windowsSysprepText?: string }, linkedClone?: boolean, templateUuid: string, timeout?: number } | undefined>;
    /**
     * Allow CPUs to be added to this virtual
     * machine while it is running.
     */
    public readonly cpuHotAddEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Allow CPUs to be removed to this
     * virtual machine while it is running.
     */
    public readonly cpuHotRemoveEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The maximum amount of CPU (in MHz) that this virtual
     * machine can consume, regardless of available resources. The default is no
     * limit.
     */
    public readonly cpuLimit: pulumi.Output<number | undefined>;
    /**
     * Enable CPU performance
     * counters on this virtual machine. Default: `false`.
     */
    public readonly cpuPerformanceCountersEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The amount of CPU (in MHz) that this virtual
     * machine is guaranteed. The default is no reservation.
     */
    public readonly cpuReservation: pulumi.Output<number | undefined>;
    /**
     * The number of CPU shares allocated to the
     * virtual machine when the `cpu_share_level` is `custom`.
     */
    public readonly cpuShareCount: pulumi.Output<number>;
    /**
     * The allocation level for CPU resources. Can be
     * one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
     */
    public readonly cpuShareLevel: pulumi.Output<string | undefined>;
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for virtual machine. See
     * [here][docs-setting-custom-attributes] for a reference on how to set values
     * for custom attributes.
     */
    public readonly customAttributes: pulumi.Output<{[key: string]: any} | undefined>;
    /**
     * The [managed object reference
     * ID][docs-about-morefs] of the datastore cluster ID to use. This setting
     * applies to entire virtual machine and implies that you wish to use Storage
     * DRS with this virtual machine. See the section on virtual machine
     * migration for details on changing this value.
     */
    public readonly datastoreClusterId: pulumi.Output<string | undefined>;
    /**
     * The datastore ID that the ISO is located in.
     * Requried for using a datastore ISO. Conflicts with `client_device`.
     */
    public readonly datastoreId: pulumi.Output<string>;
    /**
     * The IP address selected by Terraform to be used with
     * any [provisioners][tf-docs-provisioners] configured on this resource.
     * Whenever possible, this is the first IPv4 address that is reachable through
     * the default gateway configured on the machine, then the first reachable IPv6
     * address, and then the first general discovered address if neither exist. If
     * VMware tools is not running on the virtual machine, or if the VM is powered
     * off, this value will be blank.
     */
    public /*out*/ readonly defaultIpAddress: pulumi.Output<string>;
    /**
     * A specification for a virtual disk device on this virtual
     * machine. See disk options below.
     */
    public readonly disks: pulumi.Output<{ attach?: boolean, datastoreId?: string, deviceAddress: string, diskMode?: string, diskSharing?: string, eagerlyScrub?: boolean, ioLimit?: number, ioReservation?: number, ioShareCount?: number, ioShareLevel?: string, keepOnRemove?: boolean, key: number, label?: string, name?: string, path: string, size?: number, thinProvisioned?: boolean, unitNumber?: number, uuid: string, writeThrough?: boolean }[]>;
    /**
     * When the `firmware` type is set to is
     * `efi`, this enables EFI secure boot. Default: `false`.
     */
    public readonly efiSecureBootEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Expose the UUIDs of attached virtual disks to
     * the virtual machine, allowing access to them in the guest. Default: `false`.
     */
    public readonly enableDiskUuid: pulumi.Output<boolean | undefined>;
    /**
     * Enable logging of virtual machine events to a
     * log file stored in the virtual machine directory. Default: `false`.
     */
    public readonly enableLogging: pulumi.Output<boolean | undefined>;
    /**
     * The EPT/RVI (hardware memory virtualization)
     * setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
     * Default: `automatic`.
     */
    public readonly eptRviMode: pulumi.Output<string | undefined>;
    /**
     * Extra configuration data for this virtual
     * machine. Can be used to supply advanced parameters not normally in
     * configuration, such as data for cloud-config (under the guestinfo namespace).
     */
    public readonly extraConfig: pulumi.Output<{[key: string]: any} | undefined>;
    /**
     * The firmware interface to use on the virtual machine.
     * Can be one of `bios` or `EFI`. Default: `bios`.
     */
    public readonly firmware: pulumi.Output<string | undefined>;
    /**
     * The path to the folder to put this virtual machine in,
     * relative to the datacenter that the resource pool is in.
     */
    public readonly folder: pulumi.Output<string | undefined>;
    /**
     * If a guest shutdown failed or timed out while
     * updating or destroying (see
     * `shutdown_wait_timeout`), force the power-off of
     * the virtual machine. Default: `true`.
     */
    public readonly forcePowerOff: pulumi.Output<boolean | undefined>;
    /**
     * The guest ID for the operating system type. For a
     * full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
     */
    public readonly guestId: pulumi.Output<string | undefined>;
    /**
     * The current list of IP addresses on this machine,
     * including the value of `default_ip_address`. If VMware tools is not running
     * on the virtual machine, or if the VM is powered off, this list will be empty.
     * * `moid`: The [managed object reference ID][docs-about-morefs] of the created
     * virtual machine.
     */
    public /*out*/ readonly guestIpAddresses: pulumi.Output<string[]>;
    /**
     * An optional [managed object reference
     * ID][docs-about-morefs] of a host to put this virtual machine on. See the
     * section on virtual machine migration for
     * details on changing this value. If a `host_system_id` is not supplied,
     * vSphere will select a host in the resource pool to place the virtual machine,
     * according to any defaults or DRS policies in place.
     */
    public readonly hostSystemId: pulumi.Output<string>;
    /**
     * The (non-nested) hardware virtualization setting for
     * this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
     * `hvAuto`.
     */
    public readonly hvMode: pulumi.Output<string | undefined>;
    /**
     * List of IP addresses to ignore while waiting
     * for an available IP address using either of the waiters. Any IP addresses in
     * this list will be ignored if they show up so that the waiter will continue to
     * wait for a real IP address. Default: [].
     */
    public readonly ignoredGuestIps: pulumi.Output<string[] | undefined>;
    /**
     * This is flagged if the virtual machine has been imported, or the
     * state has been migrated from a previous version of the resource. It
     * influences the behavior of the first post-import apply operation. See the
     * section on importing below.
     */
    public /*out*/ readonly imported: pulumi.Output<boolean>;
    /**
     * Controls the scheduling delay of the
     * virtual machine. Use a higher sensitivity for applications that require lower
     * latency, such as VOIP, media player applications, or applications that
     * require frequent access to mouse or keyboard devices. Can be one of `low`,
     * `normal`, `medium`, or `high`.
     */
    public readonly latencySensitivity: pulumi.Output<string | undefined>;
    /**
     * The size of the virtual machine's memory, in MB.
     * Default: `1024` (1 GB).
     */
    public readonly memory: pulumi.Output<number | undefined>;
    /**
     * Allow memory to be added to this
     * virtual machine while it is running.
     */
    public readonly memoryHotAddEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The maximum amount of memory (in MB) that this
     * virtual machine can consume, regardless of available resources. The default
     * is no limit.
     */
    public readonly memoryLimit: pulumi.Output<number | undefined>;
    /**
     * The amount of memory (in MB) that this
     * virtual machine is guaranteed. The default is no reservation.
     */
    public readonly memoryReservation: pulumi.Output<number | undefined>;
    /**
     * The number of memory shares allocated to
     * the virtual machine when the `memory_share_level` is `custom`.
     */
    public readonly memoryShareCount: pulumi.Output<number>;
    /**
     * The allocation level for memory resources.
     * Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
     */
    public readonly memoryShareLevel: pulumi.Output<string | undefined>;
    /**
     * The amount of time, in minutes, to wait
     * for a virtual machine migration to complete before failing. Default: 10
     * minutes. Also see the section on virtual machine
     * migration.
     */
    public readonly migrateWaitTimeout: pulumi.Output<number | undefined>;
    /**
     * The machine object ID from VMWare
     */
    public /*out*/ readonly moid: pulumi.Output<string>;
    /**
     * An alias for both `label` and `path`, the latter when
     * using `attach`. Required if not using `label`.
     */
    public readonly name: pulumi.Output<string>;
    /**
     * Enable nested hardware virtualization on
     * this virtual machine, facilitating nested virtualization in the guest.
     * Default: `false`.
     */
    public readonly nestedHvEnabled: pulumi.Output<boolean | undefined>;
    /**
     * A specification for a virtual NIC on this
     * virtual machine. See network interface options
     * below.
     */
    public readonly networkInterfaces: pulumi.Output<{ adapterType?: string, bandwidthLimit?: number, bandwidthReservation?: number, bandwidthShareCount: number, bandwidthShareLevel?: string, deviceAddress: string, key: number, macAddress: string, networkId: string, useStaticMac?: boolean }[]>;
    /**
     * The number of cores to distribute among
     * the CPUs in this virtual machine. If specified, the value supplied to
     * `num_cpus` must be evenly divisible by this value. Default: `1`.
     */
    public readonly numCoresPerSocket: pulumi.Output<number | undefined>;
    /**
     * The number of virtual processors to assign to this
     * virtual machine. Default: `1`.
     */
    public readonly numCpus: pulumi.Output<number | undefined>;
    /**
     * Value internal to Terraform used to determine if a
     * configuration set change requires a reboot. This value is only useful during
     * an update process and gets reset on refresh.
     */
    public /*out*/ readonly rebootRequired: pulumi.Output<boolean>;
    /**
     * The [managed object reference
     * ID][docs-about-morefs] of the resource pool to put this virtual machine in.
     * See the section on virtual machine migration
     * for details on changing this value.
     */
    public readonly resourcePoolId: pulumi.Output<string>;
    /**
     * Enable the execution of
     * post-power-on scripts when VMware tools is installed. Default: `true`.
     */
    public readonly runToolsScriptsAfterPowerOn: pulumi.Output<boolean | undefined>;
    /**
     * Enable the execution of
     * post-resume scripts when VMware tools is installed. Default: `true`.
     */
    public readonly runToolsScriptsAfterResume: pulumi.Output<boolean | undefined>;
    /**
     * Enable the execution of
     * pre-reboot scripts when VMware tools is installed. Default: `false`.
     */
    public readonly runToolsScriptsBeforeGuestReboot: pulumi.Output<boolean | undefined>;
    /**
     * Enable the execution
     * of pre-shutdown scripts when VMware tools is installed. Default: `true`.
     */
    public readonly runToolsScriptsBeforeGuestShutdown: pulumi.Output<boolean | undefined>;
    /**
     * Enable the execution of
     * pre-standby scripts when VMware tools is installed. Default: `true`.
     */
    public readonly runToolsScriptsBeforeGuestStandby: pulumi.Output<boolean | undefined>;
    /**
     * Mode for sharing the SCSI bus. The modes are
     * physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
     */
    public readonly scsiBusSharing: pulumi.Output<string | undefined>;
    /**
     * The number of SCSI controllers that
     * Terraform manages on this virtual machine. This directly affects the amount
     * of disks you can add to the virtual machine and the maximum disk unit number.
     * Note that lowering this value does not remove controllers. Default: `1`.
     */
    public readonly scsiControllerCount: pulumi.Output<number | undefined>;
    /**
     * The type of SCSI bus this virtual machine will have.
     * Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
     * pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
     */
    public readonly scsiType: pulumi.Output<string | undefined>;
    /**
     * The amount of time, in minutes, to wait
     * for a graceful guest shutdown when making necessary updates to the virtual
     * machine. If `force_power_off` is set to true, the VM will be force powered-off
     * after this timeout, otherwise an error is returned. Default: 3 minutes.
     */
    public readonly shutdownWaitTimeout: pulumi.Output<number | undefined>;
    /**
     * The swap file placement policy for this
     * virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
     * Default: `inherit`.
     */
    public readonly swapPlacementPolicy: pulumi.Output<string | undefined>;
    /**
     * Enable guest clock synchronization with
     * the host. Requires VMware tools to be installed. Default: `false`.
     */
    public readonly syncTimeWithHost: pulumi.Output<boolean | undefined>;
    /**
     * The IDs of any tags to attach to this resource. See
     * [here][docs-applying-tags] for a reference on how to apply tags.
     */
    public readonly tags: pulumi.Output<string[] | undefined>;
    /**
     * The UUID of the virtual disk's VMDK file. This is used to track the
     * virtual disk on the virtual machine.
     */
    public /*out*/ readonly uuid: pulumi.Output<string>;
    /**
     * Optional vApp configuration. The only sub-key available
     * is `properties`, which is a key/value map of properties for virtual machines
     * imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
     * configuration for
     * more details.
     */
    public readonly vapp: pulumi.Output<{ properties?: {[key: string]: string} } | undefined>;
    /**
     * Computed value which is only valid for cloned virtual
     * machines. A list of vApp transport methods supported by the source virtual
     * machine or template.
     */
    public /*out*/ readonly vappTransports: pulumi.Output<string[]>;
    /**
     * The state of VMware tools in the guest. This will
     * determine the proper course of action for some device operations.
     */
    public /*out*/ readonly vmwareToolsStatus: pulumi.Output<string>;
    /**
     * The path of the virtual machine's configuration file in the VM's
     * datastore.
     */
    public /*out*/ readonly vmxPath: pulumi.Output<string>;
    /**
     * The amount of time, in minutes, to
     * wait for an available guest IP address on this virtual machine. This should
     * only be used if your version of VMware Tools does not allow the
     * `wait_for_guest_net_timeout` waiter to be
     * used. A value less than 1 disables the waiter. Default: 0.
     */
    public readonly waitForGuestIpTimeout: pulumi.Output<number | undefined>;
    /**
     * Controls whether or not the guest
     * network waiter waits for a routable address. When `false`, the waiter does
     * not wait for a default gateway, nor are IP addresses checked against any
     * discovered default gateways as part of its success criteria. This property is
     * ignored if the `wait_for_guest_ip_timeout`
     * waiter is used. Default: `true`.
     */
    public readonly waitForGuestNetRoutable: pulumi.Output<boolean | undefined>;
    /**
     * The amount of time, in minutes, to
     * wait for an available IP address on this virtual machine's NICs. Older
     * versions of VMware Tools do not populate this property. In those cases, this
     * waiter can be disabled and the
     * `wait_for_guest_ip_timeout` waiter can be used
     * instead. A value less than 1 disables the waiter. Default: 5 minutes.
     */
    public readonly waitForGuestNetTimeout: pulumi.Output<number | undefined>;

    /**
     * Create a VirtualMachine resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: VirtualMachineArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: VirtualMachineArgs | VirtualMachineState, opts?: pulumi.CustomResourceOptions) {
        let inputs: pulumi.Inputs = {};
        if (opts && opts.id) {
            const state: VirtualMachineState = argsOrState as VirtualMachineState | undefined;
            inputs["alternateGuestName"] = state ? state.alternateGuestName : undefined;
            inputs["annotation"] = state ? state.annotation : undefined;
            inputs["bootDelay"] = state ? state.bootDelay : undefined;
            inputs["bootRetryDelay"] = state ? state.bootRetryDelay : undefined;
            inputs["bootRetryEnabled"] = state ? state.bootRetryEnabled : undefined;
            inputs["cdrom"] = state ? state.cdrom : undefined;
            inputs["changeVersion"] = state ? state.changeVersion : undefined;
            inputs["clone"] = state ? state.clone : undefined;
            inputs["cpuHotAddEnabled"] = state ? state.cpuHotAddEnabled : undefined;
            inputs["cpuHotRemoveEnabled"] = state ? state.cpuHotRemoveEnabled : undefined;
            inputs["cpuLimit"] = state ? state.cpuLimit : undefined;
            inputs["cpuPerformanceCountersEnabled"] = state ? state.cpuPerformanceCountersEnabled : undefined;
            inputs["cpuReservation"] = state ? state.cpuReservation : undefined;
            inputs["cpuShareCount"] = state ? state.cpuShareCount : undefined;
            inputs["cpuShareLevel"] = state ? state.cpuShareLevel : undefined;
            inputs["customAttributes"] = state ? state.customAttributes : undefined;
            inputs["datastoreClusterId"] = state ? state.datastoreClusterId : undefined;
            inputs["datastoreId"] = state ? state.datastoreId : undefined;
            inputs["defaultIpAddress"] = state ? state.defaultIpAddress : undefined;
            inputs["disks"] = state ? state.disks : undefined;
            inputs["efiSecureBootEnabled"] = state ? state.efiSecureBootEnabled : undefined;
            inputs["enableDiskUuid"] = state ? state.enableDiskUuid : undefined;
            inputs["enableLogging"] = state ? state.enableLogging : undefined;
            inputs["eptRviMode"] = state ? state.eptRviMode : undefined;
            inputs["extraConfig"] = state ? state.extraConfig : undefined;
            inputs["firmware"] = state ? state.firmware : undefined;
            inputs["folder"] = state ? state.folder : undefined;
            inputs["forcePowerOff"] = state ? state.forcePowerOff : undefined;
            inputs["guestId"] = state ? state.guestId : undefined;
            inputs["guestIpAddresses"] = state ? state.guestIpAddresses : undefined;
            inputs["hostSystemId"] = state ? state.hostSystemId : undefined;
            inputs["hvMode"] = state ? state.hvMode : undefined;
            inputs["ignoredGuestIps"] = state ? state.ignoredGuestIps : undefined;
            inputs["imported"] = state ? state.imported : undefined;
            inputs["latencySensitivity"] = state ? state.latencySensitivity : undefined;
            inputs["memory"] = state ? state.memory : undefined;
            inputs["memoryHotAddEnabled"] = state ? state.memoryHotAddEnabled : undefined;
            inputs["memoryLimit"] = state ? state.memoryLimit : undefined;
            inputs["memoryReservation"] = state ? state.memoryReservation : undefined;
            inputs["memoryShareCount"] = state ? state.memoryShareCount : undefined;
            inputs["memoryShareLevel"] = state ? state.memoryShareLevel : undefined;
            inputs["migrateWaitTimeout"] = state ? state.migrateWaitTimeout : undefined;
            inputs["moid"] = state ? state.moid : undefined;
            inputs["name"] = state ? state.name : undefined;
            inputs["nestedHvEnabled"] = state ? state.nestedHvEnabled : undefined;
            inputs["networkInterfaces"] = state ? state.networkInterfaces : undefined;
            inputs["numCoresPerSocket"] = state ? state.numCoresPerSocket : undefined;
            inputs["numCpus"] = state ? state.numCpus : undefined;
            inputs["rebootRequired"] = state ? state.rebootRequired : undefined;
            inputs["resourcePoolId"] = state ? state.resourcePoolId : undefined;
            inputs["runToolsScriptsAfterPowerOn"] = state ? state.runToolsScriptsAfterPowerOn : undefined;
            inputs["runToolsScriptsAfterResume"] = state ? state.runToolsScriptsAfterResume : undefined;
            inputs["runToolsScriptsBeforeGuestReboot"] = state ? state.runToolsScriptsBeforeGuestReboot : undefined;
            inputs["runToolsScriptsBeforeGuestShutdown"] = state ? state.runToolsScriptsBeforeGuestShutdown : undefined;
            inputs["runToolsScriptsBeforeGuestStandby"] = state ? state.runToolsScriptsBeforeGuestStandby : undefined;
            inputs["scsiBusSharing"] = state ? state.scsiBusSharing : undefined;
            inputs["scsiControllerCount"] = state ? state.scsiControllerCount : undefined;
            inputs["scsiType"] = state ? state.scsiType : undefined;
            inputs["shutdownWaitTimeout"] = state ? state.shutdownWaitTimeout : undefined;
            inputs["swapPlacementPolicy"] = state ? state.swapPlacementPolicy : undefined;
            inputs["syncTimeWithHost"] = state ? state.syncTimeWithHost : undefined;
            inputs["tags"] = state ? state.tags : undefined;
            inputs["uuid"] = state ? state.uuid : undefined;
            inputs["vapp"] = state ? state.vapp : undefined;
            inputs["vappTransports"] = state ? state.vappTransports : undefined;
            inputs["vmwareToolsStatus"] = state ? state.vmwareToolsStatus : undefined;
            inputs["vmxPath"] = state ? state.vmxPath : undefined;
            inputs["waitForGuestIpTimeout"] = state ? state.waitForGuestIpTimeout : undefined;
            inputs["waitForGuestNetRoutable"] = state ? state.waitForGuestNetRoutable : undefined;
            inputs["waitForGuestNetTimeout"] = state ? state.waitForGuestNetTimeout : undefined;
        } else {
            const args = argsOrState as VirtualMachineArgs | undefined;
            if (!args || args.networkInterfaces === undefined) {
                throw new Error("Missing required property 'networkInterfaces'");
            }
            if (!args || args.resourcePoolId === undefined) {
                throw new Error("Missing required property 'resourcePoolId'");
            }
            inputs["alternateGuestName"] = args ? args.alternateGuestName : undefined;
            inputs["annotation"] = args ? args.annotation : undefined;
            inputs["bootDelay"] = args ? args.bootDelay : undefined;
            inputs["bootRetryDelay"] = args ? args.bootRetryDelay : undefined;
            inputs["bootRetryEnabled"] = args ? args.bootRetryEnabled : undefined;
            inputs["cdrom"] = args ? args.cdrom : undefined;
            inputs["clone"] = args ? args.clone : undefined;
            inputs["cpuHotAddEnabled"] = args ? args.cpuHotAddEnabled : undefined;
            inputs["cpuHotRemoveEnabled"] = args ? args.cpuHotRemoveEnabled : undefined;
            inputs["cpuLimit"] = args ? args.cpuLimit : undefined;
            inputs["cpuPerformanceCountersEnabled"] = args ? args.cpuPerformanceCountersEnabled : undefined;
            inputs["cpuReservation"] = args ? args.cpuReservation : undefined;
            inputs["cpuShareCount"] = args ? args.cpuShareCount : undefined;
            inputs["cpuShareLevel"] = args ? args.cpuShareLevel : undefined;
            inputs["customAttributes"] = args ? args.customAttributes : undefined;
            inputs["datastoreClusterId"] = args ? args.datastoreClusterId : undefined;
            inputs["datastoreId"] = args ? args.datastoreId : undefined;
            inputs["disks"] = args ? args.disks : undefined;
            inputs["efiSecureBootEnabled"] = args ? args.efiSecureBootEnabled : undefined;
            inputs["enableDiskUuid"] = args ? args.enableDiskUuid : undefined;
            inputs["enableLogging"] = args ? args.enableLogging : undefined;
            inputs["eptRviMode"] = args ? args.eptRviMode : undefined;
            inputs["extraConfig"] = args ? args.extraConfig : undefined;
            inputs["firmware"] = args ? args.firmware : undefined;
            inputs["folder"] = args ? args.folder : undefined;
            inputs["forcePowerOff"] = args ? args.forcePowerOff : undefined;
            inputs["guestId"] = args ? args.guestId : undefined;
            inputs["hostSystemId"] = args ? args.hostSystemId : undefined;
            inputs["hvMode"] = args ? args.hvMode : undefined;
            inputs["ignoredGuestIps"] = args ? args.ignoredGuestIps : undefined;
            inputs["latencySensitivity"] = args ? args.latencySensitivity : undefined;
            inputs["memory"] = args ? args.memory : undefined;
            inputs["memoryHotAddEnabled"] = args ? args.memoryHotAddEnabled : undefined;
            inputs["memoryLimit"] = args ? args.memoryLimit : undefined;
            inputs["memoryReservation"] = args ? args.memoryReservation : undefined;
            inputs["memoryShareCount"] = args ? args.memoryShareCount : undefined;
            inputs["memoryShareLevel"] = args ? args.memoryShareLevel : undefined;
            inputs["migrateWaitTimeout"] = args ? args.migrateWaitTimeout : undefined;
            inputs["name"] = args ? args.name : undefined;
            inputs["nestedHvEnabled"] = args ? args.nestedHvEnabled : undefined;
            inputs["networkInterfaces"] = args ? args.networkInterfaces : undefined;
            inputs["numCoresPerSocket"] = args ? args.numCoresPerSocket : undefined;
            inputs["numCpus"] = args ? args.numCpus : undefined;
            inputs["resourcePoolId"] = args ? args.resourcePoolId : undefined;
            inputs["runToolsScriptsAfterPowerOn"] = args ? args.runToolsScriptsAfterPowerOn : undefined;
            inputs["runToolsScriptsAfterResume"] = args ? args.runToolsScriptsAfterResume : undefined;
            inputs["runToolsScriptsBeforeGuestReboot"] = args ? args.runToolsScriptsBeforeGuestReboot : undefined;
            inputs["runToolsScriptsBeforeGuestShutdown"] = args ? args.runToolsScriptsBeforeGuestShutdown : undefined;
            inputs["runToolsScriptsBeforeGuestStandby"] = args ? args.runToolsScriptsBeforeGuestStandby : undefined;
            inputs["scsiBusSharing"] = args ? args.scsiBusSharing : undefined;
            inputs["scsiControllerCount"] = args ? args.scsiControllerCount : undefined;
            inputs["scsiType"] = args ? args.scsiType : undefined;
            inputs["shutdownWaitTimeout"] = args ? args.shutdownWaitTimeout : undefined;
            inputs["swapPlacementPolicy"] = args ? args.swapPlacementPolicy : undefined;
            inputs["syncTimeWithHost"] = args ? args.syncTimeWithHost : undefined;
            inputs["tags"] = args ? args.tags : undefined;
            inputs["vapp"] = args ? args.vapp : undefined;
            inputs["waitForGuestIpTimeout"] = args ? args.waitForGuestIpTimeout : undefined;
            inputs["waitForGuestNetRoutable"] = args ? args.waitForGuestNetRoutable : undefined;
            inputs["waitForGuestNetTimeout"] = args ? args.waitForGuestNetTimeout : undefined;
            inputs["changeVersion"] = undefined /*out*/;
            inputs["defaultIpAddress"] = undefined /*out*/;
            inputs["guestIpAddresses"] = undefined /*out*/;
            inputs["imported"] = undefined /*out*/;
            inputs["moid"] = undefined /*out*/;
            inputs["rebootRequired"] = undefined /*out*/;
            inputs["uuid"] = undefined /*out*/;
            inputs["vappTransports"] = undefined /*out*/;
            inputs["vmwareToolsStatus"] = undefined /*out*/;
            inputs["vmxPath"] = undefined /*out*/;
        }
        super("vsphere:index/virtualMachine:VirtualMachine", name, inputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering VirtualMachine resources.
 */
export interface VirtualMachineState {
    /**
     * The guest name for the operating system
     * when `guest_id` is `other` or `other-64`.
     */
    readonly alternateGuestName?: pulumi.Input<string>;
    /**
     * A user-provided description of the virtual machine.
     * The default is no annotation.
     */
    readonly annotation?: pulumi.Input<string>;
    /**
     * The number of milliseconds to wait before starting
     * the boot sequence. The default is no delay.
     */
    readonly bootDelay?: pulumi.Input<number>;
    /**
     * The number of milliseconds to wait before
     * retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
     * Default: `10000` (10 seconds).
     */
    readonly bootRetryDelay?: pulumi.Input<number>;
    /**
     * If set to true, a virtual machine that
     * fails to boot will try again after the delay defined in `boot_retry_delay`.
     * Default: `false`.
     */
    readonly bootRetryEnabled?: pulumi.Input<boolean>;
    /**
     * A specification for a CDROM device on this virtual
     * machine. See CDROM options below.
     */
    readonly cdrom?: pulumi.Input<{ clientDevice?: pulumi.Input<boolean>, datastoreId?: pulumi.Input<string>, deviceAddress?: pulumi.Input<string>, key?: pulumi.Input<number>, path?: pulumi.Input<string> }>;
    /**
     * A unique identifier for a given version of the last
     * configuration applied, such the timestamp of the last update to the
     * configuration.
     */
    readonly changeVersion?: pulumi.Input<string>;
    /**
     * When specified, the VM will be created as a clone of a
     * specified template. Optional customization options can be submitted as well.
     * See creating a virtual machine from a
     * template for more details.
     */
    readonly clone?: pulumi.Input<{ customize?: pulumi.Input<{ dnsServerLists?: pulumi.Input<pulumi.Input<string>[]>, dnsSuffixLists?: pulumi.Input<pulumi.Input<string>[]>, ipv4Gateway?: pulumi.Input<string>, ipv6Gateway?: pulumi.Input<string>, linuxOptions?: pulumi.Input<{ domain: pulumi.Input<string>, hostName: pulumi.Input<string>, hwClockUtc?: pulumi.Input<boolean>, timeZone?: pulumi.Input<string> }>, networkInterfaces?: pulumi.Input<pulumi.Input<{ dnsDomain?: pulumi.Input<string>, dnsServerLists?: pulumi.Input<pulumi.Input<string>[]>, ipv4Address?: pulumi.Input<string>, ipv4Netmask?: pulumi.Input<number>, ipv6Address?: pulumi.Input<string>, ipv6Netmask?: pulumi.Input<number> }>[]>, timeout?: pulumi.Input<number>, windowsOptions?: pulumi.Input<{ adminPassword?: pulumi.Input<string>, autoLogon?: pulumi.Input<boolean>, autoLogonCount?: pulumi.Input<number>, computerName: pulumi.Input<string>, domainAdminPassword?: pulumi.Input<string>, domainAdminUser?: pulumi.Input<string>, fullName?: pulumi.Input<string>, joinDomain?: pulumi.Input<string>, organizationName?: pulumi.Input<string>, productKey?: pulumi.Input<string>, runOnceCommandLists?: pulumi.Input<pulumi.Input<string>[]>, timeZone?: pulumi.Input<number>, workgroup?: pulumi.Input<string> }>, windowsSysprepText?: pulumi.Input<string> }>, linkedClone?: pulumi.Input<boolean>, templateUuid: pulumi.Input<string>, timeout?: pulumi.Input<number> }>;
    /**
     * Allow CPUs to be added to this virtual
     * machine while it is running.
     */
    readonly cpuHotAddEnabled?: pulumi.Input<boolean>;
    /**
     * Allow CPUs to be removed to this
     * virtual machine while it is running.
     */
    readonly cpuHotRemoveEnabled?: pulumi.Input<boolean>;
    /**
     * The maximum amount of CPU (in MHz) that this virtual
     * machine can consume, regardless of available resources. The default is no
     * limit.
     */
    readonly cpuLimit?: pulumi.Input<number>;
    /**
     * Enable CPU performance
     * counters on this virtual machine. Default: `false`.
     */
    readonly cpuPerformanceCountersEnabled?: pulumi.Input<boolean>;
    /**
     * The amount of CPU (in MHz) that this virtual
     * machine is guaranteed. The default is no reservation.
     */
    readonly cpuReservation?: pulumi.Input<number>;
    /**
     * The number of CPU shares allocated to the
     * virtual machine when the `cpu_share_level` is `custom`.
     */
    readonly cpuShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for CPU resources. Can be
     * one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
     */
    readonly cpuShareLevel?: pulumi.Input<string>;
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for virtual machine. See
     * [here][docs-setting-custom-attributes] for a reference on how to set values
     * for custom attributes.
     */
    readonly customAttributes?: pulumi.Input<{[key: string]: any}>;
    /**
     * The [managed object reference
     * ID][docs-about-morefs] of the datastore cluster ID to use. This setting
     * applies to entire virtual machine and implies that you wish to use Storage
     * DRS with this virtual machine. See the section on virtual machine
     * migration for details on changing this value.
     */
    readonly datastoreClusterId?: pulumi.Input<string>;
    /**
     * The datastore ID that the ISO is located in.
     * Requried for using a datastore ISO. Conflicts with `client_device`.
     */
    readonly datastoreId?: pulumi.Input<string>;
    /**
     * The IP address selected by Terraform to be used with
     * any [provisioners][tf-docs-provisioners] configured on this resource.
     * Whenever possible, this is the first IPv4 address that is reachable through
     * the default gateway configured on the machine, then the first reachable IPv6
     * address, and then the first general discovered address if neither exist. If
     * VMware tools is not running on the virtual machine, or if the VM is powered
     * off, this value will be blank.
     */
    readonly defaultIpAddress?: pulumi.Input<string>;
    /**
     * A specification for a virtual disk device on this virtual
     * machine. See disk options below.
     */
    readonly disks?: pulumi.Input<pulumi.Input<{ attach?: pulumi.Input<boolean>, datastoreId?: pulumi.Input<string>, deviceAddress?: pulumi.Input<string>, diskMode?: pulumi.Input<string>, diskSharing?: pulumi.Input<string>, eagerlyScrub?: pulumi.Input<boolean>, ioLimit?: pulumi.Input<number>, ioReservation?: pulumi.Input<number>, ioShareCount?: pulumi.Input<number>, ioShareLevel?: pulumi.Input<string>, keepOnRemove?: pulumi.Input<boolean>, key?: pulumi.Input<number>, label?: pulumi.Input<string>, name?: pulumi.Input<string>, path?: pulumi.Input<string>, size?: pulumi.Input<number>, thinProvisioned?: pulumi.Input<boolean>, unitNumber?: pulumi.Input<number>, uuid?: pulumi.Input<string>, writeThrough?: pulumi.Input<boolean> }>[]>;
    /**
     * When the `firmware` type is set to is
     * `efi`, this enables EFI secure boot. Default: `false`.
     */
    readonly efiSecureBootEnabled?: pulumi.Input<boolean>;
    /**
     * Expose the UUIDs of attached virtual disks to
     * the virtual machine, allowing access to them in the guest. Default: `false`.
     */
    readonly enableDiskUuid?: pulumi.Input<boolean>;
    /**
     * Enable logging of virtual machine events to a
     * log file stored in the virtual machine directory. Default: `false`.
     */
    readonly enableLogging?: pulumi.Input<boolean>;
    /**
     * The EPT/RVI (hardware memory virtualization)
     * setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
     * Default: `automatic`.
     */
    readonly eptRviMode?: pulumi.Input<string>;
    /**
     * Extra configuration data for this virtual
     * machine. Can be used to supply advanced parameters not normally in
     * configuration, such as data for cloud-config (under the guestinfo namespace).
     */
    readonly extraConfig?: pulumi.Input<{[key: string]: any}>;
    /**
     * The firmware interface to use on the virtual machine.
     * Can be one of `bios` or `EFI`. Default: `bios`.
     */
    readonly firmware?: pulumi.Input<string>;
    /**
     * The path to the folder to put this virtual machine in,
     * relative to the datacenter that the resource pool is in.
     */
    readonly folder?: pulumi.Input<string>;
    /**
     * If a guest shutdown failed or timed out while
     * updating or destroying (see
     * `shutdown_wait_timeout`), force the power-off of
     * the virtual machine. Default: `true`.
     */
    readonly forcePowerOff?: pulumi.Input<boolean>;
    /**
     * The guest ID for the operating system type. For a
     * full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
     */
    readonly guestId?: pulumi.Input<string>;
    /**
     * The current list of IP addresses on this machine,
     * including the value of `default_ip_address`. If VMware tools is not running
     * on the virtual machine, or if the VM is powered off, this list will be empty.
     * * `moid`: The [managed object reference ID][docs-about-morefs] of the created
     * virtual machine.
     */
    readonly guestIpAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An optional [managed object reference
     * ID][docs-about-morefs] of a host to put this virtual machine on. See the
     * section on virtual machine migration for
     * details on changing this value. If a `host_system_id` is not supplied,
     * vSphere will select a host in the resource pool to place the virtual machine,
     * according to any defaults or DRS policies in place.
     */
    readonly hostSystemId?: pulumi.Input<string>;
    /**
     * The (non-nested) hardware virtualization setting for
     * this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
     * `hvAuto`.
     */
    readonly hvMode?: pulumi.Input<string>;
    /**
     * List of IP addresses to ignore while waiting
     * for an available IP address using either of the waiters. Any IP addresses in
     * this list will be ignored if they show up so that the waiter will continue to
     * wait for a real IP address. Default: [].
     */
    readonly ignoredGuestIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * This is flagged if the virtual machine has been imported, or the
     * state has been migrated from a previous version of the resource. It
     * influences the behavior of the first post-import apply operation. See the
     * section on importing below.
     */
    readonly imported?: pulumi.Input<boolean>;
    /**
     * Controls the scheduling delay of the
     * virtual machine. Use a higher sensitivity for applications that require lower
     * latency, such as VOIP, media player applications, or applications that
     * require frequent access to mouse or keyboard devices. Can be one of `low`,
     * `normal`, `medium`, or `high`.
     */
    readonly latencySensitivity?: pulumi.Input<string>;
    /**
     * The size of the virtual machine's memory, in MB.
     * Default: `1024` (1 GB).
     */
    readonly memory?: pulumi.Input<number>;
    /**
     * Allow memory to be added to this
     * virtual machine while it is running.
     */
    readonly memoryHotAddEnabled?: pulumi.Input<boolean>;
    /**
     * The maximum amount of memory (in MB) that this
     * virtual machine can consume, regardless of available resources. The default
     * is no limit.
     */
    readonly memoryLimit?: pulumi.Input<number>;
    /**
     * The amount of memory (in MB) that this
     * virtual machine is guaranteed. The default is no reservation.
     */
    readonly memoryReservation?: pulumi.Input<number>;
    /**
     * The number of memory shares allocated to
     * the virtual machine when the `memory_share_level` is `custom`.
     */
    readonly memoryShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for memory resources.
     * Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
     */
    readonly memoryShareLevel?: pulumi.Input<string>;
    /**
     * The amount of time, in minutes, to wait
     * for a virtual machine migration to complete before failing. Default: 10
     * minutes. Also see the section on virtual machine
     * migration.
     */
    readonly migrateWaitTimeout?: pulumi.Input<number>;
    /**
     * The machine object ID from VMWare
     */
    readonly moid?: pulumi.Input<string>;
    /**
     * An alias for both `label` and `path`, the latter when
     * using `attach`. Required if not using `label`.
     */
    readonly name?: pulumi.Input<string>;
    /**
     * Enable nested hardware virtualization on
     * this virtual machine, facilitating nested virtualization in the guest.
     * Default: `false`.
     */
    readonly nestedHvEnabled?: pulumi.Input<boolean>;
    /**
     * A specification for a virtual NIC on this
     * virtual machine. See network interface options
     * below.
     */
    readonly networkInterfaces?: pulumi.Input<pulumi.Input<{ adapterType?: pulumi.Input<string>, bandwidthLimit?: pulumi.Input<number>, bandwidthReservation?: pulumi.Input<number>, bandwidthShareCount?: pulumi.Input<number>, bandwidthShareLevel?: pulumi.Input<string>, deviceAddress?: pulumi.Input<string>, key?: pulumi.Input<number>, macAddress?: pulumi.Input<string>, networkId: pulumi.Input<string>, useStaticMac?: pulumi.Input<boolean> }>[]>;
    /**
     * The number of cores to distribute among
     * the CPUs in this virtual machine. If specified, the value supplied to
     * `num_cpus` must be evenly divisible by this value. Default: `1`.
     */
    readonly numCoresPerSocket?: pulumi.Input<number>;
    /**
     * The number of virtual processors to assign to this
     * virtual machine. Default: `1`.
     */
    readonly numCpus?: pulumi.Input<number>;
    /**
     * Value internal to Terraform used to determine if a
     * configuration set change requires a reboot. This value is only useful during
     * an update process and gets reset on refresh.
     */
    readonly rebootRequired?: pulumi.Input<boolean>;
    /**
     * The [managed object reference
     * ID][docs-about-morefs] of the resource pool to put this virtual machine in.
     * See the section on virtual machine migration
     * for details on changing this value.
     */
    readonly resourcePoolId?: pulumi.Input<string>;
    /**
     * Enable the execution of
     * post-power-on scripts when VMware tools is installed. Default: `true`.
     */
    readonly runToolsScriptsAfterPowerOn?: pulumi.Input<boolean>;
    /**
     * Enable the execution of
     * post-resume scripts when VMware tools is installed. Default: `true`.
     */
    readonly runToolsScriptsAfterResume?: pulumi.Input<boolean>;
    /**
     * Enable the execution of
     * pre-reboot scripts when VMware tools is installed. Default: `false`.
     */
    readonly runToolsScriptsBeforeGuestReboot?: pulumi.Input<boolean>;
    /**
     * Enable the execution
     * of pre-shutdown scripts when VMware tools is installed. Default: `true`.
     */
    readonly runToolsScriptsBeforeGuestShutdown?: pulumi.Input<boolean>;
    /**
     * Enable the execution of
     * pre-standby scripts when VMware tools is installed. Default: `true`.
     */
    readonly runToolsScriptsBeforeGuestStandby?: pulumi.Input<boolean>;
    /**
     * Mode for sharing the SCSI bus. The modes are
     * physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
     */
    readonly scsiBusSharing?: pulumi.Input<string>;
    /**
     * The number of SCSI controllers that
     * Terraform manages on this virtual machine. This directly affects the amount
     * of disks you can add to the virtual machine and the maximum disk unit number.
     * Note that lowering this value does not remove controllers. Default: `1`.
     */
    readonly scsiControllerCount?: pulumi.Input<number>;
    /**
     * The type of SCSI bus this virtual machine will have.
     * Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
     * pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
     */
    readonly scsiType?: pulumi.Input<string>;
    /**
     * The amount of time, in minutes, to wait
     * for a graceful guest shutdown when making necessary updates to the virtual
     * machine. If `force_power_off` is set to true, the VM will be force powered-off
     * after this timeout, otherwise an error is returned. Default: 3 minutes.
     */
    readonly shutdownWaitTimeout?: pulumi.Input<number>;
    /**
     * The swap file placement policy for this
     * virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
     * Default: `inherit`.
     */
    readonly swapPlacementPolicy?: pulumi.Input<string>;
    /**
     * Enable guest clock synchronization with
     * the host. Requires VMware tools to be installed. Default: `false`.
     */
    readonly syncTimeWithHost?: pulumi.Input<boolean>;
    /**
     * The IDs of any tags to attach to this resource. See
     * [here][docs-applying-tags] for a reference on how to apply tags.
     */
    readonly tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The UUID of the virtual disk's VMDK file. This is used to track the
     * virtual disk on the virtual machine.
     */
    readonly uuid?: pulumi.Input<string>;
    /**
     * Optional vApp configuration. The only sub-key available
     * is `properties`, which is a key/value map of properties for virtual machines
     * imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
     * configuration for
     * more details.
     */
    readonly vapp?: pulumi.Input<{ properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}> }>;
    /**
     * Computed value which is only valid for cloned virtual
     * machines. A list of vApp transport methods supported by the source virtual
     * machine or template.
     */
    readonly vappTransports?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The state of VMware tools in the guest. This will
     * determine the proper course of action for some device operations.
     */
    readonly vmwareToolsStatus?: pulumi.Input<string>;
    /**
     * The path of the virtual machine's configuration file in the VM's
     * datastore.
     */
    readonly vmxPath?: pulumi.Input<string>;
    /**
     * The amount of time, in minutes, to
     * wait for an available guest IP address on this virtual machine. This should
     * only be used if your version of VMware Tools does not allow the
     * `wait_for_guest_net_timeout` waiter to be
     * used. A value less than 1 disables the waiter. Default: 0.
     */
    readonly waitForGuestIpTimeout?: pulumi.Input<number>;
    /**
     * Controls whether or not the guest
     * network waiter waits for a routable address. When `false`, the waiter does
     * not wait for a default gateway, nor are IP addresses checked against any
     * discovered default gateways as part of its success criteria. This property is
     * ignored if the `wait_for_guest_ip_timeout`
     * waiter is used. Default: `true`.
     */
    readonly waitForGuestNetRoutable?: pulumi.Input<boolean>;
    /**
     * The amount of time, in minutes, to
     * wait for an available IP address on this virtual machine's NICs. Older
     * versions of VMware Tools do not populate this property. In those cases, this
     * waiter can be disabled and the
     * `wait_for_guest_ip_timeout` waiter can be used
     * instead. A value less than 1 disables the waiter. Default: 5 minutes.
     */
    readonly waitForGuestNetTimeout?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a VirtualMachine resource.
 */
export interface VirtualMachineArgs {
    /**
     * The guest name for the operating system
     * when `guest_id` is `other` or `other-64`.
     */
    readonly alternateGuestName?: pulumi.Input<string>;
    /**
     * A user-provided description of the virtual machine.
     * The default is no annotation.
     */
    readonly annotation?: pulumi.Input<string>;
    /**
     * The number of milliseconds to wait before starting
     * the boot sequence. The default is no delay.
     */
    readonly bootDelay?: pulumi.Input<number>;
    /**
     * The number of milliseconds to wait before
     * retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
     * Default: `10000` (10 seconds).
     */
    readonly bootRetryDelay?: pulumi.Input<number>;
    /**
     * If set to true, a virtual machine that
     * fails to boot will try again after the delay defined in `boot_retry_delay`.
     * Default: `false`.
     */
    readonly bootRetryEnabled?: pulumi.Input<boolean>;
    /**
     * A specification for a CDROM device on this virtual
     * machine. See CDROM options below.
     */
    readonly cdrom?: pulumi.Input<{ clientDevice?: pulumi.Input<boolean>, datastoreId?: pulumi.Input<string>, deviceAddress?: pulumi.Input<string>, key?: pulumi.Input<number>, path?: pulumi.Input<string> }>;
    /**
     * When specified, the VM will be created as a clone of a
     * specified template. Optional customization options can be submitted as well.
     * See creating a virtual machine from a
     * template for more details.
     */
    readonly clone?: pulumi.Input<{ customize?: pulumi.Input<{ dnsServerLists?: pulumi.Input<pulumi.Input<string>[]>, dnsSuffixLists?: pulumi.Input<pulumi.Input<string>[]>, ipv4Gateway?: pulumi.Input<string>, ipv6Gateway?: pulumi.Input<string>, linuxOptions?: pulumi.Input<{ domain: pulumi.Input<string>, hostName: pulumi.Input<string>, hwClockUtc?: pulumi.Input<boolean>, timeZone?: pulumi.Input<string> }>, networkInterfaces?: pulumi.Input<pulumi.Input<{ dnsDomain?: pulumi.Input<string>, dnsServerLists?: pulumi.Input<pulumi.Input<string>[]>, ipv4Address?: pulumi.Input<string>, ipv4Netmask?: pulumi.Input<number>, ipv6Address?: pulumi.Input<string>, ipv6Netmask?: pulumi.Input<number> }>[]>, timeout?: pulumi.Input<number>, windowsOptions?: pulumi.Input<{ adminPassword?: pulumi.Input<string>, autoLogon?: pulumi.Input<boolean>, autoLogonCount?: pulumi.Input<number>, computerName: pulumi.Input<string>, domainAdminPassword?: pulumi.Input<string>, domainAdminUser?: pulumi.Input<string>, fullName?: pulumi.Input<string>, joinDomain?: pulumi.Input<string>, organizationName?: pulumi.Input<string>, productKey?: pulumi.Input<string>, runOnceCommandLists?: pulumi.Input<pulumi.Input<string>[]>, timeZone?: pulumi.Input<number>, workgroup?: pulumi.Input<string> }>, windowsSysprepText?: pulumi.Input<string> }>, linkedClone?: pulumi.Input<boolean>, templateUuid: pulumi.Input<string>, timeout?: pulumi.Input<number> }>;
    /**
     * Allow CPUs to be added to this virtual
     * machine while it is running.
     */
    readonly cpuHotAddEnabled?: pulumi.Input<boolean>;
    /**
     * Allow CPUs to be removed to this
     * virtual machine while it is running.
     */
    readonly cpuHotRemoveEnabled?: pulumi.Input<boolean>;
    /**
     * The maximum amount of CPU (in MHz) that this virtual
     * machine can consume, regardless of available resources. The default is no
     * limit.
     */
    readonly cpuLimit?: pulumi.Input<number>;
    /**
     * Enable CPU performance
     * counters on this virtual machine. Default: `false`.
     */
    readonly cpuPerformanceCountersEnabled?: pulumi.Input<boolean>;
    /**
     * The amount of CPU (in MHz) that this virtual
     * machine is guaranteed. The default is no reservation.
     */
    readonly cpuReservation?: pulumi.Input<number>;
    /**
     * The number of CPU shares allocated to the
     * virtual machine when the `cpu_share_level` is `custom`.
     */
    readonly cpuShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for CPU resources. Can be
     * one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
     */
    readonly cpuShareLevel?: pulumi.Input<string>;
    /**
     * Map of custom attribute ids to attribute
     * value strings to set for virtual machine. See
     * [here][docs-setting-custom-attributes] for a reference on how to set values
     * for custom attributes.
     */
    readonly customAttributes?: pulumi.Input<{[key: string]: any}>;
    /**
     * The [managed object reference
     * ID][docs-about-morefs] of the datastore cluster ID to use. This setting
     * applies to entire virtual machine and implies that you wish to use Storage
     * DRS with this virtual machine. See the section on virtual machine
     * migration for details on changing this value.
     */
    readonly datastoreClusterId?: pulumi.Input<string>;
    /**
     * The datastore ID that the ISO is located in.
     * Requried for using a datastore ISO. Conflicts with `client_device`.
     */
    readonly datastoreId?: pulumi.Input<string>;
    /**
     * A specification for a virtual disk device on this virtual
     * machine. See disk options below.
     */
    readonly disks?: pulumi.Input<pulumi.Input<{ attach?: pulumi.Input<boolean>, datastoreId?: pulumi.Input<string>, deviceAddress?: pulumi.Input<string>, diskMode?: pulumi.Input<string>, diskSharing?: pulumi.Input<string>, eagerlyScrub?: pulumi.Input<boolean>, ioLimit?: pulumi.Input<number>, ioReservation?: pulumi.Input<number>, ioShareCount?: pulumi.Input<number>, ioShareLevel?: pulumi.Input<string>, keepOnRemove?: pulumi.Input<boolean>, key?: pulumi.Input<number>, label?: pulumi.Input<string>, name?: pulumi.Input<string>, path?: pulumi.Input<string>, size?: pulumi.Input<number>, thinProvisioned?: pulumi.Input<boolean>, unitNumber?: pulumi.Input<number>, uuid?: pulumi.Input<string>, writeThrough?: pulumi.Input<boolean> }>[]>;
    /**
     * When the `firmware` type is set to is
     * `efi`, this enables EFI secure boot. Default: `false`.
     */
    readonly efiSecureBootEnabled?: pulumi.Input<boolean>;
    /**
     * Expose the UUIDs of attached virtual disks to
     * the virtual machine, allowing access to them in the guest. Default: `false`.
     */
    readonly enableDiskUuid?: pulumi.Input<boolean>;
    /**
     * Enable logging of virtual machine events to a
     * log file stored in the virtual machine directory. Default: `false`.
     */
    readonly enableLogging?: pulumi.Input<boolean>;
    /**
     * The EPT/RVI (hardware memory virtualization)
     * setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
     * Default: `automatic`.
     */
    readonly eptRviMode?: pulumi.Input<string>;
    /**
     * Extra configuration data for this virtual
     * machine. Can be used to supply advanced parameters not normally in
     * configuration, such as data for cloud-config (under the guestinfo namespace).
     */
    readonly extraConfig?: pulumi.Input<{[key: string]: any}>;
    /**
     * The firmware interface to use on the virtual machine.
     * Can be one of `bios` or `EFI`. Default: `bios`.
     */
    readonly firmware?: pulumi.Input<string>;
    /**
     * The path to the folder to put this virtual machine in,
     * relative to the datacenter that the resource pool is in.
     */
    readonly folder?: pulumi.Input<string>;
    /**
     * If a guest shutdown failed or timed out while
     * updating or destroying (see
     * `shutdown_wait_timeout`), force the power-off of
     * the virtual machine. Default: `true`.
     */
    readonly forcePowerOff?: pulumi.Input<boolean>;
    /**
     * The guest ID for the operating system type. For a
     * full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
     */
    readonly guestId?: pulumi.Input<string>;
    /**
     * An optional [managed object reference
     * ID][docs-about-morefs] of a host to put this virtual machine on. See the
     * section on virtual machine migration for
     * details on changing this value. If a `host_system_id` is not supplied,
     * vSphere will select a host in the resource pool to place the virtual machine,
     * according to any defaults or DRS policies in place.
     */
    readonly hostSystemId?: pulumi.Input<string>;
    /**
     * The (non-nested) hardware virtualization setting for
     * this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
     * `hvAuto`.
     */
    readonly hvMode?: pulumi.Input<string>;
    /**
     * List of IP addresses to ignore while waiting
     * for an available IP address using either of the waiters. Any IP addresses in
     * this list will be ignored if they show up so that the waiter will continue to
     * wait for a real IP address. Default: [].
     */
    readonly ignoredGuestIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Controls the scheduling delay of the
     * virtual machine. Use a higher sensitivity for applications that require lower
     * latency, such as VOIP, media player applications, or applications that
     * require frequent access to mouse or keyboard devices. Can be one of `low`,
     * `normal`, `medium`, or `high`.
     */
    readonly latencySensitivity?: pulumi.Input<string>;
    /**
     * The size of the virtual machine's memory, in MB.
     * Default: `1024` (1 GB).
     */
    readonly memory?: pulumi.Input<number>;
    /**
     * Allow memory to be added to this
     * virtual machine while it is running.
     */
    readonly memoryHotAddEnabled?: pulumi.Input<boolean>;
    /**
     * The maximum amount of memory (in MB) that this
     * virtual machine can consume, regardless of available resources. The default
     * is no limit.
     */
    readonly memoryLimit?: pulumi.Input<number>;
    /**
     * The amount of memory (in MB) that this
     * virtual machine is guaranteed. The default is no reservation.
     */
    readonly memoryReservation?: pulumi.Input<number>;
    /**
     * The number of memory shares allocated to
     * the virtual machine when the `memory_share_level` is `custom`.
     */
    readonly memoryShareCount?: pulumi.Input<number>;
    /**
     * The allocation level for memory resources.
     * Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
     */
    readonly memoryShareLevel?: pulumi.Input<string>;
    /**
     * The amount of time, in minutes, to wait
     * for a virtual machine migration to complete before failing. Default: 10
     * minutes. Also see the section on virtual machine
     * migration.
     */
    readonly migrateWaitTimeout?: pulumi.Input<number>;
    /**
     * An alias for both `label` and `path`, the latter when
     * using `attach`. Required if not using `label`.
     */
    readonly name?: pulumi.Input<string>;
    /**
     * Enable nested hardware virtualization on
     * this virtual machine, facilitating nested virtualization in the guest.
     * Default: `false`.
     */
    readonly nestedHvEnabled?: pulumi.Input<boolean>;
    /**
     * A specification for a virtual NIC on this
     * virtual machine. See network interface options
     * below.
     */
    readonly networkInterfaces: pulumi.Input<pulumi.Input<{ adapterType?: pulumi.Input<string>, bandwidthLimit?: pulumi.Input<number>, bandwidthReservation?: pulumi.Input<number>, bandwidthShareCount?: pulumi.Input<number>, bandwidthShareLevel?: pulumi.Input<string>, deviceAddress?: pulumi.Input<string>, key?: pulumi.Input<number>, macAddress?: pulumi.Input<string>, networkId: pulumi.Input<string>, useStaticMac?: pulumi.Input<boolean> }>[]>;
    /**
     * The number of cores to distribute among
     * the CPUs in this virtual machine. If specified, the value supplied to
     * `num_cpus` must be evenly divisible by this value. Default: `1`.
     */
    readonly numCoresPerSocket?: pulumi.Input<number>;
    /**
     * The number of virtual processors to assign to this
     * virtual machine. Default: `1`.
     */
    readonly numCpus?: pulumi.Input<number>;
    /**
     * The [managed object reference
     * ID][docs-about-morefs] of the resource pool to put this virtual machine in.
     * See the section on virtual machine migration
     * for details on changing this value.
     */
    readonly resourcePoolId: pulumi.Input<string>;
    /**
     * Enable the execution of
     * post-power-on scripts when VMware tools is installed. Default: `true`.
     */
    readonly runToolsScriptsAfterPowerOn?: pulumi.Input<boolean>;
    /**
     * Enable the execution of
     * post-resume scripts when VMware tools is installed. Default: `true`.
     */
    readonly runToolsScriptsAfterResume?: pulumi.Input<boolean>;
    /**
     * Enable the execution of
     * pre-reboot scripts when VMware tools is installed. Default: `false`.
     */
    readonly runToolsScriptsBeforeGuestReboot?: pulumi.Input<boolean>;
    /**
     * Enable the execution
     * of pre-shutdown scripts when VMware tools is installed. Default: `true`.
     */
    readonly runToolsScriptsBeforeGuestShutdown?: pulumi.Input<boolean>;
    /**
     * Enable the execution of
     * pre-standby scripts when VMware tools is installed. Default: `true`.
     */
    readonly runToolsScriptsBeforeGuestStandby?: pulumi.Input<boolean>;
    /**
     * Mode for sharing the SCSI bus. The modes are
     * physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
     */
    readonly scsiBusSharing?: pulumi.Input<string>;
    /**
     * The number of SCSI controllers that
     * Terraform manages on this virtual machine. This directly affects the amount
     * of disks you can add to the virtual machine and the maximum disk unit number.
     * Note that lowering this value does not remove controllers. Default: `1`.
     */
    readonly scsiControllerCount?: pulumi.Input<number>;
    /**
     * The type of SCSI bus this virtual machine will have.
     * Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
     * pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
     */
    readonly scsiType?: pulumi.Input<string>;
    /**
     * The amount of time, in minutes, to wait
     * for a graceful guest shutdown when making necessary updates to the virtual
     * machine. If `force_power_off` is set to true, the VM will be force powered-off
     * after this timeout, otherwise an error is returned. Default: 3 minutes.
     */
    readonly shutdownWaitTimeout?: pulumi.Input<number>;
    /**
     * The swap file placement policy for this
     * virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
     * Default: `inherit`.
     */
    readonly swapPlacementPolicy?: pulumi.Input<string>;
    /**
     * Enable guest clock synchronization with
     * the host. Requires VMware tools to be installed. Default: `false`.
     */
    readonly syncTimeWithHost?: pulumi.Input<boolean>;
    /**
     * The IDs of any tags to attach to this resource. See
     * [here][docs-applying-tags] for a reference on how to apply tags.
     */
    readonly tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Optional vApp configuration. The only sub-key available
     * is `properties`, which is a key/value map of properties for virtual machines
     * imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
     * configuration for
     * more details.
     */
    readonly vapp?: pulumi.Input<{ properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}> }>;
    /**
     * The amount of time, in minutes, to
     * wait for an available guest IP address on this virtual machine. This should
     * only be used if your version of VMware Tools does not allow the
     * `wait_for_guest_net_timeout` waiter to be
     * used. A value less than 1 disables the waiter. Default: 0.
     */
    readonly waitForGuestIpTimeout?: pulumi.Input<number>;
    /**
     * Controls whether or not the guest
     * network waiter waits for a routable address. When `false`, the waiter does
     * not wait for a default gateway, nor are IP addresses checked against any
     * discovered default gateways as part of its success criteria. This property is
     * ignored if the `wait_for_guest_ip_timeout`
     * waiter is used. Default: `true`.
     */
    readonly waitForGuestNetRoutable?: pulumi.Input<boolean>;
    /**
     * The amount of time, in minutes, to
     * wait for an available IP address on this virtual machine's NICs. Older
     * versions of VMware Tools do not populate this property. In those cases, this
     * waiter can be disabled and the
     * `wait_for_guest_ip_timeout` waiter can be used
     * instead. A value less than 1 disables the waiter. Default: 5 minutes.
     */
    readonly waitForGuestNetTimeout?: pulumi.Input<number>;
}
