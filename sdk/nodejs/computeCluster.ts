// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * ## Example Usage
 *
 * The following example sets up a cluster and enables DRS and vSphere HA with the
 * default settings. The hosts have to exist already in vSphere and should not
 * already be members of clusters - it's best to add these as standalone hosts
 * before adding them to a cluster.
 *
 * Note that the following example assumes each host has been configured correctly
 * according to the requirements of vSphere HA. For more information, click
 * [here][ref-vsphere-ha-checklist].
 *
 * [ref-vsphere-ha-checklist]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-availability.html
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as std from "@pulumi/std";
 * import * as vsphere from "@pulumi/vsphere";
 *
 * const config = new pulumi.Config();
 * const datacenter = config.get("datacenter") || "dc-01";
 * const hosts = config.getObject<any>("hosts") || [
 *     "esxi-01.example.com",
 *     "esxi-02.example.com",
 *     "esxi-03.example.com",
 * ];
 * const datacenterGetDatacenter = vsphere.getDatacenter({
 *     name: datacenter,
 * });
 * const host = .reduce((__obj, [__key, __value]) => ({ ...__obj, [__key]: vsphere.getHost({
 *     name: __value,
 *     datacenterId: _arg0_.id,
 * }) }));
 * const computeCluster = new vsphere.ComputeCluster("compute_cluster", {
 *     name: "pulumi-compute-cluster-test",
 *     datacenterId: datacenterGetDatacenter.then(datacenterGetDatacenter => datacenterGetDatacenter.id),
 *     hostSystemIds: Object.values(host).map(host => (host.id)),
 *     drsEnabled: true,
 *     drsAutomationLevel: "fullyAutomated",
 *     haEnabled: true,
 * });
 * ```
 *
 * ## vSphere Version Requirements
 *
 * Some settings in the `vsphere.ComputeCluster` resource may require a
 * specific version of vSphere.
 *
 * ### Settings that Require vSphere 7.0 or higher
 *
 * These settings require vSphere 7.0 or higher:
 *
 * * `drsScaleDescendantsShares`
 *
 * ### Settings that Require vSphere 8.0 or higher
 *
 * These settings require vSphere 8.0 or higher:
 *
 * * `vsanEsaEnabled`
 *
 * ## Import
 *
 * An existing cluster can be imported into this resource via the
 *
 * path to the cluster, via the following command:
 *
 * [docs-import]: https://developer.hashicorp.com/terraform/cli/import
 *
 * hcl
 *
 * variable "datacenter" {
 *
 *   default = "dc-01"
 *
 * }
 *
 * data "vsphere_datacenter" "datacenter" {
 *
 *   name = var.datacenter
 *
 * }
 *
 * resource "vsphere_compute_cluster" "compute_cluster" {
 *
 *   name          = "cluster-01"
 *
 *   datacenter_id = data.vsphere_datacenter.datacenter.id
 *
 * }
 *
 * hcl
 *
 * resource "vsphere_compute_cluster" "compute_cluster" {
 *
 *   name                      = "cluster-01"
 *
 *   datacenter_id             = data.vsphere_datacenter.datacenter.id
 *
 *   vsan_enabled              = true
 *
 *   vsan_performance_enabled  = true
 *
 *   host_system_ids           = [for host in data.vsphere_host.host : host.id]
 *
 *   dpm_automation_level      = "automated"
 *
 *   drs_automation_level      = "fullyAutomated"
 *
 *   drs_enabled               = true
 *
 *   ha_datastore_apd_response = "restartConservative"
 *
 *   ha_datastore_pdl_response = "restartAggressive"
 *
 * }
 *
 * ```sh
 * $ pulumi import vsphere:index/computeCluster:ComputeCluster compute_cluster /dc-01/host/cluster-01
 * ```
 *
 * The above would import the cluster named `cluster-01` that is located in
 *
 * the `dc-01` datacenter.
 */
export class ComputeCluster extends pulumi.CustomResource {
    /**
     * Get an existing ComputeCluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ComputeClusterState, opts?: pulumi.CustomResourceOptions): ComputeCluster {
        return new ComputeCluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'vsphere:index/computeCluster:ComputeCluster';

    /**
     * Returns true if the given object is an instance of ComputeCluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ComputeCluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ComputeCluster.__pulumiType;
    }

    /**
     * A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster. See
     * [here][docs-setting-custom-attributes] for a reference on how to set values
     * for custom attributes.
     *
     * [docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource
     *
     * > **NOTE:** Custom attributes are not supported on direct ESXi host
     * connections and requires vCenter Server.
     */
    declare public readonly customAttributes: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The [managed object ID][docs-about-morefs] of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     */
    declare public readonly datacenterId: pulumi.Output<string>;
    /**
     * The automation level for host power operations in this cluster. Can be one of manual or automated.
     */
    declare public readonly dpmAutomationLevel: pulumi.Output<string | undefined>;
    /**
     * Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual machines in the cluster. Requires that DRS be enabled.
     */
    declare public readonly dpmEnabled: pulumi.Output<boolean | undefined>;
    /**
     * A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher setting.
     */
    declare public readonly dpmThreshold: pulumi.Output<number | undefined>;
    /**
     * Advanced configuration options for DRS and DPM.
     */
    declare public readonly drsAdvancedOptions: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or fullyAutomated.
     */
    declare public readonly drsAutomationLevel: pulumi.Output<string | undefined>;
    /**
     * When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     */
    declare public readonly drsEnablePredictiveDrs: pulumi.Output<boolean | undefined>;
    /**
     * When true, allows individual VM overrides within this cluster to be set.
     */
    declare public readonly drsEnableVmOverrides: pulumi.Output<boolean | undefined>;
    /**
     * Enable DRS for this cluster.
     */
    declare public readonly drsEnabled: pulumi.Output<boolean | undefined>;
    /**
     * A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate more imbalance while a higher setting will tolerate less.
     */
    declare public readonly drsMigrationThreshold: pulumi.Output<number | undefined>;
    /**
     * Enable scalable shares for all descendants of this cluster.
     */
    declare public readonly drsScaleDescendantsShares: pulumi.Output<string | undefined>;
    /**
     * The name of the folder to locate the cluster in.
     */
    declare public readonly folder: pulumi.Output<string | undefined>;
    /**
     * Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists for testing and is not recommended in normal use.
     */
    declare public readonly forceEvacuateOnDestroy: pulumi.Output<boolean | undefined>;
    /**
     * When haAdmissionControlPolicy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS will ignore the host when making recommendations.
     */
    declare public readonly haAdmissionControlFailoverHostSystemIds: pulumi.Output<string[] | undefined>;
    /**
     * The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual machine operations. The maximum is one less than the number of hosts in the cluster.
     */
    declare public readonly haAdmissionControlHostFailureTolerance: pulumi.Output<number | undefined>;
    /**
     * The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces warnings only, whereas a value of 100 disables the setting.
     */
    declare public readonly haAdmissionControlPerformanceTolerance: pulumi.Output<number | undefined>;
    /**
     * The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage, slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service issues.
     */
    declare public readonly haAdmissionControlPolicy: pulumi.Output<string | undefined>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, automatically determine available resource percentages by subtracting the average number of host resources represented by the haAdmissionControlHostFailureTolerance setting from the total amount of resources in the cluster. Disable to supply user-defined values.
     */
    declare public readonly haAdmissionControlResourcePercentageAutoCompute: pulumi.Output<boolean | undefined>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of CPU resources in the cluster to reserve for failover.
     */
    declare public readonly haAdmissionControlResourcePercentageCpu: pulumi.Output<number | undefined>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of memory resources in the cluster to reserve for failover.
     */
    declare public readonly haAdmissionControlResourcePercentageMemory: pulumi.Output<number | undefined>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     */
    declare public readonly haAdmissionControlSlotPolicyExplicitCpu: pulumi.Output<number | undefined>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined memory slot size, in MB.
     */
    declare public readonly haAdmissionControlSlotPolicyExplicitMemory: pulumi.Output<number | undefined>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this setting controls whether or not you wish to supply explicit values to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines currently in the cluster.
     */
    declare public readonly haAdmissionControlSlotPolicyUseExplicitSize: pulumi.Output<boolean | undefined>;
    /**
     * Advanced configuration options for vSphere HA.
     */
    declare public readonly haAdvancedOptions: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines if an APD status on an affected datastore clears in the middle of an APD event. Can be one of none or reset.
     */
    declare public readonly haDatastoreApdRecoveryAction: pulumi.Output<string | undefined>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
     */
    declare public readonly haDatastoreApdResponse: pulumi.Output<string | undefined>;
    /**
     * When haVmComponentProtection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the response action defined in ha_datastore_apd_response.
     */
    declare public readonly haDatastoreApdResponseDelay: pulumi.Output<number | undefined>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     */
    declare public readonly haDatastorePdlResponse: pulumi.Output<string | undefined>;
    /**
     * Enable vSphere HA for this cluster.
     */
    declare public readonly haEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when haHeartbeatDatastorePolicy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     */
    declare public readonly haHeartbeatDatastoreIds: pulumi.Output<string[] | undefined>;
    /**
     * The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference.
     */
    declare public readonly haHeartbeatDatastorePolicy: pulumi.Output<string | undefined>;
    /**
     * The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster. Can be one of none, powerOff, or shutdown.
     */
    declare public readonly haHostIsolationResponse: pulumi.Output<string | undefined>;
    /**
     * Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     */
    declare public readonly haHostMonitoring: pulumi.Output<string | undefined>;
    /**
     * Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     */
    declare public readonly haVmComponentProtection: pulumi.Output<string | undefined>;
    /**
     * The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     */
    declare public readonly haVmDependencyRestartCondition: pulumi.Output<string | undefined>;
    /**
     * If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as failed. The value is in seconds.
     */
    declare public readonly haVmFailureInterval: pulumi.Output<number | undefined>;
    /**
     * The length of the reset window in which haVmMaximumResets can operate. When this window expires, no more resets are attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset time is allotted.
     */
    declare public readonly haVmMaximumFailureWindow: pulumi.Output<number | undefined>;
    /**
     * The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     */
    declare public readonly haVmMaximumResets: pulumi.Output<number | undefined>;
    /**
     * The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     */
    declare public readonly haVmMinimumUptime: pulumi.Output<number | undefined>;
    /**
     * The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring.
     */
    declare public readonly haVmMonitoring: pulumi.Output<string | undefined>;
    /**
     * Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     */
    declare public readonly haVmRestartAdditionalDelay: pulumi.Output<number | undefined>;
    /**
     * The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium, high, or highest.
     */
    declare public readonly haVmRestartPriority: pulumi.Output<string | undefined>;
    /**
     * The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before proceeding with the next priority.
     */
    declare public readonly haVmRestartTimeout: pulumi.Output<number | undefined>;
    /**
     * The timeout for each host maintenance mode operation when removing hosts from a cluster.
     */
    declare public readonly hostClusterExitTimeout: pulumi.Output<number | undefined>;
    /**
     * Details about the host image which should be applied to the cluster.
     */
    declare public readonly hostImage: pulumi.Output<outputs.ComputeClusterHostImage | undefined>;
    /**
     * Must be set if cluster enrollment is managed from host resource.
     */
    declare public readonly hostManaged: pulumi.Output<boolean | undefined>;
    /**
     * The managed object IDs of the hosts to put in the cluster.
     */
    declare public readonly hostSystemIds: pulumi.Output<string[] | undefined>;
    /**
     * The name of the cluster.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     */
    declare public readonly proactiveHaAutomationLevel: pulumi.Output<string | undefined>;
    /**
     * Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     */
    declare public readonly proactiveHaEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to MaintenanceMode when proactiveHaSevereRemediation is set to QuarantineMode.
     */
    declare public readonly proactiveHaModerateRemediation: pulumi.Output<string | undefined>;
    /**
     * The list of IDs for health update providers configured for this cluster.
     */
    declare public readonly proactiveHaProviderIds: pulumi.Output<string[] | undefined>;
    /**
     * The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to QuarantineMode when proactiveHaModerateRemediation is set to MaintenanceMode.
     */
    declare public readonly proactiveHaSevereRemediation: pulumi.Output<string | undefined>;
    /**
     * The [managed object ID][docs-about-morefs] of the primary
     * resource pool for this cluster. This can be passed directly to the
     * [`resourcePoolId`
     * attribute][docs-r-vsphere-virtual-machine-resource-pool-id] of the
     * [`vsphere.VirtualMachine`][docs-r-vsphere-virtual-machine] resource.
     */
    declare public /*out*/ readonly resourcePoolId: pulumi.Output<string>;
    /**
     * The IDs of any tags to attach to this resource. See
     * [here][docs-applying-tags] for a reference on how to apply tags.
     *
     * [docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider
     * [docs-applying-tags]: /docs/providers/vsphere/r/tag.html#using-tags-in-a-supported-resource
     */
    declare public readonly tags: pulumi.Output<string[] | undefined>;
    /**
     * Whether the vSAN compression service is enabled for the cluster.
     */
    declare public readonly vsanCompressionEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Whether the vSAN deduplication service is enabled for the cluster.
     */
    declare public readonly vsanDedupEnabled: pulumi.Output<boolean | undefined>;
    /**
     * A list of disk UUIDs to add to the vSAN cluster.
     */
    declare public readonly vsanDiskGroups: pulumi.Output<outputs.ComputeClusterVsanDiskGroup[]>;
    /**
     * Whether the vSAN data-in-transit encryption is enabled for the cluster.
     */
    declare public readonly vsanDitEncryptionEnabled: pulumi.Output<boolean | undefined>;
    /**
     * When vsanDitEncryptionEnabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     */
    declare public readonly vsanDitRekeyInterval: pulumi.Output<number>;
    /**
     * Whether the vSAN service is enabled for the cluster.
     */
    declare public readonly vsanEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Whether the vSAN ESA service is enabled for the cluster.
     */
    declare public readonly vsanEsaEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The configuration for vSAN fault domains.
     */
    declare public readonly vsanFaultDomains: pulumi.Output<outputs.ComputeClusterVsanFaultDomain[] | undefined>;
    /**
     * Whether the vSAN network diagnostic mode is enabled for the cluster.
     */
    declare public readonly vsanNetworkDiagnosticModeEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Whether the vSAN performance service is enabled for the cluster.
     */
    declare public readonly vsanPerformanceEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The managed object IDs of the vSAN datastore to be mounted on the cluster.
     */
    declare public readonly vsanRemoteDatastoreIds: pulumi.Output<string[] | undefined>;
    /**
     * The configuration for stretched cluster.
     */
    declare public readonly vsanStretchedCluster: pulumi.Output<outputs.ComputeClusterVsanStretchedCluster | undefined>;
    /**
     * Whether the vSAN unmap service is enabled for the cluster.
     */
    declare public readonly vsanUnmapEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Whether the vSAN verbose mode is enabled for the cluster.
     */
    declare public readonly vsanVerboseModeEnabled: pulumi.Output<boolean | undefined>;

    /**
     * Create a ComputeCluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ComputeClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ComputeClusterArgs | ComputeClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ComputeClusterState | undefined;
            resourceInputs["customAttributes"] = state?.customAttributes;
            resourceInputs["datacenterId"] = state?.datacenterId;
            resourceInputs["dpmAutomationLevel"] = state?.dpmAutomationLevel;
            resourceInputs["dpmEnabled"] = state?.dpmEnabled;
            resourceInputs["dpmThreshold"] = state?.dpmThreshold;
            resourceInputs["drsAdvancedOptions"] = state?.drsAdvancedOptions;
            resourceInputs["drsAutomationLevel"] = state?.drsAutomationLevel;
            resourceInputs["drsEnablePredictiveDrs"] = state?.drsEnablePredictiveDrs;
            resourceInputs["drsEnableVmOverrides"] = state?.drsEnableVmOverrides;
            resourceInputs["drsEnabled"] = state?.drsEnabled;
            resourceInputs["drsMigrationThreshold"] = state?.drsMigrationThreshold;
            resourceInputs["drsScaleDescendantsShares"] = state?.drsScaleDescendantsShares;
            resourceInputs["folder"] = state?.folder;
            resourceInputs["forceEvacuateOnDestroy"] = state?.forceEvacuateOnDestroy;
            resourceInputs["haAdmissionControlFailoverHostSystemIds"] = state?.haAdmissionControlFailoverHostSystemIds;
            resourceInputs["haAdmissionControlHostFailureTolerance"] = state?.haAdmissionControlHostFailureTolerance;
            resourceInputs["haAdmissionControlPerformanceTolerance"] = state?.haAdmissionControlPerformanceTolerance;
            resourceInputs["haAdmissionControlPolicy"] = state?.haAdmissionControlPolicy;
            resourceInputs["haAdmissionControlResourcePercentageAutoCompute"] = state?.haAdmissionControlResourcePercentageAutoCompute;
            resourceInputs["haAdmissionControlResourcePercentageCpu"] = state?.haAdmissionControlResourcePercentageCpu;
            resourceInputs["haAdmissionControlResourcePercentageMemory"] = state?.haAdmissionControlResourcePercentageMemory;
            resourceInputs["haAdmissionControlSlotPolicyExplicitCpu"] = state?.haAdmissionControlSlotPolicyExplicitCpu;
            resourceInputs["haAdmissionControlSlotPolicyExplicitMemory"] = state?.haAdmissionControlSlotPolicyExplicitMemory;
            resourceInputs["haAdmissionControlSlotPolicyUseExplicitSize"] = state?.haAdmissionControlSlotPolicyUseExplicitSize;
            resourceInputs["haAdvancedOptions"] = state?.haAdvancedOptions;
            resourceInputs["haDatastoreApdRecoveryAction"] = state?.haDatastoreApdRecoveryAction;
            resourceInputs["haDatastoreApdResponse"] = state?.haDatastoreApdResponse;
            resourceInputs["haDatastoreApdResponseDelay"] = state?.haDatastoreApdResponseDelay;
            resourceInputs["haDatastorePdlResponse"] = state?.haDatastorePdlResponse;
            resourceInputs["haEnabled"] = state?.haEnabled;
            resourceInputs["haHeartbeatDatastoreIds"] = state?.haHeartbeatDatastoreIds;
            resourceInputs["haHeartbeatDatastorePolicy"] = state?.haHeartbeatDatastorePolicy;
            resourceInputs["haHostIsolationResponse"] = state?.haHostIsolationResponse;
            resourceInputs["haHostMonitoring"] = state?.haHostMonitoring;
            resourceInputs["haVmComponentProtection"] = state?.haVmComponentProtection;
            resourceInputs["haVmDependencyRestartCondition"] = state?.haVmDependencyRestartCondition;
            resourceInputs["haVmFailureInterval"] = state?.haVmFailureInterval;
            resourceInputs["haVmMaximumFailureWindow"] = state?.haVmMaximumFailureWindow;
            resourceInputs["haVmMaximumResets"] = state?.haVmMaximumResets;
            resourceInputs["haVmMinimumUptime"] = state?.haVmMinimumUptime;
            resourceInputs["haVmMonitoring"] = state?.haVmMonitoring;
            resourceInputs["haVmRestartAdditionalDelay"] = state?.haVmRestartAdditionalDelay;
            resourceInputs["haVmRestartPriority"] = state?.haVmRestartPriority;
            resourceInputs["haVmRestartTimeout"] = state?.haVmRestartTimeout;
            resourceInputs["hostClusterExitTimeout"] = state?.hostClusterExitTimeout;
            resourceInputs["hostImage"] = state?.hostImage;
            resourceInputs["hostManaged"] = state?.hostManaged;
            resourceInputs["hostSystemIds"] = state?.hostSystemIds;
            resourceInputs["name"] = state?.name;
            resourceInputs["proactiveHaAutomationLevel"] = state?.proactiveHaAutomationLevel;
            resourceInputs["proactiveHaEnabled"] = state?.proactiveHaEnabled;
            resourceInputs["proactiveHaModerateRemediation"] = state?.proactiveHaModerateRemediation;
            resourceInputs["proactiveHaProviderIds"] = state?.proactiveHaProviderIds;
            resourceInputs["proactiveHaSevereRemediation"] = state?.proactiveHaSevereRemediation;
            resourceInputs["resourcePoolId"] = state?.resourcePoolId;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["vsanCompressionEnabled"] = state?.vsanCompressionEnabled;
            resourceInputs["vsanDedupEnabled"] = state?.vsanDedupEnabled;
            resourceInputs["vsanDiskGroups"] = state?.vsanDiskGroups;
            resourceInputs["vsanDitEncryptionEnabled"] = state?.vsanDitEncryptionEnabled;
            resourceInputs["vsanDitRekeyInterval"] = state?.vsanDitRekeyInterval;
            resourceInputs["vsanEnabled"] = state?.vsanEnabled;
            resourceInputs["vsanEsaEnabled"] = state?.vsanEsaEnabled;
            resourceInputs["vsanFaultDomains"] = state?.vsanFaultDomains;
            resourceInputs["vsanNetworkDiagnosticModeEnabled"] = state?.vsanNetworkDiagnosticModeEnabled;
            resourceInputs["vsanPerformanceEnabled"] = state?.vsanPerformanceEnabled;
            resourceInputs["vsanRemoteDatastoreIds"] = state?.vsanRemoteDatastoreIds;
            resourceInputs["vsanStretchedCluster"] = state?.vsanStretchedCluster;
            resourceInputs["vsanUnmapEnabled"] = state?.vsanUnmapEnabled;
            resourceInputs["vsanVerboseModeEnabled"] = state?.vsanVerboseModeEnabled;
        } else {
            const args = argsOrState as ComputeClusterArgs | undefined;
            if (args?.datacenterId === undefined && !opts.urn) {
                throw new Error("Missing required property 'datacenterId'");
            }
            resourceInputs["customAttributes"] = args?.customAttributes;
            resourceInputs["datacenterId"] = args?.datacenterId;
            resourceInputs["dpmAutomationLevel"] = args?.dpmAutomationLevel;
            resourceInputs["dpmEnabled"] = args?.dpmEnabled;
            resourceInputs["dpmThreshold"] = args?.dpmThreshold;
            resourceInputs["drsAdvancedOptions"] = args?.drsAdvancedOptions;
            resourceInputs["drsAutomationLevel"] = args?.drsAutomationLevel;
            resourceInputs["drsEnablePredictiveDrs"] = args?.drsEnablePredictiveDrs;
            resourceInputs["drsEnableVmOverrides"] = args?.drsEnableVmOverrides;
            resourceInputs["drsEnabled"] = args?.drsEnabled;
            resourceInputs["drsMigrationThreshold"] = args?.drsMigrationThreshold;
            resourceInputs["drsScaleDescendantsShares"] = args?.drsScaleDescendantsShares;
            resourceInputs["folder"] = args?.folder;
            resourceInputs["forceEvacuateOnDestroy"] = args?.forceEvacuateOnDestroy;
            resourceInputs["haAdmissionControlFailoverHostSystemIds"] = args?.haAdmissionControlFailoverHostSystemIds;
            resourceInputs["haAdmissionControlHostFailureTolerance"] = args?.haAdmissionControlHostFailureTolerance;
            resourceInputs["haAdmissionControlPerformanceTolerance"] = args?.haAdmissionControlPerformanceTolerance;
            resourceInputs["haAdmissionControlPolicy"] = args?.haAdmissionControlPolicy;
            resourceInputs["haAdmissionControlResourcePercentageAutoCompute"] = args?.haAdmissionControlResourcePercentageAutoCompute;
            resourceInputs["haAdmissionControlResourcePercentageCpu"] = args?.haAdmissionControlResourcePercentageCpu;
            resourceInputs["haAdmissionControlResourcePercentageMemory"] = args?.haAdmissionControlResourcePercentageMemory;
            resourceInputs["haAdmissionControlSlotPolicyExplicitCpu"] = args?.haAdmissionControlSlotPolicyExplicitCpu;
            resourceInputs["haAdmissionControlSlotPolicyExplicitMemory"] = args?.haAdmissionControlSlotPolicyExplicitMemory;
            resourceInputs["haAdmissionControlSlotPolicyUseExplicitSize"] = args?.haAdmissionControlSlotPolicyUseExplicitSize;
            resourceInputs["haAdvancedOptions"] = args?.haAdvancedOptions;
            resourceInputs["haDatastoreApdRecoveryAction"] = args?.haDatastoreApdRecoveryAction;
            resourceInputs["haDatastoreApdResponse"] = args?.haDatastoreApdResponse;
            resourceInputs["haDatastoreApdResponseDelay"] = args?.haDatastoreApdResponseDelay;
            resourceInputs["haDatastorePdlResponse"] = args?.haDatastorePdlResponse;
            resourceInputs["haEnabled"] = args?.haEnabled;
            resourceInputs["haHeartbeatDatastoreIds"] = args?.haHeartbeatDatastoreIds;
            resourceInputs["haHeartbeatDatastorePolicy"] = args?.haHeartbeatDatastorePolicy;
            resourceInputs["haHostIsolationResponse"] = args?.haHostIsolationResponse;
            resourceInputs["haHostMonitoring"] = args?.haHostMonitoring;
            resourceInputs["haVmComponentProtection"] = args?.haVmComponentProtection;
            resourceInputs["haVmDependencyRestartCondition"] = args?.haVmDependencyRestartCondition;
            resourceInputs["haVmFailureInterval"] = args?.haVmFailureInterval;
            resourceInputs["haVmMaximumFailureWindow"] = args?.haVmMaximumFailureWindow;
            resourceInputs["haVmMaximumResets"] = args?.haVmMaximumResets;
            resourceInputs["haVmMinimumUptime"] = args?.haVmMinimumUptime;
            resourceInputs["haVmMonitoring"] = args?.haVmMonitoring;
            resourceInputs["haVmRestartAdditionalDelay"] = args?.haVmRestartAdditionalDelay;
            resourceInputs["haVmRestartPriority"] = args?.haVmRestartPriority;
            resourceInputs["haVmRestartTimeout"] = args?.haVmRestartTimeout;
            resourceInputs["hostClusterExitTimeout"] = args?.hostClusterExitTimeout;
            resourceInputs["hostImage"] = args?.hostImage;
            resourceInputs["hostManaged"] = args?.hostManaged;
            resourceInputs["hostSystemIds"] = args?.hostSystemIds;
            resourceInputs["name"] = args?.name;
            resourceInputs["proactiveHaAutomationLevel"] = args?.proactiveHaAutomationLevel;
            resourceInputs["proactiveHaEnabled"] = args?.proactiveHaEnabled;
            resourceInputs["proactiveHaModerateRemediation"] = args?.proactiveHaModerateRemediation;
            resourceInputs["proactiveHaProviderIds"] = args?.proactiveHaProviderIds;
            resourceInputs["proactiveHaSevereRemediation"] = args?.proactiveHaSevereRemediation;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["vsanCompressionEnabled"] = args?.vsanCompressionEnabled;
            resourceInputs["vsanDedupEnabled"] = args?.vsanDedupEnabled;
            resourceInputs["vsanDiskGroups"] = args?.vsanDiskGroups;
            resourceInputs["vsanDitEncryptionEnabled"] = args?.vsanDitEncryptionEnabled;
            resourceInputs["vsanDitRekeyInterval"] = args?.vsanDitRekeyInterval;
            resourceInputs["vsanEnabled"] = args?.vsanEnabled;
            resourceInputs["vsanEsaEnabled"] = args?.vsanEsaEnabled;
            resourceInputs["vsanFaultDomains"] = args?.vsanFaultDomains;
            resourceInputs["vsanNetworkDiagnosticModeEnabled"] = args?.vsanNetworkDiagnosticModeEnabled;
            resourceInputs["vsanPerformanceEnabled"] = args?.vsanPerformanceEnabled;
            resourceInputs["vsanRemoteDatastoreIds"] = args?.vsanRemoteDatastoreIds;
            resourceInputs["vsanStretchedCluster"] = args?.vsanStretchedCluster;
            resourceInputs["vsanUnmapEnabled"] = args?.vsanUnmapEnabled;
            resourceInputs["vsanVerboseModeEnabled"] = args?.vsanVerboseModeEnabled;
            resourceInputs["resourcePoolId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ComputeCluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ComputeCluster resources.
 */
export interface ComputeClusterState {
    /**
     * A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster. See
     * [here][docs-setting-custom-attributes] for a reference on how to set values
     * for custom attributes.
     *
     * [docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource
     *
     * > **NOTE:** Custom attributes are not supported on direct ESXi host
     * connections and requires vCenter Server.
     */
    customAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The [managed object ID][docs-about-morefs] of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     */
    datacenterId?: pulumi.Input<string>;
    /**
     * The automation level for host power operations in this cluster. Can be one of manual or automated.
     */
    dpmAutomationLevel?: pulumi.Input<string>;
    /**
     * Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual machines in the cluster. Requires that DRS be enabled.
     */
    dpmEnabled?: pulumi.Input<boolean>;
    /**
     * A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher setting.
     */
    dpmThreshold?: pulumi.Input<number>;
    /**
     * Advanced configuration options for DRS and DPM.
     */
    drsAdvancedOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or fullyAutomated.
     */
    drsAutomationLevel?: pulumi.Input<string>;
    /**
     * When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     */
    drsEnablePredictiveDrs?: pulumi.Input<boolean>;
    /**
     * When true, allows individual VM overrides within this cluster to be set.
     */
    drsEnableVmOverrides?: pulumi.Input<boolean>;
    /**
     * Enable DRS for this cluster.
     */
    drsEnabled?: pulumi.Input<boolean>;
    /**
     * A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate more imbalance while a higher setting will tolerate less.
     */
    drsMigrationThreshold?: pulumi.Input<number>;
    /**
     * Enable scalable shares for all descendants of this cluster.
     */
    drsScaleDescendantsShares?: pulumi.Input<string>;
    /**
     * The name of the folder to locate the cluster in.
     */
    folder?: pulumi.Input<string>;
    /**
     * Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists for testing and is not recommended in normal use.
     */
    forceEvacuateOnDestroy?: pulumi.Input<boolean>;
    /**
     * When haAdmissionControlPolicy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS will ignore the host when making recommendations.
     */
    haAdmissionControlFailoverHostSystemIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual machine operations. The maximum is one less than the number of hosts in the cluster.
     */
    haAdmissionControlHostFailureTolerance?: pulumi.Input<number>;
    /**
     * The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces warnings only, whereas a value of 100 disables the setting.
     */
    haAdmissionControlPerformanceTolerance?: pulumi.Input<number>;
    /**
     * The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage, slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service issues.
     */
    haAdmissionControlPolicy?: pulumi.Input<string>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, automatically determine available resource percentages by subtracting the average number of host resources represented by the haAdmissionControlHostFailureTolerance setting from the total amount of resources in the cluster. Disable to supply user-defined values.
     */
    haAdmissionControlResourcePercentageAutoCompute?: pulumi.Input<boolean>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of CPU resources in the cluster to reserve for failover.
     */
    haAdmissionControlResourcePercentageCpu?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of memory resources in the cluster to reserve for failover.
     */
    haAdmissionControlResourcePercentageMemory?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     */
    haAdmissionControlSlotPolicyExplicitCpu?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined memory slot size, in MB.
     */
    haAdmissionControlSlotPolicyExplicitMemory?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this setting controls whether or not you wish to supply explicit values to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines currently in the cluster.
     */
    haAdmissionControlSlotPolicyUseExplicitSize?: pulumi.Input<boolean>;
    /**
     * Advanced configuration options for vSphere HA.
     */
    haAdvancedOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines if an APD status on an affected datastore clears in the middle of an APD event. Can be one of none or reset.
     */
    haDatastoreApdRecoveryAction?: pulumi.Input<string>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
     */
    haDatastoreApdResponse?: pulumi.Input<string>;
    /**
     * When haVmComponentProtection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the response action defined in ha_datastore_apd_response.
     */
    haDatastoreApdResponseDelay?: pulumi.Input<number>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     */
    haDatastorePdlResponse?: pulumi.Input<string>;
    /**
     * Enable vSphere HA for this cluster.
     */
    haEnabled?: pulumi.Input<boolean>;
    /**
     * The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when haHeartbeatDatastorePolicy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     */
    haHeartbeatDatastoreIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference.
     */
    haHeartbeatDatastorePolicy?: pulumi.Input<string>;
    /**
     * The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster. Can be one of none, powerOff, or shutdown.
     */
    haHostIsolationResponse?: pulumi.Input<string>;
    /**
     * Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     */
    haHostMonitoring?: pulumi.Input<string>;
    /**
     * Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     */
    haVmComponentProtection?: pulumi.Input<string>;
    /**
     * The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     */
    haVmDependencyRestartCondition?: pulumi.Input<string>;
    /**
     * If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as failed. The value is in seconds.
     */
    haVmFailureInterval?: pulumi.Input<number>;
    /**
     * The length of the reset window in which haVmMaximumResets can operate. When this window expires, no more resets are attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset time is allotted.
     */
    haVmMaximumFailureWindow?: pulumi.Input<number>;
    /**
     * The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     */
    haVmMaximumResets?: pulumi.Input<number>;
    /**
     * The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     */
    haVmMinimumUptime?: pulumi.Input<number>;
    /**
     * The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring.
     */
    haVmMonitoring?: pulumi.Input<string>;
    /**
     * Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     */
    haVmRestartAdditionalDelay?: pulumi.Input<number>;
    /**
     * The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium, high, or highest.
     */
    haVmRestartPriority?: pulumi.Input<string>;
    /**
     * The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before proceeding with the next priority.
     */
    haVmRestartTimeout?: pulumi.Input<number>;
    /**
     * The timeout for each host maintenance mode operation when removing hosts from a cluster.
     */
    hostClusterExitTimeout?: pulumi.Input<number>;
    /**
     * Details about the host image which should be applied to the cluster.
     */
    hostImage?: pulumi.Input<inputs.ComputeClusterHostImage>;
    /**
     * Must be set if cluster enrollment is managed from host resource.
     */
    hostManaged?: pulumi.Input<boolean>;
    /**
     * The managed object IDs of the hosts to put in the cluster.
     */
    hostSystemIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     */
    proactiveHaAutomationLevel?: pulumi.Input<string>;
    /**
     * Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     */
    proactiveHaEnabled?: pulumi.Input<boolean>;
    /**
     * The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to MaintenanceMode when proactiveHaSevereRemediation is set to QuarantineMode.
     */
    proactiveHaModerateRemediation?: pulumi.Input<string>;
    /**
     * The list of IDs for health update providers configured for this cluster.
     */
    proactiveHaProviderIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to QuarantineMode when proactiveHaModerateRemediation is set to MaintenanceMode.
     */
    proactiveHaSevereRemediation?: pulumi.Input<string>;
    /**
     * The [managed object ID][docs-about-morefs] of the primary
     * resource pool for this cluster. This can be passed directly to the
     * [`resourcePoolId`
     * attribute][docs-r-vsphere-virtual-machine-resource-pool-id] of the
     * [`vsphere.VirtualMachine`][docs-r-vsphere-virtual-machine] resource.
     */
    resourcePoolId?: pulumi.Input<string>;
    /**
     * The IDs of any tags to attach to this resource. See
     * [here][docs-applying-tags] for a reference on how to apply tags.
     *
     * [docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider
     * [docs-applying-tags]: /docs/providers/vsphere/r/tag.html#using-tags-in-a-supported-resource
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether the vSAN compression service is enabled for the cluster.
     */
    vsanCompressionEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN deduplication service is enabled for the cluster.
     */
    vsanDedupEnabled?: pulumi.Input<boolean>;
    /**
     * A list of disk UUIDs to add to the vSAN cluster.
     */
    vsanDiskGroups?: pulumi.Input<pulumi.Input<inputs.ComputeClusterVsanDiskGroup>[]>;
    /**
     * Whether the vSAN data-in-transit encryption is enabled for the cluster.
     */
    vsanDitEncryptionEnabled?: pulumi.Input<boolean>;
    /**
     * When vsanDitEncryptionEnabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     */
    vsanDitRekeyInterval?: pulumi.Input<number>;
    /**
     * Whether the vSAN service is enabled for the cluster.
     */
    vsanEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN ESA service is enabled for the cluster.
     */
    vsanEsaEnabled?: pulumi.Input<boolean>;
    /**
     * The configuration for vSAN fault domains.
     */
    vsanFaultDomains?: pulumi.Input<pulumi.Input<inputs.ComputeClusterVsanFaultDomain>[]>;
    /**
     * Whether the vSAN network diagnostic mode is enabled for the cluster.
     */
    vsanNetworkDiagnosticModeEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN performance service is enabled for the cluster.
     */
    vsanPerformanceEnabled?: pulumi.Input<boolean>;
    /**
     * The managed object IDs of the vSAN datastore to be mounted on the cluster.
     */
    vsanRemoteDatastoreIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The configuration for stretched cluster.
     */
    vsanStretchedCluster?: pulumi.Input<inputs.ComputeClusterVsanStretchedCluster>;
    /**
     * Whether the vSAN unmap service is enabled for the cluster.
     */
    vsanUnmapEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN verbose mode is enabled for the cluster.
     */
    vsanVerboseModeEnabled?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a ComputeCluster resource.
 */
export interface ComputeClusterArgs {
    /**
     * A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster. See
     * [here][docs-setting-custom-attributes] for a reference on how to set values
     * for custom attributes.
     *
     * [docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource
     *
     * > **NOTE:** Custom attributes are not supported on direct ESXi host
     * connections and requires vCenter Server.
     */
    customAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The [managed object ID][docs-about-morefs] of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     */
    datacenterId: pulumi.Input<string>;
    /**
     * The automation level for host power operations in this cluster. Can be one of manual or automated.
     */
    dpmAutomationLevel?: pulumi.Input<string>;
    /**
     * Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual machines in the cluster. Requires that DRS be enabled.
     */
    dpmEnabled?: pulumi.Input<boolean>;
    /**
     * A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher setting.
     */
    dpmThreshold?: pulumi.Input<number>;
    /**
     * Advanced configuration options for DRS and DPM.
     */
    drsAdvancedOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or fullyAutomated.
     */
    drsAutomationLevel?: pulumi.Input<string>;
    /**
     * When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     */
    drsEnablePredictiveDrs?: pulumi.Input<boolean>;
    /**
     * When true, allows individual VM overrides within this cluster to be set.
     */
    drsEnableVmOverrides?: pulumi.Input<boolean>;
    /**
     * Enable DRS for this cluster.
     */
    drsEnabled?: pulumi.Input<boolean>;
    /**
     * A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate more imbalance while a higher setting will tolerate less.
     */
    drsMigrationThreshold?: pulumi.Input<number>;
    /**
     * Enable scalable shares for all descendants of this cluster.
     */
    drsScaleDescendantsShares?: pulumi.Input<string>;
    /**
     * The name of the folder to locate the cluster in.
     */
    folder?: pulumi.Input<string>;
    /**
     * Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists for testing and is not recommended in normal use.
     */
    forceEvacuateOnDestroy?: pulumi.Input<boolean>;
    /**
     * When haAdmissionControlPolicy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS will ignore the host when making recommendations.
     */
    haAdmissionControlFailoverHostSystemIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual machine operations. The maximum is one less than the number of hosts in the cluster.
     */
    haAdmissionControlHostFailureTolerance?: pulumi.Input<number>;
    /**
     * The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces warnings only, whereas a value of 100 disables the setting.
     */
    haAdmissionControlPerformanceTolerance?: pulumi.Input<number>;
    /**
     * The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage, slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service issues.
     */
    haAdmissionControlPolicy?: pulumi.Input<string>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, automatically determine available resource percentages by subtracting the average number of host resources represented by the haAdmissionControlHostFailureTolerance setting from the total amount of resources in the cluster. Disable to supply user-defined values.
     */
    haAdmissionControlResourcePercentageAutoCompute?: pulumi.Input<boolean>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of CPU resources in the cluster to reserve for failover.
     */
    haAdmissionControlResourcePercentageCpu?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of memory resources in the cluster to reserve for failover.
     */
    haAdmissionControlResourcePercentageMemory?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     */
    haAdmissionControlSlotPolicyExplicitCpu?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined memory slot size, in MB.
     */
    haAdmissionControlSlotPolicyExplicitMemory?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this setting controls whether or not you wish to supply explicit values to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines currently in the cluster.
     */
    haAdmissionControlSlotPolicyUseExplicitSize?: pulumi.Input<boolean>;
    /**
     * Advanced configuration options for vSphere HA.
     */
    haAdvancedOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines if an APD status on an affected datastore clears in the middle of an APD event. Can be one of none or reset.
     */
    haDatastoreApdRecoveryAction?: pulumi.Input<string>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
     */
    haDatastoreApdResponse?: pulumi.Input<string>;
    /**
     * When haVmComponentProtection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the response action defined in ha_datastore_apd_response.
     */
    haDatastoreApdResponseDelay?: pulumi.Input<number>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     */
    haDatastorePdlResponse?: pulumi.Input<string>;
    /**
     * Enable vSphere HA for this cluster.
     */
    haEnabled?: pulumi.Input<boolean>;
    /**
     * The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when haHeartbeatDatastorePolicy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     */
    haHeartbeatDatastoreIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference.
     */
    haHeartbeatDatastorePolicy?: pulumi.Input<string>;
    /**
     * The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster. Can be one of none, powerOff, or shutdown.
     */
    haHostIsolationResponse?: pulumi.Input<string>;
    /**
     * Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     */
    haHostMonitoring?: pulumi.Input<string>;
    /**
     * Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     */
    haVmComponentProtection?: pulumi.Input<string>;
    /**
     * The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     */
    haVmDependencyRestartCondition?: pulumi.Input<string>;
    /**
     * If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as failed. The value is in seconds.
     */
    haVmFailureInterval?: pulumi.Input<number>;
    /**
     * The length of the reset window in which haVmMaximumResets can operate. When this window expires, no more resets are attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset time is allotted.
     */
    haVmMaximumFailureWindow?: pulumi.Input<number>;
    /**
     * The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     */
    haVmMaximumResets?: pulumi.Input<number>;
    /**
     * The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     */
    haVmMinimumUptime?: pulumi.Input<number>;
    /**
     * The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring.
     */
    haVmMonitoring?: pulumi.Input<string>;
    /**
     * Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     */
    haVmRestartAdditionalDelay?: pulumi.Input<number>;
    /**
     * The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium, high, or highest.
     */
    haVmRestartPriority?: pulumi.Input<string>;
    /**
     * The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before proceeding with the next priority.
     */
    haVmRestartTimeout?: pulumi.Input<number>;
    /**
     * The timeout for each host maintenance mode operation when removing hosts from a cluster.
     */
    hostClusterExitTimeout?: pulumi.Input<number>;
    /**
     * Details about the host image which should be applied to the cluster.
     */
    hostImage?: pulumi.Input<inputs.ComputeClusterHostImage>;
    /**
     * Must be set if cluster enrollment is managed from host resource.
     */
    hostManaged?: pulumi.Input<boolean>;
    /**
     * The managed object IDs of the hosts to put in the cluster.
     */
    hostSystemIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     */
    proactiveHaAutomationLevel?: pulumi.Input<string>;
    /**
     * Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     */
    proactiveHaEnabled?: pulumi.Input<boolean>;
    /**
     * The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to MaintenanceMode when proactiveHaSevereRemediation is set to QuarantineMode.
     */
    proactiveHaModerateRemediation?: pulumi.Input<string>;
    /**
     * The list of IDs for health update providers configured for this cluster.
     */
    proactiveHaProviderIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to QuarantineMode when proactiveHaModerateRemediation is set to MaintenanceMode.
     */
    proactiveHaSevereRemediation?: pulumi.Input<string>;
    /**
     * The IDs of any tags to attach to this resource. See
     * [here][docs-applying-tags] for a reference on how to apply tags.
     *
     * [docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider
     * [docs-applying-tags]: /docs/providers/vsphere/r/tag.html#using-tags-in-a-supported-resource
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether the vSAN compression service is enabled for the cluster.
     */
    vsanCompressionEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN deduplication service is enabled for the cluster.
     */
    vsanDedupEnabled?: pulumi.Input<boolean>;
    /**
     * A list of disk UUIDs to add to the vSAN cluster.
     */
    vsanDiskGroups?: pulumi.Input<pulumi.Input<inputs.ComputeClusterVsanDiskGroup>[]>;
    /**
     * Whether the vSAN data-in-transit encryption is enabled for the cluster.
     */
    vsanDitEncryptionEnabled?: pulumi.Input<boolean>;
    /**
     * When vsanDitEncryptionEnabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     */
    vsanDitRekeyInterval?: pulumi.Input<number>;
    /**
     * Whether the vSAN service is enabled for the cluster.
     */
    vsanEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN ESA service is enabled for the cluster.
     */
    vsanEsaEnabled?: pulumi.Input<boolean>;
    /**
     * The configuration for vSAN fault domains.
     */
    vsanFaultDomains?: pulumi.Input<pulumi.Input<inputs.ComputeClusterVsanFaultDomain>[]>;
    /**
     * Whether the vSAN network diagnostic mode is enabled for the cluster.
     */
    vsanNetworkDiagnosticModeEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN performance service is enabled for the cluster.
     */
    vsanPerformanceEnabled?: pulumi.Input<boolean>;
    /**
     * The managed object IDs of the vSAN datastore to be mounted on the cluster.
     */
    vsanRemoteDatastoreIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The configuration for stretched cluster.
     */
    vsanStretchedCluster?: pulumi.Input<inputs.ComputeClusterVsanStretchedCluster>;
    /**
     * Whether the vSAN unmap service is enabled for the cluster.
     */
    vsanUnmapEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN verbose mode is enabled for the cluster.
     */
    vsanVerboseModeEnabled?: pulumi.Input<boolean>;
}
