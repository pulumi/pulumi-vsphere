// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * > **A note on the naming of this resource:** VMware refers to clusters of
 * hosts in the UI and documentation as _clusters_, _HA clusters_, or _DRS
 * clusters_. All of these refer to the same kind of resource (with the latter two
 * referring to specific features of clustering). We use
 * `vsphere.ComputeCluster` to differentiate host clusters from _datastore
 * clusters_, which are clusters of datastores that can be used to distribute load
 * and ensure fault tolerance via distribution of virtual machines. Datastore
 * clusters can also be managed through the provider, via the
 * `vsphere.DatastoreCluster` resource.
 *
 * The `vsphere.ComputeCluster` resource can be used to create and manage
 * clusters of hosts allowing for resource control of compute resources, load
 * balancing through DRS, and high availability through vSphere HA.
 *
 * For more information on vSphere clusters and DRS, see [this
 * page][ref-vsphere-drs-clusters]. For more information on vSphere HA, see [this
 * page][ref-vsphere-ha-clusters].
 *
 * [ref-vsphere-drs-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-resource-management-8-0/creating-a-drs-cluster.html
 * [ref-vsphere-ha-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-availability.html
 *
 * > **NOTE:** This resource requires vCenter and is not available on
 * direct ESXi connections.
 *
 * ## Import
 *
 * An existing cluster can be imported into this resource via the
 *
 * path to the cluster, via the following command:
 *
 * hcl
 *
 * variable "datacenter" {
 *
 *   default = "dc-01"
 *
 * }
 *
 * data "vsphere_datacenter" "datacenter" {
 *
 *   name = var.datacenter
 *
 * }
 *
 * resource "vsphere_compute_cluster" "compute_cluster" {
 *
 *   name            = "cluster-01"
 *
 *   datacenter_id   = data.vsphere_datacenter.datacenter.id
 *
 * }
 *
 * hcl
 *
 * resource "vsphere_compute_cluster" "compute_cluster" {
 *
 *   name                      = "cluster-01"
 *
 *   datacenter_id             = data.vsphere_datacenter.datacenter.id
 *
 *   vsan_enabled              = true
 *
 *   vsan_performance_enabled  = true
 *
 *   host_system_ids           = [for host in data.vsphere_host.host : host.id]
 *
 *   dpm_automation_level      = "automated"
 *
 *   drs_automation_level      = "fullyAutomated"
 *
 *   drs_enabled               = true
 *
 *   ha_datastore_apd_response = "restartConservative"
 *
 *   ha_datastore_pdl_response = "restartAggressive"
 *
 *   ... etc.
 *
 * console
 *
 * ```sh
 * $ pulumi import vsphere:index/computeCluster:ComputeCluster compute_cluster /dc-01/host/cluster-01
 * ```
 *
 * The above would import the cluster named `cluster-01` that is located in
 *
 * the `dc-01` datacenter.
 */
export class ComputeCluster extends pulumi.CustomResource {
    /**
     * Get an existing ComputeCluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ComputeClusterState, opts?: pulumi.CustomResourceOptions): ComputeCluster {
        return new ComputeCluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'vsphere:index/computeCluster:ComputeCluster';

    /**
     * Returns true if the given object is an instance of ComputeCluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ComputeCluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ComputeCluster.__pulumiType;
    }

    /**
     * A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster.
     *
     * > **NOTE:** Custom attributes are unsupported on direct ESXi connections
     * and require vCenter Server.
     */
    public readonly customAttributes!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The managed object ID of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     */
    public readonly datacenterId!: pulumi.Output<string>;
    /**
     * The automation level for host power operations in this cluster. Can be one of manual or automated.
     */
    public readonly dpmAutomationLevel!: pulumi.Output<string | undefined>;
    /**
     * Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual
     * machines in the cluster. Requires that DRS be enabled.
     */
    public readonly dpmEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This
     * affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher
     * setting.
     */
    public readonly dpmThreshold!: pulumi.Output<number | undefined>;
    /**
     * Advanced configuration options for DRS and DPM.
     */
    public readonly drsAdvancedOptions!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or
     * fullyAutomated.
     */
    public readonly drsAutomationLevel!: pulumi.Output<string | undefined>;
    /**
     * When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     */
    public readonly drsEnablePredictiveDrs!: pulumi.Output<boolean | undefined>;
    /**
     * When true, allows individual VM overrides within this cluster to be set.
     */
    public readonly drsEnableVmOverrides!: pulumi.Output<boolean | undefined>;
    /**
     * Enable DRS for this cluster.
     */
    public readonly drsEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate
     * more imbalance while a higher setting will tolerate less.
     */
    public readonly drsMigrationThreshold!: pulumi.Output<number | undefined>;
    /**
     * Enable scalable shares for all descendants of this cluster.
     */
    public readonly drsScaleDescendantsShares!: pulumi.Output<string | undefined>;
    /**
     * The relative path to a folder to put this cluster in.
     * This is a path relative to the datacenter you are deploying the cluster to.
     * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
     * The provider will place a cluster named `compute-cluster-test` in a
     * host folder located at `/dc1/host/foo/bar`, with the final inventory path
     * being `/dc1/host/foo/bar/datastore-cluster-test`.
     */
    public readonly folder!: pulumi.Output<string | undefined>;
    /**
     * Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists
     * for testing and is not recommended in normal use.
     */
    public readonly forceEvacuateOnDestroy!: pulumi.Output<boolean | undefined>;
    /**
     * When haAdmissionControlPolicy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated
     * failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS
     * will ignore the host when making recommendations.
     */
    public readonly haAdmissionControlFailoverHostSystemIds!: pulumi.Output<string[] | undefined>;
    /**
     * The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual
     * machine operations. The maximum is one less than the number of hosts in the cluster.
     */
    public readonly haAdmissionControlHostFailureTolerance!: pulumi.Output<number | undefined>;
    /**
     * The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces
     * warnings only, whereas a value of 100 disables the setting.
     */
    public readonly haAdmissionControlPerformanceTolerance!: pulumi.Output<number | undefined>;
    /**
     * The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are
     * permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,
     * slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service
     * issues.
     */
    public readonly haAdmissionControlPolicy!: pulumi.Output<string | undefined>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, automatically determine available resource percentages by
     * subtracting the average number of host resources represented by the haAdmissionControlHostFailureTolerance setting from
     * the total amount of resources in the cluster. Disable to supply user-defined values.
     */
    public readonly haAdmissionControlResourcePercentageAutoCompute!: pulumi.Output<boolean | undefined>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of CPU resources in the
     * cluster to reserve for failover.
     */
    public readonly haAdmissionControlResourcePercentageCpu!: pulumi.Output<number | undefined>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of memory resources in
     * the cluster to reserve for failover.
     */
    public readonly haAdmissionControlResourcePercentageMemory!: pulumi.Output<number | undefined>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     */
    public readonly haAdmissionControlSlotPolicyExplicitCpu!: pulumi.Output<number | undefined>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined memory slot size, in MB.
     */
    public readonly haAdmissionControlSlotPolicyExplicitMemory!: pulumi.Output<number | undefined>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this setting controls whether or not you wish to supply explicit values to
     * CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines
     * currently in the cluster.
     */
    public readonly haAdmissionControlSlotPolicyUseExplicitSize!: pulumi.Output<boolean | undefined>;
    /**
     * Advanced configuration options for vSphere HA.
     */
    public readonly haAdvancedOptions!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines if an APD status on an affected
     * datastore clears in the middle of an APD event. Can be one of none or reset.
     */
    public readonly haDatastoreApdRecoveryAction!: pulumi.Output<string | undefined>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected
     * loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
     */
    public readonly haDatastoreApdResponse!: pulumi.Output<string | undefined>;
    /**
     * When haVmComponentProtection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the
     * response action defined in ha_datastore_apd_response.
     */
    public readonly haDatastoreApdResponseDelay!: pulumi.Output<number | undefined>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected a
     * permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     */
    public readonly haDatastorePdlResponse!: pulumi.Output<string | undefined>;
    /**
     * Enable vSphere HA for this cluster.
     */
    public readonly haEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when
     * haHeartbeatDatastorePolicy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     */
    public readonly haHeartbeatDatastoreIds!: pulumi.Output<string[] | undefined>;
    /**
     * The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or
     * allFeasibleDsWithUserPreference.
     */
    public readonly haHeartbeatDatastorePolicy!: pulumi.Output<string | undefined>;
    /**
     * The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.
     * Can be one of none, powerOff, or shutdown.
     */
    public readonly haHostIsolationResponse!: pulumi.Output<string | undefined>;
    /**
     * Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     */
    public readonly haHostMonitoring!: pulumi.Output<string | undefined>;
    /**
     * Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to
     * failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     */
    public readonly haVmComponentProtection!: pulumi.Output<string | undefined>;
    /**
     * The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move
     * on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     */
    public readonly haVmDependencyRestartCondition!: pulumi.Output<string | undefined>;
    /**
     * If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as
     * failed. The value is in seconds.
     */
    public readonly haVmFailureInterval!: pulumi.Output<number | undefined>;
    /**
     * The length of the reset window in which haVmMaximumResets can operate. When this window expires, no more resets are
     * attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset
     * time is allotted.
     */
    public readonly haVmMaximumFailureWindow!: pulumi.Output<number | undefined>;
    /**
     * The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     */
    public readonly haVmMaximumResets!: pulumi.Output<number | undefined>;
    /**
     * The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     */
    public readonly haVmMinimumUptime!: pulumi.Output<number | undefined>;
    /**
     * The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,
     * vmMonitoringOnly, or vmAndAppMonitoring.
     */
    public readonly haVmMonitoring!: pulumi.Output<string | undefined>;
    /**
     * Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     */
    public readonly haVmRestartAdditionalDelay!: pulumi.Output<number | undefined>;
    /**
     * The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,
     * high, or highest.
     */
    public readonly haVmRestartPriority!: pulumi.Output<string | undefined>;
    /**
     * The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before
     * proceeding with the next priority.
     */
    public readonly haVmRestartTimeout!: pulumi.Output<number | undefined>;
    /**
     * The timeout for each host maintenance mode operation when removing hosts from a cluster.
     */
    public readonly hostClusterExitTimeout!: pulumi.Output<number | undefined>;
    /**
     * Details about the host image which should be applied to the cluster.
     */
    public readonly hostImage!: pulumi.Output<outputs.ComputeClusterHostImage | undefined>;
    /**
     * Must be set if cluster enrollment is managed from host resource.
     */
    public readonly hostManaged!: pulumi.Output<boolean | undefined>;
    /**
     * The managed object IDs of the hosts to put in the cluster.
     */
    public readonly hostSystemIds!: pulumi.Output<string[] | undefined>;
    /**
     * The name of the cluster.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     */
    public readonly proactiveHaAutomationLevel!: pulumi.Output<string | undefined>;
    /**
     * Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     */
    public readonly proactiveHaEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that
     * this cannot be set to MaintenanceMode when proactiveHaSevereRemediation is set to QuarantineMode.
     */
    public readonly proactiveHaModerateRemediation!: pulumi.Output<string | undefined>;
    /**
     * The list of IDs for health update providers configured for this cluster.
     */
    public readonly proactiveHaProviderIds!: pulumi.Output<string[] | undefined>;
    /**
     * The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this
     * cannot be set to QuarantineMode when proactiveHaModerateRemediation is set to MaintenanceMode.
     */
    public readonly proactiveHaSevereRemediation!: pulumi.Output<string | undefined>;
    /**
     * The managed object ID of the primary
     * resource pool for this cluster. This can be passed directly to the
     * `resourcePoolId`
     * attribute of the
     * `vsphere.VirtualMachine` resource.
     */
    public /*out*/ readonly resourcePoolId!: pulumi.Output<string>;
    /**
     * The IDs of any tags to attach to this resource.
     */
    public readonly tags!: pulumi.Output<string[] | undefined>;
    /**
     * Whether the vSAN compression service is enabled for the cluster.
     */
    public readonly vsanCompressionEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * Whether the vSAN deduplication service is enabled for the cluster.
     */
    public readonly vsanDedupEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * A list of disk UUIDs to add to the vSAN cluster.
     */
    public readonly vsanDiskGroups!: pulumi.Output<outputs.ComputeClusterVsanDiskGroup[]>;
    /**
     * Whether the vSAN data-in-transit encryption is enabled for the cluster.
     */
    public readonly vsanDitEncryptionEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * When vsanDitEncryptionEnabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     */
    public readonly vsanDitRekeyInterval!: pulumi.Output<number>;
    /**
     * Whether the vSAN service is enabled for the cluster.
     */
    public readonly vsanEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * Whether the vSAN ESA service is enabled for the cluster.
     */
    public readonly vsanEsaEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * The configuration for vSAN fault domains.
     */
    public readonly vsanFaultDomains!: pulumi.Output<outputs.ComputeClusterVsanFaultDomain[] | undefined>;
    /**
     * Whether the vSAN network diagnostic mode is enabled for the cluster.
     */
    public readonly vsanNetworkDiagnosticModeEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * Whether the vSAN performance service is enabled for the cluster.
     */
    public readonly vsanPerformanceEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * The managed object IDs of the vSAN datastore to be mounted on the cluster.
     */
    public readonly vsanRemoteDatastoreIds!: pulumi.Output<string[] | undefined>;
    /**
     * The configuration for stretched cluster.
     */
    public readonly vsanStretchedCluster!: pulumi.Output<outputs.ComputeClusterVsanStretchedCluster | undefined>;
    /**
     * Whether the vSAN unmap service is enabled for the cluster.
     */
    public readonly vsanUnmapEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * Whether the vSAN verbose mode is enabled for the cluster.
     */
    public readonly vsanVerboseModeEnabled!: pulumi.Output<boolean | undefined>;

    /**
     * Create a ComputeCluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ComputeClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ComputeClusterArgs | ComputeClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ComputeClusterState | undefined;
            resourceInputs["customAttributes"] = state ? state.customAttributes : undefined;
            resourceInputs["datacenterId"] = state ? state.datacenterId : undefined;
            resourceInputs["dpmAutomationLevel"] = state ? state.dpmAutomationLevel : undefined;
            resourceInputs["dpmEnabled"] = state ? state.dpmEnabled : undefined;
            resourceInputs["dpmThreshold"] = state ? state.dpmThreshold : undefined;
            resourceInputs["drsAdvancedOptions"] = state ? state.drsAdvancedOptions : undefined;
            resourceInputs["drsAutomationLevel"] = state ? state.drsAutomationLevel : undefined;
            resourceInputs["drsEnablePredictiveDrs"] = state ? state.drsEnablePredictiveDrs : undefined;
            resourceInputs["drsEnableVmOverrides"] = state ? state.drsEnableVmOverrides : undefined;
            resourceInputs["drsEnabled"] = state ? state.drsEnabled : undefined;
            resourceInputs["drsMigrationThreshold"] = state ? state.drsMigrationThreshold : undefined;
            resourceInputs["drsScaleDescendantsShares"] = state ? state.drsScaleDescendantsShares : undefined;
            resourceInputs["folder"] = state ? state.folder : undefined;
            resourceInputs["forceEvacuateOnDestroy"] = state ? state.forceEvacuateOnDestroy : undefined;
            resourceInputs["haAdmissionControlFailoverHostSystemIds"] = state ? state.haAdmissionControlFailoverHostSystemIds : undefined;
            resourceInputs["haAdmissionControlHostFailureTolerance"] = state ? state.haAdmissionControlHostFailureTolerance : undefined;
            resourceInputs["haAdmissionControlPerformanceTolerance"] = state ? state.haAdmissionControlPerformanceTolerance : undefined;
            resourceInputs["haAdmissionControlPolicy"] = state ? state.haAdmissionControlPolicy : undefined;
            resourceInputs["haAdmissionControlResourcePercentageAutoCompute"] = state ? state.haAdmissionControlResourcePercentageAutoCompute : undefined;
            resourceInputs["haAdmissionControlResourcePercentageCpu"] = state ? state.haAdmissionControlResourcePercentageCpu : undefined;
            resourceInputs["haAdmissionControlResourcePercentageMemory"] = state ? state.haAdmissionControlResourcePercentageMemory : undefined;
            resourceInputs["haAdmissionControlSlotPolicyExplicitCpu"] = state ? state.haAdmissionControlSlotPolicyExplicitCpu : undefined;
            resourceInputs["haAdmissionControlSlotPolicyExplicitMemory"] = state ? state.haAdmissionControlSlotPolicyExplicitMemory : undefined;
            resourceInputs["haAdmissionControlSlotPolicyUseExplicitSize"] = state ? state.haAdmissionControlSlotPolicyUseExplicitSize : undefined;
            resourceInputs["haAdvancedOptions"] = state ? state.haAdvancedOptions : undefined;
            resourceInputs["haDatastoreApdRecoveryAction"] = state ? state.haDatastoreApdRecoveryAction : undefined;
            resourceInputs["haDatastoreApdResponse"] = state ? state.haDatastoreApdResponse : undefined;
            resourceInputs["haDatastoreApdResponseDelay"] = state ? state.haDatastoreApdResponseDelay : undefined;
            resourceInputs["haDatastorePdlResponse"] = state ? state.haDatastorePdlResponse : undefined;
            resourceInputs["haEnabled"] = state ? state.haEnabled : undefined;
            resourceInputs["haHeartbeatDatastoreIds"] = state ? state.haHeartbeatDatastoreIds : undefined;
            resourceInputs["haHeartbeatDatastorePolicy"] = state ? state.haHeartbeatDatastorePolicy : undefined;
            resourceInputs["haHostIsolationResponse"] = state ? state.haHostIsolationResponse : undefined;
            resourceInputs["haHostMonitoring"] = state ? state.haHostMonitoring : undefined;
            resourceInputs["haVmComponentProtection"] = state ? state.haVmComponentProtection : undefined;
            resourceInputs["haVmDependencyRestartCondition"] = state ? state.haVmDependencyRestartCondition : undefined;
            resourceInputs["haVmFailureInterval"] = state ? state.haVmFailureInterval : undefined;
            resourceInputs["haVmMaximumFailureWindow"] = state ? state.haVmMaximumFailureWindow : undefined;
            resourceInputs["haVmMaximumResets"] = state ? state.haVmMaximumResets : undefined;
            resourceInputs["haVmMinimumUptime"] = state ? state.haVmMinimumUptime : undefined;
            resourceInputs["haVmMonitoring"] = state ? state.haVmMonitoring : undefined;
            resourceInputs["haVmRestartAdditionalDelay"] = state ? state.haVmRestartAdditionalDelay : undefined;
            resourceInputs["haVmRestartPriority"] = state ? state.haVmRestartPriority : undefined;
            resourceInputs["haVmRestartTimeout"] = state ? state.haVmRestartTimeout : undefined;
            resourceInputs["hostClusterExitTimeout"] = state ? state.hostClusterExitTimeout : undefined;
            resourceInputs["hostImage"] = state ? state.hostImage : undefined;
            resourceInputs["hostManaged"] = state ? state.hostManaged : undefined;
            resourceInputs["hostSystemIds"] = state ? state.hostSystemIds : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["proactiveHaAutomationLevel"] = state ? state.proactiveHaAutomationLevel : undefined;
            resourceInputs["proactiveHaEnabled"] = state ? state.proactiveHaEnabled : undefined;
            resourceInputs["proactiveHaModerateRemediation"] = state ? state.proactiveHaModerateRemediation : undefined;
            resourceInputs["proactiveHaProviderIds"] = state ? state.proactiveHaProviderIds : undefined;
            resourceInputs["proactiveHaSevereRemediation"] = state ? state.proactiveHaSevereRemediation : undefined;
            resourceInputs["resourcePoolId"] = state ? state.resourcePoolId : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["vsanCompressionEnabled"] = state ? state.vsanCompressionEnabled : undefined;
            resourceInputs["vsanDedupEnabled"] = state ? state.vsanDedupEnabled : undefined;
            resourceInputs["vsanDiskGroups"] = state ? state.vsanDiskGroups : undefined;
            resourceInputs["vsanDitEncryptionEnabled"] = state ? state.vsanDitEncryptionEnabled : undefined;
            resourceInputs["vsanDitRekeyInterval"] = state ? state.vsanDitRekeyInterval : undefined;
            resourceInputs["vsanEnabled"] = state ? state.vsanEnabled : undefined;
            resourceInputs["vsanEsaEnabled"] = state ? state.vsanEsaEnabled : undefined;
            resourceInputs["vsanFaultDomains"] = state ? state.vsanFaultDomains : undefined;
            resourceInputs["vsanNetworkDiagnosticModeEnabled"] = state ? state.vsanNetworkDiagnosticModeEnabled : undefined;
            resourceInputs["vsanPerformanceEnabled"] = state ? state.vsanPerformanceEnabled : undefined;
            resourceInputs["vsanRemoteDatastoreIds"] = state ? state.vsanRemoteDatastoreIds : undefined;
            resourceInputs["vsanStretchedCluster"] = state ? state.vsanStretchedCluster : undefined;
            resourceInputs["vsanUnmapEnabled"] = state ? state.vsanUnmapEnabled : undefined;
            resourceInputs["vsanVerboseModeEnabled"] = state ? state.vsanVerboseModeEnabled : undefined;
        } else {
            const args = argsOrState as ComputeClusterArgs | undefined;
            if ((!args || args.datacenterId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'datacenterId'");
            }
            resourceInputs["customAttributes"] = args ? args.customAttributes : undefined;
            resourceInputs["datacenterId"] = args ? args.datacenterId : undefined;
            resourceInputs["dpmAutomationLevel"] = args ? args.dpmAutomationLevel : undefined;
            resourceInputs["dpmEnabled"] = args ? args.dpmEnabled : undefined;
            resourceInputs["dpmThreshold"] = args ? args.dpmThreshold : undefined;
            resourceInputs["drsAdvancedOptions"] = args ? args.drsAdvancedOptions : undefined;
            resourceInputs["drsAutomationLevel"] = args ? args.drsAutomationLevel : undefined;
            resourceInputs["drsEnablePredictiveDrs"] = args ? args.drsEnablePredictiveDrs : undefined;
            resourceInputs["drsEnableVmOverrides"] = args ? args.drsEnableVmOverrides : undefined;
            resourceInputs["drsEnabled"] = args ? args.drsEnabled : undefined;
            resourceInputs["drsMigrationThreshold"] = args ? args.drsMigrationThreshold : undefined;
            resourceInputs["drsScaleDescendantsShares"] = args ? args.drsScaleDescendantsShares : undefined;
            resourceInputs["folder"] = args ? args.folder : undefined;
            resourceInputs["forceEvacuateOnDestroy"] = args ? args.forceEvacuateOnDestroy : undefined;
            resourceInputs["haAdmissionControlFailoverHostSystemIds"] = args ? args.haAdmissionControlFailoverHostSystemIds : undefined;
            resourceInputs["haAdmissionControlHostFailureTolerance"] = args ? args.haAdmissionControlHostFailureTolerance : undefined;
            resourceInputs["haAdmissionControlPerformanceTolerance"] = args ? args.haAdmissionControlPerformanceTolerance : undefined;
            resourceInputs["haAdmissionControlPolicy"] = args ? args.haAdmissionControlPolicy : undefined;
            resourceInputs["haAdmissionControlResourcePercentageAutoCompute"] = args ? args.haAdmissionControlResourcePercentageAutoCompute : undefined;
            resourceInputs["haAdmissionControlResourcePercentageCpu"] = args ? args.haAdmissionControlResourcePercentageCpu : undefined;
            resourceInputs["haAdmissionControlResourcePercentageMemory"] = args ? args.haAdmissionControlResourcePercentageMemory : undefined;
            resourceInputs["haAdmissionControlSlotPolicyExplicitCpu"] = args ? args.haAdmissionControlSlotPolicyExplicitCpu : undefined;
            resourceInputs["haAdmissionControlSlotPolicyExplicitMemory"] = args ? args.haAdmissionControlSlotPolicyExplicitMemory : undefined;
            resourceInputs["haAdmissionControlSlotPolicyUseExplicitSize"] = args ? args.haAdmissionControlSlotPolicyUseExplicitSize : undefined;
            resourceInputs["haAdvancedOptions"] = args ? args.haAdvancedOptions : undefined;
            resourceInputs["haDatastoreApdRecoveryAction"] = args ? args.haDatastoreApdRecoveryAction : undefined;
            resourceInputs["haDatastoreApdResponse"] = args ? args.haDatastoreApdResponse : undefined;
            resourceInputs["haDatastoreApdResponseDelay"] = args ? args.haDatastoreApdResponseDelay : undefined;
            resourceInputs["haDatastorePdlResponse"] = args ? args.haDatastorePdlResponse : undefined;
            resourceInputs["haEnabled"] = args ? args.haEnabled : undefined;
            resourceInputs["haHeartbeatDatastoreIds"] = args ? args.haHeartbeatDatastoreIds : undefined;
            resourceInputs["haHeartbeatDatastorePolicy"] = args ? args.haHeartbeatDatastorePolicy : undefined;
            resourceInputs["haHostIsolationResponse"] = args ? args.haHostIsolationResponse : undefined;
            resourceInputs["haHostMonitoring"] = args ? args.haHostMonitoring : undefined;
            resourceInputs["haVmComponentProtection"] = args ? args.haVmComponentProtection : undefined;
            resourceInputs["haVmDependencyRestartCondition"] = args ? args.haVmDependencyRestartCondition : undefined;
            resourceInputs["haVmFailureInterval"] = args ? args.haVmFailureInterval : undefined;
            resourceInputs["haVmMaximumFailureWindow"] = args ? args.haVmMaximumFailureWindow : undefined;
            resourceInputs["haVmMaximumResets"] = args ? args.haVmMaximumResets : undefined;
            resourceInputs["haVmMinimumUptime"] = args ? args.haVmMinimumUptime : undefined;
            resourceInputs["haVmMonitoring"] = args ? args.haVmMonitoring : undefined;
            resourceInputs["haVmRestartAdditionalDelay"] = args ? args.haVmRestartAdditionalDelay : undefined;
            resourceInputs["haVmRestartPriority"] = args ? args.haVmRestartPriority : undefined;
            resourceInputs["haVmRestartTimeout"] = args ? args.haVmRestartTimeout : undefined;
            resourceInputs["hostClusterExitTimeout"] = args ? args.hostClusterExitTimeout : undefined;
            resourceInputs["hostImage"] = args ? args.hostImage : undefined;
            resourceInputs["hostManaged"] = args ? args.hostManaged : undefined;
            resourceInputs["hostSystemIds"] = args ? args.hostSystemIds : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["proactiveHaAutomationLevel"] = args ? args.proactiveHaAutomationLevel : undefined;
            resourceInputs["proactiveHaEnabled"] = args ? args.proactiveHaEnabled : undefined;
            resourceInputs["proactiveHaModerateRemediation"] = args ? args.proactiveHaModerateRemediation : undefined;
            resourceInputs["proactiveHaProviderIds"] = args ? args.proactiveHaProviderIds : undefined;
            resourceInputs["proactiveHaSevereRemediation"] = args ? args.proactiveHaSevereRemediation : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["vsanCompressionEnabled"] = args ? args.vsanCompressionEnabled : undefined;
            resourceInputs["vsanDedupEnabled"] = args ? args.vsanDedupEnabled : undefined;
            resourceInputs["vsanDiskGroups"] = args ? args.vsanDiskGroups : undefined;
            resourceInputs["vsanDitEncryptionEnabled"] = args ? args.vsanDitEncryptionEnabled : undefined;
            resourceInputs["vsanDitRekeyInterval"] = args ? args.vsanDitRekeyInterval : undefined;
            resourceInputs["vsanEnabled"] = args ? args.vsanEnabled : undefined;
            resourceInputs["vsanEsaEnabled"] = args ? args.vsanEsaEnabled : undefined;
            resourceInputs["vsanFaultDomains"] = args ? args.vsanFaultDomains : undefined;
            resourceInputs["vsanNetworkDiagnosticModeEnabled"] = args ? args.vsanNetworkDiagnosticModeEnabled : undefined;
            resourceInputs["vsanPerformanceEnabled"] = args ? args.vsanPerformanceEnabled : undefined;
            resourceInputs["vsanRemoteDatastoreIds"] = args ? args.vsanRemoteDatastoreIds : undefined;
            resourceInputs["vsanStretchedCluster"] = args ? args.vsanStretchedCluster : undefined;
            resourceInputs["vsanUnmapEnabled"] = args ? args.vsanUnmapEnabled : undefined;
            resourceInputs["vsanVerboseModeEnabled"] = args ? args.vsanVerboseModeEnabled : undefined;
            resourceInputs["resourcePoolId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ComputeCluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ComputeCluster resources.
 */
export interface ComputeClusterState {
    /**
     * A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster.
     *
     * > **NOTE:** Custom attributes are unsupported on direct ESXi connections
     * and require vCenter Server.
     */
    customAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The managed object ID of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     */
    datacenterId?: pulumi.Input<string>;
    /**
     * The automation level for host power operations in this cluster. Can be one of manual or automated.
     */
    dpmAutomationLevel?: pulumi.Input<string>;
    /**
     * Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual
     * machines in the cluster. Requires that DRS be enabled.
     */
    dpmEnabled?: pulumi.Input<boolean>;
    /**
     * A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This
     * affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher
     * setting.
     */
    dpmThreshold?: pulumi.Input<number>;
    /**
     * Advanced configuration options for DRS and DPM.
     */
    drsAdvancedOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or
     * fullyAutomated.
     */
    drsAutomationLevel?: pulumi.Input<string>;
    /**
     * When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     */
    drsEnablePredictiveDrs?: pulumi.Input<boolean>;
    /**
     * When true, allows individual VM overrides within this cluster to be set.
     */
    drsEnableVmOverrides?: pulumi.Input<boolean>;
    /**
     * Enable DRS for this cluster.
     */
    drsEnabled?: pulumi.Input<boolean>;
    /**
     * A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate
     * more imbalance while a higher setting will tolerate less.
     */
    drsMigrationThreshold?: pulumi.Input<number>;
    /**
     * Enable scalable shares for all descendants of this cluster.
     */
    drsScaleDescendantsShares?: pulumi.Input<string>;
    /**
     * The relative path to a folder to put this cluster in.
     * This is a path relative to the datacenter you are deploying the cluster to.
     * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
     * The provider will place a cluster named `compute-cluster-test` in a
     * host folder located at `/dc1/host/foo/bar`, with the final inventory path
     * being `/dc1/host/foo/bar/datastore-cluster-test`.
     */
    folder?: pulumi.Input<string>;
    /**
     * Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists
     * for testing and is not recommended in normal use.
     */
    forceEvacuateOnDestroy?: pulumi.Input<boolean>;
    /**
     * When haAdmissionControlPolicy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated
     * failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS
     * will ignore the host when making recommendations.
     */
    haAdmissionControlFailoverHostSystemIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual
     * machine operations. The maximum is one less than the number of hosts in the cluster.
     */
    haAdmissionControlHostFailureTolerance?: pulumi.Input<number>;
    /**
     * The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces
     * warnings only, whereas a value of 100 disables the setting.
     */
    haAdmissionControlPerformanceTolerance?: pulumi.Input<number>;
    /**
     * The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are
     * permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,
     * slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service
     * issues.
     */
    haAdmissionControlPolicy?: pulumi.Input<string>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, automatically determine available resource percentages by
     * subtracting the average number of host resources represented by the haAdmissionControlHostFailureTolerance setting from
     * the total amount of resources in the cluster. Disable to supply user-defined values.
     */
    haAdmissionControlResourcePercentageAutoCompute?: pulumi.Input<boolean>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of CPU resources in the
     * cluster to reserve for failover.
     */
    haAdmissionControlResourcePercentageCpu?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of memory resources in
     * the cluster to reserve for failover.
     */
    haAdmissionControlResourcePercentageMemory?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     */
    haAdmissionControlSlotPolicyExplicitCpu?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined memory slot size, in MB.
     */
    haAdmissionControlSlotPolicyExplicitMemory?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this setting controls whether or not you wish to supply explicit values to
     * CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines
     * currently in the cluster.
     */
    haAdmissionControlSlotPolicyUseExplicitSize?: pulumi.Input<boolean>;
    /**
     * Advanced configuration options for vSphere HA.
     */
    haAdvancedOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines if an APD status on an affected
     * datastore clears in the middle of an APD event. Can be one of none or reset.
     */
    haDatastoreApdRecoveryAction?: pulumi.Input<string>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected
     * loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
     */
    haDatastoreApdResponse?: pulumi.Input<string>;
    /**
     * When haVmComponentProtection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the
     * response action defined in ha_datastore_apd_response.
     */
    haDatastoreApdResponseDelay?: pulumi.Input<number>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected a
     * permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     */
    haDatastorePdlResponse?: pulumi.Input<string>;
    /**
     * Enable vSphere HA for this cluster.
     */
    haEnabled?: pulumi.Input<boolean>;
    /**
     * The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when
     * haHeartbeatDatastorePolicy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     */
    haHeartbeatDatastoreIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or
     * allFeasibleDsWithUserPreference.
     */
    haHeartbeatDatastorePolicy?: pulumi.Input<string>;
    /**
     * The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.
     * Can be one of none, powerOff, or shutdown.
     */
    haHostIsolationResponse?: pulumi.Input<string>;
    /**
     * Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     */
    haHostMonitoring?: pulumi.Input<string>;
    /**
     * Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to
     * failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     */
    haVmComponentProtection?: pulumi.Input<string>;
    /**
     * The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move
     * on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     */
    haVmDependencyRestartCondition?: pulumi.Input<string>;
    /**
     * If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as
     * failed. The value is in seconds.
     */
    haVmFailureInterval?: pulumi.Input<number>;
    /**
     * The length of the reset window in which haVmMaximumResets can operate. When this window expires, no more resets are
     * attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset
     * time is allotted.
     */
    haVmMaximumFailureWindow?: pulumi.Input<number>;
    /**
     * The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     */
    haVmMaximumResets?: pulumi.Input<number>;
    /**
     * The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     */
    haVmMinimumUptime?: pulumi.Input<number>;
    /**
     * The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,
     * vmMonitoringOnly, or vmAndAppMonitoring.
     */
    haVmMonitoring?: pulumi.Input<string>;
    /**
     * Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     */
    haVmRestartAdditionalDelay?: pulumi.Input<number>;
    /**
     * The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,
     * high, or highest.
     */
    haVmRestartPriority?: pulumi.Input<string>;
    /**
     * The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before
     * proceeding with the next priority.
     */
    haVmRestartTimeout?: pulumi.Input<number>;
    /**
     * The timeout for each host maintenance mode operation when removing hosts from a cluster.
     */
    hostClusterExitTimeout?: pulumi.Input<number>;
    /**
     * Details about the host image which should be applied to the cluster.
     */
    hostImage?: pulumi.Input<inputs.ComputeClusterHostImage>;
    /**
     * Must be set if cluster enrollment is managed from host resource.
     */
    hostManaged?: pulumi.Input<boolean>;
    /**
     * The managed object IDs of the hosts to put in the cluster.
     */
    hostSystemIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     */
    proactiveHaAutomationLevel?: pulumi.Input<string>;
    /**
     * Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     */
    proactiveHaEnabled?: pulumi.Input<boolean>;
    /**
     * The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that
     * this cannot be set to MaintenanceMode when proactiveHaSevereRemediation is set to QuarantineMode.
     */
    proactiveHaModerateRemediation?: pulumi.Input<string>;
    /**
     * The list of IDs for health update providers configured for this cluster.
     */
    proactiveHaProviderIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this
     * cannot be set to QuarantineMode when proactiveHaModerateRemediation is set to MaintenanceMode.
     */
    proactiveHaSevereRemediation?: pulumi.Input<string>;
    /**
     * The managed object ID of the primary
     * resource pool for this cluster. This can be passed directly to the
     * `resourcePoolId`
     * attribute of the
     * `vsphere.VirtualMachine` resource.
     */
    resourcePoolId?: pulumi.Input<string>;
    /**
     * The IDs of any tags to attach to this resource.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether the vSAN compression service is enabled for the cluster.
     */
    vsanCompressionEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN deduplication service is enabled for the cluster.
     */
    vsanDedupEnabled?: pulumi.Input<boolean>;
    /**
     * A list of disk UUIDs to add to the vSAN cluster.
     */
    vsanDiskGroups?: pulumi.Input<pulumi.Input<inputs.ComputeClusterVsanDiskGroup>[]>;
    /**
     * Whether the vSAN data-in-transit encryption is enabled for the cluster.
     */
    vsanDitEncryptionEnabled?: pulumi.Input<boolean>;
    /**
     * When vsanDitEncryptionEnabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     */
    vsanDitRekeyInterval?: pulumi.Input<number>;
    /**
     * Whether the vSAN service is enabled for the cluster.
     */
    vsanEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN ESA service is enabled for the cluster.
     */
    vsanEsaEnabled?: pulumi.Input<boolean>;
    /**
     * The configuration for vSAN fault domains.
     */
    vsanFaultDomains?: pulumi.Input<pulumi.Input<inputs.ComputeClusterVsanFaultDomain>[]>;
    /**
     * Whether the vSAN network diagnostic mode is enabled for the cluster.
     */
    vsanNetworkDiagnosticModeEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN performance service is enabled for the cluster.
     */
    vsanPerformanceEnabled?: pulumi.Input<boolean>;
    /**
     * The managed object IDs of the vSAN datastore to be mounted on the cluster.
     */
    vsanRemoteDatastoreIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The configuration for stretched cluster.
     */
    vsanStretchedCluster?: pulumi.Input<inputs.ComputeClusterVsanStretchedCluster>;
    /**
     * Whether the vSAN unmap service is enabled for the cluster.
     */
    vsanUnmapEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN verbose mode is enabled for the cluster.
     */
    vsanVerboseModeEnabled?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a ComputeCluster resource.
 */
export interface ComputeClusterArgs {
    /**
     * A map of custom attribute ids to attribute
     * value strings to set for the datastore cluster.
     *
     * > **NOTE:** Custom attributes are unsupported on direct ESXi connections
     * and require vCenter Server.
     */
    customAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The managed object ID of
     * the datacenter to create the cluster in. Forces a new resource if changed.
     */
    datacenterId: pulumi.Input<string>;
    /**
     * The automation level for host power operations in this cluster. Can be one of manual or automated.
     */
    dpmAutomationLevel?: pulumi.Input<string>;
    /**
     * Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual
     * machines in the cluster. Requires that DRS be enabled.
     */
    dpmEnabled?: pulumi.Input<boolean>;
    /**
     * A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This
     * affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher
     * setting.
     */
    dpmThreshold?: pulumi.Input<number>;
    /**
     * Advanced configuration options for DRS and DPM.
     */
    drsAdvancedOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or
     * fullyAutomated.
     */
    drsAutomationLevel?: pulumi.Input<string>;
    /**
     * When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.
     */
    drsEnablePredictiveDrs?: pulumi.Input<boolean>;
    /**
     * When true, allows individual VM overrides within this cluster to be set.
     */
    drsEnableVmOverrides?: pulumi.Input<boolean>;
    /**
     * Enable DRS for this cluster.
     */
    drsEnabled?: pulumi.Input<boolean>;
    /**
     * A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate
     * more imbalance while a higher setting will tolerate less.
     */
    drsMigrationThreshold?: pulumi.Input<number>;
    /**
     * Enable scalable shares for all descendants of this cluster.
     */
    drsScaleDescendantsShares?: pulumi.Input<string>;
    /**
     * The relative path to a folder to put this cluster in.
     * This is a path relative to the datacenter you are deploying the cluster to.
     * Example: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,
     * The provider will place a cluster named `compute-cluster-test` in a
     * host folder located at `/dc1/host/foo/bar`, with the final inventory path
     * being `/dc1/host/foo/bar/datastore-cluster-test`.
     */
    folder?: pulumi.Input<string>;
    /**
     * Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists
     * for testing and is not recommended in normal use.
     */
    forceEvacuateOnDestroy?: pulumi.Input<boolean>;
    /**
     * When haAdmissionControlPolicy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated
     * failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS
     * will ignore the host when making recommendations.
     */
    haAdmissionControlFailoverHostSystemIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual
     * machine operations. The maximum is one less than the number of hosts in the cluster.
     */
    haAdmissionControlHostFailureTolerance?: pulumi.Input<number>;
    /**
     * The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces
     * warnings only, whereas a value of 100 disables the setting.
     */
    haAdmissionControlPerformanceTolerance?: pulumi.Input<number>;
    /**
     * The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are
     * permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,
     * slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service
     * issues.
     */
    haAdmissionControlPolicy?: pulumi.Input<string>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, automatically determine available resource percentages by
     * subtracting the average number of host resources represented by the haAdmissionControlHostFailureTolerance setting from
     * the total amount of resources in the cluster. Disable to supply user-defined values.
     */
    haAdmissionControlResourcePercentageAutoCompute?: pulumi.Input<boolean>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of CPU resources in the
     * cluster to reserve for failover.
     */
    haAdmissionControlResourcePercentageCpu?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is resourcePercentage, this controls the user-defined percentage of memory resources in
     * the cluster to reserve for failover.
     */
    haAdmissionControlResourcePercentageMemory?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined CPU slot size, in MHz.
     */
    haAdmissionControlSlotPolicyExplicitCpu?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this controls the user-defined memory slot size, in MB.
     */
    haAdmissionControlSlotPolicyExplicitMemory?: pulumi.Input<number>;
    /**
     * When haAdmissionControlPolicy is slotPolicy, this setting controls whether or not you wish to supply explicit values to
     * CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines
     * currently in the cluster.
     */
    haAdmissionControlSlotPolicyUseExplicitSize?: pulumi.Input<boolean>;
    /**
     * Advanced configuration options for vSphere HA.
     */
    haAdvancedOptions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines if an APD status on an affected
     * datastore clears in the middle of an APD event. Can be one of none or reset.
     */
    haDatastoreApdRecoveryAction?: pulumi.Input<string>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected
     * loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive.
     */
    haDatastoreApdResponse?: pulumi.Input<string>;
    /**
     * When haVmComponentProtection is enabled, controls the delay in seconds to wait after an APD timeout event to execute the
     * response action defined in ha_datastore_apd_response.
     */
    haDatastoreApdResponseDelay?: pulumi.Input<number>;
    /**
     * When haVmComponentProtection is enabled, controls the action to take on virtual machines when the cluster has detected a
     * permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.
     */
    haDatastorePdlResponse?: pulumi.Input<string>;
    /**
     * Enable vSphere HA for this cluster.
     */
    haEnabled?: pulumi.Input<boolean>;
    /**
     * The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when
     * haHeartbeatDatastorePolicy is set to either userSelectedDs or allFeasibleDsWithUserPreference.
     */
    haHeartbeatDatastoreIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or
     * allFeasibleDsWithUserPreference.
     */
    haHeartbeatDatastorePolicy?: pulumi.Input<string>;
    /**
     * The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.
     * Can be one of none, powerOff, or shutdown.
     */
    haHostIsolationResponse?: pulumi.Input<string>;
    /**
     * Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.
     */
    haHostMonitoring?: pulumi.Input<string>;
    /**
     * Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to
     * failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.
     */
    haVmComponentProtection?: pulumi.Input<string>;
    /**
     * The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move
     * on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.
     */
    haVmDependencyRestartCondition?: pulumi.Input<string>;
    /**
     * If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as
     * failed. The value is in seconds.
     */
    haVmFailureInterval?: pulumi.Input<number>;
    /**
     * The length of the reset window in which haVmMaximumResets can operate. When this window expires, no more resets are
     * attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset
     * time is allotted.
     */
    haVmMaximumFailureWindow?: pulumi.Input<number>;
    /**
     * The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.
     */
    haVmMaximumResets?: pulumi.Input<number>;
    /**
     * The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.
     */
    haVmMinimumUptime?: pulumi.Input<number>;
    /**
     * The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,
     * vmMonitoringOnly, or vmAndAppMonitoring.
     */
    haVmMonitoring?: pulumi.Input<string>;
    /**
     * Additional delay in seconds after ready condition is met. A VM is considered ready at this point.
     */
    haVmRestartAdditionalDelay?: pulumi.Input<number>;
    /**
     * The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,
     * high, or highest.
     */
    haVmRestartPriority?: pulumi.Input<string>;
    /**
     * The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before
     * proceeding with the next priority.
     */
    haVmRestartTimeout?: pulumi.Input<number>;
    /**
     * The timeout for each host maintenance mode operation when removing hosts from a cluster.
     */
    hostClusterExitTimeout?: pulumi.Input<number>;
    /**
     * Details about the host image which should be applied to the cluster.
     */
    hostImage?: pulumi.Input<inputs.ComputeClusterHostImage>;
    /**
     * Must be set if cluster enrollment is managed from host resource.
     */
    hostManaged?: pulumi.Input<boolean>;
    /**
     * The managed object IDs of the hosts to put in the cluster.
     */
    hostSystemIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.
     */
    proactiveHaAutomationLevel?: pulumi.Input<string>;
    /**
     * Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.
     */
    proactiveHaEnabled?: pulumi.Input<boolean>;
    /**
     * The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that
     * this cannot be set to MaintenanceMode when proactiveHaSevereRemediation is set to QuarantineMode.
     */
    proactiveHaModerateRemediation?: pulumi.Input<string>;
    /**
     * The list of IDs for health update providers configured for this cluster.
     */
    proactiveHaProviderIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this
     * cannot be set to QuarantineMode when proactiveHaModerateRemediation is set to MaintenanceMode.
     */
    proactiveHaSevereRemediation?: pulumi.Input<string>;
    /**
     * The IDs of any tags to attach to this resource.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether the vSAN compression service is enabled for the cluster.
     */
    vsanCompressionEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN deduplication service is enabled for the cluster.
     */
    vsanDedupEnabled?: pulumi.Input<boolean>;
    /**
     * A list of disk UUIDs to add to the vSAN cluster.
     */
    vsanDiskGroups?: pulumi.Input<pulumi.Input<inputs.ComputeClusterVsanDiskGroup>[]>;
    /**
     * Whether the vSAN data-in-transit encryption is enabled for the cluster.
     */
    vsanDitEncryptionEnabled?: pulumi.Input<boolean>;
    /**
     * When vsanDitEncryptionEnabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).
     */
    vsanDitRekeyInterval?: pulumi.Input<number>;
    /**
     * Whether the vSAN service is enabled for the cluster.
     */
    vsanEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN ESA service is enabled for the cluster.
     */
    vsanEsaEnabled?: pulumi.Input<boolean>;
    /**
     * The configuration for vSAN fault domains.
     */
    vsanFaultDomains?: pulumi.Input<pulumi.Input<inputs.ComputeClusterVsanFaultDomain>[]>;
    /**
     * Whether the vSAN network diagnostic mode is enabled for the cluster.
     */
    vsanNetworkDiagnosticModeEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN performance service is enabled for the cluster.
     */
    vsanPerformanceEnabled?: pulumi.Input<boolean>;
    /**
     * The managed object IDs of the vSAN datastore to be mounted on the cluster.
     */
    vsanRemoteDatastoreIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The configuration for stretched cluster.
     */
    vsanStretchedCluster?: pulumi.Input<inputs.ComputeClusterVsanStretchedCluster>;
    /**
     * Whether the vSAN unmap service is enabled for the cluster.
     */
    vsanUnmapEnabled?: pulumi.Input<boolean>;
    /**
     * Whether the vSAN verbose mode is enabled for the cluster.
     */
    vsanVerboseModeEnabled?: pulumi.Input<boolean>;
}
