{
    "name": "vsphere",
    "description": "A Pulumi package for creating vsphere resources",
    "keywords": [
        "pulumi",
        "vsphere"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vsphere` Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere).",
    "repository": "https://github.com/pulumi/pulumi-vsphere",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "vsphere": "VSphere"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0",
                "builtin-modules": "3.0.0",
                "read-package-tree": "^5.2.1",
                "resolve": "^1.8.1"
            },
            "devDependencies": {
                "@types/node": "^10.9.2"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating vsphere resources",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vsphere` repo](https://github.com/pulumi/pulumi-vsphere/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vsphere` repo](https://github.com/hashicorp/terraform-provider-vsphere/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vsphere` repo](https://github.com/pulumi/pulumi-vsphere/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vsphere` repo](https://github.com/hashicorp/terraform-provider-vsphere/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "defaults": [
            "password",
            "user"
        ]
    },
    "types": {
        "vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup": {
            "properties": {
                "cache": {
                    "type": "string",
                    "description": "The canonical name of the disk to use for vSAN cache.\n"
                },
                "storages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of disk canonical names for vSAN storage.\n\n\u003e **NOTE:** You must disable vSphere HA before you enable vSAN on the cluster.\nYou can enable or re-enable vSphere HA after vSAN is configured.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst computeCluster = new vsphere.ComputeCluster(\"computeCluster\", {\n    datacenterId: data.vsphere_datacenter.datacenter.id,\n    hostSystemIds: [data.vsphere_host.host.map(__item =\u003e __item.id)],\n    drsEnabled: true,\n    drsAutomationLevel: \"fullyAutomated\",\n    haEnabled: false,\n    vsanEnabled: true,\n    vsanDedupEnabled: true,\n    vsanCompressionEnabled: true,\n    vsanPerformanceEnabled: true,\n    vsanVerboseModeEnabled: true,\n    vsanNetworkDiagnosticModeEnabled: true,\n    vsanUnmapEnabled: true,\n    vsanDitEncryptionEnabled: true,\n    vsanDitRekeyInterval: 1800,\n    vsanDiskGroups: [{\n        cache: data.vsphere_vmfs_disks.cache_disks[0],\n        storages: data.vsphere_vmfs_disks.storage_disks,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncompute_cluster = vsphere.ComputeCluster(\"computeCluster\",\n    datacenter_id=data[\"vsphere_datacenter\"][\"datacenter\"][\"id\"],\n    host_system_ids=[[__item[\"id\"] for __item in data[\"vsphere_host\"][\"host\"]]],\n    drs_enabled=True,\n    drs_automation_level=\"fullyAutomated\",\n    ha_enabled=False,\n    vsan_enabled=True,\n    vsan_dedup_enabled=True,\n    vsan_compression_enabled=True,\n    vsan_performance_enabled=True,\n    vsan_verbose_mode_enabled=True,\n    vsan_network_diagnostic_mode_enabled=True,\n    vsan_unmap_enabled=True,\n    vsan_dit_encryption_enabled=True,\n    vsan_dit_rekey_interval=1800,\n    vsan_disk_groups=[vsphere.ComputeClusterVsanDiskGroupArgs(\n        cache=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n        storages=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var computeCluster = new VSphere.ComputeCluster(\"computeCluster\", new()\n    {\n        DatacenterId = data.Vsphere_datacenter.Datacenter.Id,\n        HostSystemIds = new[]\n        {\n            data.Vsphere_host.Host.Select(__item =\u003e __item.Id).ToList(),\n        },\n        DrsEnabled = true,\n        DrsAutomationLevel = \"fullyAutomated\",\n        HaEnabled = false,\n        VsanEnabled = true,\n        VsanDedupEnabled = true,\n        VsanCompressionEnabled = true,\n        VsanPerformanceEnabled = true,\n        VsanVerboseModeEnabled = true,\n        VsanNetworkDiagnosticModeEnabled = true,\n        VsanUnmapEnabled = true,\n        VsanDitEncryptionEnabled = true,\n        VsanDitRekeyInterval = 1800,\n        VsanDiskGroups = new[]\n        {\n            new VSphere.Inputs.ComputeClusterVsanDiskGroupArgs\n            {\n                Cache = data.Vsphere_vmfs_disks.Cache_disks[0],\n                Storages = data.Vsphere_vmfs_disks.Storage_disks,\n            },\n        },\n    });\n\n});\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.ComputeCluster;\nimport com.pulumi.vsphere.ComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.ComputeClusterVsanDiskGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var computeCluster = new ComputeCluster(\"computeCluster\", ComputeClusterArgs.builder()        \n            .datacenterId(data.vsphere_datacenter().datacenter().id())\n            .hostSystemIds(data.vsphere_host().host().stream().map(element -\u003e element.id()).collect(toList()))\n            .drsEnabled(true)\n            .drsAutomationLevel(\"fullyAutomated\")\n            .haEnabled(false)\n            .vsanEnabled(true)\n            .vsanDedupEnabled(true)\n            .vsanCompressionEnabled(true)\n            .vsanPerformanceEnabled(true)\n            .vsanVerboseModeEnabled(true)\n            .vsanNetworkDiagnosticModeEnabled(true)\n            .vsanUnmapEnabled(true)\n            .vsanDitEncryptionEnabled(true)\n            .vsanDitRekeyInterval(1800)\n            .vsanDiskGroups(ComputeClusterVsanDiskGroupArgs.builder()\n                .cache(data.vsphere_vmfs_disks().cache_disks()[0])\n                .storages(data.vsphere_vmfs_disks().storage_disks())\n                .build())\n            .build());\n\n    }\n}\n```\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/ContentLibraryPublication:ContentLibraryPublication": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "Password used for authentication.\n",
                    "willReplaceOnChanges": true
                },
                "publishUrl": {
                    "type": "string",
                    "description": "The URL of the published content library.\n",
                    "willReplaceOnChanges": true
                },
                "published": {
                    "type": "boolean",
                    "description": "Publish the content library. Default `false`.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Username used for authentication.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "password",
                        "publishUrl",
                        "username"
                    ]
                }
            }
        },
        "vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.\n",
                    "willReplaceOnChanges": true
                },
                "automaticSync": {
                    "type": "boolean",
                    "description": "Enable automatic synchronization with the published library. Default `false`.\n",
                    "willReplaceOnChanges": true
                },
                "onDemand": {
                    "type": "boolean",
                    "description": "Download the library from a content only when needed. Default `true`.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "Password used for authentication.\n",
                    "willReplaceOnChanges": true
                },
                "subscriptionUrl": {
                    "type": "string",
                    "description": "URL of the published content library.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Username used for authentication.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "password",
                        "username"
                    ]
                }
            }
        },
        "vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer"
                },
                "minVlan": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost": {
            "properties": {
                "devices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of NIC devices to map to uplinks on the VDS,\nadded in order they are specified.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The host system ID of the host to add to the\nVDS.\n"
                }
            },
            "type": "object",
            "required": [
                "hostSystemId"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping": {
            "properties": {
                "primaryVlanId": {
                    "type": "integer",
                    "description": "The primary VLAN ID. The VLAN IDs of 0 and\n4095 are reserved and cannot be used in this property.\n"
                },
                "pvlanType": {
                    "type": "string",
                    "description": "The private VLAN type. Valid values are\npromiscuous, community and isolated.\n"
                },
                "secondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID. The VLAN IDs of 0\nand 4095 are reserved and cannot be used in this property.\n"
                }
            },
            "type": "object",
            "required": [
                "primaryVlanId",
                "pvlanType",
                "secondaryVlanId"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer"
                },
                "minVlan": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission": {
            "properties": {
                "isGroup": {
                    "type": "boolean",
                    "description": "Whether user_or_group field refers to a user or a group. True for a group and false for a user.\n"
                },
                "propagate": {
                    "type": "boolean",
                    "description": "Whether or not this permission propagates down the hierarchy to sub-entities.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The role id of the role to be given to the user on the specified entity.\n"
                },
                "userOrGroup": {
                    "type": "string",
                    "description": "The user/group getting the permission.\n"
                }
            },
            "type": "object",
            "required": [
                "isGroup",
                "propagate",
                "roleId",
                "userOrGroup"
            ]
        },
        "vsphere:index/HostPortGroupPort:HostPortGroupPort": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n"
                },
                "macAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "macAddresses",
                        "type"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom": {
            "properties": {
                "clientDevice": {
                    "type": "boolean",
                    "description": "Indicates whether the device should be backed by remote client device. Conflicts with `datastore_id` and `path`.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The managed object reference ID of the datastore in which to place the virtual machine. The virtual machine configuration files is placed here, along with any virtual disks that are created where a datastore is not explicitly specified. See the section on virtual machine migration for more information on modifying this value.\n\n\u003e **NOTE:** Datastores cannot be assigned to individual disks when `datastore_cluster_id` is used.\n"
                },
                "deviceAddress": {
                    "type": "string"
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n"
                },
                "path": {
                    "type": "string",
                    "description": "When using `attach`, this parameter controls the path of a virtual disk to attach externally. Otherwise, it is a computed attribute that contains the virtual disk filename.\n\n\u003e **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .\n\n\u003e **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceAddress",
                        "key"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineClone:VirtualMachineClone": {
            "properties": {
                "customize": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize"
                },
                "linkedClone": {
                    "type": "boolean"
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "ovfStorageMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "templateUuid": {
                    "type": "string"
                },
                "timeout": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "templateUuid"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize": {
            "properties": {
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "dnsSuffixLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ipv4Gateway": {
                    "type": "string"
                },
                "ipv6Gateway": {
                    "type": "string"
                },
                "linuxOptions": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on the virtual machine. See network interface options for more information.\n"
                },
                "timeout": {
                    "type": "integer"
                },
                "windowsOptions": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions"
                },
                "windowsSysprepText": {
                    "type": "string",
                    "secret": true
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions": {
            "properties": {
                "domain": {
                    "type": "string"
                },
                "hostName": {
                    "type": "string"
                },
                "hwClockUtc": {
                    "type": "boolean"
                },
                "scriptText": {
                    "type": "string",
                    "secret": true
                },
                "timeZone": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "domain",
                "hostName"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface": {
            "properties": {
                "dnsDomain": {
                    "type": "string"
                },
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "ipv4Address": {
                    "type": "string"
                },
                "ipv4Netmask": {
                    "type": "integer"
                },
                "ipv6Address": {
                    "type": "string"
                },
                "ipv6Netmask": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "secret": true
                },
                "autoLogon": {
                    "type": "boolean"
                },
                "autoLogonCount": {
                    "type": "integer"
                },
                "computerName": {
                    "type": "string"
                },
                "domainAdminPassword": {
                    "type": "string",
                    "secret": true
                },
                "domainAdminUser": {
                    "type": "string"
                },
                "fullName": {
                    "type": "string"
                },
                "joinDomain": {
                    "type": "string"
                },
                "organizationName": {
                    "type": "string"
                },
                "productKey": {
                    "type": "string",
                    "secret": true
                },
                "runOnceCommandLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "timeZone": {
                    "type": "integer"
                },
                "workgroup": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "computerName"
            ]
        },
        "vsphere:index/VirtualMachineDisk:VirtualMachineDisk": {
            "properties": {
                "attach": {
                    "type": "boolean",
                    "description": "Attach an external disk instead of creating a new one. Implies and conflicts with `keep_on_remove`. If set, you cannot set `size`, `eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.\n\n\u003e **NOTE:** External disks cannot be attached when `datastore_cluster_id` is used.\n"
                },
                "controllerType": {
                    "type": "string",
                    "description": "The type of storage controller to attach the  disk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate number of controllers enabled for the selected type. Default `scsi`.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The managed object reference ID of the datastore in which to place the virtual machine. The virtual machine configuration files is placed here, along with any virtual disks that are created where a datastore is not explicitly specified. See the section on virtual machine migration for more information on modifying this value.\n\n\u003e **NOTE:** Datastores cannot be assigned to individual disks when `datastore_cluster_id` is used.\n"
                },
                "deviceAddress": {
                    "type": "string"
                },
                "diskMode": {
                    "type": "string",
                    "description": "The mode of this this virtual disk for purposes of writes and snapshots. One of `append`, `independent_nonpersistent`, `independent_persistent`, `nonpersistent`, `persistent`, or `undoable`. Default: `persistent`. For more information on these option, please refer to the [product documentation][vmware-docs-disk-mode].\n\n[vmware-docs-disk-mode]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.device.VirtualDiskOption.DiskMode.html\n"
                },
                "diskSharing": {
                    "type": "string",
                    "description": "The sharing mode of this virtual disk. One of `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.\n\n\u003e **NOTE:** Disk sharing is only available on vSphere 6.0 and later.\n"
                },
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "If set to `true`, the disk space is zeroed out when the virtual machine is created. This will delay the creation of the virtual disk. Cannot be set to `true` when `thin_provisioned` is `true`.  See the section on picking a disk type for more information.  Default: `false`.\n"
                },
                "ioLimit": {
                    "type": "integer",
                    "description": "The upper limit of IOPS that this disk can use. The default is no limit.\n"
                },
                "ioReservation": {
                    "type": "integer",
                    "description": "The I/O reservation (guarantee) for the virtual disk has, in IOPS.  The default is no reservation.\n"
                },
                "ioShareCount": {
                    "type": "integer",
                    "description": "The share count for the virtual disk when the share level is `custom`.\n"
                },
                "ioShareLevel": {
                    "type": "string",
                    "description": "The share allocation level for the virtual disk. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.\n"
                },
                "keepOnRemove": {
                    "type": "boolean",
                    "description": "Keep this disk when removing the device or destroying the virtual machine. Default: `false`.\n"
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n"
                },
                "label": {
                    "type": "string"
                },
                "path": {
                    "type": "string",
                    "description": "When using `attach`, this parameter controls the path of a virtual disk to attach externally. Otherwise, it is a computed attribute that contains the virtual disk filename.\n\n\u003e **NOTE:** Either `client_device` (for a remote backed CD-ROM) or `datastore_id` and `path` (for a datastore ISO backed CD-ROM) are required to .\n\n\u003e **NOTE:** Some CD-ROM drive types are not supported by this resource, such as pass-through devices. If these drives are present in a cloned template, or added outside of the provider, the desired state will be corrected to the defined device, or removed if no `cdrom` block is present.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GB. Must be a whole number.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The ID of the storage policy to assign to the home directory of a virtual machine.\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "If `true`, the disk is thin provisioned, with space for the file being allocated on an as-needed basis. Cannot be set to `true` when `eagerly_scrub` is `true`. See the section on selecting a disk type for more information. Default: `true`.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The disk number on the storage bus. The maximum value for this setting is the value of the controller count times the controller capacity (15 for SCSI, 30 for SATA, and 2 for IDE). Duplicate unit numbers are not allowed. Default `0`, for which one disk must be set to.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.\n"
                },
                "writeThrough": {
                    "type": "boolean",
                    "description": "If `true`, writes for this disk are sent directly to the filesystem immediately instead of being buffered. Default: `false`.\n"
                }
            },
            "type": "object",
            "required": [
                "label"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "datastoreId",
                        "deviceAddress",
                        "key",
                        "label",
                        "path",
                        "storagePolicyId",
                        "uuid"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The network interface type. One of `e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.\n"
                },
                "bandwidthLimit": {
                    "type": "integer",
                    "description": "The upper bandwidth limit of the network interface, in Mbits/sec. The default is no limit.\n"
                },
                "bandwidthReservation": {
                    "type": "integer",
                    "description": "The bandwidth reservation of the network interface, in Mbits/sec. The default is no reservation.\n"
                },
                "bandwidthShareCount": {
                    "type": "integer",
                    "description": "The share count for the network interface when the share level is `custom`.\n"
                },
                "bandwidthShareLevel": {
                    "type": "string",
                    "description": "The bandwidth share allocation level for the network interface. One of `low`, `normal`, `high`, or `custom`. Default: `normal`.\n"
                },
                "deviceAddress": {
                    "type": "string"
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of the network interface. Can only be manually set if `use_static_mac` is `true`. Otherwise, the value is computed and presents the assigned MAC address for the interface.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The [managed object reference ID][docs-about-morefs] of the network on which to connect the virtual machine network interface.\n"
                },
                "ovfMapping": {
                    "type": "string",
                    "description": "Specifies which NIC in an OVF/OVA the `network_interface` should be associated. Only applies at creation when deploying from an OVF/OVA.\n",
                    "willReplaceOnChanges": true
                },
                "useStaticMac": {
                    "type": "boolean",
                    "description": "If true, the `mac_address` field is treated as a static MAC address and set accordingly. Setting this to `true` requires `mac_address` to be set. Default: `false`.\n"
                }
            },
            "type": "object",
            "required": [
                "networkId"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bandwidthShareCount",
                        "deviceAddress",
                        "key",
                        "macAddress",
                        "networkId"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy": {
            "properties": {
                "allowUnverifiedSslCert": {
                    "type": "boolean"
                },
                "deploymentOption": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "diskProvisioning": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "enableHiddenProperties": {
                    "type": "boolean",
                    "willReplaceOnChanges": true
                },
                "ipAllocationPolicy": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "ipProtocol": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "localOvfPath": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "willReplaceOnChanges": true
                },
                "remoteOvfUrl": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineVapp:VirtualMachineVapp": {
            "properties": {
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule": {
            "properties": {
                "includeDatastoresWithTags": {
                    "type": "boolean",
                    "description": "Include datastores with the given tags or exclude. Default `true`.\n"
                },
                "tagCategory": {
                    "type": "string",
                    "description": "Name of the tag category.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Name of tags to select from the given category.\n"
                }
            },
            "type": "object",
            "required": [
                "tagCategory",
                "tags"
            ]
        },
        "vsphere:index/VnicIpv4:VnicIpv4": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n"
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP is not set.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "Address of the interface, if DHCP is not set.\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "Netmask of the interface, if DHCP is not set.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/VnicIpv6:VnicIpv6": {
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IPv6 addresses\n"
                },
                "autoconfig": {
                    "type": "boolean",
                    "description": "Use IPv6 Autoconfiguration (RFC2462).\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n"
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP is not set.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/getVirtualMachineDisk:getVirtualMachineDisk": {
            "properties": {
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been eager zeroed.\n"
                },
                "label": {
                    "type": "string",
                    "description": "The label for the disk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GIB.\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been thin provisioned.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The disk number on the storage bus.\n"
                }
            },
            "type": "object",
            "required": [
                "eagerlyScrub",
                "label",
                "size",
                "thinProvisioned",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getVirtualMachineNetworkInterface:getVirtualMachineNetworkInterface": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The network interface types for each network interface found \non the virtual machine, in device bus order. Will be one of `e1000`, `e1000e`,\n`vmxnet3vrdma`, or `vmxnet3`.\n"
                },
                "bandwidthLimit": {
                    "type": "integer",
                    "description": "The upper bandwidth limit of this network interface, \nin Mbits/sec.\n"
                },
                "bandwidthReservation": {
                    "type": "integer",
                    "description": "The bandwidth reservation of this network interface,\nin Mbits/sec.\n"
                },
                "bandwidthShareCount": {
                    "type": "integer",
                    "description": "The share count for this network interface when the\nshare level is custom.\n"
                },
                "bandwidthShareLevel": {
                    "type": "string",
                    "description": "The bandwidth share allocation level for this interface.\nCan be one of `low`, `normal`, `high`, or `custom`.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of this network interface.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The managed object reference ID of the network this interface is\nconnected to.\n"
                }
            },
            "type": "object",
            "required": [
                "adapterType",
                "bandwidthShareCount",
                "macAddress",
                "networkId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp": {
            "properties": {
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the vsphere package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n"
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n"
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n"
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n"
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n"
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n"
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n"
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n"
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "required": [
            "password",
            "user"
        ],
        "inputProperties": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "requiredInputs": [
            "password",
            "user"
        ]
    },
    "resources": {
        "vsphere:index/computeCluster:ComputeCluster": {
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations in this cluster. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS in this cluster.\nRequires `drs_enabled` to be `true` in order to be effective.\nDefault: `false`.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating the\nthreshold of load within the cluster that influences host power operations.\nThis affects both power on and power off operations - a lower setting will\ntolerate more of a surplus/deficit than a higher setting. Default: `3`.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all\nvirtual machines in this cluster. Can be one of `manual`,\n`partiallyAutomated`, or `fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When `true`, enables DRS to use data\nfrom [vRealize Operations Manager][ref-vsphere-vrops] to make proactive DRS\nrecommendations. \u003csup\u003e\\*\u003c/sup\u003e\n\n[ref-vsphere-vrops]: https://docs.vmware.com/en/vRealize-Operations-Manager/index.html\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "Allow individual DRS overrides to be\nset for virtual machines in the cluster. Default: `true`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster. Default: `false`.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating\nthe threshold of imbalance tolerated between hosts. A lower setting will\ntolerate more imbalance while a higher setting will tolerate less. Default:\n`3`.\n"
                },
                "drsScaleDescendantsShares": {
                    "type": "string",
                    "description": "Enable scalable shares for all\nresource pools in the cluster. Can be one of `disabled` or\n`scaleCpuAndMemoryShares`. Default: `disabled`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "When destroying the resource, setting this to\n`true` will auto-remove any hosts that are currently a member of the cluster,\nas if they were removed by taking their entry out of `host_system_ids` (see\nbelow. This is an advanced\noption and should only be used for testing. Default: `false`.\n\n\u003e **NOTE:** Do not set `force_evacuate_on_destroy` in production operation as\nthere are many pitfalls to its use when working with complex cluster\nconfigurations. Depending on the virtual machines currently on the cluster, and\nyour DRS and HA settings, the full host evacuation may fail. Instead,\nincrementally remove hosts from your configuration by adjusting the contents of\nthe `host_system_ids` attribute.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines the\nmanaged object IDs of hosts to use as dedicated failover\nhosts. These hosts are kept as available as possible - admission control will\nblock access to the host, and DRS will ignore the host when making\nrecommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number\nof failed hosts that admission control tolerates when making decisions on\nwhether to permit virtual machine operations. The maximum is one less than\nthe number of hosts in the cluster. Default: `1`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of\nresource reduction that a cluster of virtual machines can tolerate in case of\na failover. A value of 0 produces warnings only, whereas a value of 100\ndisables the setting. Default: `100` (disabled).\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control\npolicy to use with vSphere HA. Can be one of `resourcePercentage`,\n`slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "Automatically determine available resource percentages by subtracting the\naverage number of host resources represented by the\n`ha_admission_control_host_failure_tolerance`\nsetting from the total amount of resources in the cluster. Disable to supply\nuser-defined values. Default: `true`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of CPU resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of memory resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined CPU slot size, in MHz. Default: `32`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined memory slot size, in MB. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "Controls\nwhether or not you wish to supply explicit values to CPU and memory slot\nsizes. The default is `false`, which tells vSphere to gather a automatic\naverage based on all powered-on virtual machines currently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non virtual machines if an APD status on an affected datastore clears in the\nmiddle of an APD event. Can be one of `none` or `reset`. Default: `none`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected loss to all paths to a\nrelevant datastore. Can be one of `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "The time, in seconds,\nto wait after an APD timeout event to run the response action defined in\n`ha_datastore_apd_response`. Default: `180`\nseconds (3 minutes). \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `disabled`, `warning`, or\n`restartAggressive`. Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster. Default:\n`false`.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for\npreferred datastores to use for HA heartbeating. This setting is only useful\nwhen `ha_heartbeat_datastore_policy` is set\nto either `userSelectedDs` or `allFeasibleDsWithUserPreference`.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA\nheartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or\n`allFeasibleDsWithUserPreference`. Default:\n`allFeasibleDsWithUserPreference`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual\nmachines when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:\n`none`.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether\nvSphere HA remediates virtual machines on host failure. Can be one of `enabled`\nor `disabled`. Default: `enabled`.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component\nprotection for virtual machines in this cluster. Can be one of `enabled` or\n`disabled`. Default: `enabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to\ndetermine whether or not virtual machines in a certain restart priority class\nare online, allowing HA to move on to restarting virtual machines on the next\npriority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or\n`appHbStatusGreen`. The default is `none`, which means that a virtual machine\nis considered ready immediately after a host is found to start it on.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "The time interval, in seconds, a heartbeat\nfrom a virtual machine is not received within this configured interval,\nthe virtual machine is marked as failed. Default: `30` seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The time, in seconds, for the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. Default: `-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to a virtual machine when responding to a failure event. Default: `3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on a virtual machine before monitoring for heartbeats. Default:\n`120` seconds (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay, in seconds,\nafter ready condition is met. A VM is considered ready at this point.\nDefault: `0` seconds (no delay). \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority\nfor affected virtual machines when vSphere detects a host failure. Can be one\nof `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds,\nthat vSphere HA will wait for virtual machines in one priority to be ready\nbefore proceeding with the next priority. Default: `600` seconds (10 minutes).\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout, in seconds, for each host maintenance\nmode operation when removing hosts from a cluster. Default: `3600` seconds (1 hour).\n"
                },
                "hostManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `host` resource rather than the\n`compute_cluster` resource. Conflicts with: `host_system_ids`.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster. Conflicts with: `host_managed`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "Determines how the host\nquarantine, maintenance mode, or virtual machine migration recommendations\nmade by proactive HA are to be handled. Can be one of `Automated` or\n`Manual`. Default: `Manual`. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables Proactive HA. Default: `false`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation\nfor moderately degraded hosts. Can be one of `MaintenanceMode` or\n`QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when\n`proactive_ha_severe_remediation` is set\nto `QuarantineMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update\nproviders configured for this cluster.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for\nseverely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.\nNote that this cannot be set to `QuarantineMode` when\n`proactive_ha_moderate_remediation` is\nset to `MaintenanceMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID of the primary\nresource pool for this cluster. This can be passed directly to the\n`resource_pool_id`\nattribute of the\n`vsphere.VirtualMachine` resource.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "vsanCompressionEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN compression on the\ncluster.\n"
                },
                "vsanDedupEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN deduplication on the cluster.\nCannot be independently set to true. When vSAN deduplication is enabled, vSAN\ncompression must also be enabled.\n"
                },
                "vsanDiskGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                    },
                    "description": "Represents the configuration of a host disk\ngroup in the cluster.\n"
                },
                "vsanDitEncryptionEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN data-in-transit\nencryption on the cluster. Conflicts with `vsan_remote_datastore_ids`, i.e.,\nvSAN data-in-transit feature cannot be enabled with the vSAN HCI Mesh feature\nat the same time.\n"
                },
                "vsanDitRekeyInterval": {
                    "type": "integer",
                    "description": "Indicates the rekey interval in\nminutes for data-in-transit encryption. The valid rekey interval is 30 to\n10800 (feature defaults to 1440). Conflicts with `vsan_remote_datastore_ids`.\n"
                },
                "vsanEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN on the cluster.\n"
                },
                "vsanNetworkDiagnosticModeEnabled": {
                    "type": "boolean",
                    "description": "Enables network\ndiagnostic mode for vSAN performance service on the cluster.\n"
                },
                "vsanPerformanceEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN performance service on\nthe cluster. Default: `true`.\n"
                },
                "vsanRemoteDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The remote vSAN datastore IDs to be\nmounted to this cluster. Conflicts with `vsan_dit_encryption_enabled` and\n`vsan_dit_rekey_interval`, i.e., vSAN HCI Mesh feature cannot be enabled with\ndata-in-transit encryption feature at the same time.\n"
                },
                "vsanUnmapEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN unmap on the cluster.\n"
                },
                "vsanVerboseModeEnabled": {
                    "type": "boolean",
                    "description": "Enables verbose mode for vSAN\nperformance service on the cluster.\n"
                }
            },
            "required": [
                "datacenterId",
                "name",
                "resourcePoolId",
                "vsanDiskGroups",
                "vsanDitRekeyInterval"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations in this cluster. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS in this cluster.\nRequires `drs_enabled` to be `true` in order to be effective.\nDefault: `false`.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating the\nthreshold of load within the cluster that influences host power operations.\nThis affects both power on and power off operations - a lower setting will\ntolerate more of a surplus/deficit than a higher setting. Default: `3`.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all\nvirtual machines in this cluster. Can be one of `manual`,\n`partiallyAutomated`, or `fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When `true`, enables DRS to use data\nfrom [vRealize Operations Manager][ref-vsphere-vrops] to make proactive DRS\nrecommendations. \u003csup\u003e\\*\u003c/sup\u003e\n\n[ref-vsphere-vrops]: https://docs.vmware.com/en/vRealize-Operations-Manager/index.html\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "Allow individual DRS overrides to be\nset for virtual machines in the cluster. Default: `true`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster. Default: `false`.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating\nthe threshold of imbalance tolerated between hosts. A lower setting will\ntolerate more imbalance while a higher setting will tolerate less. Default:\n`3`.\n"
                },
                "drsScaleDescendantsShares": {
                    "type": "string",
                    "description": "Enable scalable shares for all\nresource pools in the cluster. Can be one of `disabled` or\n`scaleCpuAndMemoryShares`. Default: `disabled`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "When destroying the resource, setting this to\n`true` will auto-remove any hosts that are currently a member of the cluster,\nas if they were removed by taking their entry out of `host_system_ids` (see\nbelow. This is an advanced\noption and should only be used for testing. Default: `false`.\n\n\u003e **NOTE:** Do not set `force_evacuate_on_destroy` in production operation as\nthere are many pitfalls to its use when working with complex cluster\nconfigurations. Depending on the virtual machines currently on the cluster, and\nyour DRS and HA settings, the full host evacuation may fail. Instead,\nincrementally remove hosts from your configuration by adjusting the contents of\nthe `host_system_ids` attribute.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines the\nmanaged object IDs of hosts to use as dedicated failover\nhosts. These hosts are kept as available as possible - admission control will\nblock access to the host, and DRS will ignore the host when making\nrecommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number\nof failed hosts that admission control tolerates when making decisions on\nwhether to permit virtual machine operations. The maximum is one less than\nthe number of hosts in the cluster. Default: `1`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of\nresource reduction that a cluster of virtual machines can tolerate in case of\na failover. A value of 0 produces warnings only, whereas a value of 100\ndisables the setting. Default: `100` (disabled).\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control\npolicy to use with vSphere HA. Can be one of `resourcePercentage`,\n`slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "Automatically determine available resource percentages by subtracting the\naverage number of host resources represented by the\n`ha_admission_control_host_failure_tolerance`\nsetting from the total amount of resources in the cluster. Disable to supply\nuser-defined values. Default: `true`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of CPU resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of memory resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined CPU slot size, in MHz. Default: `32`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined memory slot size, in MB. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "Controls\nwhether or not you wish to supply explicit values to CPU and memory slot\nsizes. The default is `false`, which tells vSphere to gather a automatic\naverage based on all powered-on virtual machines currently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non virtual machines if an APD status on an affected datastore clears in the\nmiddle of an APD event. Can be one of `none` or `reset`. Default: `none`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected loss to all paths to a\nrelevant datastore. Can be one of `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "The time, in seconds,\nto wait after an APD timeout event to run the response action defined in\n`ha_datastore_apd_response`. Default: `180`\nseconds (3 minutes). \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `disabled`, `warning`, or\n`restartAggressive`. Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster. Default:\n`false`.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for\npreferred datastores to use for HA heartbeating. This setting is only useful\nwhen `ha_heartbeat_datastore_policy` is set\nto either `userSelectedDs` or `allFeasibleDsWithUserPreference`.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA\nheartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or\n`allFeasibleDsWithUserPreference`. Default:\n`allFeasibleDsWithUserPreference`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual\nmachines when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:\n`none`.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether\nvSphere HA remediates virtual machines on host failure. Can be one of `enabled`\nor `disabled`. Default: `enabled`.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component\nprotection for virtual machines in this cluster. Can be one of `enabled` or\n`disabled`. Default: `enabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to\ndetermine whether or not virtual machines in a certain restart priority class\nare online, allowing HA to move on to restarting virtual machines on the next\npriority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or\n`appHbStatusGreen`. The default is `none`, which means that a virtual machine\nis considered ready immediately after a host is found to start it on.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "The time interval, in seconds, a heartbeat\nfrom a virtual machine is not received within this configured interval,\nthe virtual machine is marked as failed. Default: `30` seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The time, in seconds, for the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. Default: `-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to a virtual machine when responding to a failure event. Default: `3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on a virtual machine before monitoring for heartbeats. Default:\n`120` seconds (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay, in seconds,\nafter ready condition is met. A VM is considered ready at this point.\nDefault: `0` seconds (no delay). \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority\nfor affected virtual machines when vSphere detects a host failure. Can be one\nof `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds,\nthat vSphere HA will wait for virtual machines in one priority to be ready\nbefore proceeding with the next priority. Default: `600` seconds (10 minutes).\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout, in seconds, for each host maintenance\nmode operation when removing hosts from a cluster. Default: `3600` seconds (1 hour).\n"
                },
                "hostManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `host` resource rather than the\n`compute_cluster` resource. Conflicts with: `host_system_ids`.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster. Conflicts with: `host_managed`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "Determines how the host\nquarantine, maintenance mode, or virtual machine migration recommendations\nmade by proactive HA are to be handled. Can be one of `Automated` or\n`Manual`. Default: `Manual`. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables Proactive HA. Default: `false`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation\nfor moderately degraded hosts. Can be one of `MaintenanceMode` or\n`QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when\n`proactive_ha_severe_remediation` is set\nto `QuarantineMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update\nproviders configured for this cluster.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for\nseverely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.\nNote that this cannot be set to `QuarantineMode` when\n`proactive_ha_moderate_remediation` is\nset to `MaintenanceMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "vsanCompressionEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN compression on the\ncluster.\n"
                },
                "vsanDedupEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN deduplication on the cluster.\nCannot be independently set to true. When vSAN deduplication is enabled, vSAN\ncompression must also be enabled.\n"
                },
                "vsanDiskGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                    },
                    "description": "Represents the configuration of a host disk\ngroup in the cluster.\n"
                },
                "vsanDitEncryptionEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN data-in-transit\nencryption on the cluster. Conflicts with `vsan_remote_datastore_ids`, i.e.,\nvSAN data-in-transit feature cannot be enabled with the vSAN HCI Mesh feature\nat the same time.\n"
                },
                "vsanDitRekeyInterval": {
                    "type": "integer",
                    "description": "Indicates the rekey interval in\nminutes for data-in-transit encryption. The valid rekey interval is 30 to\n10800 (feature defaults to 1440). Conflicts with `vsan_remote_datastore_ids`.\n"
                },
                "vsanEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN on the cluster.\n"
                },
                "vsanNetworkDiagnosticModeEnabled": {
                    "type": "boolean",
                    "description": "Enables network\ndiagnostic mode for vSAN performance service on the cluster.\n"
                },
                "vsanPerformanceEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN performance service on\nthe cluster. Default: `true`.\n"
                },
                "vsanRemoteDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The remote vSAN datastore IDs to be\nmounted to this cluster. Conflicts with `vsan_dit_encryption_enabled` and\n`vsan_dit_rekey_interval`, i.e., vSAN HCI Mesh feature cannot be enabled with\ndata-in-transit encryption feature at the same time.\n"
                },
                "vsanUnmapEnabled": {
                    "type": "boolean",
                    "description": "Enables vSAN unmap on the cluster.\n"
                },
                "vsanVerboseModeEnabled": {
                    "type": "boolean",
                    "description": "Enables verbose mode for vSAN\nperformance service on the cluster.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter Server.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power\noperations in this cluster. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for DRS in this cluster.\nRequires `drs_enabled` to be `true` in order to be effective.\nDefault: `false`.\n"
                    },
                    "dpmThreshold": {
                        "type": "integer",
                        "description": "A value between `1` and `5` indicating the\nthreshold of load within the cluster that influences host power operations.\nThis affects both power on and power off operations - a lower setting will\ntolerate more of a surplus/deficit than a higher setting. Default: `3`.\n"
                    },
                    "drsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key/value map that specifies advanced\noptions for DRS and DPM.\n"
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "The default automation level for all\nvirtual machines in this cluster. Can be one of `manual`,\n`partiallyAutomated`, or `fullyAutomated`. Default: `manual`.\n"
                    },
                    "drsEnablePredictiveDrs": {
                        "type": "boolean",
                        "description": "When `true`, enables DRS to use data\nfrom [vRealize Operations Manager][ref-vsphere-vrops] to make proactive DRS\nrecommendations. \u003csup\u003e\\*\u003c/sup\u003e\n\n[ref-vsphere-vrops]: https://docs.vmware.com/en/vRealize-Operations-Manager/index.html\n"
                    },
                    "drsEnableVmOverrides": {
                        "type": "boolean",
                        "description": "Allow individual DRS overrides to be\nset for virtual machines in the cluster. Default: `true`.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Enable DRS for this cluster. Default: `false`.\n"
                    },
                    "drsMigrationThreshold": {
                        "type": "integer",
                        "description": "A value between `1` and `5` indicating\nthe threshold of imbalance tolerated between hosts. A lower setting will\ntolerate more imbalance while a higher setting will tolerate less. Default:\n`3`.\n"
                    },
                    "drsScaleDescendantsShares": {
                        "type": "string",
                        "description": "Enable scalable shares for all\nresource pools in the cluster. Can be one of `disabled` or\n`scaleCpuAndMemoryShares`. Default: `disabled`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                    },
                    "forceEvacuateOnDestroy": {
                        "type": "boolean",
                        "description": "When destroying the resource, setting this to\n`true` will auto-remove any hosts that are currently a member of the cluster,\nas if they were removed by taking their entry out of `host_system_ids` (see\nbelow. This is an advanced\noption and should only be used for testing. Default: `false`.\n\n\u003e **NOTE:** Do not set `force_evacuate_on_destroy` in production operation as\nthere are many pitfalls to its use when working with complex cluster\nconfigurations. Depending on the virtual machines currently on the cluster, and\nyour DRS and HA settings, the full host evacuation may fail. Instead,\nincrementally remove hosts from your configuration by adjusting the contents of\nthe `host_system_ids` attribute.\n"
                    },
                    "haAdmissionControlFailoverHostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines the\nmanaged object IDs of hosts to use as dedicated failover\nhosts. These hosts are kept as available as possible - admission control will\nblock access to the host, and DRS will ignore the host when making\nrecommendations.\n"
                    },
                    "haAdmissionControlHostFailureTolerance": {
                        "type": "integer",
                        "description": "The maximum number\nof failed hosts that admission control tolerates when making decisions on\nwhether to permit virtual machine operations. The maximum is one less than\nthe number of hosts in the cluster. Default: `1`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haAdmissionControlPerformanceTolerance": {
                        "type": "integer",
                        "description": "The percentage of\nresource reduction that a cluster of virtual machines can tolerate in case of\na failover. A value of 0 produces warnings only, whereas a value of 100\ndisables the setting. Default: `100` (disabled).\n"
                    },
                    "haAdmissionControlPolicy": {
                        "type": "string",
                        "description": "The type of admission control\npolicy to use with vSphere HA. Can be one of `resourcePercentage`,\n`slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.\n"
                    },
                    "haAdmissionControlResourcePercentageAutoCompute": {
                        "type": "boolean",
                        "description": "Automatically determine available resource percentages by subtracting the\naverage number of host resources represented by the\n`ha_admission_control_host_failure_tolerance`\nsetting from the total amount of resources in the cluster. Disable to supply\nuser-defined values. Default: `true`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haAdmissionControlResourcePercentageCpu": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined percentage of CPU resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                    },
                    "haAdmissionControlResourcePercentageMemory": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined percentage of memory resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitCpu": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined CPU slot size, in MHz. Default: `32`.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitMemory": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined memory slot size, in MB. Default: `100`.\n"
                    },
                    "haAdmissionControlSlotPolicyUseExplicitSize": {
                        "type": "boolean",
                        "description": "Controls\nwhether or not you wish to supply explicit values to CPU and memory slot\nsizes. The default is `false`, which tells vSphere to gather a automatic\naverage based on all powered-on virtual machines currently in the cluster.\n"
                    },
                    "haAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key/value map that specifies advanced\noptions for vSphere HA.\n"
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "Controls the action to take\non virtual machines if an APD status on an affected datastore clears in the\nmiddle of an APD event. Can be one of `none` or `reset`. Default: `none`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "Controls the action to take on\nvirtual machines when the cluster has detected loss to all paths to a\nrelevant datastore. Can be one of `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "The time, in seconds,\nto wait after an APD timeout event to run the response action defined in\n`ha_datastore_apd_response`. Default: `180`\nseconds (3 minutes). \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "Controls the action to take on\nvirtual machines when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `disabled`, `warning`, or\n`restartAggressive`. Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haEnabled": {
                        "type": "boolean",
                        "description": "Enable vSphere HA for this cluster. Default:\n`false`.\n"
                    },
                    "haHeartbeatDatastoreIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of managed object IDs for\npreferred datastores to use for HA heartbeating. This setting is only useful\nwhen `ha_heartbeat_datastore_policy` is set\nto either `userSelectedDs` or `allFeasibleDsWithUserPreference`.\n"
                    },
                    "haHeartbeatDatastorePolicy": {
                        "type": "string",
                        "description": "The selection policy for HA\nheartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or\n`allFeasibleDsWithUserPreference`. Default:\n`allFeasibleDsWithUserPreference`.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on virtual\nmachines when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:\n`none`.\n"
                    },
                    "haHostMonitoring": {
                        "type": "string",
                        "description": "Global setting that controls whether\nvSphere HA remediates virtual machines on host failure. Can be one of `enabled`\nor `disabled`. Default: `enabled`.\n"
                    },
                    "haVmComponentProtection": {
                        "type": "string",
                        "description": "Controls vSphere VM component\nprotection for virtual machines in this cluster. Can be one of `enabled` or\n`disabled`. Default: `enabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haVmDependencyRestartCondition": {
                        "type": "string",
                        "description": "The condition used to\ndetermine whether or not virtual machines in a certain restart priority class\nare online, allowing HA to move on to restarting virtual machines on the next\npriority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or\n`appHbStatusGreen`. The default is `none`, which means that a virtual machine\nis considered ready immediately after a host is found to start it on.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "The time interval, in seconds, a heartbeat\nfrom a virtual machine is not received within this configured interval,\nthe virtual machine is marked as failed. Default: `30` seconds.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The time, in seconds, for the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. Default: `-1` (no window).\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will\nperform to a virtual machine when responding to a failure event. Default: `3`\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after\npowering on a virtual machine before monitoring for heartbeats. Default:\n`120` seconds (2 minutes).\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                    },
                    "haVmRestartAdditionalDelay": {
                        "type": "integer",
                        "description": "Additional delay, in seconds,\nafter ready condition is met. A VM is considered ready at this point.\nDefault: `0` seconds (no delay). \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The default restart priority\nfor affected virtual machines when vSphere detects a host failure. Can be one\nof `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds,\nthat vSphere HA will wait for virtual machines in one priority to be ready\nbefore proceeding with the next priority. Default: `600` seconds (10 minutes).\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "hostClusterExitTimeout": {
                        "type": "integer",
                        "description": "The timeout, in seconds, for each host maintenance\nmode operation when removing hosts from a cluster. Default: `3600` seconds (1 hour).\n"
                    },
                    "hostManaged": {
                        "type": "boolean",
                        "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `host` resource rather than the\n`compute_cluster` resource. Conflicts with: `host_system_ids`.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to put in the cluster. Conflicts with: `host_managed`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the cluster.\n"
                    },
                    "proactiveHaAutomationLevel": {
                        "type": "string",
                        "description": "Determines how the host\nquarantine, maintenance mode, or virtual machine migration recommendations\nmade by proactive HA are to be handled. Can be one of `Automated` or\n`Manual`. Default: `Manual`. \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaEnabled": {
                        "type": "boolean",
                        "description": "Enables Proactive HA. Default: `false`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaModerateRemediation": {
                        "type": "string",
                        "description": "The configured remediation\nfor moderately degraded hosts. Can be one of `MaintenanceMode` or\n`QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when\n`proactive_ha_severe_remediation` is set\nto `QuarantineMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaProviderIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of IDs for health update\nproviders configured for this cluster.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaSevereRemediation": {
                        "type": "string",
                        "description": "The configured remediation for\nseverely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.\nNote that this cannot be set to `QuarantineMode` when\n`proactive_ha_moderate_remediation` is\nset to `MaintenanceMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID of the primary\nresource pool for this cluster. This can be passed directly to the\n`resource_pool_id`\nattribute of the\n`vsphere.VirtualMachine` resource.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "vsanCompressionEnabled": {
                        "type": "boolean",
                        "description": "Enables vSAN compression on the\ncluster.\n"
                    },
                    "vsanDedupEnabled": {
                        "type": "boolean",
                        "description": "Enables vSAN deduplication on the cluster.\nCannot be independently set to true. When vSAN deduplication is enabled, vSAN\ncompression must also be enabled.\n"
                    },
                    "vsanDiskGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                        },
                        "description": "Represents the configuration of a host disk\ngroup in the cluster.\n"
                    },
                    "vsanDitEncryptionEnabled": {
                        "type": "boolean",
                        "description": "Enables vSAN data-in-transit\nencryption on the cluster. Conflicts with `vsan_remote_datastore_ids`, i.e.,\nvSAN data-in-transit feature cannot be enabled with the vSAN HCI Mesh feature\nat the same time.\n"
                    },
                    "vsanDitRekeyInterval": {
                        "type": "integer",
                        "description": "Indicates the rekey interval in\nminutes for data-in-transit encryption. The valid rekey interval is 30 to\n10800 (feature defaults to 1440). Conflicts with `vsan_remote_datastore_ids`.\n"
                    },
                    "vsanEnabled": {
                        "type": "boolean",
                        "description": "Enables vSAN on the cluster.\n"
                    },
                    "vsanNetworkDiagnosticModeEnabled": {
                        "type": "boolean",
                        "description": "Enables network\ndiagnostic mode for vSAN performance service on the cluster.\n"
                    },
                    "vsanPerformanceEnabled": {
                        "type": "boolean",
                        "description": "Enables vSAN performance service on\nthe cluster. Default: `true`.\n"
                    },
                    "vsanRemoteDatastoreIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The remote vSAN datastore IDs to be\nmounted to this cluster. Conflicts with `vsan_dit_encryption_enabled` and\n`vsan_dit_rekey_interval`, i.e., vSAN HCI Mesh feature cannot be enabled with\ndata-in-transit encryption feature at the same time.\n"
                    },
                    "vsanUnmapEnabled": {
                        "type": "boolean",
                        "description": "Enables vSAN unmap on the cluster.\n"
                    },
                    "vsanVerboseModeEnabled": {
                        "type": "boolean",
                        "description": "Enables verbose mode for vSAN\nperformance service on the cluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterHostGroup:ComputeClusterHostGroup": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterVmGroup`\nresource. Make sure your names are unique across both resources.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterVmGroup`\nresource. Make sure your names are unique across both resources.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterHostGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to put in the cluster.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterVmGroup`\nresource. Make sure your names are unique across both resources.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAffinityRule:ComputeClusterVmAffinityRule": {
            "description": "The `vsphere.ComputeClusterVmAffinityRule` resource can be used to\nmanage virtual machine affinity rules in a cluster, either created by the\n`vsphere.ComputeCluster` resource or looked up\nby the `vsphere.ComputeCluster` data source.\n\nThis rule can be used to tell a set of virtual machines to run together on the\nsame host within a cluster. When configured, DRS will make a best effort to\nensure that the virtual machines run on the same host, or prevent any operation\nthat would keep that from happening, depending on the value of the\n`mandatory` flag.\n\n\u003e An affinity rule can only be used to place virtual machines on the same\n_non-specific_ hosts. It cannot be used to pin virtual machines to a host. \nTo enable this capability, use the\n`vsphere.ComputeClusterVmHostRule`\nresource.\n\n\u003e **NOTE:** This resource requires vCenter Server and is not available on\ndirect ESXi host connections.\n\n\u003e **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe following example creates two virtual machines in a cluster using the\n`vsphere.VirtualMachine` resource, creating the\nvirtual machines in the cluster looked up by the\n`vsphere.ComputeCluster` data source. It\nthen creates an affinity rule for these two virtual machines, ensuring they\nwill run on the same host whenever possible.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore-01\",\n    datacenterId: datacenter.id,\n}));\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"VM Network\",\n    datacenterId: datacenter.id,\n}));\nconst vm: vsphere.VirtualMachine[] = [];\nfor (const range = {value: 0}; range.value \u003c 2; range.value++) {\n    vm.push(new vsphere.VirtualMachine(`vm-${range.value}`, {\n        resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n        datastoreId: datastore.then(datastore =\u003e datastore.id),\n        numCpus: 1,\n        memory: 1024,\n        guestId: \"otherLinux64Guest\",\n        networkInterfaces: [{\n            networkId: network.then(network =\u003e network.id),\n        }],\n        disks: [{\n            label: \"disk0\",\n            size: 20,\n        }],\n    }));\n}\nconst vmAffinityRule = new vsphere.ComputeClusterVmAffinityRule(\"vmAffinityRule\", {\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: vm.map((v, k) =\u003e [k, v]).map(([, ]) =\u003e (v.id)),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore-01\",\n    datacenter_id=datacenter.id)\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"VM Network\",\n    datacenter_id=datacenter.id)\nvm = []\nfor range in [{\"value\": i} for i in range(0, 2)]:\n    vm.append(vsphere.VirtualMachine(f\"vm-{range['value']}\",\n        resource_pool_id=cluster.resource_pool_id,\n        datastore_id=datastore.id,\n        num_cpus=1,\n        memory=1024,\n        guest_id=\"otherLinux64Guest\",\n        network_interfaces=[vsphere.VirtualMachineNetworkInterfaceArgs(\n            network_id=network.id,\n        )],\n        disks=[vsphere.VirtualMachineDiskArgs(\n            label=\"disk0\",\n            size=20,\n        )]))\nvm_affinity_rule = vsphere.ComputeClusterVmAffinityRule(\"vmAffinityRule\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[v.id for k, v in vm])\n```\n\nThe following example creates an affinity rule for a set of virtual machines\nin the cluster by looking up the virtual machine UUIDs from the\n`vsphere.VirtualMachine` data source.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vms = [\n    \"foo-0\",\n    \"foo-1\",\n];\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst vmsVirtualMachine = (new Array(vms.length)).map((_, i) =\u003e i).map(__index =\u003e (vsphere.getVirtualMachine({\n    name: vms[__index],\n    datacenterId: _arg0_.id,\n})));\nconst vmAffinityRule = new vsphere.ComputeClusterVmAffinityRule(\"vmAffinityRule\", {\n    enabled: true,\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: vmsVirtualMachine.map(__item =\u003e __item.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvms = [\n    \"foo-0\",\n    \"foo-1\",\n]\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nvms_virtual_machine = [vsphere.get_virtual_machine(name=vms[__index],\n    datacenter_id=datacenter.id) for __index in range(len(vms))]\nvm_affinity_rule = vsphere.ComputeClusterVmAffinityRule(\"vmAffinityRule\",\n    enabled=True,\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[__item.id for __item in vms_virtual_machine])\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAntiAffinityRule:ComputeClusterVmAntiAffinityRule": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmDependencyRule:ComputeClusterVmDependencyRule": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "required": [
                "computeClusterId",
                "dependencyVmGroupName",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "dependencyVmGroupName",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmDependencyRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "dependencyVmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmGroup:ComputeClusterVmGroup": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterHostGroup`\nresource. Make sure your names are unique across both resources.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterHostGroup`\nresource. Make sure your names are unique across both resources.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines in this\ngroup.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterHostGroup`\nresource. Make sure your names are unique across both resources.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmHostRule:ComputeClusterVmHostRule": {
            "properties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** One of `affinity_host_group_name` or\n`anti_affinity_host_group_name` must be\ndefined, but not both.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** One of `affinity_host_group_name` or\n`anti_affinity_host_group_name` must be\ndefined, but not both.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmHostRule resources.\n",
                "properties": {
                    "affinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                    },
                    "antiAffinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                    },
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** One of `affinity_host_group_name` or\n`anti_affinity_host_group_name` must be\ndefined, but not both.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the virtual machine group to use\nwith this rule.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibrary:ContentLibrary": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the content library.\n"
                },
                "publication": {
                    "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                    "description": "Options to publish a local content library.\n"
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID of the datastore on which to store the content library items.\n"
                },
                "subscription": {
                    "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                    "description": "Options subscribe to a published content library.\n"
                }
            },
            "required": [
                "name",
                "publication",
                "storageBackings"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the content library.\n",
                    "willReplaceOnChanges": true
                },
                "publication": {
                    "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                    "description": "Options to publish a local content library.\n",
                    "willReplaceOnChanges": true
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID of the datastore on which to store the content library items.\n",
                    "willReplaceOnChanges": true
                },
                "subscription": {
                    "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                    "description": "Options subscribe to a published content library.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "storageBackings"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibrary resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description for the content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "publication": {
                        "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                        "description": "Options to publish a local content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageBackings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object reference ID of the datastore on which to store the content library items.\n",
                        "willReplaceOnChanges": true
                    },
                    "subscription": {
                        "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                        "description": "Options subscribe to a published content library.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibraryItem:ContentLibraryItem": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library item.\n"
                },
                "fileUrl": {
                    "type": "string",
                    "description": "File to import as the content library item.\n"
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the content library in which to create the item.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the content library.\n"
                },
                "sourceUuid": {
                    "type": "string",
                    "description": "Virtual machine UUID to clone to content library.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\nOne of \"ovf\", \"iso\", or \"vm-template\". Default: `ovf`.\n"
                }
            },
            "required": [
                "libraryId",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library item.\n",
                    "willReplaceOnChanges": true
                },
                "fileUrl": {
                    "type": "string",
                    "description": "File to import as the content library item.\n",
                    "willReplaceOnChanges": true
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the content library in which to create the item.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the content library.\n",
                    "willReplaceOnChanges": true
                },
                "sourceUuid": {
                    "type": "string",
                    "description": "Virtual machine UUID to clone to content library.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\nOne of \"ovf\", \"iso\", or \"vm-template\". Default: `ovf`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "libraryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibraryItem resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description for the content library item.\n",
                        "willReplaceOnChanges": true
                    },
                    "fileUrl": {
                        "type": "string",
                        "description": "File to import as the content library item.\n",
                        "willReplaceOnChanges": true
                    },
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the content library in which to create the item.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the item to be created in the content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceUuid": {
                        "type": "string",
                        "description": "Virtual machine UUID to clone to content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of content library item.\nOne of \"ovf\", \"iso\", or \"vm-template\". Default: `ovf`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/customAttribute:CustomAttribute": {
            "properties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, review the Managed Object Types. Forces a new resource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, review the Managed Object Types. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomAttribute resources.\n",
                "properties": {
                    "managedObjectType": {
                        "type": "string",
                        "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, review the Managed Object Types. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datacenter:Datacenter": {
            "description": "Provides a VMware vSphere datacenter resource. This can be used as the primary\ncontainer of inventory objects such as hosts and virtual machines.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Create datacenter on the root folder\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodDatacenter = new vsphere.Datacenter(\"prodDatacenter\", {});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_datacenter = vsphere.Datacenter(\"prodDatacenter\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodDatacenter = new VSphere.Datacenter(\"prodDatacenter\");\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDatacenter(ctx, \"prodDatacenter\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.Datacenter;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var prodDatacenter = new Datacenter(\"prodDatacenter\");\n\n    }\n}\n```\n```yaml\nresources:\n  prodDatacenter:\n    type: vsphere:Datacenter\n```\n{{% /example %}}\n{{% example %}}\n### Create datacenter on a subfolder\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst researchDatacenter = new vsphere.Datacenter(\"researchDatacenter\", {folder: \"/research/\"});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nresearch_datacenter = vsphere.Datacenter(\"researchDatacenter\", folder=\"/research/\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var researchDatacenter = new VSphere.Datacenter(\"researchDatacenter\", new()\n    {\n        Folder = \"/research/\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDatacenter(ctx, \"researchDatacenter\", \u0026vsphere.DatacenterArgs{\n\t\t\tFolder: pulumi.String(\"/research/\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.Datacenter;\nimport com.pulumi.vsphere.DatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var researchDatacenter = new Datacenter(\"researchDatacenter\", DatacenterArgs.builder()        \n            .folder(\"/research/\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  researchDatacenter:\n    type: vsphere:Datacenter\n    properties:\n      folder: /research/\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value \nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "Managed object ID of this datacenter.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                }
            },
            "required": [
                "moid",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value \nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Datacenter resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to value \nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "moid": {
                        "type": "string",
                        "description": "Managed object ID of this datacenter.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreCluster:DatastoreCluster": {
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map of advanced Storage DRS\nsettings that are not exposed via the provider or the vSphere client.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The global automation level for all\nvirtual machines in this datastore cluster. Default: `manual`.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When `true`, all disks in a\nsingle virtual machine will be kept on the same datastore. Default: `true`.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The threshold, in GB, that storage\nDRS uses to make decisions to migrate VMs out of a datastore. Default: `50`\nGB.\nWhen set to `utilization`, `drs_space_utilization_threshold` is used, and\nwhen set to `freeSpace`, `drs_free_space_threshold` is used. Default:\n`utilization`.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in\npercent of used space, that storage DRS uses to make decisions to migrate VMs\nout of a datastore. Default: `80` percent.\npercent, of difference between space utilization in datastores before storage\nDRS makes decisions to balance the space. Default: `5` percent.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in\nmilliseconds, that storage DRS uses to make recommendations to move disks\nfrom this datastore. Default: `15` seconds.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for\nthis datastore cluster. Default: `true`.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load\nin datastores in the cluster before storage DRS makes recommendations to\nbalance the load. Default: `5` percent.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable\nIOPS of all virtual machines on the datastore before storage DRS makes\nrecommendations to move VMs off of a datastore. Note that this setting should\nonly be set if `sdrs_io_reservable_percent_threshold` cannot make an accurate\nestimate of the capacity of the datastores in your cluster, and should be set\nto roughly 50-60% of the worst case peak performance of the backing LUNs.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of actual estimated performance of the datastore (in IOPS) that\nstorage DRS uses to make recommendations to move VMs off of a datastore when\nthe total reservable IOPS exceeds the threshold. Default: `60` percent.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS\nthreshold setting to use, `sdrs_io_reservable_percent_threshold` in the event\nof `automatic`, or `sdrs_io_reservable_iops_threshold` in the event of\n`manual`. Default: `automatic`.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in\nminutes. Default: `480` minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "Runtime thresholds govern \nwhen Storage DRS performs or recommends migrations\n(based on the selected automation level). Default: `80` percent.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support requires vCenter 6.0 or higher.\n"
                }
            },
            "required": [
                "datacenterId",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map of advanced Storage DRS\nsettings that are not exposed via the provider or the vSphere client.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The global automation level for all\nvirtual machines in this datastore cluster. Default: `manual`.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When `true`, all disks in a\nsingle virtual machine will be kept on the same datastore. Default: `true`.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The threshold, in GB, that storage\nDRS uses to make decisions to migrate VMs out of a datastore. Default: `50`\nGB.\nWhen set to `utilization`, `drs_space_utilization_threshold` is used, and\nwhen set to `freeSpace`, `drs_free_space_threshold` is used. Default:\n`utilization`.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in\npercent of used space, that storage DRS uses to make decisions to migrate VMs\nout of a datastore. Default: `80` percent.\npercent, of difference between space utilization in datastores before storage\nDRS makes decisions to balance the space. Default: `5` percent.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in\nmilliseconds, that storage DRS uses to make recommendations to move disks\nfrom this datastore. Default: `15` seconds.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for\nthis datastore cluster. Default: `true`.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load\nin datastores in the cluster before storage DRS makes recommendations to\nbalance the load. Default: `5` percent.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable\nIOPS of all virtual machines on the datastore before storage DRS makes\nrecommendations to move VMs off of a datastore. Note that this setting should\nonly be set if `sdrs_io_reservable_percent_threshold` cannot make an accurate\nestimate of the capacity of the datastores in your cluster, and should be set\nto roughly 50-60% of the worst case peak performance of the backing LUNs.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of actual estimated performance of the datastore (in IOPS) that\nstorage DRS uses to make recommendations to move VMs off of a datastore when\nthe total reservable IOPS exceeds the threshold. Default: `60` percent.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS\nthreshold setting to use, `sdrs_io_reservable_percent_threshold` in the event\nof `automatic`, or `sdrs_io_reservable_iops_threshold` in the event of\n`manual`. Default: `automatic`.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in\nminutes. Default: `480` minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "Runtime thresholds govern \nwhen Storage DRS performs or recommends migrations\n(based on the selected automation level). Default: `80` percent.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support requires vCenter 6.0 or higher.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore cluster.\n"
                    },
                    "sdrsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key/value map of advanced Storage DRS\nsettings that are not exposed via the provider or the vSphere client.\n"
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "The global automation level for all\nvirtual machines in this datastore cluster. Default: `manual`.\n"
                    },
                    "sdrsDefaultIntraVmAffinity": {
                        "type": "boolean",
                        "description": "When `true`, all disks in a\nsingle virtual machine will be kept on the same datastore. Default: `true`.\n"
                    },
                    "sdrsEnabled": {
                        "type": "boolean",
                        "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                    },
                    "sdrsFreeSpaceThreshold": {
                        "type": "integer",
                        "description": "The threshold, in GB, that storage\nDRS uses to make decisions to migrate VMs out of a datastore. Default: `50`\nGB.\nWhen set to `utilization`, `drs_space_utilization_threshold` is used, and\nwhen set to `freeSpace`, `drs_free_space_threshold` is used. Default:\n`utilization`.\n"
                    },
                    "sdrsFreeSpaceThresholdMode": {
                        "type": "string",
                        "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                    },
                    "sdrsFreeSpaceUtilizationDifference": {
                        "type": "integer",
                        "description": "The threshold, in\npercent of used space, that storage DRS uses to make decisions to migrate VMs\nout of a datastore. Default: `80` percent.\npercent, of difference between space utilization in datastores before storage\nDRS makes decisions to balance the space. Default: `5` percent.\n"
                    },
                    "sdrsIoBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting I/O load imbalances.\n"
                    },
                    "sdrsIoLatencyThreshold": {
                        "type": "integer",
                        "description": "The I/O latency threshold, in\nmilliseconds, that storage DRS uses to make recommendations to move disks\nfrom this datastore. Default: `15` seconds.\n"
                    },
                    "sdrsIoLoadBalanceEnabled": {
                        "type": "boolean",
                        "description": "Enable I/O load balancing for\nthis datastore cluster. Default: `true`.\n"
                    },
                    "sdrsIoLoadImbalanceThreshold": {
                        "type": "integer",
                        "description": "The difference between load\nin datastores in the cluster before storage DRS makes recommendations to\nbalance the load. Default: `5` percent.\n"
                    },
                    "sdrsIoReservableIopsThreshold": {
                        "type": "integer",
                        "description": "The threshold of reservable\nIOPS of all virtual machines on the datastore before storage DRS makes\nrecommendations to move VMs off of a datastore. Note that this setting should\nonly be set if `sdrs_io_reservable_percent_threshold` cannot make an accurate\nestimate of the capacity of the datastores in your cluster, and should be set\nto roughly 50-60% of the worst case peak performance of the backing LUNs.\n"
                    },
                    "sdrsIoReservablePercentThreshold": {
                        "type": "integer",
                        "description": "The threshold, in\npercent, of actual estimated performance of the datastore (in IOPS) that\nstorage DRS uses to make recommendations to move VMs off of a datastore when\nthe total reservable IOPS exceeds the threshold. Default: `60` percent.\n"
                    },
                    "sdrsIoReservableThresholdMode": {
                        "type": "string",
                        "description": "The reservable IOPS\nthreshold setting to use, `sdrs_io_reservable_percent_threshold` in the event\nof `automatic`, or `sdrs_io_reservable_iops_threshold` in the event of\n`manual`. Default: `automatic`.\n"
                    },
                    "sdrsLoadBalanceInterval": {
                        "type": "integer",
                        "description": "The storage DRS poll interval, in\nminutes. Default: `480` minutes.\n"
                    },
                    "sdrsPolicyEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting storage and VM policy violations.\n"
                    },
                    "sdrsRuleEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting affinity rule violations.\n"
                    },
                    "sdrsSpaceBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting disk space imbalances.\n"
                    },
                    "sdrsSpaceUtilizationThreshold": {
                        "type": "integer",
                        "description": "Runtime thresholds govern \nwhen Storage DRS performs or recommends migrations\n(based on the selected automation level). Default: `80` percent.\n"
                    },
                    "sdrsVmEvacuationAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when generating recommendations for datastore evacuation.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support requires vCenter 6.0 or higher.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreClusterVmAntiAffinityRule:DatastoreClusterVmAntiAffinityRule": {
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n\n\u003e **NOTE:** The minimum length of `virtual_machine_ids` is 2.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n\n\u003e **NOTE:** The minimum length of `virtual_machine_ids` is 2.\n"
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n\n\u003e **NOTE:** The minimum length of `virtual_machine_ids` is 2.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedPortGroup:DistributedPortGroup": {
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n\n\u003e **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`\nmay lead to errors when the port count grows past the amount specified.  If you\nspecify `number_of_ports`, you may wish to set `auto_expand` to `false`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the port shutdown\npolicy to be overridden on an individual port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "The current version of the port group configuration,\nincremented by subsequent updates to the port group.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the VDS to add the\nport group to. Forces a new resource if changed.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The generated UUID of the port group.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a port in this port group to be\nmoved to another port group while it is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the\n[Netflow policy][netflow-policy] on this port group to be overridden on an\nindividual port.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network\nresource pool set on this port group to be overridden on an individual port.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset a port's settings to the\nsettings defined on this port group policy when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n\n[ext-vsphere-portname-format]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/b50dcbbf-051d-4204-a3e7-e1b618c1e384/538cf2ec-b34f-4bae-a332-3820ef9e7773/vim.dvs.DistributedVirtualPortgroup.ConfigInfo.html#portNameFormat\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the \n[security policy settings][sec-policy-settings] defined in this port group\npolicy to be overridden on an individual port.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the\n[traffic shaping options][traffic-shaping-settings] on this port group policy\nto be overridden on an individual port.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any traffic filters on\nthis port group to be overridden on an individual port.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the\n[uplink teaming options][uplink-teaming-settings] on this port group to be\noverridden on an individual port.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the\n[VLAN settings][vlan-settings] on this port group to be overridden on an\nindividual port.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "directpathGen2Allowed",
                "distributedVirtualSwitchUuid",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "key",
                "lacpEnabled",
                "lacpMode",
                "name",
                "netflowEnabled",
                "notifySwitches",
                "numberOfPorts",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "vlanId",
                "vlanRanges"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n\n\u003e **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`\nmay lead to errors when the port count grows past the amount specified.  If you\nspecify `number_of_ports`, you may wish to set `auto_expand` to `false`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the port shutdown\npolicy to be overridden on an individual port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the VDS to add the\nport group to. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a port in this port group to be\nmoved to another port group while it is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the\n[Netflow policy][netflow-policy] on this port group to be overridden on an\nindividual port.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network\nresource pool set on this port group to be overridden on an individual port.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset a port's settings to the\nsettings defined on this port group policy when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n\n[ext-vsphere-portname-format]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/b50dcbbf-051d-4204-a3e7-e1b618c1e384/538cf2ec-b34f-4bae-a332-3820ef9e7773/vim.dvs.DistributedVirtualPortgroup.ConfigInfo.html#portNameFormat\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the \n[security policy settings][sec-policy-settings] defined in this port group\npolicy to be overridden on an individual port.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the\n[traffic shaping options][traffic-shaping-settings] on this port group policy\nto be overridden on an individual port.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any traffic filters on\nthis port group to be overridden on an individual port.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the\n[uplink teaming options][uplink-teaming-settings] on this port group to be\noverridden on an individual port.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the\n[VLAN settings][vlan-settings] on this port group to be overridden on an\nindividual port.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "requiredInputs": [
                "distributedVirtualSwitchUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedPortGroup resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "autoExpand": {
                        "type": "boolean",
                        "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n\n\u003e **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`\nmay lead to errors when the port count grows past the amount specified.  If you\nspecify `number_of_ports`, you may wish to set `auto_expand` to `false`.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Indicates whether to block all ports by default.\n"
                    },
                    "blockOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the port shutdown\npolicy to be overridden on an individual port.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing on the ports this policy applies to.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "The current version of the port group configuration,\nincremented by subsequent updates to the port group.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description for the port group.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "The ID of the VDS to add the\nport group to. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The generated UUID of the port group.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable LACP on all uplink ports.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                    },
                    "livePortMovingAllowed": {
                        "type": "boolean",
                        "description": "Allow a port in this port group to be\nmoved to another port group while it is connected.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether to enable netflow on all ports.\n"
                    },
                    "netflowOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the\n[Netflow policy][netflow-policy] on this port group to be overridden on an\nindividual port.\n"
                    },
                    "networkResourcePoolKey": {
                        "type": "string",
                        "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                    },
                    "networkResourcePoolOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the network\nresource pool set on this port group to be overridden on an individual port.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                    },
                    "portConfigResetAtDisconnect": {
                        "type": "boolean",
                        "description": "Reset a port's settings to the\nsettings defined on this port group policy when the port disconnects.\n"
                    },
                    "portNameFormat": {
                        "type": "string",
                        "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n\n[ext-vsphere-portname-format]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/b50dcbbf-051d-4204-a3e7-e1b618c1e384/538cf2ec-b34f-4bae-a332-3820ef9e7773/vim.dvs.DistributedVirtualPortgroup.ConfigInfo.html#portNameFormat\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "The secondary VLAN ID for this port.\n"
                    },
                    "securityPolicyOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the \n[security policy settings][sec-policy-settings] defined in this port group\npolicy to be overridden on an individual port.\n"
                    },
                    "shapingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the\n[traffic shaping options][traffic-shaping-settings] on this port group policy\nto be overridden on an individual port.\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                    },
                    "trafficFilterOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow any traffic filters on\nthis port group to be overridden on an individual port.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                    },
                    "uplinkTeamingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the\n[uplink teaming options][uplink-teaming-settings] on this port group to be\noverridden on an individual port.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the\n[VLAN settings][vlan-settings] on this port group to be overridden on an\nindividual port.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                        },
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch": {
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of active uplinks to be used in load\nbalancing. These uplinks need to match the definitions in the\n`uplinks` VDS argument. See\nhere for more details.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not a virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port.\n"
                },
                "backupnfcMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                },
                "backupnfcShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Shuts down all ports in the port groups that\nthis policy applies to, effectively blocking all network access to connected\nvirtual devices.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enables beacon probing as an additional measure\nto detect NIC failure.\n\n\u003e **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon\nprobing.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "The current version of the VDS configuration, incremented\nby subsequent updates to the VDS.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the VDS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nVDS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for VDS.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand requires vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VDS will be\ncreated. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the VDS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 for the ports\nfor which this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits\nper second if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is enabled\non the port for egress traffic.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts\nin bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will re-activate failed\nuplinks higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder in which to create the VDS.\nForces a new resource if changed.\n"
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "Use the `host` block to declare a host specification. The\noptions are:\n"
                },
                "ignoreOtherPvlanMappings": {
                    "type": "boolean",
                    "description": "Whether to ignore existing PVLAN\nmappings not managed by this resource. Defaults to false.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in\nbits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is\nenabled on the port for ingress traffic.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during\nbursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the VDS. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Enables LACP for the ports that this policy\napplies to.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The LACP mode. Can be one of `active` or `passive`.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the VDS.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the VDS. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VDS.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nactive flows are forced to be exported to the collector. Allowed range is\n`60` to `3600`. Default: `60`.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the Netflow\ncollector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.\nMust be set before Netflow can be enabled.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "Port for the Netflow collector. This\nmust be set before Netflow can be enabled.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Enables Netflow on all ports that this policy\napplies to.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nidle flows are forced to be exported to the collector. Allowed range is `10`\nto `600`. Default: `15`.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to\ntraffic that has both source and destination served by the same host.\nDefault: `false`.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation domain ID for\nthe Netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to\nthe number of packets analyzed. The default is `0`, which indicates that the\nVDS should analyze all packets. The maximum value is `1000`, which\nindicates an analysis rate of 0.001%.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable\nnetwork I/O control. Default: `false`.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The version of network I/O\ncontrol to use. Can be one of `version2` or `version3`. Default: `version2`.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will notify the\nbroadcast network of an uplink failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "Used to define a secondary VLAN\nID when using private VLANs.\n"
                },
                "pvlanMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                    },
                    "description": "Use the `pvlan_mapping` block to declare a\nprivate VLAN mapping. The options are:\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of standby uplinks to be used in\nfailover. These uplinks need to match the definitions in the\n`uplinks` VDS argument. See\nhere for more details.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support requires vCenter Server 6.0 or higher.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The uplink teaming policy. Can be one of\n`loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,\n`failover_explicit`, or `loadbalance_loadbased`.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "Forward all traffic transmitted by ports for which\nthis policy applies to its VDS uplinks.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of strings that uniquely identifies the names\nof the uplinks on the VDS across hosts. The number of items in this list\ncontrols the number of uplinks that exist on the VDS, in addition to the\nnames. See here for an example on how to\nuse this option.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the VDS. BY default, a VDS is created\nat the latest version supported by the vSphere version if not specified.\nA VDS can be upgraded to a newer version, but can not be downgraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "Used to denote VLAN trunking. Use the `min_vlan`\nand `max_vlan` sub-arguments to define the tagged VLAN range. Multiple\n`vlan_range` definitions are allowed, but they must not overlap. Example\nbelow:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vds = new vsphere.DistributedVirtualSwitch(\"vds\", {vlanRanges: [\n    {\n        maxVlan: 199,\n        minVlan: 100,\n    },\n    {\n        maxVlan: 399,\n        minVlan: 300,\n    },\n]});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvds = vsphere.DistributedVirtualSwitch(\"vds\", vlan_ranges=[\n    vsphere.DistributedVirtualSwitchVlanRangeArgs(\n        max_vlan=199,\n        min_vlan=100,\n    ),\n    vsphere.DistributedVirtualSwitchVlanRangeArgs(\n        max_vlan=399,\n        min_vlan=300,\n    ),\n])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vds = new VSphere.DistributedVirtualSwitch(\"vds\", new()\n    {\n        VlanRanges = new[]\n        {\n            new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs\n            {\n                MaxVlan = 199,\n                MinVlan = 100,\n            },\n            new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs\n            {\n                MaxVlan = 399,\n                MinVlan = 300,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDistributedVirtualSwitch(ctx, \"vds\", \u0026vsphere.DistributedVirtualSwitchArgs{\n\t\t\tVlanRanges: vsphere.DistributedVirtualSwitchVlanRangeArray{\n\t\t\t\t\u0026vsphere.DistributedVirtualSwitchVlanRangeArgs{\n\t\t\t\t\tMaxVlan: pulumi.Int(199),\n\t\t\t\t\tMinVlan: pulumi.Int(100),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.DistributedVirtualSwitchVlanRangeArgs{\n\t\t\t\t\tMaxVlan: pulumi.Int(399),\n\t\t\t\t\tMinVlan: pulumi.Int(300),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.DistributedVirtualSwitch;\nimport com.pulumi.vsphere.DistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vds = new DistributedVirtualSwitch(\"vds\", DistributedVirtualSwitchArgs.builder()        \n            .vlanRanges(            \n                DistributedVirtualSwitchVlanRangeArgs.builder()\n                    .maxVlan(199)\n                    .minVlan(100)\n                    .build(),\n                DistributedVirtualSwitchVlanRangeArgs.builder()\n                    .maxVlan(399)\n                    .minVlan(300)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vds:\n    type: vsphere:DistributedVirtualSwitch\n    properties:\n      vlanRanges:\n        - maxVlan: 199\n          minVlan: 100\n        - maxVlan: 399\n          minVlan: 300\n```\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "backupnfcMaximumMbit",
                "backupnfcReservationMbit",
                "backupnfcShareCount",
                "backupnfcShareLevel",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "datacenterId",
                "directpathGen2Allowed",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "faulttoleranceMaximumMbit",
                "faulttoleranceReservationMbit",
                "faulttoleranceShareCount",
                "faulttoleranceShareLevel",
                "hbrMaximumMbit",
                "hbrReservationMbit",
                "hbrShareCount",
                "hbrShareLevel",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "iscsiMaximumMbit",
                "iscsiReservationMbit",
                "iscsiShareCount",
                "iscsiShareLevel",
                "lacpApiVersion",
                "lacpEnabled",
                "lacpMode",
                "managementMaximumMbit",
                "managementReservationMbit",
                "managementShareCount",
                "managementShareLevel",
                "maxMtu",
                "multicastFilteringMode",
                "name",
                "netflowEnabled",
                "networkResourceControlVersion",
                "nfsMaximumMbit",
                "nfsReservationMbit",
                "nfsShareCount",
                "nfsShareLevel",
                "notifySwitches",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "uplinks",
                "vdpMaximumMbit",
                "vdpReservationMbit",
                "vdpShareCount",
                "vdpShareLevel",
                "version",
                "virtualmachineMaximumMbit",
                "virtualmachineReservationMbit",
                "virtualmachineShareCount",
                "virtualmachineShareLevel",
                "vlanId",
                "vlanRanges",
                "vmotionMaximumMbit",
                "vmotionReservationMbit",
                "vmotionShareCount",
                "vmotionShareLevel",
                "vsanMaximumMbit",
                "vsanReservationMbit",
                "vsanShareCount",
                "vsanShareLevel"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of active uplinks to be used in load\nbalancing. These uplinks need to match the definitions in the\n`uplinks` VDS argument. See\nhere for more details.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not a virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port.\n"
                },
                "backupnfcMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                },
                "backupnfcShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Shuts down all ports in the port groups that\nthis policy applies to, effectively blocking all network access to connected\nvirtual devices.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enables beacon probing as an additional measure\nto detect NIC failure.\n\n\u003e **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon\nprobing.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the VDS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nVDS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for VDS.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand requires vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VDS will be\ncreated. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the VDS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 for the ports\nfor which this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits\nper second if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is enabled\non the port for egress traffic.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts\nin bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will re-activate failed\nuplinks higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder in which to create the VDS.\nForces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "Use the `host` block to declare a host specification. The\noptions are:\n"
                },
                "ignoreOtherPvlanMappings": {
                    "type": "boolean",
                    "description": "Whether to ignore existing PVLAN\nmappings not managed by this resource. Defaults to false.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in\nbits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is\nenabled on the port for ingress traffic.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during\nbursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the VDS. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Enables LACP for the ports that this policy\napplies to.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The LACP mode. Can be one of `active` or `passive`.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the VDS.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the VDS. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VDS.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nactive flows are forced to be exported to the collector. Allowed range is\n`60` to `3600`. Default: `60`.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the Netflow\ncollector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.\nMust be set before Netflow can be enabled.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "Port for the Netflow collector. This\nmust be set before Netflow can be enabled.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Enables Netflow on all ports that this policy\napplies to.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nidle flows are forced to be exported to the collector. Allowed range is `10`\nto `600`. Default: `15`.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to\ntraffic that has both source and destination served by the same host.\nDefault: `false`.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation domain ID for\nthe Netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to\nthe number of packets analyzed. The default is `0`, which indicates that the\nVDS should analyze all packets. The maximum value is `1000`, which\nindicates an analysis rate of 0.001%.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable\nnetwork I/O control. Default: `false`.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The version of network I/O\ncontrol to use. Can be one of `version2` or `version3`. Default: `version2`.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will notify the\nbroadcast network of an uplink failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "Used to define a secondary VLAN\nID when using private VLANs.\n"
                },
                "pvlanMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                    },
                    "description": "Use the `pvlan_mapping` block to declare a\nprivate VLAN mapping. The options are:\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of standby uplinks to be used in\nfailover. These uplinks need to match the definitions in the\n`uplinks` VDS argument. See\nhere for more details.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support requires vCenter Server 6.0 or higher.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The uplink teaming policy. Can be one of\n`loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,\n`failover_explicit`, or `loadbalance_loadbased`.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "Forward all traffic transmitted by ports for which\nthis policy applies to its VDS uplinks.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of strings that uniquely identifies the names\nof the uplinks on the VDS across hosts. The number of items in this list\ncontrols the number of uplinks that exist on the VDS, in addition to the\nnames. See here for an example on how to\nuse this option.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the VDS. BY default, a VDS is created\nat the latest version supported by the vSphere version if not specified.\nA VDS can be upgraded to a newer version, but can not be downgraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "Used to denote VLAN trunking. Use the `min_vlan`\nand `max_vlan` sub-arguments to define the tagged VLAN range. Multiple\n`vlan_range` definitions are allowed, but they must not overlap. Example\nbelow:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vds = new vsphere.DistributedVirtualSwitch(\"vds\", {vlanRanges: [\n    {\n        maxVlan: 199,\n        minVlan: 100,\n    },\n    {\n        maxVlan: 399,\n        minVlan: 300,\n    },\n]});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvds = vsphere.DistributedVirtualSwitch(\"vds\", vlan_ranges=[\n    vsphere.DistributedVirtualSwitchVlanRangeArgs(\n        max_vlan=199,\n        min_vlan=100,\n    ),\n    vsphere.DistributedVirtualSwitchVlanRangeArgs(\n        max_vlan=399,\n        min_vlan=300,\n    ),\n])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vds = new VSphere.DistributedVirtualSwitch(\"vds\", new()\n    {\n        VlanRanges = new[]\n        {\n            new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs\n            {\n                MaxVlan = 199,\n                MinVlan = 100,\n            },\n            new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs\n            {\n                MaxVlan = 399,\n                MinVlan = 300,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDistributedVirtualSwitch(ctx, \"vds\", \u0026vsphere.DistributedVirtualSwitchArgs{\n\t\t\tVlanRanges: vsphere.DistributedVirtualSwitchVlanRangeArray{\n\t\t\t\t\u0026vsphere.DistributedVirtualSwitchVlanRangeArgs{\n\t\t\t\t\tMaxVlan: pulumi.Int(199),\n\t\t\t\t\tMinVlan: pulumi.Int(100),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.DistributedVirtualSwitchVlanRangeArgs{\n\t\t\t\t\tMaxVlan: pulumi.Int(399),\n\t\t\t\t\tMinVlan: pulumi.Int(300),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.DistributedVirtualSwitch;\nimport com.pulumi.vsphere.DistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vds = new DistributedVirtualSwitch(\"vds\", DistributedVirtualSwitchArgs.builder()        \n            .vlanRanges(            \n                DistributedVirtualSwitchVlanRangeArgs.builder()\n                    .maxVlan(199)\n                    .minVlan(100)\n                    .build(),\n                DistributedVirtualSwitchVlanRangeArgs.builder()\n                    .maxVlan(399)\n                    .minVlan(300)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vds:\n    type: vsphere:DistributedVirtualSwitch\n    properties:\n      vlanRanges:\n        - maxVlan: 199\n          minVlan: 100\n        - maxVlan: 399\n          minVlan: 300\n```\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedVirtualSwitch resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of active uplinks to be used in load\nbalancing. These uplinks need to match the definitions in the\n`uplinks` VDS argument. See\nhere for more details.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not a virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "backupnfcMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                    },
                    "backupnfcReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                    },
                    "backupnfcShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                    },
                    "backupnfcShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Shuts down all ports in the port groups that\nthis policy applies to, effectively blocking all network access to connected\nvirtual devices.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enables beacon probing as an additional measure\nto detect NIC failure.\n\n\u003e **NOTE:** VMware recommends using a minimum of 3 NICs when using beacon\nprobing.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "The current version of the VDS configuration, incremented\nby subsequent updates to the VDS.\n"
                    },
                    "contactDetail": {
                        "type": "string",
                        "description": "The detailed contact information for the person\nwho is responsible for the VDS.\n"
                    },
                    "contactName": {
                        "type": "string",
                        "description": "The name of the person who is responsible for the\nVDS.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue strings to set for VDS.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand requires vCenter Server.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter where the VDS will be\ncreated. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A detailed description for the VDS.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 for the ports\nfor which this policy applies to.\n"
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits\nper second if egress traffic shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in\nbytes if egress traffic shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "`true` if the traffic shaper is enabled\non the port for egress traffic.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts\nin bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If `true`, the teaming policy will re-activate failed\nuplinks higher in precedence when they come back up.\n"
                    },
                    "faulttoleranceMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                    },
                    "faulttoleranceShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder in which to create the VDS.\nForces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "hbrMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                    },
                    "hbrShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                        },
                        "description": "Use the `host` block to declare a host specification. The\noptions are:\n"
                    },
                    "ignoreOtherPvlanMappings": {
                        "type": "boolean",
                        "description": "Whether to ignore existing PVLAN\nmappings not managed by this resource. Defaults to false.\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in\nbits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in\nbytes if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "`true` if the traffic shaper is\nenabled on the port for ingress traffic.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during\nbursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ipv4Address": {
                        "type": "string",
                        "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments.\n"
                    },
                    "iscsiMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                    },
                    "iscsiShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "lacpApiVersion": {
                        "type": "string",
                        "description": "The Link Aggregation Control Protocol group\nversion to use with the VDS. Possible values are `singleLag` and\n`multipleLag`.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Enables LACP for the ports that this policy\napplies to.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The LACP mode. Can be one of `active` or `passive`.\n"
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                    },
                    "managementMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                    },
                    "managementShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "maxMtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the VDS.\n"
                    },
                    "multicastFilteringMode": {
                        "type": "string",
                        "description": "The multicast filtering mode to use\nwith the VDS. Can be one of `legacyFiltering` or `snooping`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VDS.\n"
                    },
                    "netflowActiveFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which\nactive flows are forced to be exported to the collector. Allowed range is\n`60` to `3600`. Default: `60`.\n"
                    },
                    "netflowCollectorIpAddress": {
                        "type": "string",
                        "description": "IP address for the Netflow\ncollector, using IPv4 or IPv6. IPv6 is supported in VDS version 6.0 or later.\nMust be set before Netflow can be enabled.\n"
                    },
                    "netflowCollectorPort": {
                        "type": "integer",
                        "description": "Port for the Netflow collector. This\nmust be set before Netflow can be enabled.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Enables Netflow on all ports that this policy\napplies to.\n"
                    },
                    "netflowIdleFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which\nidle flows are forced to be exported to the collector. Allowed range is `10`\nto `600`. Default: `15`.\n"
                    },
                    "netflowInternalFlowsOnly": {
                        "type": "boolean",
                        "description": "Whether to limit analysis to\ntraffic that has both source and destination served by the same host.\nDefault: `false`.\n"
                    },
                    "netflowObservationDomainId": {
                        "type": "integer",
                        "description": "The observation domain ID for\nthe Netflow collector.\n"
                    },
                    "netflowSamplingRate": {
                        "type": "integer",
                        "description": "The ratio of total number of packets to\nthe number of packets analyzed. The default is `0`, which indicates that the\nVDS should analyze all packets. The maximum value is `1000`, which\nindicates an analysis rate of 0.001%.\n"
                    },
                    "networkResourceControlEnabled": {
                        "type": "boolean",
                        "description": "Set to `true` to enable\nnetwork I/O control. Default: `false`.\n"
                    },
                    "networkResourceControlVersion": {
                        "type": "string",
                        "description": "The version of network I/O\ncontrol to use. Can be one of `version2` or `version3`. Default: `version2`.\n"
                    },
                    "nfsMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                    },
                    "nfsShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If `true`, the teaming policy will notify the\nbroadcast network of an uplink failover, triggering cache updates.\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "Used to define a secondary VLAN\nID when using private VLANs.\n"
                    },
                    "pvlanMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                        },
                        "description": "Use the `pvlan_mapping` block to declare a\nprivate VLAN mapping. The options are:\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of standby uplinks to be used in\nfailover. These uplinks need to match the definitions in the\n`uplinks` VDS argument. See\nhere for more details.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support requires vCenter Server 6.0 or higher.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The uplink teaming policy. Can be one of\n`loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`,\n`failover_explicit`, or `loadbalance_loadbased`.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "Forward all traffic transmitted by ports for which\nthis policy applies to its VDS uplinks.\n"
                    },
                    "uplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of strings that uniquely identifies the names\nof the uplinks on the VDS across hosts. The number of items in this list\ncontrols the number of uplinks that exist on the VDS, in addition to the\nnames. See here for an example on how to\nuse this option.\n"
                    },
                    "vdpMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                    },
                    "vdpShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the VDS. BY default, a VDS is created\nat the latest version supported by the vSphere version if not specified.\nA VDS can be upgraded to a newer version, but can not be downgraded.\n"
                    },
                    "virtualmachineMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                    },
                    "virtualmachineShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                        },
                        "description": "Used to denote VLAN trunking. Use the `min_vlan`\nand `max_vlan` sub-arguments to define the tagged VLAN range. Multiple\n`vlan_range` definitions are allowed, but they must not overlap. Example\nbelow:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vds = new vsphere.DistributedVirtualSwitch(\"vds\", {vlanRanges: [\n    {\n        maxVlan: 199,\n        minVlan: 100,\n    },\n    {\n        maxVlan: 399,\n        minVlan: 300,\n    },\n]});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvds = vsphere.DistributedVirtualSwitch(\"vds\", vlan_ranges=[\n    vsphere.DistributedVirtualSwitchVlanRangeArgs(\n        max_vlan=199,\n        min_vlan=100,\n    ),\n    vsphere.DistributedVirtualSwitchVlanRangeArgs(\n        max_vlan=399,\n        min_vlan=300,\n    ),\n])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vds = new VSphere.DistributedVirtualSwitch(\"vds\", new()\n    {\n        VlanRanges = new[]\n        {\n            new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs\n            {\n                MaxVlan = 199,\n                MinVlan = 100,\n            },\n            new VSphere.Inputs.DistributedVirtualSwitchVlanRangeArgs\n            {\n                MaxVlan = 399,\n                MinVlan = 300,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDistributedVirtualSwitch(ctx, \"vds\", \u0026vsphere.DistributedVirtualSwitchArgs{\n\t\t\tVlanRanges: vsphere.DistributedVirtualSwitchVlanRangeArray{\n\t\t\t\t\u0026vsphere.DistributedVirtualSwitchVlanRangeArgs{\n\t\t\t\t\tMaxVlan: pulumi.Int(199),\n\t\t\t\t\tMinVlan: pulumi.Int(100),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.DistributedVirtualSwitchVlanRangeArgs{\n\t\t\t\t\tMaxVlan: pulumi.Int(399),\n\t\t\t\t\tMinVlan: pulumi.Int(300),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.DistributedVirtualSwitch;\nimport com.pulumi.vsphere.DistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.inputs.DistributedVirtualSwitchVlanRangeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vds = new DistributedVirtualSwitch(\"vds\", DistributedVirtualSwitchArgs.builder()        \n            .vlanRanges(            \n                DistributedVirtualSwitchVlanRangeArgs.builder()\n                    .maxVlan(199)\n                    .minVlan(100)\n                    .build(),\n                DistributedVirtualSwitchVlanRangeArgs.builder()\n                    .maxVlan(399)\n                    .minVlan(300)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vds:\n    type: vsphere:DistributedVirtualSwitch\n    properties:\n      vlanRanges:\n        - maxVlan: 199\n          minVlan: 100\n        - maxVlan: 399\n          minVlan: 300\n```\n"
                    },
                    "vmotionMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                    },
                    "vmotionShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vsanMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                    },
                    "vsanShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/dpmHostOverride:DpmHostOverride": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`dpm_enabled` or `dpm_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n"
                }
            },
            "required": [
                "computeClusterId",
                "hostSystemId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`dpm_enabled` or `dpm_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DpmHostOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`dpm_enabled` or `dpm_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for this host. Default:\n`false`.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of the host.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/drsVmOverride:DrsVmOverride": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`drs_enabled` or `drs_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`drs_enabled` or `drs_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DrsVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`drs_enabled` or `drs_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/entityPermissions:EntityPermissions": {
            "properties": {
                "entityId": {
                    "type": "string",
                    "description": "The managed object id (uuid for some entities) on which permissions are to be created.\n"
                },
                "entityType": {
                    "type": "string",
                    "description": "The managed object type, types can be found in the managed object type section \n[here](https://developer.vmware.com/apis/968/vsphere).\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                    },
                    "description": "The permissions to be given on this entity. Keep the permissions sorted\nalphabetically on `user_or_group` for a better user experience.\n"
                }
            },
            "required": [
                "entityId",
                "entityType",
                "permissions"
            ],
            "inputProperties": {
                "entityId": {
                    "type": "string",
                    "description": "The managed object id (uuid for some entities) on which permissions are to be created.\n"
                },
                "entityType": {
                    "type": "string",
                    "description": "The managed object type, types can be found in the managed object type section \n[here](https://developer.vmware.com/apis/968/vsphere).\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                    },
                    "description": "The permissions to be given on this entity. Keep the permissions sorted\nalphabetically on `user_or_group` for a better user experience.\n"
                }
            },
            "requiredInputs": [
                "entityId",
                "entityType",
                "permissions"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityPermissions resources.\n",
                "properties": {
                    "entityId": {
                        "type": "string",
                        "description": "The managed object id (uuid for some entities) on which permissions are to be created.\n"
                    },
                    "entityType": {
                        "type": "string",
                        "description": "The managed object type, types can be found in the managed object type section \n[here](https://developer.vmware.com/apis/968/vsphere).\n"
                    },
                    "permissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                        },
                        "description": "The permissions to be given on this entity. Keep the permissions sorted\nalphabetically on `user_or_group` for a better user experience.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/file:File": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Uploading a File\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuVmdkUpload = new vsphere.File(\"ubuntuVmdkUpload\", {\n    createDirectories: true,\n    datacenter: \"dc-01\",\n    datastore: \"datastore-01\",\n    destinationFile: \"/my/dst/path/custom_ubuntu.vmdk\",\n    sourceFile: \"/my/src/path/custom_ubuntu.vmdk\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_vmdk_upload = vsphere.File(\"ubuntuVmdkUpload\",\n    create_directories=True,\n    datacenter=\"dc-01\",\n    datastore=\"datastore-01\",\n    destination_file=\"/my/dst/path/custom_ubuntu.vmdk\",\n    source_file=\"/my/src/path/custom_ubuntu.vmdk\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuVmdkUpload = new VSphere.File(\"ubuntuVmdkUpload\", new()\n    {\n        CreateDirectories = true,\n        Datacenter = \"dc-01\",\n        Datastore = \"datastore-01\",\n        DestinationFile = \"/my/dst/path/custom_ubuntu.vmdk\",\n        SourceFile = \"/my/src/path/custom_ubuntu.vmdk\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewFile(ctx, \"ubuntuVmdkUpload\", \u0026vsphere.FileArgs{\n\t\t\tCreateDirectories: pulumi.Bool(true),\n\t\t\tDatacenter:        pulumi.String(\"dc-01\"),\n\t\t\tDatastore:         pulumi.String(\"datastore-01\"),\n\t\t\tDestinationFile:   pulumi.String(\"/my/dst/path/custom_ubuntu.vmdk\"),\n\t\t\tSourceFile:        pulumi.String(\"/my/src/path/custom_ubuntu.vmdk\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.File;\nimport com.pulumi.vsphere.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntuVmdkUpload = new File(\"ubuntuVmdkUpload\", FileArgs.builder()        \n            .createDirectories(true)\n            .datacenter(\"dc-01\")\n            .datastore(\"datastore-01\")\n            .destinationFile(\"/my/dst/path/custom_ubuntu.vmdk\")\n            .sourceFile(\"/my/src/path/custom_ubuntu.vmdk\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuVmdkUpload:\n    type: vsphere:File\n    properties:\n      createDirectories: true\n      datacenter: dc-01\n      datastore: datastore-01\n      destinationFile: /my/dst/path/custom_ubuntu.vmdk\n      sourceFile: /my/src/path/custom_ubuntu.vmdk\n```\n{{% /example %}}\n{{% example %}}\n### Copying a File\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuCopy = new vsphere.File(\"ubuntuCopy\", {\n    createDirectories: true,\n    datacenter: \"dc-01\",\n    datastore: \"datastore-01\",\n    destinationFile: \"/my/dst/path/custom_ubuntu.vmdk\",\n    sourceDatacenter: \"dc-01\",\n    sourceDatastore: \"datastore-01\",\n    sourceFile: \"/my/src/path/custom_ubuntu.vmdk\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_copy = vsphere.File(\"ubuntuCopy\",\n    create_directories=True,\n    datacenter=\"dc-01\",\n    datastore=\"datastore-01\",\n    destination_file=\"/my/dst/path/custom_ubuntu.vmdk\",\n    source_datacenter=\"dc-01\",\n    source_datastore=\"datastore-01\",\n    source_file=\"/my/src/path/custom_ubuntu.vmdk\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuCopy = new VSphere.File(\"ubuntuCopy\", new()\n    {\n        CreateDirectories = true,\n        Datacenter = \"dc-01\",\n        Datastore = \"datastore-01\",\n        DestinationFile = \"/my/dst/path/custom_ubuntu.vmdk\",\n        SourceDatacenter = \"dc-01\",\n        SourceDatastore = \"datastore-01\",\n        SourceFile = \"/my/src/path/custom_ubuntu.vmdk\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewFile(ctx, \"ubuntuCopy\", \u0026vsphere.FileArgs{\n\t\t\tCreateDirectories: pulumi.Bool(true),\n\t\t\tDatacenter:        pulumi.String(\"dc-01\"),\n\t\t\tDatastore:         pulumi.String(\"datastore-01\"),\n\t\t\tDestinationFile:   pulumi.String(\"/my/dst/path/custom_ubuntu.vmdk\"),\n\t\t\tSourceDatacenter:  pulumi.String(\"dc-01\"),\n\t\t\tSourceDatastore:   pulumi.String(\"datastore-01\"),\n\t\t\tSourceFile:        pulumi.String(\"/my/src/path/custom_ubuntu.vmdk\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.File;\nimport com.pulumi.vsphere.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntuCopy = new File(\"ubuntuCopy\", FileArgs.builder()        \n            .createDirectories(true)\n            .datacenter(\"dc-01\")\n            .datastore(\"datastore-01\")\n            .destinationFile(\"/my/dst/path/custom_ubuntu.vmdk\")\n            .sourceDatacenter(\"dc-01\")\n            .sourceDatastore(\"datastore-01\")\n            .sourceFile(\"/my/src/path/custom_ubuntu.vmdk\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuCopy:\n    type: vsphere:File\n    properties:\n      createDirectories: true\n      datacenter: dc-01\n      datastore: datastore-01\n      destinationFile: /my/dst/path/custom_ubuntu.vmdk\n      sourceDatacenter: dc-01\n      sourceDatastore: datastore-01\n      sourceFile: /my/src/path/custom_ubuntu.vmdk\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter on first apply if any are missing for copy operation.\n\n\u003e **NOTE:** Any directory created as part of the `create_directories` argument\nwill not be deleted when the resource is destroyed. New directories are not\ncreated if the `destination_file` path is changed in subsequent applies.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter to which the file will be\nuploaded.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore to which to upload the\nfile.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on the destination `datastore` in vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter from which the file\nwill be copied. Forces a new resource if changed.\n"
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore from which file will\nbe copied. Forces a new resource if changed.\n"
                },
                "sourceFile": {
                    "type": "string"
                }
            },
            "required": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "inputProperties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter on first apply if any are missing for copy operation.\n\n\u003e **NOTE:** Any directory created as part of the `create_directories` argument\nwill not be deleted when the resource is destroyed. New directories are not\ncreated if the `destination_file` path is changed in subsequent applies.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter to which the file will be\nuploaded.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore to which to upload the\nfile.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on the destination `datastore` in vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter from which the file\nwill be copied. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore from which file will\nbe copied. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "sourceFile": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering File resources.\n",
                "properties": {
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Create directories in `destination_file`\npath parameter on first apply if any are missing for copy operation.\n\n\u003e **NOTE:** Any directory created as part of the `create_directories` argument\nwill not be deleted when the resource is destroyed. New directories are not\ncreated if the `destination_file` path is changed in subsequent applies.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of a datacenter to which the file will be\nuploaded.\n"
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore to which to upload the\nfile.\n"
                    },
                    "destinationFile": {
                        "type": "string",
                        "description": "The path to where the file should be uploaded\nor copied to on the destination `datastore` in vSphere.\n"
                    },
                    "sourceDatacenter": {
                        "type": "string",
                        "description": "The name of a datacenter from which the file\nwill be copied. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceDatastore": {
                        "type": "string",
                        "description": "The name of the datastore from which file will\nbe copied. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceFile": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/folder:Folder": {
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n\n\u003e **NOTE:** `path` can be modified - the resulting behavior is dependent on\nwhat section of `path` you are modifying. If you are modifying the parent (so\nany part before the last `/`), your folder will be moved to that new parent. If\nmodifying the name (the part after the last `/`), your folder will be renamed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "path",
                "type"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n\n\u003e **NOTE:** `path` can be modified - the resulting behavior is dependent on\nwhat section of `path` you are modifying. If you are modifying the parent (so\nany part before the last `/`), your folder will be moved to that new parent. If\nmodifying the name (the part after the last `/`), your folder will be renamed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "path",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Folder resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n\n\u003e **NOTE:** `path` can be modified - the resulting behavior is dependent on\nwhat section of `path` you are modifying. If you are modifying the parent (so\nany part before the last `/`), your folder will be moved to that new parent. If\nmodifying the name (the part after the last `/`), your folder will be renamed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/haVmOverride:HaVmOverride": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non this virtual machine if an APD status on an affected datastore clears in\nthe middle of an APD event. Can be one of `useClusterDefault`, `none` or\n`reset`.  Default: `useClusterDefault`.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of `clusterDefault`, `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `clusterDefault`.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in seconds\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Use `-1` to use\nthe cluster default. Default: `-1`.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `clusterDefault`, `disabled`, `warning`, or\n`restartAggressive`. Default: `clusterDefault`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual\nmachine when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `clusterIsolationResponse`, `none`, `powerOff`, or\n`shutdown`. Default: `clusterIsolationResponse`.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual\nmachine is not received within this configured interval, the virtual machine\nis marked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to this virtual machine when responding to a failure event. Default:\n`3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on this virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or\nnot the cluster's default settings or the VM override settings specified in\nthis resource are used for virtual machine monitoring. The default is `true`\n(use cluster defaults) - set to `false` to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for the virtual\nmachine when vSphere detects a host failure. Can be one of\n`clusterRestartPriority`, `lowest`, `low`, `medium`, `high`, `highest`, or `disabled`.\nDefault: `clusterRestartPriority`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that\nvSphere HA will wait for this virtual machine to be ready. Use `-1` to\nspecify the cluster default.  Default: `-1`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non this virtual machine if an APD status on an affected datastore clears in\nthe middle of an APD event. Can be one of `useClusterDefault`, `none` or\n`reset`.  Default: `useClusterDefault`.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of `clusterDefault`, `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `clusterDefault`.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in seconds\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Use `-1` to use\nthe cluster default. Default: `-1`.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `clusterDefault`, `disabled`, `warning`, or\n`restartAggressive`. Default: `clusterDefault`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual\nmachine when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `clusterIsolationResponse`, `none`, `powerOff`, or\n`shutdown`. Default: `clusterIsolationResponse`.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual\nmachine is not received within this configured interval, the virtual machine\nis marked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to this virtual machine when responding to a failure event. Default:\n`3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on this virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or\nnot the cluster's default settings or the VM override settings specified in\nthis resource are used for virtual machine monitoring. The default is `true`\n(use cluster defaults) - set to `false` to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for the virtual\nmachine when vSphere detects a host failure. Can be one of\n`clusterRestartPriority`, `lowest`, `low`, `medium`, `high`, `highest`, or `disabled`.\nDefault: `clusterRestartPriority`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that\nvSphere HA will wait for this virtual machine to be ready. Use `-1` to\nspecify the cluster default.  Default: `-1`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HaVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "Controls the action to take\non this virtual machine if an APD status on an affected datastore clears in\nthe middle of an APD event. Can be one of `useClusterDefault`, `none` or\n`reset`.  Default: `useClusterDefault`.\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this\nvirtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of `clusterDefault`, `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `clusterDefault`.\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "Controls the delay in seconds\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Use `-1` to use\nthe cluster default. Default: `-1`.\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this\nvirtual machine when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `clusterDefault`, `disabled`, `warning`, or\n`restartAggressive`. Default: `clusterDefault`.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on this virtual\nmachine when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `clusterIsolationResponse`, `none`, `powerOff`, or\n`shutdown`. Default: `clusterIsolationResponse`.\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "If a heartbeat from this virtual\nmachine is not received within this configured interval, the virtual machine\nis marked as failed. The value is in seconds. Default: `30`.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will\nperform to this virtual machine when responding to a failure event. Default:\n`3`\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after\npowering on this virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                    },
                    "haVmMonitoringUseClusterDefaults": {
                        "type": "boolean",
                        "description": "Determines whether or\nnot the cluster's default settings or the VM override settings specified in\nthis resource are used for virtual machine monitoring. The default is `true`\n(use cluster defaults) - set to `false` to have overrides take effect.\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The restart priority for the virtual\nmachine when vSphere detects a host failure. Can be one of\n`clusterRestartPriority`, `lowest`, `low`, `medium`, `high`, `highest`, or `disabled`.\nDefault: `clusterRestartPriority`.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds, that\nvSphere HA will wait for this virtual machine to be ready. Use `-1` to\nspecify the cluster default.  Default: `-1`.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/host:Host": {
            "description": "Provides a VMware vSphere host resource. This represents an ESXi host that\ncan be used either as a member of a cluster or as a standalone host.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Create a standalone host\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst thumbprint = vsphere.getHostThumbprint({\n    address: \"esx-01.example.com\",\n    insecure: true,\n});\nconst esx_01 = new vsphere.Host(\"esx-01\", {\n    hostname: \"esx-01.example.com\",\n    username: \"root\",\n    password: \"password\",\n    license: \"00000-00000-00000-00000-00000\",\n    thumbprint: thumbprint.then(thumbprint =\u003e thumbprint.id),\n    datacenter: datacenter.then(datacenter =\u003e datacenter.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nthumbprint = vsphere.get_host_thumbprint(address=\"esx-01.example.com\",\n    insecure=True)\nesx_01 = vsphere.Host(\"esx-01\",\n    hostname=\"esx-01.example.com\",\n    username=\"root\",\n    password=\"password\",\n    license=\"00000-00000-00000-00000-00000\",\n    thumbprint=thumbprint.id,\n    datacenter=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var thumbprint = VSphere.GetHostThumbprint.Invoke(new()\n    {\n        Address = \"esx-01.example.com\",\n        Insecure = true,\n    });\n\n    var esx_01 = new VSphere.Host(\"esx-01\", new()\n    {\n        Hostname = \"esx-01.example.com\",\n        Username = \"root\",\n        Password = \"password\",\n        License = \"00000-00000-00000-00000-00000\",\n        Thumbprint = thumbprint.Apply(getHostThumbprintResult =\u003e getHostThumbprintResult.Id),\n        Datacenter = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthumbprint, err := vsphere.GetHostThumbprint(ctx, \u0026vsphere.GetHostThumbprintArgs{\n\t\t\tAddress:  \"esx-01.example.com\",\n\t\t\tInsecure: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHost(ctx, \"esx-01\", \u0026vsphere.HostArgs{\n\t\t\tHostname:   pulumi.String(\"esx-01.example.com\"),\n\t\t\tUsername:   pulumi.String(\"root\"),\n\t\t\tPassword:   pulumi.String(\"password\"),\n\t\t\tLicense:    pulumi.String(\"00000-00000-00000-00000-00000\"),\n\t\t\tThumbprint: *pulumi.String(thumbprint.Id),\n\t\t\tDatacenter: *pulumi.String(datacenter.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostThumbprintArgs;\nimport com.pulumi.vsphere.Host;\nimport com.pulumi.vsphere.HostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var thumbprint = VsphereFunctions.getHostThumbprint(GetHostThumbprintArgs.builder()\n            .address(\"esx-01.example.com\")\n            .insecure(true)\n            .build());\n\n        var esx_01 = new Host(\"esx-01\", HostArgs.builder()        \n            .hostname(\"esx-01.example.com\")\n            .username(\"root\")\n            .password(\"password\")\n            .license(\"00000-00000-00000-00000-00000\")\n            .thumbprint(thumbprint.applyValue(getHostThumbprintResult -\u003e getHostThumbprintResult.id()))\n            .datacenter(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  esx-01:\n    type: vsphere:Host\n    properties:\n      hostname: esx-01.example.com\n      username: root\n      password: password\n      license: 00000-00000-00000-00000-00000\n      thumbprint: ${thumbprint.id}\n      datacenter: ${datacenter.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  thumbprint:\n    fn::invoke:\n      Function: vsphere:getHostThumbprint\n      Arguments:\n        address: esx-01.example.com\n        insecure: true\n```\n{{% /example %}}\n{{% example %}}\n### Create host in a compute cluster\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst thumbprint = vsphere.getHostThumbprint({\n    address: \"esx-01.example.com\",\n    insecure: true,\n});\nconst esx_01 = new vsphere.Host(\"esx-01\", {\n    hostname: \"esx-01.example.com\",\n    username: \"root\",\n    password: \"password\",\n    license: \"00000-00000-00000-00000-00000\",\n    thumbprint: thumbprint.then(thumbprint =\u003e thumbprint.id),\n    cluster: cluster.then(cluster =\u003e cluster.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nthumbprint = vsphere.get_host_thumbprint(address=\"esx-01.example.com\",\n    insecure=True)\nesx_01 = vsphere.Host(\"esx-01\",\n    hostname=\"esx-01.example.com\",\n    username=\"root\",\n    password=\"password\",\n    license=\"00000-00000-00000-00000-00000\",\n    thumbprint=thumbprint.id,\n    cluster=cluster.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var thumbprint = VSphere.GetHostThumbprint.Invoke(new()\n    {\n        Address = \"esx-01.example.com\",\n        Insecure = true,\n    });\n\n    var esx_01 = new VSphere.Host(\"esx-01\", new()\n    {\n        Hostname = \"esx-01.example.com\",\n        Username = \"root\",\n        Password = \"password\",\n        License = \"00000-00000-00000-00000-00000\",\n        Thumbprint = thumbprint.Apply(getHostThumbprintResult =\u003e getHostThumbprintResult.Id),\n        Cluster = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthumbprint, err := vsphere.GetHostThumbprint(ctx, \u0026vsphere.GetHostThumbprintArgs{\n\t\t\tAddress:  \"esx-01.example.com\",\n\t\t\tInsecure: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHost(ctx, \"esx-01\", \u0026vsphere.HostArgs{\n\t\t\tHostname:   pulumi.String(\"esx-01.example.com\"),\n\t\t\tUsername:   pulumi.String(\"root\"),\n\t\t\tPassword:   pulumi.String(\"password\"),\n\t\t\tLicense:    pulumi.String(\"00000-00000-00000-00000-00000\"),\n\t\t\tThumbprint: *pulumi.String(thumbprint.Id),\n\t\t\tCluster:    *pulumi.String(cluster.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetHostThumbprintArgs;\nimport com.pulumi.vsphere.Host;\nimport com.pulumi.vsphere.HostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var thumbprint = VsphereFunctions.getHostThumbprint(GetHostThumbprintArgs.builder()\n            .address(\"esx-01.example.com\")\n            .insecure(true)\n            .build());\n\n        var esx_01 = new Host(\"esx-01\", HostArgs.builder()        \n            .hostname(\"esx-01.example.com\")\n            .username(\"root\")\n            .password(\"password\")\n            .license(\"00000-00000-00000-00000-00000\")\n            .thumbprint(thumbprint.applyValue(getHostThumbprintResult -\u003e getHostThumbprintResult.id()))\n            .cluster(cluster.applyValue(getComputeClusterResult -\u003e getComputeClusterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  esx-01:\n    type: vsphere:Host\n    properties:\n      hostname: esx-01.example.com\n      username: root\n      password: password\n      license: 00000-00000-00000-00000-00000\n      thumbprint: ${thumbprint.id}\n      cluster: ${cluster.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  cluster:\n    fn::invoke:\n      Function: vsphere:getComputeCluster\n      Arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n  thumbprint:\n    fn::invoke:\n      Function: vsphere:getHostThumbprint\n      Arguments:\n        address: esx-01.example.com\n        insecure: true\n```\n{{% /example %}}\n{{% /examples %}}\n## Importing\n\nAn existing host can be [imported][docs-import] into this resource by supplying\nthe host's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n\nThe above would import the host with ID `host-123`.\n",
            "properties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster_managed`.\n"
                },
                "clusterManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconnected.\nDefault is `false`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute IDs and string\nvalues to apply to the resource. Please refer to the\n`vsphere_custom_attributes` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n\n[docs-host-thumbprint-data-source]: /docs/providers/vsphere/d/host_thumbprint.html\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to `true` then it will force the host to be added,\neven if the host is already connected to a different vCenter Server instance.\nDefault is `false`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host.\nDefault is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n",
                    "secret": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. Please\nrefer to the `vsphere.Tag` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Tagging support is not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the\nCA that signed the host's certificate should be trusted. If the CA is not\ntrusted and no thumbprint is set then the operation will fail. See data source\n[`vsphere.getHostThumbprint`][docs-host-thumbprint-data-source].\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "required": [
                "hostname",
                "password",
                "username"
            ],
            "inputProperties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster_managed`.\n"
                },
                "clusterManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconnected.\nDefault is `false`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute IDs and string\nvalues to apply to the resource. Please refer to the\n`vsphere_custom_attributes` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n\n[docs-host-thumbprint-data-source]: /docs/providers/vsphere/d/host_thumbprint.html\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to `true` then it will force the host to be added,\neven if the host is already connected to a different vCenter Server instance.\nDefault is `false`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host.\nDefault is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n",
                    "secret": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. Please\nrefer to the `vsphere.Tag` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Tagging support is not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the\nCA that signed the host's certificate should be trusted. If the CA is not\ntrusted and no thumbprint is set then the operation will fail. See data source\n[`vsphere.getHostThumbprint`][docs-host-thumbprint-data-source].\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "requiredInputs": [
                "hostname",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Host resources.\n",
                "properties": {
                    "cluster": {
                        "type": "string",
                        "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster_managed`.\n"
                    },
                    "clusterManaged": {
                        "type": "boolean",
                        "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                    },
                    "connected": {
                        "type": "boolean",
                        "description": "If set to false then the host will be disconnected.\nDefault is `false`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute IDs and string\nvalues to apply to the resource. Please refer to the\n`vsphere_custom_attributes` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n\n[docs-host-thumbprint-data-source]: /docs/providers/vsphere/d/host_thumbprint.html\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                    },
                    "force": {
                        "type": "boolean",
                        "description": "If set to `true` then it will force the host to be added,\neven if the host is already connected to a different vCenter Server instance.\nDefault is `false`.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "FQDN or IP address of the host to be added.\n"
                    },
                    "license": {
                        "type": "string",
                        "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                    },
                    "lockdown": {
                        "type": "string",
                        "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                    },
                    "maintenance": {
                        "type": "boolean",
                        "description": "Set the management state of the host.\nDefault is `false`.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password that will be used by vSphere to authenticate\nto the host.\n",
                        "secret": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. Please\nrefer to the `vsphere.Tag` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Tagging support is not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                    },
                    "thumbprint": {
                        "type": "string",
                        "description": "Host's certificate SHA-1 thumbprint. If not set the\nCA that signed the host's certificate should be trusted. If the CA is not\ntrusted and no thumbprint is set then the operation will fail. See data source\n[`vsphere.getHostThumbprint`][docs-host-thumbprint-data-source].\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostPortGroup:HostPortGroup": {
            "description": "The `vsphere.HostPortGroup` resource can be used to manage port groups on\nESXi hosts. These port groups are connected to standard switches, which\ncan be managed by the `vsphere.HostVirtualSwitch`\nresource.\n\nFor an overview on vSphere networking concepts, see [the product documentation][ref-vsphere-net-concepts].\n\n[ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n**Create a Virtual Switch and Bind a Port Group:**\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst hostVirtualSwitch = new vsphere.HostVirtualSwitch(\"hostVirtualSwitch\", {\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    activeNics: [\"vmnic0\"],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    hostSystemId: host.then(host =\u003e host.id),\n    virtualSwitchName: hostVirtualSwitch.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nhost_virtual_switch = vsphere.HostVirtualSwitch(\"hostVirtualSwitch\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    active_nics=[\"vmnic0\"],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    host_system_id=host.id,\n    virtual_switch_name=host_virtual_switch.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hostVirtualSwitch = new VSphere.HostVirtualSwitch(\"hostVirtualSwitch\", new()\n    {\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic0\",\n            \"vmnic1\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic0\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic1\",\n        },\n    });\n\n    var pg = new VSphere.HostPortGroup(\"pg\", new()\n    {\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        VirtualSwitchName = hostVirtualSwitch.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostVirtualSwitch, err := vsphere.NewHostVirtualSwitch(ctx, \"hostVirtualSwitch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tHostSystemId: *pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tHostSystemId:      *pulumi.String(host.Id),\n\t\t\tVirtualSwitchName: hostVirtualSwitch.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport com.pulumi.vsphere.HostPortGroup;\nimport com.pulumi.vsphere.HostPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var hostVirtualSwitch = new HostVirtualSwitch(\"hostVirtualSwitch\", HostVirtualSwitchArgs.builder()        \n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .networkAdapters(            \n                \"vmnic0\",\n                \"vmnic1\")\n            .activeNics(\"vmnic0\")\n            .standbyNics(\"vmnic1\")\n            .build());\n\n        var pg = new HostPortGroup(\"pg\", HostPortGroupArgs.builder()        \n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .virtualSwitchName(hostVirtualSwitch.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hostVirtualSwitch:\n    type: vsphere:HostVirtualSwitch\n    properties:\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic0\n        - vmnic1\n      activeNics:\n        - vmnic0\n      standbyNics:\n        - vmnic1\n  pg:\n    type: vsphere:HostPortGroup\n    properties:\n      hostSystemId: ${host.id}\n      virtualSwitchName: ${hostVirtualSwitch.name}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\n**Create a Port Group with a VLAN and ab Override:**\n\nThis example sets the trunk mode VLAN (`4095`, which passes through all tags)\nand sets\n`allow_promiscuous`\nto ensure that all traffic is seen on the port. The setting overrides\nthe implicit default of `false` set on the standard switch.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst hostVirtualSwitch = new vsphere.HostVirtualSwitch(\"hostVirtualSwitch\", {\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    activeNics: [\"vmnic0\"],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    hostSystemId: host.then(host =\u003e host.id),\n    virtualSwitchName: hostVirtualSwitch.name,\n    vlanId: 4095,\n    allowPromiscuous: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nhost_virtual_switch = vsphere.HostVirtualSwitch(\"hostVirtualSwitch\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    active_nics=[\"vmnic0\"],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    host_system_id=host.id,\n    virtual_switch_name=host_virtual_switch.name,\n    vlan_id=4095,\n    allow_promiscuous=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hostVirtualSwitch = new VSphere.HostVirtualSwitch(\"hostVirtualSwitch\", new()\n    {\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic0\",\n            \"vmnic1\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic0\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic1\",\n        },\n    });\n\n    var pg = new VSphere.HostPortGroup(\"pg\", new()\n    {\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        VirtualSwitchName = hostVirtualSwitch.Name,\n        VlanId = 4095,\n        AllowPromiscuous = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostVirtualSwitch, err := vsphere.NewHostVirtualSwitch(ctx, \"hostVirtualSwitch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tHostSystemId: *pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tHostSystemId:      *pulumi.String(host.Id),\n\t\t\tVirtualSwitchName: hostVirtualSwitch.Name,\n\t\t\tVlanId:            pulumi.Int(4095),\n\t\t\tAllowPromiscuous:  pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport com.pulumi.vsphere.HostPortGroup;\nimport com.pulumi.vsphere.HostPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var hostVirtualSwitch = new HostVirtualSwitch(\"hostVirtualSwitch\", HostVirtualSwitchArgs.builder()        \n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .networkAdapters(            \n                \"vmnic0\",\n                \"vmnic1\")\n            .activeNics(\"vmnic0\")\n            .standbyNics(\"vmnic1\")\n            .build());\n\n        var pg = new HostPortGroup(\"pg\", HostPortGroupArgs.builder()        \n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .virtualSwitchName(hostVirtualSwitch.name())\n            .vlanId(4095)\n            .allowPromiscuous(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hostVirtualSwitch:\n    type: vsphere:HostVirtualSwitch\n    properties:\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic0\n        - vmnic1\n      activeNics:\n        - vmnic0\n      standbyNics:\n        - vmnic1\n  pg:\n    type: vsphere:HostPortGroup\n    properties:\n      hostSystemId: ${host.id}\n      virtualSwitchName: ${hostVirtualSwitch.name}\n      vlanId: 4095\n      allowPromiscuous: true\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}\n## Importing\n\nAn existing host port group can be imported into this resource\nusing the host port group's ID. An example is below:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n\nThe above would import the `management` host port group from host with ID `host-123`.\n",
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "computedPolicy": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/HostPortGroupPort:HostPortGroupPort"
                    },
                    "description": "A list of ports that currently exist and are used on this port group.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "required": [
                "computedPolicy",
                "hostSystemId",
                "key",
                "name",
                "ports",
                "virtualSwitchName"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "requiredInputs": [
                "hostSystemId",
                "virtualSwitchName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostPortGroup resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active network adapters used for load balancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                    },
                    "computedPolicy": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The key for this port group as returned from the vSphere API.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.  Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "ports": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/HostPortGroupPort:HostPortGroupPort"
                        },
                        "description": "A list of ports that currently exist and are used on this port group.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Enable traffic shaping on this virtual switch or port group.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby network adapters used for failover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                    },
                    "virtualSwitchName": {
                        "type": "string",
                        "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostVirtualSwitch:HostVirtualSwitch": {
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of active network adapters used for load\nbalancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own. Default: `true`.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed. Default: `true`.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port. Default:\n`false`.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "The interval, in seconds, that a NIC beacon\npacket is sent out. This can be used with `check_beacon` to\noffer link failure capability beyond link status only. Default: `1`.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing - this requires that the\n`beacon_interval` option has been set in the bridge\noptions. If this is set to `false`, only link status is used to check for\nfailed NICs.  Default: `false`.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will re-activate\nfailed interfaces higher in precedence when they come back up.  Default:\n`true`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic. Default: `listen`.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type.  Valid\ntypes are `cpd` and `lldp`. Default: `cdp`.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n"
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The network interfaces to bind to the bridge.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will\nnotify the broadcast network of a NIC failover, triggering cache updates.\nDefault: `true`.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n\n\u003e **NOTE:** Changing the port count requires a reboot of the host. This provider\nwill not restart the host for you.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per\nsecond if traffic shaping is enabled. Default: `0`\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if\nshaping is enabled. Default: `0`\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the traffic shaper for\nports managed by this virtual switch. Default: `false`.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in\nbits per second if traffic shaping is enabled. Default: `0`\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of standby network adapters used for\nfailover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one\nof `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`. Default: `loadbalance_srcid`.\n"
                }
            },
            "required": [
                "activeNics",
                "hostSystemId",
                "name",
                "networkAdapters"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of active network adapters used for load\nbalancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own. Default: `true`.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed. Default: `true`.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port. Default:\n`false`.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "The interval, in seconds, that a NIC beacon\npacket is sent out. This can be used with `check_beacon` to\noffer link failure capability beyond link status only. Default: `1`.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing - this requires that the\n`beacon_interval` option has been set in the bridge\noptions. If this is set to `false`, only link status is used to check for\nfailed NICs.  Default: `false`.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will re-activate\nfailed interfaces higher in precedence when they come back up.  Default:\n`true`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic. Default: `listen`.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type.  Valid\ntypes are `cpd` and `lldp`. Default: `cdp`.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The network interfaces to bind to the bridge.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will\nnotify the broadcast network of a NIC failover, triggering cache updates.\nDefault: `true`.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n\n\u003e **NOTE:** Changing the port count requires a reboot of the host. This provider\nwill not restart the host for you.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per\nsecond if traffic shaping is enabled. Default: `0`\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if\nshaping is enabled. Default: `0`\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the traffic shaper for\nports managed by this virtual switch. Default: `false`.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in\nbits per second if traffic shaping is enabled. Default: `0`\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of standby network adapters used for\nfailover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one\nof `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`. Default: `loadbalance_srcid`.\n"
                }
            },
            "requiredInputs": [
                "activeNics",
                "hostSystemId",
                "networkAdapters"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostVirtualSwitch resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of active network adapters used for load\nbalancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own. Default: `true`.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed. Default: `true`.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port. Default:\n`false`.\n"
                    },
                    "beaconInterval": {
                        "type": "integer",
                        "description": "The interval, in seconds, that a NIC beacon\npacket is sent out. This can be used with `check_beacon` to\noffer link failure capability beyond link status only. Default: `1`.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing - this requires that the\n`beacon_interval` option has been set in the bridge\noptions. If this is set to `false`, only link status is used to check for\nfailed NICs.  Default: `false`.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If set to `true`, the teaming policy will re-activate\nfailed interfaces higher in precedence when they come back up.  Default:\n`true`.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to `advertise` or `listen`\nfor link discovery traffic. Default: `listen`.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type.  Valid\ntypes are `cpd` and `lldp`. Default: `cdp`.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkAdapters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The network interfaces to bind to the bridge.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If set to `true`, the teaming policy will\nnotify the broadcast network of a NIC failover, triggering cache updates.\nDefault: `true`.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n\n\u003e **NOTE:** Changing the port count requires a reboot of the host. This provider\nwill not restart the host for you.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per\nsecond if traffic shaping is enabled. Default: `0`\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if\nshaping is enabled. Default: `0`\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Set to `true` to enable the traffic shaper for\nports managed by this virtual switch. Default: `false`.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in\nbits per second if traffic shaping is enabled. Default: `0`\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of standby network adapters used for\nfailover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one\nof `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`. Default: `loadbalance_srcid`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/license:License": {
            "description": "Provides a VMware vSphere license resource. This can be used to add and remove license keys.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst licenseKey = new vsphere.License(\"licenseKey\", {\n    labels: {\n        VpxClientLicenseLabel: \"Hello World\",\n        Workflow: \"Hello World\",\n    },\n    licenseKey: \"452CQ-2EK54-K8742-00000-00000\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlicense_key = vsphere.License(\"licenseKey\",\n    labels={\n        \"VpxClientLicenseLabel\": \"Hello World\",\n        \"Workflow\": \"Hello World\",\n    },\n    license_key=\"452CQ-2EK54-K8742-00000-00000\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var licenseKey = new VSphere.License(\"licenseKey\", new()\n    {\n        Labels = \n        {\n            { \"VpxClientLicenseLabel\", \"Hello World\" },\n            { \"Workflow\", \"Hello World\" },\n        },\n        LicenseKey = \"452CQ-2EK54-K8742-00000-00000\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewLicense(ctx, \"licenseKey\", \u0026vsphere.LicenseArgs{\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"VpxClientLicenseLabel\": pulumi.String(\"Hello World\"),\n\t\t\t\t\"Workflow\":              pulumi.String(\"Hello World\"),\n\t\t\t},\n\t\t\tLicenseKey: pulumi.String(\"452CQ-2EK54-K8742-00000-00000\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.License;\nimport com.pulumi.vsphere.LicenseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var licenseKey = new License(\"licenseKey\", LicenseArgs.builder()        \n            .labels(Map.ofEntries(\n                Map.entry(\"VpxClientLicenseLabel\", \"Hello World\"),\n                Map.entry(\"Workflow\", \"Hello World\")\n            ))\n            .licenseKey(\"452CQ-2EK54-K8742-00000-00000\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  licenseKey:\n    type: vsphere:License\n    properties:\n      labels:\n        VpxClientLicenseLabel: Hello World\n        Workflow: Hello World\n      licenseKey: 452CQ-2EK54-K8742-00000-00000\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "editionKey": {
                    "type": "string",
                    "description": "The product edition of the license key.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name for the license.\n"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of units (example: CPUs) contained in the license.\n"
                },
                "used": {
                    "type": "integer",
                    "description": "The number of units (example: CPUs) assigned to this license.\n"
                }
            },
            "required": [
                "editionKey",
                "licenseKey",
                "name",
                "total",
                "used"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "licenseKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering License resources.\n",
                "properties": {
                    "editionKey": {
                        "type": "string",
                        "description": "The product edition of the license key.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                    },
                    "licenseKey": {
                        "type": "string",
                        "description": "The license key to add.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name for the license.\n"
                    },
                    "total": {
                        "type": "integer",
                        "description": "Total number of units (example: CPUs) contained in the license.\n"
                    },
                    "used": {
                        "type": "integer",
                        "description": "The number of units (example: CPUs) assigned to this license.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/nasDatastore:NasDatastore": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n"
                },
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "protocolEndpoint": {
                    "type": "boolean",
                    "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nserver or servers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n"
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n"
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "freeSpace",
                "hostSystemIds",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "protocolEndpoint",
                "remoteHosts",
                "remotePath",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nserver or servers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "hostSystemIds",
                "remoteHosts",
                "remotePath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NasDatastore resources.\n",
                "properties": {
                    "accessMode": {
                        "type": "string",
                        "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "protocolEndpoint": {
                        "type": "boolean",
                        "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                    },
                    "remoteHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The hostnames or IP addresses of the remote\nserver or servers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "remotePath": {
                        "type": "string",
                        "description": "The remote path of the mount point. Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "securityType": {
                        "type": "string",
                        "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/resourcePool:ResourcePool": {
            "description": "The `vsphere.ResourcePool` resource can be used to create and manage\nresource pools on DRS-enabled vSphere clusters or standalone ESXi hosts.\n\nFor more information on vSphere resource pools, please refer to the\n[product documentation][ref-vsphere-resource_pools].\n\n[ref-vsphere-resource_pools]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.resmgmt.doc/GUID-60077B40-66FF-4625-934A-641703ED7601.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe following example sets up a resource pool in an existing compute cluster\nwith the default settings for CPU and memory reservations, shares, and limits.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst computeCluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst resourcePool = new vsphere.ResourcePool(\"resourcePool\", {parentResourcePoolId: computeCluster.then(computeCluster =\u003e computeCluster.resourcePoolId)});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncompute_cluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nresource_pool = vsphere.ResourcePool(\"resourcePool\", parent_resource_pool_id=compute_cluster.resource_pool_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var resourcePool = new VSphere.ResourcePool(\"resourcePool\", new()\n    {\n        ParentResourcePoolId = computeCluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcomputeCluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewResourcePool(ctx, \"resourcePool\", \u0026vsphere.ResourcePoolArgs{\n\t\t\tParentResourcePoolId: *pulumi.String(computeCluster.ResourcePoolId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.ResourcePool;\nimport com.pulumi.vsphere.ResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var resourcePool = new ResourcePool(\"resourcePool\", ResourcePoolArgs.builder()        \n            .parentResourcePoolId(computeCluster.applyValue(getComputeClusterResult -\u003e getComputeClusterResult.resourcePoolId()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  resourcePool:\n    type: vsphere:ResourcePool\n    properties:\n      parentResourcePoolId: ${computeCluster.resourcePoolId}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  computeCluster:\n    fn::invoke:\n      Function: vsphere:getComputeCluster\n      Arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n```\n\nA virtual machine resource could be targeted to use the default resource pool\nof the cluster using the following:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vm = new vsphere.VirtualMachine(\"vm\", {resourcePoolId: data.vsphere_compute_cluster.cluster.resource_pool_id});\n// ... other configuration ...\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvm = vsphere.VirtualMachine(\"vm\", resource_pool_id=data[\"vsphere_compute_cluster\"][\"cluster\"][\"resource_pool_id\"])\n# ... other configuration ...\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vm = new VSphere.VirtualMachine(\"vm\", new()\n    {\n        ResourcePoolId = data.Vsphere_compute_cluster.Cluster.Resource_pool_id,\n    });\n\n    // ... other configuration ...\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachine(ctx, \"vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tResourcePoolId: pulumi.Any(data.Vsphere_compute_cluster.Cluster.Resource_pool_id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vm = new VirtualMachine(\"vm\", VirtualMachineArgs.builder()        \n            .resourcePoolId(data.vsphere_compute_cluster().cluster().resource_pool_id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      # ... other configuration ...\n      resourcePoolId: ${data.vsphere_compute_cluster.cluster.resource_pool_id}\n```\n\nThe following example sets up a parent resource pool in an existing compute cluster\nwith a child resource pool nested below. Each resource pool is configured with\nthe default settings for CPU and memory reservations, shares, and limits.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst computeCluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst resourcePoolParent = new vsphere.ResourcePool(\"resourcePoolParent\", {parentResourcePoolId: computeCluster.then(computeCluster =\u003e computeCluster.resourcePoolId)});\nconst resourcePoolChild = new vsphere.ResourcePool(\"resourcePoolChild\", {parentResourcePoolId: resourcePoolParent.id});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncompute_cluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nresource_pool_parent = vsphere.ResourcePool(\"resourcePoolParent\", parent_resource_pool_id=compute_cluster.resource_pool_id)\nresource_pool_child = vsphere.ResourcePool(\"resourcePoolChild\", parent_resource_pool_id=resource_pool_parent.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var resourcePoolParent = new VSphere.ResourcePool(\"resourcePoolParent\", new()\n    {\n        ParentResourcePoolId = computeCluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n    });\n\n    var resourcePoolChild = new VSphere.ResourcePool(\"resourcePoolChild\", new()\n    {\n        ParentResourcePoolId = resourcePoolParent.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcomputeCluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresourcePoolParent, err := vsphere.NewResourcePool(ctx, \"resourcePoolParent\", \u0026vsphere.ResourcePoolArgs{\n\t\t\tParentResourcePoolId: *pulumi.String(computeCluster.ResourcePoolId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewResourcePool(ctx, \"resourcePoolChild\", \u0026vsphere.ResourcePoolArgs{\n\t\t\tParentResourcePoolId: resourcePoolParent.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.ResourcePool;\nimport com.pulumi.vsphere.ResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var resourcePoolParent = new ResourcePool(\"resourcePoolParent\", ResourcePoolArgs.builder()        \n            .parentResourcePoolId(computeCluster.applyValue(getComputeClusterResult -\u003e getComputeClusterResult.resourcePoolId()))\n            .build());\n\n        var resourcePoolChild = new ResourcePool(\"resourcePoolChild\", ResourcePoolArgs.builder()        \n            .parentResourcePoolId(resourcePoolParent.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  resourcePoolParent:\n    type: vsphere:ResourcePool\n    properties:\n      parentResourcePoolId: ${computeCluster.resourcePoolId}\n  resourcePoolChild:\n    type: vsphere:ResourcePool\n    properties:\n      parentResourcePoolId: ${resourcePoolParent.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  computeCluster:\n    fn::invoke:\n      Function: vsphere:getComputeCluster\n      Arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}\n## Importing\n### Settings that Require vSphere 7.0 or higher\n\nThese settings require vSphere 7.0 or higher:\n\n* `scale_descendants_shares`\n",
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool.\n"
                },
                "scaleDescendantsShares": {
                    "type": "string",
                    "description": "Determines if the shares of all\ndescendants of the resource pool are scaled up or down when the shares\nof the resource pool are scaled up or down. Can be one of `disabled` or\n`scaleCpuAndMemoryShares`. Default: `disabled`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool.\n"
                },
                "scaleDescendantsShares": {
                    "type": "string",
                    "description": "Determines if the shares of all\ndescendants of the resource pool are scaled up or down when the shares\nof the resource pool are scaled up or down. Can be one of `disabled` or\n`scaleCpuAndMemoryShares`. Default: `disabled`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourcePool resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource pool.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool.\n"
                    },
                    "scaleDescendantsShares": {
                        "type": "string",
                        "description": "Determines if the shares of all\ndescendants of the resource pool are scaled up or down when the shares\nof the resource pool are scaled up or down. Can be one of `disabled` or\n`scaleCpuAndMemoryShares`. Default: `disabled`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/role:Role": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "The display label of the role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "rolePrivileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to be associated with this role.\n"
                }
            },
            "required": [
                "label",
                "name"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "rolePrivileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to be associated with this role.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "label": {
                        "type": "string",
                        "description": "The display label of the role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges to be associated with this role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/storageDrsVmOverride:StorageDrsVmOverride": {
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageDrsVmOverride resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                    },
                    "sdrsEnabled": {
                        "type": "string",
                        "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                    },
                    "sdrsIntraVmAffinity": {
                        "type": "string",
                        "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tag:Tag": {
            "properties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "required": [
                "categoryId",
                "name"
            ],
            "inputProperties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "requiredInputs": [
                "categoryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tag resources.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the tag.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tagCategory:TagCategory": {
            "properties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n\n\u003e **NOTE:** You can add associable types to a category, but you cannot remove\nthem. Attempting to do so will result in an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "required": [
                "associableTypes",
                "cardinality",
                "name"
            ],
            "inputProperties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n\n\u003e **NOTE:** You can add associable types to a category, but you cannot remove\nthem. Attempting to do so will result in an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "requiredInputs": [
                "associableTypes",
                "cardinality"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagCategory resources.\n",
                "properties": {
                    "associableTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                    },
                    "cardinality": {
                        "type": "string",
                        "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the category.\n\n\u003e **NOTE:** You can add associable types to a category, but you cannot remove\nthem. Attempting to do so will result in an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappContainer:VappContainer": {
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappContainer resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container.\n"
                    },
                    "parentFolderId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappEntity:VappEntity": {
            "properties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n"
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "required": [
                "containerId",
                "targetId"
            ],
            "inputProperties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n",
                    "willReplaceOnChanges": true
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n",
                    "willReplaceOnChanges": true
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "requiredInputs": [
                "containerId",
                "targetId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappEntity resources.\n",
                "properties": {
                    "containerId": {
                        "type": "string",
                        "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n",
                        "willReplaceOnChanges": true
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "startAction": {
                        "type": "string",
                        "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                    },
                    "startDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                    },
                    "startOrder": {
                        "type": "integer",
                        "description": "Order to start and stop target in vApp. Default: 1\n"
                    },
                    "stopAction": {
                        "type": "string",
                        "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                    },
                    "stopDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "targetId": {
                        "type": "string",
                        "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n",
                        "willReplaceOnChanges": true
                    },
                    "waitForGuest": {
                        "type": "boolean",
                        "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualDisk:VirtualDisk": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n\n\u003e **NOTE:** `adapter_type` is **deprecated**: it does not dictate the type of\ncontroller that the virtual disk will be attached to on the virtual machine.\nPlease see the `scsi_type` parameter\nin the `vsphere.VirtualMachine` resource for information on how to control\ndisk controller types. This parameter will be removed in future versions of the\nvSphere provider.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead"
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n\n\u003e **NOTE:** Any directory created as part of the operation when\n`create_directories` is enabled will not be deleted when the resource is\ndestroyed.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when when ESXi or if there is only one datacenter in\nyour infrastructure.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB).\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n\n[docs-vmware-vm-disk-provisioning]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-4C0F4D73-82F2-4B81-8AA7-1DD752A8A5AC.html\n"
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n"
                }
            },
            "required": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "inputProperties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n\n\u003e **NOTE:** `adapter_type` is **deprecated**: it does not dictate the type of\ncontroller that the virtual disk will be attached to on the virtual machine.\nPlease see the `scsi_type` parameter\nin the `vsphere.VirtualMachine` resource for information on how to control\ndisk controller types. This parameter will be removed in future versions of the\nvSphere provider.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead",
                    "willReplaceOnChanges": true
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n\n\u003e **NOTE:** Any directory created as part of the operation when\n`create_directories` is enabled will not be deleted when the resource is\ndestroyed.\n",
                    "willReplaceOnChanges": true
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when when ESXi or if there is only one datacenter in\nyour infrastructure.\n",
                    "willReplaceOnChanges": true
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n",
                    "willReplaceOnChanges": true
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB).\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n\n[docs-vmware-vm-disk-provisioning]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-4C0F4D73-82F2-4B81-8AA7-1DD752A8A5AC.html\n",
                    "willReplaceOnChanges": true
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualDisk resources.\n",
                "properties": {
                    "adapterType": {
                        "type": "string",
                        "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n\n\u003e **NOTE:** `adapter_type` is **deprecated**: it does not dictate the type of\ncontroller that the virtual disk will be attached to on the virtual machine.\nPlease see the `scsi_type` parameter\nin the `vsphere.VirtualMachine` resource for information on how to control\ndisk controller types. This parameter will be removed in future versions of the\nvSphere provider.\n",
                        "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead",
                        "willReplaceOnChanges": true
                    },
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n\n\u003e **NOTE:** Any directory created as part of the operation when\n`create_directories` is enabled will not be deleted when the resource is\ndestroyed.\n",
                        "willReplaceOnChanges": true
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when when ESXi or if there is only one datacenter in\nyour infrastructure.\n",
                        "willReplaceOnChanges": true
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore in which to create the\ndisk.\n",
                        "willReplaceOnChanges": true
                    },
                    "size": {
                        "type": "integer",
                        "description": "Size of the disk (in GB).\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n\n[docs-vmware-vm-disk-provisioning]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-4C0F4D73-82F2-4B81-8AA7-1DD752A8A5AC.html\n",
                        "willReplaceOnChanges": true
                    },
                    "vmdkPath": {
                        "type": "string",
                        "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachine:VirtualMachine": {
            "properties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system when `guest_id` is `otherGuest` or `otherGuest64`.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "A user-provided description of the virtual machine.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting the boot sequence. The default is no delay.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before retrying the boot sequence. This option is only valid if `boot_retry_enabled` is `true`. Default: `10000` (10 seconds).\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to `true`, a virtual machine that fails to boot will try again after the delay defined in `boot_retry_delay`. Default: `false`.\n"
                },
                "cdroms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom"
                    },
                    "description": "A specification for a CD-ROM device on the virtual machine. See CD-ROM options for more information.\n"
                },
                "changeVersion": {
                    "type": "string",
                    "description": "A unique identifier for a given version of the last configuration was applied.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                    "description": "When specified, the virtual machine will be created as a clone of a specified template. Optional customization options can be submitted for the resource. See creating a virtual machine from a template for more information.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to the virtual machine while it is powered on.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be removed to the virtual machine while it is powered on.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of CPU (in MHz) that the virtual machine can consume, regardless of available resources. The default is no limit.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance counters on the virtual machine. Default: `false`.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of CPU (in MHz) that the virtual machine is guaranteed. The default is no reservation.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The number of CPU shares allocated to the virtual machine when the `cpu_share_level` is `custom`.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtual machine CPU resources. One of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute value strings to set for virtual machine. Please refer to the `vsphere_custom_attributes` resource for more information on setting custom attributes.\n\n\u003e **NOTE:** Custom attributes requires vCenter Server and is not supported on direct ESXi host connections.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter ID. Required only when deploying an OVF/OVA template.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference ID of the datastore cluster in which to place the virtual machine. This setting applies to entire virtual machine and implies that you wish to use vSphere Storage DRS with the virtual machine. See the section on virtual machine migration for more information on modifying this value.\n\n\u003e **NOTE:** One of `datastore_id` or `datastore_cluster_id` must be specified.\n\n\u003e **NOTE:** Use of `datastore_cluster_id` requires vSphere Storage DRS to be enabled on the specified datastore cluster.\n\n\u003e **NOTE:** The `datastore_cluster_id` setting applies to the entire virtual machine resource. You cannot assign individual individual disks to datastore clusters. In addition, you cannot use the `attach` setting to attach external disks on virtual machines that are assigned to datastore clusters.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The managed object reference ID of the datastore in which to place the virtual machine. The virtual machine configuration files is placed here, along with any virtual disks that are created where a datastore is not explicitly specified. See the section on virtual machine migration for more information on modifying this value.\n\n\u003e **NOTE:** Datastores cannot be assigned to individual disks when `datastore_cluster_id` is used.\n"
                },
                "defaultIpAddress": {
                    "type": "string",
                    "description": "The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on the virtual machine. See disk options for more information.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "Use this option to enable EFI secure boot when the `firmware` type is set to is `efi`. Default: `false`.\n\n\u003e **NOTE:** EFI secure boot is only available on vSphere 6.5 and later.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest. Default: `false`.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging of virtual machine events to a log file stored in the virtual machine directory. Default: `false`.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization) setting for the virtual machine. One of `automatic`, `on`, or `off`. Default: `automatic`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for the virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata and userdata.\n\n\u003e **NOTE:** Do not use `extra_config` when working with a template imported from OVF/OVA as your settings may be ignored. Use the `vapp` block `properties` section as described in Using vApp Properties for OVF/OVA Configuration.\n"
                },
                "extraConfigRebootRequired": {
                    "type": "boolean",
                    "description": "Allow the virtual machine to be rebooted when a change to `extra_config` occurs. Default: `true`.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware for the virtual machine. One of `bios` or `efi`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The path to the virtual machine folder in which to place the virtual machine, relative to the datacenter path (`/\u003cdatacenter-name\u003e/vm`).  For example, `/dc-01/vm/foo`\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "If a guest shutdown failed or times out while updating or destroying (see `shutdown_wait_timeout`), force the power-off of the virtual machine. Default: `true`.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system type. For a full list of possible values, see [here][vmware-docs-guest-ids]. Default: `otherGuest64`.\n\n[vmware-docs-guest-ids]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/b50dcbbf-051d-4204-a3e7-e1b618c1e384/538cf2ec-b34f-4bae-a332-3820ef9e7773/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html\n"
                },
                "guestIpAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The current list of IP addresses on this machine, including the value of `default_ip_address`. If VMware Tools is not running on the virtual machine, or if the virtul machine is powered off, this list will be empty.\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version number. Valid range is from 4 to 19. The hardware version cannot be downgraded. See [virtual machine hardware compatibility][virtual-machine-hardware-compatibility] for more information.\n\n[virtual-machine-hardware-compatibility]: https://kb.vmware.com/s/article/2007240\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object reference ID of a host on which to place the virtual machine. See the section on virtual machine migration for more information on modifying this value. When using a vSphere cluster, if a `host_system_id` is not supplied, vSphere will select a host in the cluster to place the virtual machine, according to any defaults or vSphere DRS placement policies.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The hardware virtualization (non-nested) setting for the virtual machine. One of `hvAuto`, `hvOn`, or `hvOff`. Default: `hvAuto`.\n"
                },
                "ideControllerCount": {
                    "type": "integer",
                    "description": "The number of IDE controllers that the virtual machine. This directly affects the number of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers. Default: `2`.\n"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to ignore while waiting for an available IP address using either of the waiters. Any IP addresses in this list will be ignored so that the waiter will continue to wait for a valid IP address. Default: `[]`.\n"
                },
                "imported": {
                    "type": "boolean",
                    "description": "Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. One of `low`, `normal`, `medium`, or `high`.\n\n\u003e **NOTE:** On higher sensitivities, you may need to adjust the `memory_reservation` to the full amount of memory provisioned for the virtual machine.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The memory size to assign to the virtual machine, in MB. Default: `1024` (1 GB).\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to the virtual machine while it is powered on.\n\n\u003e **NOTE:** CPU and memory hot add options are not available on all guest operating systems. Please refer to the [VMware Guest OS Compatibility Guide][vmware-docs-compat-guide] to which settings are allow for your guest operating system. In addition, at least one `pulumi up` must be run before you are able to use CPU and memory hot add.\n\n[vmware-docs-compat-guide]: http://partnerweb.vmware.com/comp_guide2/pdf/VMware_GOS_Compatibility_Guide.pdf\n\n\u003e **NOTE:** For Linux 64-bit guest operating systems with less than or equal to 3GB, the virtual machine must powered off to add memory beyond 3GB. Subsequent hot add of memory does not require the virtual machine to be powered-off to apply the plan. Please refer to [VMware KB 2008405][vmware-kb-2008405].\n\n[vmware-kb-2008405]: https://kb.vmware.com/s/article/2008405\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) that th virtual machine can consume, regardless of available resources. The default is no limit.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) that the virtual machine is guaranteed. The default is no reservation.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The number of memory shares allocated to the virtual machine when the `memory_share_level` is `custom`.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtual machine memory resources. One of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for a virtual machine migration to complete before failing. Default: `10` minutes. See the section on virtual machine migration for more information.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "The managed object reference ID of the created virtual machine.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual machine.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on the virtual machine, facilitating nested virtualization in the guest operating system. Default: `false`.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on the virtual machine. See network interface options for more information.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores per socket in the virtual machine. The number of vCPUs on the virtual machine will be `num_cpus` divided by `num_cores_per_socket`. If specified, the value supplied to `num_cpus` must be evenly divisible by this value. Default: `1`.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The total number of virtual processor cores to assign to the virtual machine. Default: `1`.\n"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "When specified, the virtual machine will be deployed from the provided OVF/OVA template. See creating a virtual machine from an OVF/OVA template for more information.\n"
                },
                "pciDeviceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of host PCI device IDs in which to create PCI passthroughs.\n\n\u003e **NOTE:** Cloning requires vCenter Server and is not supported on direct ESXi host connections.\n"
                },
                "powerState": {
                    "type": "string",
                    "description": "A computed value for the current power state of the virtual machine. One of `on`, `off`, or `suspended`.\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "rebootRequired": {
                    "type": "boolean",
                    "description": "Value internal to Terraform used to determine if a configuration set change requires a reboot.\n"
                },
                "replaceTrigger": {
                    "type": "string",
                    "description": "Triggers replacement of resource whenever it changes.\n\nFor example, `replace_trigger = sha256(format(\"%s-%s\",data.template_file.cloud_init_metadata.rendered,data.template_file.cloud_init_userdata.rendered))` will fingerprint the changes in cloud-init metadata and userdata templates. This will enable a replacement of the resource whenever the dependant template renders a new configuration. (Forces a replacement.)\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object reference ID of the resource pool in which to place the virtual machine. See the Virtual Machine Migration section for more information on modifying this value.\n\n\u003e **NOTE:** All clusters and standalone hosts have a default root resource pool. This resource argument does not directly accept the cluster or standalone host resource. For more information, see the section on specifying the Root Resource Pool in the `vsphere.ResourcePool` data source documentation on using the root resource pool.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable post-power-on scripts to run when VMware Tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable ost-resume scripts to run when VMware Tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable pre-reboot scripts to run when VMware Tools is installed. Default: `false`.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable pre-shutdown scripts to run when VMware Tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable pre-standby scripts to run when VMware Tools is installed. Default: `true`.\n"
                },
                "sataControllerCount": {
                    "type": "integer",
                    "description": "The number of SATA controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "The type of SCSI bus sharing for the virtual machine SCSI controller. One of `physicalSharing`, `virtualSharing`, and `noSharing`. Default: `noSharing`.\n"
                },
                "scsiControllerCount": {
                    "type": "integer",
                    "description": "The number of SCSI controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The SCSI controller type for the virtual machine. One of `lsilogic` (LSI Logic Parallel), `lsilogic-sas` (LSI Logic SAS) or `pvscsi` (VMware Paravirtual). Default: `pvscsi`.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for a graceful guest shutdown when making necessary updates to the virtual machine. If `force_power_off` is set to `true`, the virtual machine will be forced to power-off after the timeout, otherwise an error is returned. Default: `3` minutes.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The ID of the storage policy to assign to the home directory of a virtual machine.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for the virtual machine. One of `inherit`, `hostLocal`, or `vmDirectory`. Default: `inherit`.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable the guest operating system to synchronization its clock with the host when the virtual machine is powered on or resumed. Requires vSphere 7.0 Update 1 and later. Requires VMware Tools to be installed. Default: `false`.\n"
                },
                "syncTimeWithHostPeriodically": {
                    "type": "boolean",
                    "description": "Enable the guest operating system to periodically synchronize its clock with the host. Requires vSphere 7.0 Update 1 and later. On previous versions, setting `sync_time_with_host` is will enable periodic synchronization. Requires VMware Tools to be installed. Default: `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. Please refer to the `vsphere.Tag` resource for more information on applying tags to virtual machine resources.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi host connections and requires vCenter Server instance.\n"
                },
                "toolsUpgradePolicy": {
                    "type": "string",
                    "description": "Enable automatic upgrade of the VMware Tools version when the virtual machine is rebooted. If necessary, VMware Tools is upgraded to the latest version supported by the host on which the virtual machine is running. Requires VMware Tools to be installed. One of `manual` or `upgradeAtPowerCycle`. Default: `manual`.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.\n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "Used for vApp configurations. The only sub-key available is `properties`, which is a key/value map of properties for virtual machines imported from and OVF/OVA. See Using vApp Properties for OVF/OVA Configuration for more information.\n"
                },
                "vappTransports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.\n"
                },
                "vbsEnabled": {
                    "type": "boolean",
                    "description": "Enable Virtualization Based Security. Requires `firmware` to be `efi`. In addition, `vvtd_enabled`, `nested_hv_enabled`, and `efi_secure_boot_enabled` must all have a value of `true`. Supported on vSphere 6.7 and later. Default: `false`.\n"
                },
                "vmwareToolsStatus": {
                    "type": "string",
                    "description": "The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.\n"
                },
                "vmxPath": {
                    "type": "string",
                    "description": "The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.\n"
                },
                "vvtdEnabled": {
                    "type": "boolean",
                    "description": "Enable Intel Virtualization Technology for Directed I/O for the virtual machine (_I/O MMU_ in the vSphere Client). Supported on vSphere 6.7 and later. Default: `false`.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available guest IP address on the virtual machine. This should only be used if the version VMware Tools does not allow the `wait_for_guest_net_timeout` waiter to be used. A value less than `1` disables the waiter. Default: `0`.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest network waiter waits for a routable address. When `false`, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria. This property is ignored if the `wait_for_guest_ip_timeout` waiter is used. Default: `true`.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available guest IP address on the virtual machine. Older versions of VMware Tools do not populate this property. In those cases, this waiter can be disabled and the `wait_for_guest_ip_timeout` waiter can be used instead. A value less than `1` disables the waiter. Default: `5` minutes.\n"
                }
            },
            "required": [
                "annotation",
                "changeVersion",
                "cpuShareCount",
                "datastoreId",
                "defaultIpAddress",
                "disks",
                "guestId",
                "guestIpAddresses",
                "hardwareVersion",
                "hostSystemId",
                "imported",
                "memoryShareCount",
                "moid",
                "name",
                "powerState",
                "rebootRequired",
                "resourcePoolId",
                "storagePolicyId",
                "uuid",
                "vappTransports",
                "vmwareToolsStatus",
                "vmxPath"
            ],
            "inputProperties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system when `guest_id` is `otherGuest` or `otherGuest64`.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "A user-provided description of the virtual machine.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting the boot sequence. The default is no delay.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before retrying the boot sequence. This option is only valid if `boot_retry_enabled` is `true`. Default: `10000` (10 seconds).\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to `true`, a virtual machine that fails to boot will try again after the delay defined in `boot_retry_delay`. Default: `false`.\n"
                },
                "cdroms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom"
                    },
                    "description": "A specification for a CD-ROM device on the virtual machine. See CD-ROM options for more information.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                    "description": "When specified, the virtual machine will be created as a clone of a specified template. Optional customization options can be submitted for the resource. See creating a virtual machine from a template for more information.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to the virtual machine while it is powered on.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be removed to the virtual machine while it is powered on.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of CPU (in MHz) that the virtual machine can consume, regardless of available resources. The default is no limit.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance counters on the virtual machine. Default: `false`.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of CPU (in MHz) that the virtual machine is guaranteed. The default is no reservation.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The number of CPU shares allocated to the virtual machine when the `cpu_share_level` is `custom`.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtual machine CPU resources. One of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute value strings to set for virtual machine. Please refer to the `vsphere_custom_attributes` resource for more information on setting custom attributes.\n\n\u003e **NOTE:** Custom attributes requires vCenter Server and is not supported on direct ESXi host connections.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter ID. Required only when deploying an OVF/OVA template.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference ID of the datastore cluster in which to place the virtual machine. This setting applies to entire virtual machine and implies that you wish to use vSphere Storage DRS with the virtual machine. See the section on virtual machine migration for more information on modifying this value.\n\n\u003e **NOTE:** One of `datastore_id` or `datastore_cluster_id` must be specified.\n\n\u003e **NOTE:** Use of `datastore_cluster_id` requires vSphere Storage DRS to be enabled on the specified datastore cluster.\n\n\u003e **NOTE:** The `datastore_cluster_id` setting applies to the entire virtual machine resource. You cannot assign individual individual disks to datastore clusters. In addition, you cannot use the `attach` setting to attach external disks on virtual machines that are assigned to datastore clusters.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The managed object reference ID of the datastore in which to place the virtual machine. The virtual machine configuration files is placed here, along with any virtual disks that are created where a datastore is not explicitly specified. See the section on virtual machine migration for more information on modifying this value.\n\n\u003e **NOTE:** Datastores cannot be assigned to individual disks when `datastore_cluster_id` is used.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on the virtual machine. See disk options for more information.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "Use this option to enable EFI secure boot when the `firmware` type is set to is `efi`. Default: `false`.\n\n\u003e **NOTE:** EFI secure boot is only available on vSphere 6.5 and later.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest. Default: `false`.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging of virtual machine events to a log file stored in the virtual machine directory. Default: `false`.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization) setting for the virtual machine. One of `automatic`, `on`, or `off`. Default: `automatic`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for the virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata and userdata.\n\n\u003e **NOTE:** Do not use `extra_config` when working with a template imported from OVF/OVA as your settings may be ignored. Use the `vapp` block `properties` section as described in Using vApp Properties for OVF/OVA Configuration.\n"
                },
                "extraConfigRebootRequired": {
                    "type": "boolean",
                    "description": "Allow the virtual machine to be rebooted when a change to `extra_config` occurs. Default: `true`.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware for the virtual machine. One of `bios` or `efi`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The path to the virtual machine folder in which to place the virtual machine, relative to the datacenter path (`/\u003cdatacenter-name\u003e/vm`).  For example, `/dc-01/vm/foo`\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "If a guest shutdown failed or times out while updating or destroying (see `shutdown_wait_timeout`), force the power-off of the virtual machine. Default: `true`.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system type. For a full list of possible values, see [here][vmware-docs-guest-ids]. Default: `otherGuest64`.\n\n[vmware-docs-guest-ids]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/b50dcbbf-051d-4204-a3e7-e1b618c1e384/538cf2ec-b34f-4bae-a332-3820ef9e7773/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version number. Valid range is from 4 to 19. The hardware version cannot be downgraded. See [virtual machine hardware compatibility][virtual-machine-hardware-compatibility] for more information.\n\n[virtual-machine-hardware-compatibility]: https://kb.vmware.com/s/article/2007240\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object reference ID of a host on which to place the virtual machine. See the section on virtual machine migration for more information on modifying this value. When using a vSphere cluster, if a `host_system_id` is not supplied, vSphere will select a host in the cluster to place the virtual machine, according to any defaults or vSphere DRS placement policies.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The hardware virtualization (non-nested) setting for the virtual machine. One of `hvAuto`, `hvOn`, or `hvOff`. Default: `hvAuto`.\n"
                },
                "ideControllerCount": {
                    "type": "integer",
                    "description": "The number of IDE controllers that the virtual machine. This directly affects the number of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers. Default: `2`.\n"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to ignore while waiting for an available IP address using either of the waiters. Any IP addresses in this list will be ignored so that the waiter will continue to wait for a valid IP address. Default: `[]`.\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. One of `low`, `normal`, `medium`, or `high`.\n\n\u003e **NOTE:** On higher sensitivities, you may need to adjust the `memory_reservation` to the full amount of memory provisioned for the virtual machine.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The memory size to assign to the virtual machine, in MB. Default: `1024` (1 GB).\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to the virtual machine while it is powered on.\n\n\u003e **NOTE:** CPU and memory hot add options are not available on all guest operating systems. Please refer to the [VMware Guest OS Compatibility Guide][vmware-docs-compat-guide] to which settings are allow for your guest operating system. In addition, at least one `pulumi up` must be run before you are able to use CPU and memory hot add.\n\n[vmware-docs-compat-guide]: http://partnerweb.vmware.com/comp_guide2/pdf/VMware_GOS_Compatibility_Guide.pdf\n\n\u003e **NOTE:** For Linux 64-bit guest operating systems with less than or equal to 3GB, the virtual machine must powered off to add memory beyond 3GB. Subsequent hot add of memory does not require the virtual machine to be powered-off to apply the plan. Please refer to [VMware KB 2008405][vmware-kb-2008405].\n\n[vmware-kb-2008405]: https://kb.vmware.com/s/article/2008405\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) that th virtual machine can consume, regardless of available resources. The default is no limit.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) that the virtual machine is guaranteed. The default is no reservation.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The number of memory shares allocated to the virtual machine when the `memory_share_level` is `custom`.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtual machine memory resources. One of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for a virtual machine migration to complete before failing. Default: `10` minutes. See the section on virtual machine migration for more information.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual machine.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on the virtual machine, facilitating nested virtualization in the guest operating system. Default: `false`.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on the virtual machine. See network interface options for more information.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores per socket in the virtual machine. The number of vCPUs on the virtual machine will be `num_cpus` divided by `num_cores_per_socket`. If specified, the value supplied to `num_cpus` must be evenly divisible by this value. Default: `1`.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The total number of virtual processor cores to assign to the virtual machine. Default: `1`.\n"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "When specified, the virtual machine will be deployed from the provided OVF/OVA template. See creating a virtual machine from an OVF/OVA template for more information.\n"
                },
                "pciDeviceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of host PCI device IDs in which to create PCI passthroughs.\n\n\u003e **NOTE:** Cloning requires vCenter Server and is not supported on direct ESXi host connections.\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "replaceTrigger": {
                    "type": "string",
                    "description": "Triggers replacement of resource whenever it changes.\n\nFor example, `replace_trigger = sha256(format(\"%s-%s\",data.template_file.cloud_init_metadata.rendered,data.template_file.cloud_init_userdata.rendered))` will fingerprint the changes in cloud-init metadata and userdata templates. This will enable a replacement of the resource whenever the dependant template renders a new configuration. (Forces a replacement.)\n",
                    "willReplaceOnChanges": true
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object reference ID of the resource pool in which to place the virtual machine. See the Virtual Machine Migration section for more information on modifying this value.\n\n\u003e **NOTE:** All clusters and standalone hosts have a default root resource pool. This resource argument does not directly accept the cluster or standalone host resource. For more information, see the section on specifying the Root Resource Pool in the `vsphere.ResourcePool` data source documentation on using the root resource pool.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable post-power-on scripts to run when VMware Tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable ost-resume scripts to run when VMware Tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable pre-reboot scripts to run when VMware Tools is installed. Default: `false`.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable pre-shutdown scripts to run when VMware Tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable pre-standby scripts to run when VMware Tools is installed. Default: `true`.\n"
                },
                "sataControllerCount": {
                    "type": "integer",
                    "description": "The number of SATA controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "The type of SCSI bus sharing for the virtual machine SCSI controller. One of `physicalSharing`, `virtualSharing`, and `noSharing`. Default: `noSharing`.\n"
                },
                "scsiControllerCount": {
                    "type": "integer",
                    "description": "The number of SCSI controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The SCSI controller type for the virtual machine. One of `lsilogic` (LSI Logic Parallel), `lsilogic-sas` (LSI Logic SAS) or `pvscsi` (VMware Paravirtual). Default: `pvscsi`.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for a graceful guest shutdown when making necessary updates to the virtual machine. If `force_power_off` is set to `true`, the virtual machine will be forced to power-off after the timeout, otherwise an error is returned. Default: `3` minutes.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The ID of the storage policy to assign to the home directory of a virtual machine.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for the virtual machine. One of `inherit`, `hostLocal`, or `vmDirectory`. Default: `inherit`.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable the guest operating system to synchronization its clock with the host when the virtual machine is powered on or resumed. Requires vSphere 7.0 Update 1 and later. Requires VMware Tools to be installed. Default: `false`.\n"
                },
                "syncTimeWithHostPeriodically": {
                    "type": "boolean",
                    "description": "Enable the guest operating system to periodically synchronize its clock with the host. Requires vSphere 7.0 Update 1 and later. On previous versions, setting `sync_time_with_host` is will enable periodic synchronization. Requires VMware Tools to be installed. Default: `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. Please refer to the `vsphere.Tag` resource for more information on applying tags to virtual machine resources.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi host connections and requires vCenter Server instance.\n"
                },
                "toolsUpgradePolicy": {
                    "type": "string",
                    "description": "Enable automatic upgrade of the VMware Tools version when the virtual machine is rebooted. If necessary, VMware Tools is upgraded to the latest version supported by the host on which the virtual machine is running. Requires VMware Tools to be installed. One of `manual` or `upgradeAtPowerCycle`. Default: `manual`.\n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "Used for vApp configurations. The only sub-key available is `properties`, which is a key/value map of properties for virtual machines imported from and OVF/OVA. See Using vApp Properties for OVF/OVA Configuration for more information.\n"
                },
                "vbsEnabled": {
                    "type": "boolean",
                    "description": "Enable Virtualization Based Security. Requires `firmware` to be `efi`. In addition, `vvtd_enabled`, `nested_hv_enabled`, and `efi_secure_boot_enabled` must all have a value of `true`. Supported on vSphere 6.7 and later. Default: `false`.\n"
                },
                "vvtdEnabled": {
                    "type": "boolean",
                    "description": "Enable Intel Virtualization Technology for Directed I/O for the virtual machine (_I/O MMU_ in the vSphere Client). Supported on vSphere 6.7 and later. Default: `false`.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available guest IP address on the virtual machine. This should only be used if the version VMware Tools does not allow the `wait_for_guest_net_timeout` waiter to be used. A value less than `1` disables the waiter. Default: `0`.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest network waiter waits for a routable address. When `false`, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria. This property is ignored if the `wait_for_guest_ip_timeout` waiter is used. Default: `true`.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available guest IP address on the virtual machine. Older versions of VMware Tools do not populate this property. In those cases, this waiter can be disabled and the `wait_for_guest_ip_timeout` waiter can be used instead. A value less than `1` disables the waiter. Default: `5` minutes.\n"
                }
            },
            "requiredInputs": [
                "resourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachine resources.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The guest name for the operating system when `guest_id` is `otherGuest` or `otherGuest64`.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "A user-provided description of the virtual machine.\n"
                    },
                    "bootDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before starting the boot sequence. The default is no delay.\n"
                    },
                    "bootRetryDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before retrying the boot sequence. This option is only valid if `boot_retry_enabled` is `true`. Default: `10000` (10 seconds).\n"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean",
                        "description": "If set to `true`, a virtual machine that fails to boot will try again after the delay defined in `boot_retry_delay`. Default: `false`.\n"
                    },
                    "cdroms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom"
                        },
                        "description": "A specification for a CD-ROM device on the virtual machine. See CD-ROM options for more information.\n"
                    },
                    "changeVersion": {
                        "type": "string",
                        "description": "A unique identifier for a given version of the last configuration was applied.\n"
                    },
                    "clone": {
                        "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                        "description": "When specified, the virtual machine will be created as a clone of a specified template. Optional customization options can be submitted for the resource. See creating a virtual machine from a template for more information.\n"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to the virtual machine while it is powered on.\n"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be removed to the virtual machine while it is powered on.\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The maximum amount of CPU (in MHz) that the virtual machine can consume, regardless of available resources. The default is no limit.\n"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean",
                        "description": "Enable CPU performance counters on the virtual machine. Default: `false`.\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "The amount of CPU (in MHz) that the virtual machine is guaranteed. The default is no reservation.\n"
                    },
                    "cpuShareCount": {
                        "type": "integer",
                        "description": "The number of CPU shares allocated to the virtual machine when the `cpu_share_level` is `custom`.\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the virtual machine CPU resources. One of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute value strings to set for virtual machine. Please refer to the `vsphere_custom_attributes` resource for more information on setting custom attributes.\n\n\u003e **NOTE:** Custom attributes requires vCenter Server and is not supported on direct ESXi host connections.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The datacenter ID. Required only when deploying an OVF/OVA template.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference ID of the datastore cluster in which to place the virtual machine. This setting applies to entire virtual machine and implies that you wish to use vSphere Storage DRS with the virtual machine. See the section on virtual machine migration for more information on modifying this value.\n\n\u003e **NOTE:** One of `datastore_id` or `datastore_cluster_id` must be specified.\n\n\u003e **NOTE:** Use of `datastore_cluster_id` requires vSphere Storage DRS to be enabled on the specified datastore cluster.\n\n\u003e **NOTE:** The `datastore_cluster_id` setting applies to the entire virtual machine resource. You cannot assign individual individual disks to datastore clusters. In addition, you cannot use the `attach` setting to attach external disks on virtual machines that are assigned to datastore clusters.\n"
                    },
                    "datastoreId": {
                        "type": "string",
                        "description": "The managed object reference ID of the datastore in which to place the virtual machine. The virtual machine configuration files is placed here, along with any virtual disks that are created where a datastore is not explicitly specified. See the section on virtual machine migration for more information on modifying this value.\n\n\u003e **NOTE:** Datastores cannot be assigned to individual disks when `datastore_cluster_id` is used.\n"
                    },
                    "defaultIpAddress": {
                        "type": "string",
                        "description": "The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                        },
                        "description": "A specification for a virtual disk device on the virtual machine. See disk options for more information.\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean",
                        "description": "Use this option to enable EFI secure boot when the `firmware` type is set to is `efi`. Default: `false`.\n\n\u003e **NOTE:** EFI secure boot is only available on vSphere 6.5 and later.\n"
                    },
                    "enableDiskUuid": {
                        "type": "boolean",
                        "description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest. Default: `false`.\n"
                    },
                    "enableLogging": {
                        "type": "boolean",
                        "description": "Enable logging of virtual machine events to a log file stored in the virtual machine directory. Default: `false`.\n"
                    },
                    "eptRviMode": {
                        "type": "string",
                        "description": "The EPT/RVI (hardware memory virtualization) setting for the virtual machine. One of `automatic`, `on`, or `off`. Default: `automatic`.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Extra configuration data for the virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata and userdata.\n\n\u003e **NOTE:** Do not use `extra_config` when working with a template imported from OVF/OVA as your settings may be ignored. Use the `vapp` block `properties` section as described in Using vApp Properties for OVF/OVA Configuration.\n"
                    },
                    "extraConfigRebootRequired": {
                        "type": "boolean",
                        "description": "Allow the virtual machine to be rebooted when a change to `extra_config` occurs. Default: `true`.\n"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware for the virtual machine. One of `bios` or `efi`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The path to the virtual machine folder in which to place the virtual machine, relative to the datacenter path (`/\u003cdatacenter-name\u003e/vm`).  For example, `/dc-01/vm/foo`\n"
                    },
                    "forcePowerOff": {
                        "type": "boolean",
                        "description": "If a guest shutdown failed or times out while updating or destroying (see `shutdown_wait_timeout`), force the power-off of the virtual machine. Default: `true`.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID for the operating system type. For a full list of possible values, see [here][vmware-docs-guest-ids]. Default: `otherGuest64`.\n\n[vmware-docs-guest-ids]: https://vdc-download.vmware.com/vmwb-repository/dcr-public/b50dcbbf-051d-4204-a3e7-e1b618c1e384/538cf2ec-b34f-4bae-a332-3820ef9e7773/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html\n"
                    },
                    "guestIpAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The current list of IP addresses on this machine, including the value of `default_ip_address`. If VMware Tools is not running on the virtual machine, or if the virtul machine is powered off, this list will be empty.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version number. Valid range is from 4 to 19. The hardware version cannot be downgraded. See [virtual machine hardware compatibility][virtual-machine-hardware-compatibility] for more information.\n\n[virtual-machine-hardware-compatibility]: https://kb.vmware.com/s/article/2007240\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object reference ID of a host on which to place the virtual machine. See the section on virtual machine migration for more information on modifying this value. When using a vSphere cluster, if a `host_system_id` is not supplied, vSphere will select a host in the cluster to place the virtual machine, according to any defaults or vSphere DRS placement policies.\n"
                    },
                    "hvMode": {
                        "type": "string",
                        "description": "The hardware virtualization (non-nested) setting for the virtual machine. One of `hvAuto`, `hvOn`, or `hvOff`. Default: `hvAuto`.\n"
                    },
                    "ideControllerCount": {
                        "type": "integer",
                        "description": "The number of IDE controllers that the virtual machine. This directly affects the number of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers. Default: `2`.\n"
                    },
                    "ignoredGuestIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP addresses and CIDR networks to ignore while waiting for an available IP address using either of the waiters. Any IP addresses in this list will be ignored so that the waiter will continue to wait for a valid IP address. Default: `[]`.\n"
                    },
                    "imported": {
                        "type": "boolean",
                        "description": "Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.\n"
                    },
                    "latencySensitivity": {
                        "type": "string",
                        "description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. One of `low`, `normal`, `medium`, or `high`.\n\n\u003e **NOTE:** On higher sensitivities, you may need to adjust the `memory_reservation` to the full amount of memory provisioned for the virtual machine.\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The memory size to assign to the virtual machine, in MB. Default: `1024` (1 GB).\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow memory to be added to the virtual machine while it is powered on.\n\n\u003e **NOTE:** CPU and memory hot add options are not available on all guest operating systems. Please refer to the [VMware Guest OS Compatibility Guide][vmware-docs-compat-guide] to which settings are allow for your guest operating system. In addition, at least one `pulumi up` must be run before you are able to use CPU and memory hot add.\n\n[vmware-docs-compat-guide]: http://partnerweb.vmware.com/comp_guide2/pdf/VMware_GOS_Compatibility_Guide.pdf\n\n\u003e **NOTE:** For Linux 64-bit guest operating systems with less than or equal to 3GB, the virtual machine must powered off to add memory beyond 3GB. Subsequent hot add of memory does not require the virtual machine to be powered-off to apply the plan. Please refer to [VMware KB 2008405][vmware-kb-2008405].\n\n[vmware-kb-2008405]: https://kb.vmware.com/s/article/2008405\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The maximum amount of memory (in MB) that th virtual machine can consume, regardless of available resources. The default is no limit.\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "The amount of memory (in MB) that the virtual machine is guaranteed. The default is no reservation.\n"
                    },
                    "memoryShareCount": {
                        "type": "integer",
                        "description": "The number of memory shares allocated to the virtual machine when the `memory_share_level` is `custom`.\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the virtual machine memory resources. One of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                    },
                    "migrateWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for a virtual machine migration to complete before failing. Default: `10` minutes. See the section on virtual machine migration for more information.\n"
                    },
                    "moid": {
                        "type": "string",
                        "description": "The managed object reference ID of the created virtual machine.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual machine.\n"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean",
                        "description": "Enable nested hardware virtualization on the virtual machine, facilitating nested virtualization in the guest operating system. Default: `false`.\n"
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                        },
                        "description": "A specification for a virtual NIC on the virtual machine. See network interface options for more information.\n"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per socket in the virtual machine. The number of vCPUs on the virtual machine will be `num_cpus` divided by `num_cores_per_socket`. If specified, the value supplied to `num_cpus` must be evenly divisible by this value. Default: `1`.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The total number of virtual processor cores to assign to the virtual machine. Default: `1`.\n"
                    },
                    "ovfDeploy": {
                        "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                        "description": "When specified, the virtual machine will be deployed from the provided OVF/OVA template. See creating a virtual machine from an OVF/OVA template for more information.\n"
                    },
                    "pciDeviceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of host PCI device IDs in which to create PCI passthroughs.\n\n\u003e **NOTE:** Cloning requires vCenter Server and is not supported on direct ESXi host connections.\n"
                    },
                    "powerState": {
                        "type": "string",
                        "description": "A computed value for the current power state of the virtual machine. One of `on`, `off`, or `suspended`.\n"
                    },
                    "poweronTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                    },
                    "rebootRequired": {
                        "type": "boolean",
                        "description": "Value internal to Terraform used to determine if a configuration set change requires a reboot.\n"
                    },
                    "replaceTrigger": {
                        "type": "string",
                        "description": "Triggers replacement of resource whenever it changes.\n\nFor example, `replace_trigger = sha256(format(\"%s-%s\",data.template_file.cloud_init_metadata.rendered,data.template_file.cloud_init_userdata.rendered))` will fingerprint the changes in cloud-init metadata and userdata templates. This will enable a replacement of the resource whenever the dependant template renders a new configuration. (Forces a replacement.)\n",
                        "willReplaceOnChanges": true
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object reference ID of the resource pool in which to place the virtual machine. See the Virtual Machine Migration section for more information on modifying this value.\n\n\u003e **NOTE:** All clusters and standalone hosts have a default root resource pool. This resource argument does not directly accept the cluster or standalone host resource. For more information, see the section on specifying the Root Resource Pool in the `vsphere.ResourcePool` data source documentation on using the root resource pool.\n"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean",
                        "description": "Enable post-power-on scripts to run when VMware Tools is installed. Default: `true`.\n"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean",
                        "description": "Enable ost-resume scripts to run when VMware Tools is installed. Default: `true`.\n"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean",
                        "description": "Enable pre-reboot scripts to run when VMware Tools is installed. Default: `false`.\n"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean",
                        "description": "Enable pre-shutdown scripts to run when VMware Tools is installed. Default: `true`.\n"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean",
                        "description": "Enable pre-standby scripts to run when VMware Tools is installed. Default: `true`.\n"
                    },
                    "sataControllerCount": {
                        "type": "integer",
                        "description": "The number of SATA controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                    },
                    "scsiBusSharing": {
                        "type": "string",
                        "description": "The type of SCSI bus sharing for the virtual machine SCSI controller. One of `physicalSharing`, `virtualSharing`, and `noSharing`. Default: `noSharing`.\n"
                    },
                    "scsiControllerCount": {
                        "type": "integer",
                        "description": "The number of SCSI controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                    },
                    "scsiType": {
                        "type": "string",
                        "description": "The SCSI controller type for the virtual machine. One of `lsilogic` (LSI Logic Parallel), `lsilogic-sas` (LSI Logic SAS) or `pvscsi` (VMware Paravirtual). Default: `pvscsi`.\n"
                    },
                    "shutdownWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for a graceful guest shutdown when making necessary updates to the virtual machine. If `force_power_off` is set to `true`, the virtual machine will be forced to power-off after the timeout, otherwise an error is returned. Default: `3` minutes.\n"
                    },
                    "storagePolicyId": {
                        "type": "string",
                        "description": "The ID of the storage policy to assign to the home directory of a virtual machine.\n"
                    },
                    "swapPlacementPolicy": {
                        "type": "string",
                        "description": "The swap file placement policy for the virtual machine. One of `inherit`, `hostLocal`, or `vmDirectory`. Default: `inherit`.\n"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean",
                        "description": "Enable the guest operating system to synchronization its clock with the host when the virtual machine is powered on or resumed. Requires vSphere 7.0 Update 1 and later. Requires VMware Tools to be installed. Default: `false`.\n"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean",
                        "description": "Enable the guest operating system to periodically synchronize its clock with the host. Requires vSphere 7.0 Update 1 and later. On previous versions, setting `sync_time_with_host` is will enable periodic synchronization. Requires VMware Tools to be installed. Default: `false`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. Please refer to the `vsphere.Tag` resource for more information on applying tags to virtual machine resources.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi host connections and requires vCenter Server instance.\n"
                    },
                    "toolsUpgradePolicy": {
                        "type": "string",
                        "description": "Enable automatic upgrade of the VMware Tools version when the virtual machine is rebooted. If necessary, VMware Tools is upgraded to the latest version supported by the host on which the virtual machine is running. Requires VMware Tools to be installed. One of `manual` or `upgradeAtPowerCycle`. Default: `manual`.\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "The UUID of the virtual disk VMDK file. This is used to track the virtual disk on the virtual machine.\n"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                        "description": "Used for vApp configurations. The only sub-key available is `properties`, which is a key/value map of properties for virtual machines imported from and OVF/OVA. See Using vApp Properties for OVF/OVA Configuration for more information.\n"
                    },
                    "vappTransports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.\n"
                    },
                    "vbsEnabled": {
                        "type": "boolean",
                        "description": "Enable Virtualization Based Security. Requires `firmware` to be `efi`. In addition, `vvtd_enabled`, `nested_hv_enabled`, and `efi_secure_boot_enabled` must all have a value of `true`. Supported on vSphere 6.7 and later. Default: `false`.\n"
                    },
                    "vmwareToolsStatus": {
                        "type": "string",
                        "description": "The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.\n"
                    },
                    "vmxPath": {
                        "type": "string",
                        "description": "The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.\n"
                    },
                    "vvtdEnabled": {
                        "type": "boolean",
                        "description": "Enable Intel Virtualization Technology for Directed I/O for the virtual machine (_I/O MMU_ in the vSphere Client). Supported on vSphere 6.7 and later. Default: `false`.\n"
                    },
                    "waitForGuestIpTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for an available guest IP address on the virtual machine. This should only be used if the version VMware Tools does not allow the `wait_for_guest_net_timeout` waiter to be used. A value less than `1` disables the waiter. Default: `0`.\n"
                    },
                    "waitForGuestNetRoutable": {
                        "type": "boolean",
                        "description": "Controls whether or not the guest network waiter waits for a routable address. When `false`, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria. This property is ignored if the `wait_for_guest_ip_timeout` waiter is used. Default: `true`.\n"
                    },
                    "waitForGuestNetTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for an available guest IP address on the virtual machine. Older versions of VMware Tools do not populate this property. In those cases, this waiter can be disabled and the `wait_for_guest_ip_timeout` waiter can be used instead. A value less than `1` disables the waiter. Default: `5` minutes.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachineSnapshot:VirtualMachineSnapshot": {
            "description": "The `vsphere.VirtualMachineSnapshot` resource can be used to manage snapshots\nfor a virtual machine.\n\nFor more information on managing snapshots and how they work in VMware, see\n[here][ext-vm-snapshot-management].\n\n[ext-vm-snapshot-management]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-CA948C69-7F58-4519-AEB1-739545EA94E5.html\n\n\u003e **NOTE:** A snapshot in VMware differs from traditional disk snapshots, and\ncan contain the actual running state of the virtual machine, data for all disks\nthat have not been set to be independent from the snapshot (including ones that\nhave been attached via the `attach`\nparameter to the `vsphere.VirtualMachine` `disk` block), and even the\nconfiguration of the virtual machine at the time of the snapshot. Virtual\nmachine, disk activity, and configuration changes post-snapshot are not\nincluded in the original state. Use this resource with care! Neither VMware nor\nHashiCorp recommends retaining snapshots for a extended period of time and does\nNOT recommend using them as as backup feature. For more information on the\nlimitation of virtual machine snapshots, see [here][ext-vm-snap-limitations].\n\n[ext-vm-snap-limitations]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-53F65726-A23B-4CF0-A7D5-48E584B88613.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst demo1 = new vsphere.VirtualMachineSnapshot(\"demo1\", {\n    consolidate: true,\n    description: \"This is Demo Snapshot\",\n    memory: true,\n    quiesce: true,\n    removeChildren: false,\n    snapshotName: \"Snapshot Name\",\n    virtualMachineUuid: \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndemo1 = vsphere.VirtualMachineSnapshot(\"demo1\",\n    consolidate=True,\n    description=\"This is Demo Snapshot\",\n    memory=True,\n    quiesce=True,\n    remove_children=False,\n    snapshot_name=\"Snapshot Name\",\n    virtual_machine_uuid=\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demo1 = new VSphere.VirtualMachineSnapshot(\"demo1\", new()\n    {\n        Consolidate = true,\n        Description = \"This is Demo Snapshot\",\n        Memory = true,\n        Quiesce = true,\n        RemoveChildren = false,\n        SnapshotName = \"Snapshot Name\",\n        VirtualMachineUuid = \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachineSnapshot(ctx, \"demo1\", \u0026vsphere.VirtualMachineSnapshotArgs{\n\t\t\tConsolidate:        pulumi.Bool(true),\n\t\t\tDescription:        pulumi.String(\"This is Demo Snapshot\"),\n\t\t\tMemory:             pulumi.Bool(true),\n\t\t\tQuiesce:            pulumi.Bool(true),\n\t\t\tRemoveChildren:     pulumi.Bool(false),\n\t\t\tSnapshotName:       pulumi.String(\"Snapshot Name\"),\n\t\t\tVirtualMachineUuid: pulumi.String(\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachineSnapshot;\nimport com.pulumi.vsphere.VirtualMachineSnapshotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demo1 = new VirtualMachineSnapshot(\"demo1\", VirtualMachineSnapshotArgs.builder()        \n            .consolidate(\"true\")\n            .description(\"This is Demo Snapshot\")\n            .memory(\"true\")\n            .quiesce(\"true\")\n            .removeChildren(\"false\")\n            .snapshotName(\"Snapshot Name\")\n            .virtualMachineUuid(\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demo1:\n    type: vsphere:VirtualMachineSnapshot\n    properties:\n      consolidate: 'true'\n      description: This is Demo Snapshot\n      memory: 'true'\n      quiesce: 'true'\n      removeChildren: 'false'\n      snapshotName: Snapshot Name\n      virtualMachineUuid: 9aac5551-a351-4158-8c5c-15a71e8ec5c9\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n"
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n"
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n"
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n"
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n"
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n"
                }
            },
            "required": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "inputProperties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n",
                    "willReplaceOnChanges": true
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n",
                    "willReplaceOnChanges": true
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachineSnapshot resources.\n",
                "properties": {
                    "consolidate": {
                        "type": "boolean",
                        "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "memory": {
                        "type": "boolean",
                        "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "quiesce": {
                        "type": "boolean",
                        "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n",
                        "willReplaceOnChanges": true
                    },
                    "removeChildren": {
                        "type": "boolean",
                        "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotName": {
                        "type": "string",
                        "description": "The name of the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "virtualMachineUuid": {
                        "type": "string",
                        "description": "The virtual machine UUID.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vmStoragePolicy:VmStoragePolicy": {
            "description": "The `vsphere.VmStoragePolicy` resource can be used to create and manage storage \npolicies. Using this resource, tag based placement rules can be created to \nplace virtual machines on a datastore with matching tags. If storage requirements for the applications on the virtual machine change, you can modify the storage policy that was originally applied to the virtual machine.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe following example creates storage policies with `tag_rules` base on sets of environment, service level, and replication attributes.\n\nIn this example, tags are first applied to datastores.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst environment = vsphere.getTagCategory({\n    name: \"environment\",\n});\nconst serviceLevel = vsphere.getTagCategory({\n    name: \"service_level\",\n});\nconst replication = vsphere.getTagCategory({\n    name: \"replication\",\n});\nconst production = vsphere.getTag({\n    categoryId: \"data.vsphere_tag_category.environment.id\",\n    name: \"production\",\n});\nconst development = vsphere.getTag({\n    categoryId: \"data.vsphere_tag_category.environment.id\",\n    name: \"development\",\n});\nconst platinum = vsphere.getTag({\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n    name: \"platinum\",\n});\nconst gold = vsphere.getTag({\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n    name: \"platinum\",\n});\nconst silver = vsphere.getTag({\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n    name: \"silver\",\n});\nconst bronze = vsphere.getTag({\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n    name: \"bronze\",\n});\nconst replicated = vsphere.getTag({\n    categoryId: \"data.vsphere_tag_category.replication.id\",\n    name: \"replicated\",\n});\nconst nonReplicated = vsphere.getTag({\n    categoryId: \"data.vsphere_tag_category.replication.id\",\n    name: \"non_replicated\",\n});\nconst prodDatastore = new vsphere.VmfsDatastore(\"prodDatastore\", {tags: [\n    \"data.vsphere_tag.production.id\",\n    \"data.vsphere_tag.platinum.id\",\n    \"data.vsphere_tag.replicated.id\",\n]});\nconst devDatastore = new vsphere.NasDatastore(\"devDatastore\", {tags: [\n    \"data.vsphere_tag.development.id\",\n    \"data.vsphere_tag.silver.id\",\n    \"data.vsphere_tag.non_replicated.id\",\n]});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nenvironment = vsphere.get_tag_category(name=\"environment\")\nservice_level = vsphere.get_tag_category(name=\"service_level\")\nreplication = vsphere.get_tag_category(name=\"replication\")\nproduction = vsphere.get_tag(category_id=\"data.vsphere_tag_category.environment.id\",\n    name=\"production\")\ndevelopment = vsphere.get_tag(category_id=\"data.vsphere_tag_category.environment.id\",\n    name=\"development\")\nplatinum = vsphere.get_tag(category_id=\"data.vsphere_tag_category.service_level.id\",\n    name=\"platinum\")\ngold = vsphere.get_tag(category_id=\"data.vsphere_tag_category.service_level.id\",\n    name=\"platinum\")\nsilver = vsphere.get_tag(category_id=\"data.vsphere_tag_category.service_level.id\",\n    name=\"silver\")\nbronze = vsphere.get_tag(category_id=\"data.vsphere_tag_category.service_level.id\",\n    name=\"bronze\")\nreplicated = vsphere.get_tag(category_id=\"data.vsphere_tag_category.replication.id\",\n    name=\"replicated\")\nnon_replicated = vsphere.get_tag(category_id=\"data.vsphere_tag_category.replication.id\",\n    name=\"non_replicated\")\nprod_datastore = vsphere.VmfsDatastore(\"prodDatastore\", tags=[\n    \"data.vsphere_tag.production.id\",\n    \"data.vsphere_tag.platinum.id\",\n    \"data.vsphere_tag.replicated.id\",\n])\ndev_datastore = vsphere.NasDatastore(\"devDatastore\", tags=[\n    \"data.vsphere_tag.development.id\",\n    \"data.vsphere_tag.silver.id\",\n    \"data.vsphere_tag.non_replicated.id\",\n])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var environment = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"environment\",\n    });\n\n    var serviceLevel = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"service_level\",\n    });\n\n    var replication = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"replication\",\n    });\n\n    var production = VSphere.GetTag.Invoke(new()\n    {\n        CategoryId = \"data.vsphere_tag_category.environment.id\",\n        Name = \"production\",\n    });\n\n    var development = VSphere.GetTag.Invoke(new()\n    {\n        CategoryId = \"data.vsphere_tag_category.environment.id\",\n        Name = \"development\",\n    });\n\n    var platinum = VSphere.GetTag.Invoke(new()\n    {\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n        Name = \"platinum\",\n    });\n\n    var gold = VSphere.GetTag.Invoke(new()\n    {\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n        Name = \"platinum\",\n    });\n\n    var silver = VSphere.GetTag.Invoke(new()\n    {\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n        Name = \"silver\",\n    });\n\n    var bronze = VSphere.GetTag.Invoke(new()\n    {\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n        Name = \"bronze\",\n    });\n\n    var replicated = VSphere.GetTag.Invoke(new()\n    {\n        CategoryId = \"data.vsphere_tag_category.replication.id\",\n        Name = \"replicated\",\n    });\n\n    var nonReplicated = VSphere.GetTag.Invoke(new()\n    {\n        CategoryId = \"data.vsphere_tag_category.replication.id\",\n        Name = \"non_replicated\",\n    });\n\n    var prodDatastore = new VSphere.VmfsDatastore(\"prodDatastore\", new()\n    {\n        Tags = new[]\n        {\n            \"data.vsphere_tag.production.id\",\n            \"data.vsphere_tag.platinum.id\",\n            \"data.vsphere_tag.replicated.id\",\n        },\n    });\n\n    var devDatastore = new VSphere.NasDatastore(\"devDatastore\", new()\n    {\n        Tags = new[]\n        {\n            \"data.vsphere_tag.development.id\",\n            \"data.vsphere_tag.silver.id\",\n            \"data.vsphere_tag.non_replicated.id\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"environment\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"service_level\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"replication\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tCategoryId: \"data.vsphere_tag_category.environment.id\",\n\t\t\tName:       \"production\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tCategoryId: \"data.vsphere_tag_category.environment.id\",\n\t\t\tName:       \"development\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t\tName:       \"platinum\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t\tName:       \"platinum\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t\tName:       \"silver\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t\tName:       \"bronze\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tCategoryId: \"data.vsphere_tag_category.replication.id\",\n\t\t\tName:       \"replicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tCategoryId: \"data.vsphere_tag_category.replication.id\",\n\t\t\tName:       \"non_replicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVmfsDatastore(ctx, \"prodDatastore\", \u0026vsphere.VmfsDatastoreArgs{\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"data.vsphere_tag.production.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.platinum.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.replicated.id\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewNasDatastore(ctx, \"devDatastore\", \u0026vsphere.NasDatastoreArgs{\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"data.vsphere_tag.development.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.silver.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.non_replicated.id\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport com.pulumi.vsphere.inputs.GetTagArgs;\nimport com.pulumi.vsphere.VmfsDatastore;\nimport com.pulumi.vsphere.VmfsDatastoreArgs;\nimport com.pulumi.vsphere.NasDatastore;\nimport com.pulumi.vsphere.NasDatastoreArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var environment = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"environment\")\n            .build());\n\n        final var serviceLevel = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"service_level\")\n            .build());\n\n        final var replication = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"replication\")\n            .build());\n\n        final var production = VsphereFunctions.getTag(GetTagArgs.builder()\n            .categoryId(\"data.vsphere_tag_category.environment.id\")\n            .name(\"production\")\n            .build());\n\n        final var development = VsphereFunctions.getTag(GetTagArgs.builder()\n            .categoryId(\"data.vsphere_tag_category.environment.id\")\n            .name(\"development\")\n            .build());\n\n        final var platinum = VsphereFunctions.getTag(GetTagArgs.builder()\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .name(\"platinum\")\n            .build());\n\n        final var gold = VsphereFunctions.getTag(GetTagArgs.builder()\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .name(\"platinum\")\n            .build());\n\n        final var silver = VsphereFunctions.getTag(GetTagArgs.builder()\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .name(\"silver\")\n            .build());\n\n        final var bronze = VsphereFunctions.getTag(GetTagArgs.builder()\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .name(\"bronze\")\n            .build());\n\n        final var replicated = VsphereFunctions.getTag(GetTagArgs.builder()\n            .categoryId(\"data.vsphere_tag_category.replication.id\")\n            .name(\"replicated\")\n            .build());\n\n        final var nonReplicated = VsphereFunctions.getTag(GetTagArgs.builder()\n            .categoryId(\"data.vsphere_tag_category.replication.id\")\n            .name(\"non_replicated\")\n            .build());\n\n        var prodDatastore = new VmfsDatastore(\"prodDatastore\", VmfsDatastoreArgs.builder()        \n            .tags(            \n                \"data.vsphere_tag.production.id\",\n                \"data.vsphere_tag.platinum.id\",\n                \"data.vsphere_tag.replicated.id\")\n            .build());\n\n        var devDatastore = new NasDatastore(\"devDatastore\", NasDatastoreArgs.builder()        \n            .tags(            \n                \"data.vsphere_tag.development.id\",\n                \"data.vsphere_tag.silver.id\",\n                \"data.vsphere_tag.non_replicated.id\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodDatastore:\n    type: vsphere:VmfsDatastore\n    properties:\n      # ... other configuration ...\n      tags:\n        - data.vsphere_tag.production.id\n        - data.vsphere_tag.platinum.id\n        - data.vsphere_tag.replicated.id\n  devDatastore:\n    type: vsphere:NasDatastore\n    properties:\n      # ... other configuration ...\n      tags:\n        - data.vsphere_tag.development.id\n        - data.vsphere_tag.silver.id\n        - data.vsphere_tag.non_replicated.id\nvariables:\n  environment:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: environment\n  serviceLevel:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: service_level\n  replication:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: replication\n  production:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        categoryId: data.vsphere_tag_category.environment.id\n        name: production\n  development:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        categoryId: data.vsphere_tag_category.environment.id\n        name: development\n  platinum:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        categoryId: data.vsphere_tag_category.service_level.id\n        name: platinum\n  gold:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        categoryId: data.vsphere_tag_category.service_level.id\n        name: platinum\n  silver:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        categoryId: data.vsphere_tag_category.service_level.id\n        name: silver\n  bronze:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        categoryId: data.vsphere_tag_category.service_level.id\n        name: bronze\n  replicated:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        categoryId: data.vsphere_tag_category.replication.id\n        name: replicated\n  nonReplicated:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        categoryId: data.vsphere_tag_category.replication.id\n        name: non_replicated\n```\n\nNext, storage policies are created and `tag_rules` are applied.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodPlatinumReplicated = new vsphere.VmStoragePolicy(\"prodPlatinumReplicated\", {\n    description: \"prod_platinum_replicated\",\n    tagRules: [\n        {\n            tagCategory: data.vsphere_tag_category.environment.name,\n            tags: [data.vsphere_tag.production.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: data.vsphere_tag_category.service_level.name,\n            tags: [data.vsphere_tag.platinum.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: data.vsphere_tag_category.replication.name,\n            tags: [data.vsphere_tag.replicated.name],\n            includeDatastoresWithTags: true,\n        },\n    ],\n});\nconst devSilverNonreplicated = new vsphere.VmStoragePolicy(\"devSilverNonreplicated\", {\n    description: \"dev_silver_nonreplicated\",\n    tagRules: [\n        {\n            tagCategory: data.vsphere_tag_category.environment.name,\n            tags: [data.vsphere_tag.development.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: data.vsphere_tag_category.service_level.name,\n            tags: [data.vsphere_tag.silver.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: data.vsphere_tag_category.replication.name,\n            tags: [data.vsphere_tag.non_replicated.name],\n            includeDatastoresWithTags: true,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_platinum_replicated = vsphere.VmStoragePolicy(\"prodPlatinumReplicated\",\n    description=\"prod_platinum_replicated\",\n    tag_rules=[\n        vsphere.VmStoragePolicyTagRuleArgs(\n            tag_category=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n            tags=[data[\"vsphere_tag\"][\"production\"][\"name\"]],\n            include_datastores_with_tags=True,\n        ),\n        vsphere.VmStoragePolicyTagRuleArgs(\n            tag_category=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n            tags=[data[\"vsphere_tag\"][\"platinum\"][\"name\"]],\n            include_datastores_with_tags=True,\n        ),\n        vsphere.VmStoragePolicyTagRuleArgs(\n            tag_category=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n            tags=[data[\"vsphere_tag\"][\"replicated\"][\"name\"]],\n            include_datastores_with_tags=True,\n        ),\n    ])\ndev_silver_nonreplicated = vsphere.VmStoragePolicy(\"devSilverNonreplicated\",\n    description=\"dev_silver_nonreplicated\",\n    tag_rules=[\n        vsphere.VmStoragePolicyTagRuleArgs(\n            tag_category=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n            tags=[data[\"vsphere_tag\"][\"development\"][\"name\"]],\n            include_datastores_with_tags=True,\n        ),\n        vsphere.VmStoragePolicyTagRuleArgs(\n            tag_category=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n            tags=[data[\"vsphere_tag\"][\"silver\"][\"name\"]],\n            include_datastores_with_tags=True,\n        ),\n        vsphere.VmStoragePolicyTagRuleArgs(\n            tag_category=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n            tags=[data[\"vsphere_tag\"][\"non_replicated\"][\"name\"]],\n            include_datastores_with_tags=True,\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodPlatinumReplicated = new VSphere.VmStoragePolicy(\"prodPlatinumReplicated\", new()\n    {\n        Description = \"prod_platinum_replicated\",\n        TagRules = new[]\n        {\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = data.Vsphere_tag_category.Environment.Name,\n                Tags = new[]\n                {\n                    data.Vsphere_tag.Production.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = data.Vsphere_tag_category.Service_level.Name,\n                Tags = new[]\n                {\n                    data.Vsphere_tag.Platinum.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = data.Vsphere_tag_category.Replication.Name,\n                Tags = new[]\n                {\n                    data.Vsphere_tag.Replicated.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n        },\n    });\n\n    var devSilverNonreplicated = new VSphere.VmStoragePolicy(\"devSilverNonreplicated\", new()\n    {\n        Description = \"dev_silver_nonreplicated\",\n        TagRules = new[]\n        {\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = data.Vsphere_tag_category.Environment.Name,\n                Tags = new[]\n                {\n                    data.Vsphere_tag.Development.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = data.Vsphere_tag_category.Service_level.Name,\n                Tags = new[]\n                {\n                    data.Vsphere_tag.Silver.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = data.Vsphere_tag_category.Replication.Name,\n                Tags = new[]\n                {\n                    data.Vsphere_tag.Non_replicated.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVmStoragePolicy(ctx, \"prodPlatinumReplicated\", \u0026vsphere.VmStoragePolicyArgs{\n\t\t\tDescription: pulumi.String(\"prod_platinum_replicated\"),\n\t\t\tTagRules: vsphere.VmStoragePolicyTagRuleArray{\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(data.Vsphere_tag_category.Environment.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tdata.Vsphere_tag.Production.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(data.Vsphere_tag_category.Service_level.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tdata.Vsphere_tag.Platinum.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(data.Vsphere_tag_category.Replication.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tdata.Vsphere_tag.Replicated.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVmStoragePolicy(ctx, \"devSilverNonreplicated\", \u0026vsphere.VmStoragePolicyArgs{\n\t\t\tDescription: pulumi.String(\"dev_silver_nonreplicated\"),\n\t\t\tTagRules: vsphere.VmStoragePolicyTagRuleArray{\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(data.Vsphere_tag_category.Environment.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tdata.Vsphere_tag.Development.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(data.Vsphere_tag_category.Service_level.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tdata.Vsphere_tag.Silver.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(data.Vsphere_tag_category.Replication.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tdata.Vsphere_tag.Non_replicated.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VmStoragePolicy;\nimport com.pulumi.vsphere.VmStoragePolicyArgs;\nimport com.pulumi.vsphere.inputs.VmStoragePolicyTagRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var prodPlatinumReplicated = new VmStoragePolicy(\"prodPlatinumReplicated\", VmStoragePolicyArgs.builder()        \n            .description(\"prod_platinum_replicated\")\n            .tagRules(            \n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(data.vsphere_tag_category().environment().name())\n                    .tags(data.vsphere_tag().production().name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(data.vsphere_tag_category().service_level().name())\n                    .tags(data.vsphere_tag().platinum().name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(data.vsphere_tag_category().replication().name())\n                    .tags(data.vsphere_tag().replicated().name())\n                    .includeDatastoresWithTags(true)\n                    .build())\n            .build());\n\n        var devSilverNonreplicated = new VmStoragePolicy(\"devSilverNonreplicated\", VmStoragePolicyArgs.builder()        \n            .description(\"dev_silver_nonreplicated\")\n            .tagRules(            \n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(data.vsphere_tag_category().environment().name())\n                    .tags(data.vsphere_tag().development().name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(data.vsphere_tag_category().service_level().name())\n                    .tags(data.vsphere_tag().silver().name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(data.vsphere_tag_category().replication().name())\n                    .tags(data.vsphere_tag().non_replicated().name())\n                    .includeDatastoresWithTags(true)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodPlatinumReplicated:\n    type: vsphere:VmStoragePolicy\n    properties:\n      description: prod_platinum_replicated\n      tagRules:\n        - tagCategory: ${data.vsphere_tag_category.environment.name}\n          tags:\n            - ${data.vsphere_tag.production.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${data.vsphere_tag_category.service_level.name}\n          tags:\n            - ${data.vsphere_tag.platinum.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${data.vsphere_tag_category.replication.name}\n          tags:\n            - ${data.vsphere_tag.replicated.name}\n          includeDatastoresWithTags: true\n  devSilverNonreplicated:\n    type: vsphere:VmStoragePolicy\n    properties:\n      description: dev_silver_nonreplicated\n      tagRules:\n        - tagCategory: ${data.vsphere_tag_category.environment.name}\n          tags:\n            - ${data.vsphere_tag.development.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${data.vsphere_tag_category.service_level.name}\n          tags:\n            - ${data.vsphere_tag.silver.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${data.vsphere_tag_category.replication.name}\n          tags:\n            - ${data.vsphere_tag.non_replicated.name}\n          includeDatastoresWithTags: true\n```\n\nLasttly, when creating a virtual machine resource, a storage policy can be specificed to direct virtual machine placement to a datastore which matches the policy's `tags_rules`.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodPlatinumReplicated = vsphere.getPolicy({\n    name: \"prod_platinum_replicated\",\n});\nconst devSilverNonreplicated = vsphere.getPolicy({\n    name: \"dev_silver_nonreplicated\",\n});\nconst prodVm = new vsphere.VirtualMachine(\"prodVm\", {storagePolicyId: data.vsphere_storage_policy.storage_policy.prod_platinum_replicated.id});\n// ... other configuration ...\nconst devVm = new vsphere.VirtualMachine(\"devVm\", {storagePolicyId: data.vsphere_storage_policy.storage_policy.dev_silver_nonreplicated.id});\n// ... other configuration ...\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_platinum_replicated = vsphere.get_policy(name=\"prod_platinum_replicated\")\ndev_silver_nonreplicated = vsphere.get_policy(name=\"dev_silver_nonreplicated\")\nprod_vm = vsphere.VirtualMachine(\"prodVm\", storage_policy_id=data[\"vsphere_storage_policy\"][\"storage_policy\"][\"prod_platinum_replicated\"][\"id\"])\n# ... other configuration ...\ndev_vm = vsphere.VirtualMachine(\"devVm\", storage_policy_id=data[\"vsphere_storage_policy\"][\"storage_policy\"][\"dev_silver_nonreplicated\"][\"id\"])\n# ... other configuration ...\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodPlatinumReplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"prod_platinum_replicated\",\n    });\n\n    var devSilverNonreplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"dev_silver_nonreplicated\",\n    });\n\n    var prodVm = new VSphere.VirtualMachine(\"prodVm\", new()\n    {\n        StoragePolicyId = data.Vsphere_storage_policy.Storage_policy.Prod_platinum_replicated.Id,\n    });\n\n    // ... other configuration ...\n    var devVm = new VSphere.VirtualMachine(\"devVm\", new()\n    {\n        StoragePolicyId = data.Vsphere_storage_policy.Storage_policy.Dev_silver_nonreplicated.Id,\n    });\n\n    // ... other configuration ...\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"prod_platinum_replicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"dev_silver_nonreplicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVirtualMachine(ctx, \"prodVm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tStoragePolicyId: pulumi.Any(data.Vsphere_storage_policy.Storage_policy.Prod_platinum_replicated.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVirtualMachine(ctx, \"devVm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tStoragePolicyId: pulumi.Any(data.Vsphere_storage_policy.Storage_policy.Dev_silver_nonreplicated.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetPolicyArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var prodPlatinumReplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"prod_platinum_replicated\")\n            .build());\n\n        final var devSilverNonreplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"dev_silver_nonreplicated\")\n            .build());\n\n        var prodVm = new VirtualMachine(\"prodVm\", VirtualMachineArgs.builder()        \n            .storagePolicyId(data.vsphere_storage_policy().storage_policy().prod_platinum_replicated().id())\n            .build());\n\n        var devVm = new VirtualMachine(\"devVm\", VirtualMachineArgs.builder()        \n            .storagePolicyId(data.vsphere_storage_policy().storage_policy().dev_silver_nonreplicated().id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodVm:\n    type: vsphere:VirtualMachine\n    properties:\n      # ... other configuration ...\n      storagePolicyId: ${data.vsphere_storage_policy.storage_policy.prod_platinum_replicated.id}\n  devVm:\n    type: vsphere:VirtualMachine\n    properties:\n      # ... other configuration ...\n      storagePolicyId: ${data.vsphere_storage_policy.storage_policy.dev_silver_nonreplicated.id}\nvariables:\n  prodPlatinumReplicated:\n    fn::invoke:\n      Function: vsphere:getPolicy\n      Arguments:\n        name: prod_platinum_replicated\n  devSilverNonreplicated:\n    fn::invoke:\n      Function: vsphere:getPolicy\n      Arguments:\n        name: dev_silver_nonreplicated\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the storage policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "tagRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                    },
                    "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                }
            },
            "required": [
                "name",
                "tagRules"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the storage policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "tagRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                    },
                    "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                }
            },
            "requiredInputs": [
                "tagRules"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmStoragePolicy resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the storage policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    },
                    "tagRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                        },
                        "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vmfsDatastore:VmfsDatastore": {
            "properties": {
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "disks",
                "freeSpace",
                "hostSystemId",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                }
            },
            "requiredInputs": [
                "disks",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmfsDatastore resources.\n",
                "properties": {
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The disks to use with the datastore.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vnic:Vnic": {
            "description": "Provides a VMware vSphere vnic resource.\n\n{{% examples %}}\n## Example Usage\n\n### S\n{{% example %}}\n### Create a vnic attached to a distributed virtual switch using the vmotion TCP/IP stack\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = vsphere.getDatacenter({\n    name: \"mydc\",\n});\nconst h1 = dc.then(dc =\u003e vsphere.getHost({\n    name: \"esxi1.host.test\",\n    datacenterId: dc.id,\n}));\nconst d1 = new vsphere.DistributedVirtualSwitch(\"d1\", {\n    datacenterId: dc.then(dc =\u003e dc.id),\n    hosts: [{\n        hostSystemId: h1.then(h1 =\u003e h1.id),\n        devices: [\"vnic3\"],\n    }],\n});\nconst p1 = new vsphere.DistributedPortGroup(\"p1\", {\n    vlanId: 1234,\n    distributedVirtualSwitchUuid: d1.id,\n});\nconst v1 = new vsphere.Vnic(\"v1\", {\n    host: h1.then(h1 =\u003e h1.id),\n    distributedSwitchPort: d1.id,\n    distributedPortGroup: p1.id,\n    ipv4: {\n        dhcp: true,\n    },\n    netstack: \"vmotion\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"mydc\")\nh1 = vsphere.get_host(name=\"esxi1.host.test\",\n    datacenter_id=dc.id)\nd1 = vsphere.DistributedVirtualSwitch(\"d1\",\n    datacenter_id=dc.id,\n    hosts=[vsphere.DistributedVirtualSwitchHostArgs(\n        host_system_id=h1.id,\n        devices=[\"vnic3\"],\n    )])\np1 = vsphere.DistributedPortGroup(\"p1\",\n    vlan_id=1234,\n    distributed_virtual_switch_uuid=d1.id)\nv1 = vsphere.Vnic(\"v1\",\n    host=h1.id,\n    distributed_switch_port=d1.id,\n    distributed_port_group=p1.id,\n    ipv4=vsphere.VnicIpv4Args(\n        dhcp=True,\n    ),\n    netstack=\"vmotion\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dc = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"mydc\",\n    });\n\n    var h1 = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi1.host.test\",\n        DatacenterId = dc.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var d1 = new VSphere.DistributedVirtualSwitch(\"d1\", new()\n    {\n        DatacenterId = dc.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n        Hosts = new[]\n        {\n            new VSphere.Inputs.DistributedVirtualSwitchHostArgs\n            {\n                HostSystemId = h1.Apply(getHostResult =\u003e getHostResult.Id),\n                Devices = new[]\n                {\n                    \"vnic3\",\n                },\n            },\n        },\n    });\n\n    var p1 = new VSphere.DistributedPortGroup(\"p1\", new()\n    {\n        VlanId = 1234,\n        DistributedVirtualSwitchUuid = d1.Id,\n    });\n\n    var v1 = new VSphere.Vnic(\"v1\", new()\n    {\n        Host = h1.Apply(getHostResult =\u003e getHostResult.Id),\n        DistributedSwitchPort = d1.Id,\n        DistributedPortGroup = p1.Id,\n        Ipv4 = new VSphere.Inputs.VnicIpv4Args\n        {\n            Dhcp = true,\n        },\n        Netstack = \"vmotion\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdc, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"mydc\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\th1, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi1.host.test\"),\n\t\t\tDatacenterId: dc.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\td1, err := vsphere.NewDistributedVirtualSwitch(ctx, \"d1\", \u0026vsphere.DistributedVirtualSwitchArgs{\n\t\t\tDatacenterId: *pulumi.String(dc.Id),\n\t\t\tHosts: vsphere.DistributedVirtualSwitchHostArray{\n\t\t\t\t\u0026vsphere.DistributedVirtualSwitchHostArgs{\n\t\t\t\t\tHostSystemId: *pulumi.String(h1.Id),\n\t\t\t\t\tDevices: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"vnic3\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp1, err := vsphere.NewDistributedPortGroup(ctx, \"p1\", \u0026vsphere.DistributedPortGroupArgs{\n\t\t\tVlanId:                       pulumi.Int(1234),\n\t\t\tDistributedVirtualSwitchUuid: d1.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVnic(ctx, \"v1\", \u0026vsphere.VnicArgs{\n\t\t\tHost:                  *pulumi.String(h1.Id),\n\t\t\tDistributedSwitchPort: d1.ID(),\n\t\t\tDistributedPortGroup:  p1.ID(),\n\t\t\tIpv4: \u0026vsphere.VnicIpv4Args{\n\t\t\t\tDhcp: pulumi.Bool(true),\n\t\t\t},\n\t\t\tNetstack: pulumi.String(\"vmotion\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.DistributedVirtualSwitch;\nimport com.pulumi.vsphere.DistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.inputs.DistributedVirtualSwitchHostArgs;\nimport com.pulumi.vsphere.DistributedPortGroup;\nimport com.pulumi.vsphere.DistributedPortGroupArgs;\nimport com.pulumi.vsphere.Vnic;\nimport com.pulumi.vsphere.VnicArgs;\nimport com.pulumi.vsphere.inputs.VnicIpv4Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dc = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"mydc\")\n            .build());\n\n        final var h1 = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi1.host.test\")\n            .datacenterId(dc.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var d1 = new DistributedVirtualSwitch(\"d1\", DistributedVirtualSwitchArgs.builder()        \n            .datacenterId(dc.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .hosts(DistributedVirtualSwitchHostArgs.builder()\n                .hostSystemId(h1.applyValue(getHostResult -\u003e getHostResult.id()))\n                .devices(\"vnic3\")\n                .build())\n            .build());\n\n        var p1 = new DistributedPortGroup(\"p1\", DistributedPortGroupArgs.builder()        \n            .vlanId(1234)\n            .distributedVirtualSwitchUuid(d1.id())\n            .build());\n\n        var v1 = new Vnic(\"v1\", VnicArgs.builder()        \n            .host(h1.applyValue(getHostResult -\u003e getHostResult.id()))\n            .distributedSwitchPort(d1.id())\n            .distributedPortGroup(p1.id())\n            .ipv4(VnicIpv4Args.builder()\n                .dhcp(true)\n                .build())\n            .netstack(\"vmotion\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  d1:\n    type: vsphere:DistributedVirtualSwitch\n    properties:\n      datacenterId: ${dc.id}\n      hosts:\n        - hostSystemId: ${h1.id}\n          devices:\n            - vnic3\n  p1:\n    type: vsphere:DistributedPortGroup\n    properties:\n      vlanId: 1234\n      distributedVirtualSwitchUuid: ${d1.id}\n  v1:\n    type: vsphere:Vnic\n    properties:\n      host: ${h1.id}\n      distributedSwitchPort: ${d1.id}\n      distributedPortGroup: ${p1.id}\n      ipv4:\n        dhcp: true\n      netstack: vmotion\nvariables:\n  dc:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: mydc\n  h1:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi1.host.test\n        datacenterId: ${dc.id}\n```\n{{% /example %}}\n{{% example %}}\n### Create a vnic attached to a portgroup using the default TCP/IP stack\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport com.pulumi.vsphere.HostPortGroup;\nimport com.pulumi.vsphere.HostPortGroupArgs;\nimport com.pulumi.vsphere.Vnic;\nimport com.pulumi.vsphere.VnicArgs;\nimport com.pulumi.vsphere.inputs.VnicIpv4Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dc = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"mydc\")\n            .build());\n\n        final var h1 = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi1.host.test\")\n            .datacenterId(dc.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var hvs1 = new HostVirtualSwitch(\"hvs1\", HostVirtualSwitchArgs.builder()        \n            .hostSystemId(h1.applyValue(getHostResult -\u003e getHostResult.id()))\n            .networkAdapters(            \n                \"vmnic3\",\n                \"vmnic4\")\n            .activeNics(\"vmnic3\")\n            .standbyNics(\"vmnic4\")\n            .build());\n\n        var p1 = new HostPortGroup(\"p1\", HostPortGroupArgs.builder()        \n            .virtualSwitchName(hvs1.name())\n            .hostSystemId(h1.applyValue(getHostResult -\u003e getHostResult.id()))\n            .build());\n\n        var v1 = new Vnic(\"v1\", VnicArgs.builder()        \n            .host(h1.applyValue(getHostResult -\u003e getHostResult.id()))\n            .portgroup(p1.name())\n            .ipv4(VnicIpv4Args.builder()\n                .dhcp(true)\n                .build())\n            .enabledServices(            \n                \"vsan\",\n                \"management\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hvs1:\n    type: vsphere:HostVirtualSwitch\n    properties:\n      hostSystemId: ${h1.id}\n      networkAdapters:\n        - vmnic3\n        - vmnic4\n      activeNics:\n        - vmnic3\n      standbyNics:\n        - vmnic4\n  p1:\n    type: vsphere:HostPortGroup\n    properties:\n      virtualSwitchName: ${hvs1.name}\n      hostSystemId: ${h1.id}\n  v1:\n    type: vsphere:Vnic\n    properties:\n      host: ${h1.id}\n      portgroup: ${p1.name}\n      ipv4:\n        dhcp: true\n      enabledServices:\n        - vsan\n        - management\nvariables:\n  dc:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: mydc\n  h1:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi1.host.test\n        datacenterId: ${dc.id}\n```\n{{% /example %}}\n{{% /examples %}}\n## Importing \n\nAn existing vNic can be [imported][docs-import] into this resource\nvia supplying the vNic's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n    }\n}\n```\n```yaml\n{}\n```\n\nThe above would import the vnic `vmk2` from host with ID `host-123`.\n",
            "properties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to.\n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n"
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See  ipv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See  ipv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default: `defaultTcpipStack`)\n"
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Enabled services setting for this interface. Current possible values are 'vmotion', 'management', and 'vsan'.\n"
                }
            },
            "required": [
                "host",
                "mac",
                "mtu"
            ],
            "inputProperties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to.\n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n",
                    "willReplaceOnChanges": true
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See  ipv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See  ipv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default: `defaultTcpipStack`)\n",
                    "willReplaceOnChanges": true
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Enabled services setting for this interface. Current possible values are 'vmotion', 'management', and 'vsan'.\n"
                }
            },
            "requiredInputs": [
                "host"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vnic resources.\n",
                "properties": {
                    "distributedPortGroup": {
                        "type": "string",
                        "description": "Key of the distributed portgroup the nic will connect to.\n"
                    },
                    "distributedSwitchPort": {
                        "type": "string",
                        "description": "UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.\n"
                    },
                    "host": {
                        "type": "string",
                        "description": "ESX host the interface belongs to\n",
                        "willReplaceOnChanges": true
                    },
                    "ipv4": {
                        "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                        "description": "IPv4 settings. Either this or `ipv6` needs to be set. See  ipv4 options below.\n"
                    },
                    "ipv6": {
                        "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                        "description": "IPv6 settings. Either this or `ipv6` needs to be set. See  ipv6 options below.\n"
                    },
                    "mac": {
                        "type": "string",
                        "description": "MAC address of the interface.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "MTU of the interface.\n"
                    },
                    "netstack": {
                        "type": "string",
                        "description": "TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default: `defaultTcpipStack`)\n",
                        "willReplaceOnChanges": true
                    },
                    "portgroup": {
                        "type": "string",
                        "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                    },
                    "services": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Enabled services setting for this interface. Current possible values are 'vmotion', 'management', and 'vsan'.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "vsphere:index/getComputeCluster:getComputeCluster": {
            "description": "The `vsphere.ComputeCluster` data source can be used to discover the ID of a\ncluster in vSphere. This is useful to fetch the ID of a cluster that you want\nto use for virtual machine placement via the `vsphere.VirtualMachine` resource, allowing to specify the cluster's root resource pool directly versus\nusing the alias available through the `vsphere.ResourcePool`\ndata source.\n\n\u003e You may also wish to see the `vsphere.ComputeCluster`\n resource for more information about clusters and how to managed the resource\n in this provider.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst computeCluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncompute_cluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  computeCluster:\n    fn::invoke:\n      Function: vsphere:getComputeCluster\n      Arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the cluster is located in.  This can be omitted if the\nsearch path used in `name` is an absolute path. For default datacenters,\nuse the `id` attribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object reference ID of\nthe root resource pool for the cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "resourcePoolId",
                    "id"
                ]
            }
        },
        "vsphere:index/getComputeClusterHostGroup:getComputeClusterHostGroup": {
            "description": "The `vsphere.ComputeClusterHostGroup` data source can be used to discover\nthe IDs ESXi hosts in a host group and return host group attributes to other\nresources.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: _var.vsphere_datacenter,\n});\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: _var.vsphere_cluster,\n    datacenterId: datacenter.id,\n}));\nconst hostGroup1 = cluster.then(cluster =\u003e vsphere.getComputeClusterHostGroup({\n    name: \"host_group1\",\n    computeClusterId: cluster.id,\n}));\nconst hostRule1 = new vsphere.ComputeClusterVmHostRule(\"hostRule1\", {\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    vmGroupName: \"vm_group1\",\n    affinityHostGroupName: hostGroup1.then(hostGroup1 =\u003e hostGroup1.name),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\ncluster = vsphere.get_compute_cluster(name=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),\n    datacenter_id=datacenter.id)\nhost_group1 = vsphere.get_compute_cluster_host_group(name=\"host_group1\",\n    compute_cluster_id=cluster.id)\nhost_rule1 = vsphere.ComputeClusterVmHostRule(\"hostRule1\",\n    compute_cluster_id=cluster.id,\n    vm_group_name=\"vm_group1\",\n    affinity_host_group_name=host_group1.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = @var.Vsphere_datacenter,\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = @var.Vsphere_cluster,\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hostGroup1 = VSphere.GetComputeClusterHostGroup.Invoke(new()\n    {\n        Name = \"host_group1\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n    });\n\n    var hostRule1 = new VSphere.ComputeClusterVmHostRule(\"hostRule1\", new()\n    {\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        VmGroupName = \"vm_group1\",\n        AffinityHostGroupName = hostGroup1.Apply(getComputeClusterHostGroupResult =\u003e getComputeClusterHostGroupResult.Name),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(_var.Vsphere_datacenter),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         _var.Vsphere_cluster,\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostGroup1, err := vsphere.LookupComputeClusterHostGroup(ctx, \u0026vsphere.LookupComputeClusterHostGroupArgs{\n\t\t\tName:             \"host_group1\",\n\t\t\tComputeClusterId: cluster.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewComputeClusterVmHostRule(ctx, \"hostRule1\", \u0026vsphere.ComputeClusterVmHostRuleArgs{\n\t\t\tComputeClusterId:      *pulumi.String(cluster.Id),\n\t\t\tVmGroupName:           pulumi.String(\"vm_group1\"),\n\t\t\tAffinityHostGroupName: *pulumi.String(hostGroup1.Name),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterHostGroupArgs;\nimport com.pulumi.vsphere.ComputeClusterVmHostRule;\nimport com.pulumi.vsphere.ComputeClusterVmHostRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(var_.vsphere_datacenter())\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(var_.vsphere_cluster())\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var hostGroup1 = VsphereFunctions.getComputeClusterHostGroup(GetComputeClusterHostGroupArgs.builder()\n            .name(\"host_group1\")\n            .computeClusterId(cluster.applyValue(getComputeClusterResult -\u003e getComputeClusterResult.id()))\n            .build());\n\n        var hostRule1 = new ComputeClusterVmHostRule(\"hostRule1\", ComputeClusterVmHostRuleArgs.builder()        \n            .computeClusterId(cluster.applyValue(getComputeClusterResult -\u003e getComputeClusterResult.id()))\n            .vmGroupName(\"vm_group1\")\n            .affinityHostGroupName(hostGroup1.applyValue(getComputeClusterHostGroupResult -\u003e getComputeClusterHostGroupResult.name()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hostRule1:\n    type: vsphere:ComputeClusterVmHostRule\n    properties:\n      computeClusterId: ${cluster.id}\n      vmGroupName: vm_group1\n      affinityHostGroupName: ${hostGroup1.name}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: ${var.vsphere_datacenter}\n  cluster:\n    fn::invoke:\n      Function: vsphere:getComputeCluster\n      Arguments:\n        name: ${var.vsphere_cluster}\n        datacenterId: ${datacenter.id}\n  hostGroup1:\n    fn::invoke:\n      Function: vsphere:getComputeClusterHostGroup\n      Arguments:\n        name: host_group1\n        computeClusterId: ${cluster.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getComputeClusterHostGroup.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The [managed object reference ID][docs-about-morefs]\nof the compute cluster for the host group.\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "computeClusterId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getComputeClusterHostGroup.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The [managed object reference ID][docs-about-morefs] of\nthe ESXi hosts in the host group.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "computeClusterId",
                    "hostSystemIds",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getContentLibrary:getContentLibrary": {
            "description": "The `vsphere.ContentLibrary` data source can be used to discover the ID of a content library.\n\n\u003e **NOTE:** This resource requires vCenter Server and is not available on direct ESXi host connections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst library = vsphere.getContentLibrary({\n    name: \"Content Library\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlibrary = vsphere.get_content_library(name=\"Content Library\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var library = VSphere.GetContentLibrary.Invoke(new()\n    {\n        Name = \"Content Library\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupContentLibrary(ctx, \u0026vsphere.LookupContentLibraryArgs{\n\t\t\tName: \"Content Library\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetContentLibraryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var library = VsphereFunctions.getContentLibrary(GetContentLibraryArgs.builder()\n            .name(\"Content Library\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  library:\n    fn::invoke:\n      Function: vsphere:getContentLibrary\n      Arguments:\n        name: Content Library\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibrary.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the content library.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibrary.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getContentLibraryItem:getContentLibraryItem": {
            "description": "The `vsphere.ContentLibraryItem` data source can be used to discover the ID\nof a content library item.\n\n\u003e **NOTE:** This resource requires vCenter Server and is not available on\ndirect ESXi host connections.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibraryItem.\n",
                "properties": {
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the content library in which the item exists.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the content library item.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "The type for the content library item. One of `ovf`, `vm-template`, or `iso`\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "libraryId",
                    "name",
                    "type"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibraryItem.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "libraryId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "libraryId",
                    "name",
                    "type",
                    "id"
                ]
            }
        },
        "vsphere:index/getCustomAttribute:getCustomAttribute": {
            "description": "The `vsphere.CustomAttribute` data source can be used to reference custom\nattributes that are not managed by this provider. Its attributes are exactly the\nsame as the `vsphere.CustomAttribute` resource,\nand, like importing, the data source takes a name argument for the search. The\n`id` and other attributes are then populated with the data found by the search.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand require vCenter Server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst attribute = vsphere.getCustomAttribute({\n    name: \"test-attribute\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nattribute = vsphere.get_custom_attribute(name=\"test-attribute\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attribute = VSphere.GetCustomAttribute.Invoke(new()\n    {\n        Name = \"test-attribute\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupCustomAttribute(ctx, \u0026vsphere.LookupCustomAttributeArgs{\n\t\t\tName: \"test-attribute\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetCustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var attribute = VsphereFunctions.getCustomAttribute(GetCustomAttributeArgs.builder()\n            .name(\"test-attribute\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  attribute:\n    fn::invoke:\n      Function: vsphere:getCustomAttribute\n      Arguments:\n        name: test-attribute\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomAttribute.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomAttribute.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "managedObjectType": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "managedObjectType",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getDatacenter:getDatacenter": {
            "description": "The `vsphere.Datacenter` data source can be used to discover the ID of a\nvSphere datacenter object. This can then be used with resources or data sources\nthat require a datacenter, such as the `vsphere.Host`\ndata source.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatacenter.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This can be a name or path.\nCan be omitted if there is only one datacenter in the inventory.\n\n\u003e **NOTE:** When used with an ESXi host, this data source _always_ returns the\nhost's \"default\" datacenter, which is a special datacenter name unrelated to the\ndatacenters that exist in the vSphere inventory when managed by a vCenter Server\ninstance. Hence, the `name` attribute is completely ignored.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatacenter.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            }
        },
        "vsphere:index/getDatastore:getDatastore": {
            "description": "The `vsphere.getDatastore` data source can be used to discover the ID of a\nvSphere datastore object. This can then be used with resources or data sources\nthat require a datastore. For example, to create virtual machines in using the\n`vsphere.VirtualMachine` resource.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  datastore:\n    fn::invoke:\n      Function: vsphere:getDatastore\n      Arguments:\n        name: datastore-01\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the datastore is located in. This can be omitted if the\nsearch path used in `name` is an absolute path. For default datacenters, use\nthe `id` attribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getDatastoreCluster:getDatastoreCluster": {
            "description": "The `vsphere.DatastoreCluster` data source can be used to discover the ID of a\nvSphere datastore cluster object. This can then be used with resources or data sources\nthat require a datastore. For example, to assign datastores using the\n`vsphere.NasDatastore` or `vsphere.VmfsDatastore` resources, or to create virtual machines in using the `vsphere.VirtualMachine` resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastoreCluster = datacenter.then(datacenter =\u003e vsphere.getDatastoreCluster({\n    name: \"datastore-cluster-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore_cluster = vsphere.get_datastore_cluster(name=\"datastore-cluster-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastoreCluster = VSphere.GetDatastoreCluster.Invoke(new()\n    {\n        Name = \"datastore-cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupDatastoreCluster(ctx, \u0026vsphere.LookupDatastoreClusterArgs{\n\t\t\tName:         \"datastore-cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastoreCluster = VsphereFunctions.getDatastoreCluster(GetDatastoreClusterArgs.builder()\n            .name(\"datastore-cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  datastoreCluster:\n    fn::invoke:\n      Function: vsphere:getDatastoreCluster\n      Arguments:\n        name: datastore-cluster-01\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the datastore cluster is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the id attribute from an empty\n`vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the datastore cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getDistributedVirtualSwitch:getDistributedVirtualSwitch": {
            "description": "The `vsphere.DistributedVirtualSwitch` data source can be used to discover\nthe ID and uplink data of a of a vSphere distributed switch (VDS). This\ncan then be used with resources or data sources that require a VDS, such as the\n`vsphere.DistributedPortGroup` resource, for which\nan example is shown below.\n\n\u003e **NOTE:** This data source requires vCenter Server and is not available on\ndirect ESXi host connections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe following example locates a distributed switch named `vds-01`, in the\ndatacenter `dc-01`. It then uses this distributed switch to set up a\n`vsphere.DistributedPortGroup` resource that uses the first uplink as a\nprimary uplink and the second uplink as a secondary.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst vds = datacenter.then(datacenter =\u003e vsphere.getDistributedVirtualSwitch({\n    name: \"vds-01\",\n    datacenterId: datacenter.id,\n}));\nconst dvpg = new vsphere.DistributedPortGroup(\"dvpg\", {\n    distributedVirtualSwitchUuid: vds.then(vds =\u003e vds.id),\n    activeUplinks: [vds.then(vds =\u003e vds.uplinks?.[0])],\n    standbyUplinks: [vds.then(vds =\u003e vds.uplinks?.[1])],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nvds = vsphere.get_distributed_virtual_switch(name=\"vds-01\",\n    datacenter_id=datacenter.id)\ndvpg = vsphere.DistributedPortGroup(\"dvpg\",\n    distributed_virtual_switch_uuid=vds.id,\n    active_uplinks=[vds.uplinks[0]],\n    standby_uplinks=[vds.uplinks[1]])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var vds = VSphere.GetDistributedVirtualSwitch.Invoke(new()\n    {\n        Name = \"vds-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var dvpg = new VSphere.DistributedPortGroup(\"dvpg\", new()\n    {\n        DistributedVirtualSwitchUuid = vds.Apply(getDistributedVirtualSwitchResult =\u003e getDistributedVirtualSwitchResult.Id),\n        ActiveUplinks = new[]\n        {\n            vds.Apply(getDistributedVirtualSwitchResult =\u003e getDistributedVirtualSwitchResult.Uplinks[0]),\n        },\n        StandbyUplinks = new[]\n        {\n            vds.Apply(getDistributedVirtualSwitchResult =\u003e getDistributedVirtualSwitchResult.Uplinks[1]),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvds, err := vsphere.LookupDistributedVirtualSwitch(ctx, \u0026vsphere.LookupDistributedVirtualSwitchArgs{\n\t\t\tName:         \"vds-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewDistributedPortGroup(ctx, \"dvpg\", \u0026vsphere.DistributedPortGroupArgs{\n\t\t\tDistributedVirtualSwitchUuid: *pulumi.String(vds.Id),\n\t\t\tActiveUplinks: pulumi.StringArray{\n\t\t\t\t*pulumi.String(vds.Uplinks[0]),\n\t\t\t},\n\t\t\tStandbyUplinks: pulumi.StringArray{\n\t\t\t\t*pulumi.String(vds.Uplinks[1]),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.DistributedPortGroup;\nimport com.pulumi.vsphere.DistributedPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var vds = VsphereFunctions.getDistributedVirtualSwitch(GetDistributedVirtualSwitchArgs.builder()\n            .name(\"vds-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var dvpg = new DistributedPortGroup(\"dvpg\", DistributedPortGroupArgs.builder()        \n            .distributedVirtualSwitchUuid(vds.applyValue(getDistributedVirtualSwitchResult -\u003e getDistributedVirtualSwitchResult.id()))\n            .activeUplinks(vds.applyValue(getDistributedVirtualSwitchResult -\u003e getDistributedVirtualSwitchResult.uplinks()[0]))\n            .standbyUplinks(vds.applyValue(getDistributedVirtualSwitchResult -\u003e getDistributedVirtualSwitchResult.uplinks()[1]))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dvpg:\n    type: vsphere:DistributedPortGroup\n    properties:\n      distributedVirtualSwitchUuid: ${vds.id}\n      activeUplinks:\n        - ${vds.uplinks[0]}\n      standbyUplinks:\n        - ${vds.uplinks[1]}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  vds:\n    fn::invoke:\n      Function: vsphere:getDistributedVirtualSwitch\n      Arguments:\n        name: vds-01\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the VDS is located in. This can be omitted if the search\npath used in `name` is an absolute path. For default datacenters, use the `id`\nattribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VDS. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "uplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of the uplinks on this vSphere distributed switch, as per the\n`uplinks` argument to the\n`vsphere.DistributedVirtualSwitch`\nresource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "uplinks",
                    "id"
                ]
            }
        },
        "vsphere:index/getDynamic:getDynamic": {
            "description": "[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n\nThe `vsphere.getDynamic` data source can be used to get the [managed object reference ID][docs-about-morefs]\nof any tagged managed object in vCenter Server by providing a list of tag IDs\nand an optional regular expression to filter objects by name.\n   \n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = vsphere.getTagCategory({\n    name: \"SomeCategory\",\n});\nconst tag1 = vsphere.getTag({\n    name: \"FirstTag\",\n    categoryId: data.vsphere_tag_category.cat.id,\n});\nconst tag2 = vsphere.getTag({\n    name: \"SecondTag\",\n    categoryId: data.vsphere_tag_category.cat.id,\n});\nconst dyn = Promise.all([tag1, tag1]).then(([tag1, tag11]) =\u003e vsphere.getDynamic({\n    filters: [\n        tag1.id,\n        tag11.id,\n    ],\n    nameRegex: \"ubuntu\",\n    type: \"Datacenter\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"SomeCategory\")\ntag1 = vsphere.get_tag(name=\"FirstTag\",\n    category_id=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\ntag2 = vsphere.get_tag(name=\"SecondTag\",\n    category_id=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\ndyn = vsphere.get_dynamic(filters=[\n        tag1.id,\n        tag1.id,\n    ],\n    name_regex=\"ubuntu\",\n    type=\"Datacenter\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"SomeCategory\",\n    });\n\n    var tag1 = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"FirstTag\",\n        CategoryId = data.Vsphere_tag_category.Cat.Id,\n    });\n\n    var tag2 = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"SecondTag\",\n        CategoryId = data.Vsphere_tag_category.Cat.Id,\n    });\n\n    var dyn = VSphere.GetDynamic.Invoke(new()\n    {\n        Filters = new[]\n        {\n            tag1.Apply(getTagResult =\u003e getTagResult.Id),\n            tag1.Apply(getTagResult =\u003e getTagResult.Id),\n        },\n        NameRegex = \"ubuntu\",\n        Type = \"Datacenter\",\n    });\n\n});\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport com.pulumi.vsphere.inputs.GetTagArgs;\nimport com.pulumi.vsphere.inputs.GetDynamicArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var category = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"SomeCategory\")\n            .build());\n\n        final var tag1 = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"FirstTag\")\n            .categoryId(data.vsphere_tag_category().cat().id())\n            .build());\n\n        final var tag2 = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"SecondTag\")\n            .categoryId(data.vsphere_tag_category().cat().id())\n            .build());\n\n        final var dyn = VsphereFunctions.getDynamic(GetDynamicArgs.builder()\n            .filters(            \n                tag1.applyValue(getTagResult -\u003e getTagResult.id()),\n                tag1.applyValue(getTagResult -\u003e getTagResult.id()))\n            .nameRegex(\"ubuntu\")\n            .type(\"Datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  category:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: SomeCategory\n  tag1:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: FirstTag\n        categoryId: ${data.vsphere_tag_category.cat.id}\n  tag2:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: SecondTag\n        categoryId: ${data.vsphere_tag_category.cat.id}\n  dyn:\n    fn::invoke:\n      Function: vsphere:getDynamic\n      Arguments:\n        filters:\n          - ${tag1.id}\n          - ${tag1.id}\n        nameRegex: ubuntu\n        type: Datacenter\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDynamic.\n",
                "properties": {
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs that must be present on an object to\nbe a match.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match\nthe object's name.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The managed object type the returned object must match.\nThe managed object types can be found in the managed object type section\n[here](https://developer.vmware.com/apis/968/vsphere).\n"
                    }
                },
                "type": "object",
                "required": [
                    "filters"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDynamic.\n",
                "properties": {
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "nameRegex": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "filters",
                    "id"
                ]
            }
        },
        "vsphere:index/getFolder:getFolder": {
            "description": "The `vsphere.Folder` data source can be used to get the general attributes of a\nvSphere inventory folder. Paths are absolute and must include the datacenter.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst folder = vsphere.getFolder({\n    path: \"/dc-01/datastore-01/folder-01\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nfolder = vsphere.get_folder(path=\"/dc-01/datastore-01/folder-01\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var folder = VSphere.GetFolder.Invoke(new()\n    {\n        Path = \"/dc-01/datastore-01/folder-01\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupFolder(ctx, \u0026vsphere.LookupFolderArgs{\n\t\t\tPath: \"/dc-01/datastore-01/folder-01\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetFolderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var folder = VsphereFunctions.getFolder(GetFolderArgs.builder()\n            .path(\"/dc-01/datastore-01/folder-01\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  folder:\n    fn::invoke:\n      Function: vsphere:getFolder\n      Arguments:\n        path: /dc-01/datastore-01/folder-01\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFolder.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The absolute path of the folder. For example, given a\ndefault datacenter of `default-dc`, a folder of type `vm`, and a folder name\nof `test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`. The valid folder types to be used in\nthe path are: `vm`, `host`, `datacenter`, `datastore`, or `network`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFolder.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "id"
                ]
            }
        },
        "vsphere:index/getHost:getHost": {
            "description": "The `vsphere.Host` data source can be used to discover the ID of an ESXi host.\nThis can then be used with resources or data sources that require an ESX\nhost's managed object reference ID.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof a vSphere datacenter object.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ESXI host. This can be a name or path.\nCan be omitted if there is only one host in your inventory.\n\n\u003e **NOTE:** When used against an ESXi host directly, this data source _always_\nreturns the ESXi host's object ID, regardless of what is entered into `name`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID of the ESXi\nhost's root resource pool.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "resourcePoolId",
                    "id"
                ]
            }
        },
        "vsphere:index/getHostPciDevice:getHostPciDevice": {
            "description": "The `vsphere.getHostPciDevice` data source can be used to discover the device ID\nof a vSphere host's PCI device. This can then be used with\n`vsphere.VirtualMachine`'s `pci_device_id`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### With Vendor ID And Class ID\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst dev = host.then(host =\u003e vsphere.getHostPciDevice({\n    hostId: host.id,\n    classId: \"123\",\n    vendorId: \"456\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\ndev = vsphere.get_host_pci_device(host_id=host.id,\n    class_id=\"123\",\n    vendor_id=\"456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var dev = VSphere.GetHostPciDevice.Invoke(new()\n    {\n        HostId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        ClassId = \"123\",\n        VendorId = \"456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostPciDevice(ctx, \u0026vsphere.GetHostPciDeviceArgs{\n\t\t\tHostId:   host.Id,\n\t\t\tClassId:  pulumi.StringRef(\"123\"),\n\t\t\tVendorId: pulumi.StringRef(\"456\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetHostPciDeviceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var dev = VsphereFunctions.getHostPciDevice(GetHostPciDeviceArgs.builder()\n            .hostId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .classId(123)\n            .vendorId(456)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  dev:\n    fn::invoke:\n      Function: vsphere:getHostPciDevice\n      Arguments:\n        hostId: ${host.id}\n        classId: 123\n        vendorId: 456\n```\n{{% /example %}}\n### With Name Regular Expression\n \n ```hcl\n data \"vsphere_datacenter\" \"datacenter\" {\n   name = \"dc-01\"\n }\n \n data \"vsphere_host\" \"host\" {\n   name          = \"esxi-01.example.com\"\n   datacenter_id = data.vsphere_datacenter.datacenter.id\n }\n \n data \"vsphere_host_pci_device\" \"dev\" {\n   host_id    = data.vsphere_host.host.id\n   name_regex = \"MMC\"\n }\n ```\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getHostPciDevice.\n",
                "properties": {
                    "classId": {
                        "type": "string",
                        "description": "The hexadecimal PCI device class ID\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n\n\u003e **NOTE:** `name_regex`, `vendor_id`, and `class_id` can all be used together.\n"
                    },
                    "hostId": {
                        "type": "string",
                        "description": "The [managed object reference ID][docs-about-morefs] of a host.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match the\nhost PCI device name.\n"
                    },
                    "vendorId": {
                        "type": "string",
                        "description": "The hexadecimal PCI device vendor ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostPciDevice.\n",
                "properties": {
                    "classId": {
                        "type": "string"
                    },
                    "hostId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the PCI device.\n"
                    },
                    "nameRegex": {
                        "type": "string"
                    },
                    "vendorId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "hostId",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getHostThumbprint:getHostThumbprint": {
            "description": "The `vsphere_thumbprint` data source can be used to discover the host\nthumbprint of an ESXi host. This can be used when adding the `vsphere.Host`\nresource. If the ESXi host is using a certificate chain, the first one returned\nwill be used to generate the thumbprint.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst thumbprint = vsphere.getHostThumbprint({\n    address: \"esxi-01.example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nthumbprint = vsphere.get_host_thumbprint(address=\"esxi-01.example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var thumbprint = VSphere.GetHostThumbprint.Invoke(new()\n    {\n        Address = \"esxi-01.example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetHostThumbprint(ctx, \u0026vsphere.GetHostThumbprintArgs{\n\t\t\tAddress: \"esxi-01.example.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetHostThumbprintArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var thumbprint = VsphereFunctions.getHostThumbprint(GetHostThumbprintArgs.builder()\n            .address(\"esxi-01.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  thumbprint:\n    fn::invoke:\n      Function: vsphere:getHostThumbprint\n      Arguments:\n        address: esxi-01.example.com\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getHostThumbprint.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The address of the ESXi host to retrieve the\nthumbprint from.\n"
                    },
                    "insecure": {
                        "type": "boolean",
                        "description": "Disables SSL certificate verification.\nDefault: `false`\n"
                    },
                    "port": {
                        "type": "string",
                        "description": "The port to use connecting to the ESXi host. Default: 443\n"
                    }
                },
                "type": "object",
                "required": [
                    "address"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostThumbprint.\n",
                "properties": {
                    "address": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "insecure": {
                        "type": "boolean"
                    },
                    "port": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "address",
                    "id"
                ]
            }
        },
        "vsphere:index/getLicense:getLicense": {
            "description": "The `vsphere.License` data source can be used to get the general attributes of\na license keys from a vCenter Server instance.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst license = vsphere.getLicense({\n    licenseKey: \"00000-00000-00000-00000-00000\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlicense = vsphere.get_license(license_key=\"00000-00000-00000-00000-00000\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var license = VSphere.GetLicense.Invoke(new()\n    {\n        LicenseKey = \"00000-00000-00000-00000-00000\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupLicense(ctx, \u0026vsphere.LookupLicenseArgs{\n\t\t\tLicenseKey: \"00000-00000-00000-00000-00000\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetLicenseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var license = VsphereFunctions.getLicense(GetLicenseArgs.builder()\n            .licenseKey(\"00000-00000-00000-00000-00000\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  license:\n    fn::invoke:\n      Function: vsphere:getLicense\n      Arguments:\n        licenseKey: 00000-00000-00000-00000-00000\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getLicense.\n",
                "properties": {
                    "licenseKey": {
                        "type": "string",
                        "description": "The license key.\n"
                    }
                },
                "type": "object",
                "required": [
                    "licenseKey"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLicense.\n",
                "properties": {
                    "editionKey": {
                        "type": "string",
                        "description": "The product edition of the license key.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of key/value pairs attached as labels (tags) to the license key.\n"
                    },
                    "licenseKey": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name for the license.\n"
                    },
                    "total": {
                        "type": "integer",
                        "description": "Total number of units (example: CPUs) contained in the license.\n"
                    },
                    "used": {
                        "type": "integer",
                        "description": "The number of units (example: CPUs) assigned to this license.\n"
                    }
                },
                "type": "object",
                "required": [
                    "editionKey",
                    "id",
                    "labels",
                    "licenseKey",
                    "name",
                    "total",
                    "used"
                ]
            }
        },
        "vsphere:index/getNetwork:getNetwork": {
            "description": "The `vsphere.getNetwork` data source can be used to discover the ID of a network\nin vSphere. This can be any network that can be used as the backing for a\nnetwork interface for `vsphere.VirtualMachine` or any other vSphere resource\nthat requires a network. This includes standard (host-based) port groups,\ndistributed port groups, or opaque networks such as those managed by NSX.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"VM Network\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nnetwork = vsphere.get_network(name=\"VM Network\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"VM Network\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"VM Network\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"VM Network\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  network:\n    fn::invoke:\n      Function: vsphere:getNetwork\n      Arguments:\n        name: VM Network\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the network is located in. This can be omitted if the\nsearch path used in `name` is an absolute path. For default datacenters,\nuse the `id` attribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "For distributed port group type\nnetwork objects, the ID of the distributed virtual switch for which the port\ngroup belongs. It is useful to differentiate port groups with same name\nusing the distributed virtual switch ID.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the network. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The managed object type for the discovered network. This will be one\nof `DistributedVirtualPortgroup` for distributed port groups, `Network` for\nstandard (host-based) port groups, or `OpaqueNetwork` for networks managed\nexternally, such as those managed by NSX.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "type",
                    "id"
                ]
            }
        },
        "vsphere:index/getOvfVmTemplate:getOvfVmTemplate": {
            "description": "The `vsphere.getOvfVmTemplate` data source can be used to submit an OVF to\nvSphere and extract its hardware settings in a form that can be then used as\ninputs for a `vsphere.VirtualMachine` resource.\n\n## Remote OVF/OVA Source\n\ndata \"vsphere_ovf_vm_template\" \"ovfRemote\" {\n  name              = \"Nested-ESXi-7.0-Terraform-Deploy-1\"\n  disk_provisioning = \"thin\"\n  resource_pool_id  = data.vsphere_resource_pool.default.id\n  datastore_id      = data.vsphere_datastore.datastore.id\n  host_system_id    = data.vsphere_host.host.id\n  remote_ovf_url    = \"https://download3.vmware.com/software/vmw-tools/nested-esxi/Nested_ESXi7.0u3_Appliance_Template_v1.ova\"\n  ovf_network_map = {\n    \"VM Network\" : data.vsphere_network.network.id\n  }\n}\n\n## Local OVF/OVA Source\n\ndata \"vsphere_ovf_vm_template\" \"ovfLocal\" {\n  name              = \"Nested-ESXi-7.0-Terraform-Deploy-2\"\n  disk_provisioning = \"thin\"\n  resource_pool_id  = data.vsphere_resource_pool.default.id\n  datastore_id      = data.vsphere_datastore.datastore.id\n  host_system_id    = data.vsphere_host.host.id\n  local_ovf_path    = \"/Volume/Storage/OVA/Nested_ESXi7.0u3_Appliance_Template_v1.ova\"\n  ovf_network_map = {\n    \"VM Network\" : data.vsphere_network.network.id\n  }\n}\n\n## Deployment of VM from Remote OVF\n\nresource \"vsphere_virtual_machine\" \"vmFromRemoteOvf\" {\n  name                 = \"Nested-ESXi-7.0-Terraform-Deploy-1\"\n  datacenter_id        = data.vsphere_datacenter.datacenter.id\n  datastore_id         = data.vsphere_datastore.datastore.id\n  host_system_id       = data.vsphere_host.host.id\n  resource_pool_id     = data.vsphere_resource_pool.default.id\n  num_cpus             = data.vsphere_ovf_vm_template.ovfRemote.num_cpus\n  num_cores_per_socket = data.vsphere_ovf_vm_template.ovfRemote.num_cores_per_socket\n  memory               = data.vsphere_ovf_vm_template.ovfRemote.memory\n  guest_id             = data.vsphere_ovf_vm_template.ovfRemote.guest_id\n  firmware             = data.vsphere_ovf_vm_template.ovfRemote.firmware\n  scsi_type            = data.vsphere_ovf_vm_template.ovfRemote.scsi_type\n  nested_hv_enabled    = data.vsphere_ovf_vm_template.ovfRemote.nested_hv_enabled\n  dynamic \"network_interface\" {\n    for_each = data.vsphere_ovf_vm_template.ovfRemote.ovf_network_map\n    content {\n      network_id = network_interface.value\n    }\n  }\n  wait_for_guest_net_timeout = 0\n  wait_for_guest_ip_timeout  = 0\n\n  ovf_deploy {\n    allow_unverified_ssl_cert = false\n    remote_ovf_url            = data.vsphere_ovf_vm_template.ovfRemote.remote_ovf_url\n    disk_provisioning         = data.vsphere_ovf_vm_template.ovfRemote.disk_provisioning\n    ovf_network_map           = data.vsphere_ovf_vm_template.ovfRemote.ovf_network_map\n  }\n\n  vapp {\n    properties = {\n      \"guestinfo.hostname\"  = \"nested-esxi-01.example.com\",\n      \"guestinfo.ipaddress\" = \"172.16.11.101\",\n      \"guestinfo.netmask\"   = \"255.255.255.0\",\n      \"guestinfo.gateway\"   = \"172.16.11.1\",\n      \"guestinfo.dns\"       = \"172.16.11.4\",\n      \"guestinfo.domain\"    = \"example.com\",\n      \"guestinfo.ntp\"       = \"ntp.example.com\",\n      \"guestinfo.password\"  = \"VMware1!\",\n      \"guestinfo.ssh\"       = \"True\"\n    }\n  }\n\n  lifecycle {\n    ignore_changes = [\n      annotation,\n      disk[0].io_share_count,\n      disk[1].io_share_count,\n      disk[2].io_share_count,\n      vapp[0].properties,\n    ]\n  }\n}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOvfVmTemplate.\n",
                "properties": {
                    "allowUnverifiedSslCert": {
                        "type": "boolean",
                        "description": "Allow unverified SSL certificates\nwhen deploying OVF/OVA from a URL.\n"
                    },
                    "datastoreId": {
                        "type": "string",
                        "description": "The ID of the virtual machine's datastore. The\nvirtual machine configuration is placed here, along with any virtual disks\nthat are created without datastores.\n"
                    },
                    "deploymentOption": {
                        "type": "string",
                        "description": "The key of the chosen deployment option. If\nempty, the default option is chosen.\n",
                        "willReplaceOnChanges": true
                    },
                    "diskProvisioning": {
                        "type": "string",
                        "description": "The disk provisioning type. If set, all the\ndisks in the deployed OVA/OVF will have the same specified disk type. Can be\none of `thin`, `flat`, `thick` or `sameAsSource`.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableHiddenProperties": {
                        "type": "boolean",
                        "description": "Allow properties with\n`ovf:userConfigurable=false` to be set.\n",
                        "willReplaceOnChanges": true
                    },
                    "folder": {
                        "type": "string",
                        "description": "The name of the folder in which to place the virtual\nmachine.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The ID of the ESXi host system to deploy the\nvirtual machine.\n"
                    },
                    "ipAllocationPolicy": {
                        "type": "string",
                        "description": "The IP allocation policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipProtocol": {
                        "type": "string",
                        "description": "The IP protocol.\n",
                        "willReplaceOnChanges": true
                    },
                    "localOvfPath": {
                        "type": "string",
                        "description": "The absolute path to the OVF/OVA file on the\nlocal system. When deploying from an OVF, ensure all necessary files such as\nthe `.vmdk` files are present in the same directory as the OVF.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the virtual machine to create.\n"
                    },
                    "ovfNetworkMap": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The mapping of name of network identifiers\nfrom the OVF descriptor to network UUID in the environment.\n",
                        "willReplaceOnChanges": true
                    },
                    "remoteOvfUrl": {
                        "type": "string",
                        "description": "URL of the remote OVF/OVA file to be deployed.\n\n\u003e **NOTE:** Either `local_ovf_path` or `remote_ovf_url` is required, both can\nnot be empty.\n",
                        "willReplaceOnChanges": true
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The ID of a resource pool in which to place\nthe virtual machine.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostSystemId",
                    "name",
                    "resourcePoolId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOvfVmTemplate.\n",
                "properties": {
                    "allowUnverifiedSslCert": {
                        "type": "boolean"
                    },
                    "alternateGuestName": {
                        "type": "string",
                        "description": "An alternate guest operating system name.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "A description of the virtual machine.\n"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to the virtual machine while\npowered on.\n"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be removed from the virtual machine\nwhile powered on.\n"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "datastoreId": {
                        "type": "string"
                    },
                    "deploymentOption": {
                        "type": "string"
                    },
                    "diskProvisioning": {
                        "type": "string"
                    },
                    "enableHiddenProperties": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware to use on the virtual machine.\n"
                    },
                    "folder": {
                        "type": "string"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The ID for the guest operating system\n"
                    },
                    "hostSystemId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ideControllerCount": {
                        "type": "integer"
                    },
                    "ipAllocationPolicy": {
                        "type": "string"
                    },
                    "ipProtocol": {
                        "type": "string"
                    },
                    "localOvfPath": {
                        "type": "string"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow memory to be added to the virtual machine\nwhile powered on.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean",
                        "description": "Enable nested hardware virtualization on the virtual\nmachine, facilitating nested virtualization in the guest.\n"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per virtual CPU in the virtual\nmachine.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The number of virtual CPUs to assign to the virtual machine.\n"
                    },
                    "ovfNetworkMap": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "remoteOvfUrl": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string"
                    },
                    "sataControllerCount": {
                        "type": "integer"
                    },
                    "scsiControllerCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string",
                        "description": "The swap file placement policy for the virtual\nmachine.\n"
                    }
                },
                "type": "object",
                "required": [
                    "alternateGuestName",
                    "annotation",
                    "cpuHotAddEnabled",
                    "cpuHotRemoveEnabled",
                    "cpuPerformanceCountersEnabled",
                    "firmware",
                    "guestId",
                    "hostSystemId",
                    "ideControllerCount",
                    "memory",
                    "memoryHotAddEnabled",
                    "name",
                    "nestedHvEnabled",
                    "numCoresPerSocket",
                    "numCpus",
                    "resourcePoolId",
                    "sataControllerCount",
                    "scsiControllerCount",
                    "scsiType",
                    "swapPlacementPolicy",
                    "id"
                ]
            }
        },
        "vsphere:index/getPolicy:getPolicy": {
            "description": "The `vsphere.getPolicy` data source can be used to discover the UUID of a\nstorage policy. This can then be used with other resources or data sources that\nuse a storage policy.\n\n\u003e **NOTE:** Storage policies are not supported on direct ESXi hosts and\nrequires vCenter Server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodPlatinumReplicated = vsphere.getPolicy({\n    name: \"prod_platinum_replicated\",\n});\nconst devSilverNonreplicated = vsphere.getPolicy({\n    name: \"dev_silver_nonreplicated\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_platinum_replicated = vsphere.get_policy(name=\"prod_platinum_replicated\")\ndev_silver_nonreplicated = vsphere.get_policy(name=\"dev_silver_nonreplicated\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodPlatinumReplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"prod_platinum_replicated\",\n    });\n\n    var devSilverNonreplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"dev_silver_nonreplicated\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"prod_platinum_replicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"dev_silver_nonreplicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var prodPlatinumReplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"prod_platinum_replicated\")\n            .build());\n\n        final var devSilverNonreplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"dev_silver_nonreplicated\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  prodPlatinumReplicated:\n    fn::invoke:\n      Function: vsphere:getPolicy\n      Arguments:\n        name: prod_platinum_replicated\n  devSilverNonreplicated:\n    fn::invoke:\n      Function: vsphere:getPolicy\n      Arguments:\n        name: dev_silver_nonreplicated\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPolicy.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getResourcePool:getResourcePool": {
            "description": "The `vsphere.ResourcePool` data source can be used to discover the ID of a\nresource pool in vSphere. This is useful to return the ID of a resource pool\nthat you want to use to create virtual machines in using the\n`vsphere.VirtualMachine` resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst pool = datacenter.then(datacenter =\u003e vsphere.getResourcePool({\n    name: \"resource-pool-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\npool = vsphere.get_resource_pool(name=\"resource-pool-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var pool = VSphere.GetResourcePool.Invoke(new()\n    {\n        Name = \"resource-pool-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupResourcePool(ctx, \u0026vsphere.LookupResourcePoolArgs{\n\t\t\tName:         pulumi.StringRef(\"resource-pool-01\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var pool = VsphereFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"resource-pool-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  pool:\n    fn::invoke:\n      Function: vsphere:getResourcePool\n      Arguments:\n        name: resource-pool-01\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% example %}}\n### Specifying the Root Resource Pool for a Standalone ESXi Host\n\n\u003e **NOTE:** Returning the root resource pool for a cluster can be done\ndirectly via the `vsphere.ComputeCluster`\ndata source.\n\nAll compute resources in vSphere have a resource pool, even if one has not been\nexplicitly created. This resource pool is referred to as the\n_root resource pool_ and can be looked up by specifying the path.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst pool = vsphere.getResourcePool({\n    name: \"esxi-01.example.com/Resources\",\n    datacenterId: data.vsphere_datacenter.datacenter.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\npool = vsphere.get_resource_pool(name=\"esxi-01.example.com/Resources\",\n    datacenter_id=%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pool = VSphere.GetResourcePool.Invoke(new()\n    {\n        Name = \"esxi-01.example.com/Resources\",\n        DatacenterId = data.Vsphere_datacenter.Datacenter.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupResourcePool(ctx, \u0026vsphere.LookupResourcePoolArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com/Resources\"),\n\t\t\tDatacenterId: pulumi.StringRef(data.Vsphere_datacenter.Datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var pool = VsphereFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"esxi-01.example.com/Resources\")\n            .datacenterId(data.vsphere_datacenter().datacenter().id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  pool:\n    fn::invoke:\n      Function: vsphere:getResourcePool\n      Arguments:\n        name: esxi-01.example.com/Resources\n        datacenterId: ${data.vsphere_datacenter.datacenter.id}\n```\n\nFor more information on the root resource pool, see [Managing Resource Pools][vmware-docs-resource-pools] in the vSphere documentation.\n\n[vmware-docs-resource-pools]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.resmgmt.doc/GUID-60077B40-66FF-4625-934A-641703ED7601.html\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter in which the resource pool is located. This can be omitted\nif the search path used in `name` is an absolute path. For default\ndatacenters, use the id attribute from an empty `vsphere.Datacenter` data\nsource.\n\n\u003e **Note:** When using ESXi without a vCenter Server instance, you do not\nneed to specify either attribute to use this data source. An empty declaration\nwill load the ESXi host's root resource pool.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource pool. This can be a name or\npath. This is required when using vCenter.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            }
        },
        "vsphere:index/getRole:getRole": {
            "description": "The `vsphere.Role` data source can be used to discover the `id` and privileges associated\nwith a role given its name or display label.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst terraformRole = vsphere.getRole({\n    label: \"Terraform to vSphere Integration Role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nterraform_role = vsphere.get_role(label=\"Terraform to vSphere Integration Role\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var terraformRole = VSphere.GetRole.Invoke(new()\n    {\n        Label = \"Terraform to vSphere Integration Role\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupRole(ctx, \u0026vsphere.LookupRoleArgs{\n\t\t\tLabel: \"Terraform to vSphere Integration Role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var terraformRole = VsphereFunctions.getRole(GetRoleArgs.builder()\n            .label(\"Terraform to vSphere Integration Role\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  terraformRole:\n    fn::invoke:\n      Function: vsphere:getRole\n      Arguments:\n        label: Terraform to vSphere Integration Role\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the role.\n"
                    },
                    "label": {
                        "type": "string",
                        "description": "The label of the role.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges associated with the role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "label"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the role.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "label": {
                        "type": "string",
                        "description": "The display label of the role.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges associated with the role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "label",
                    "id"
                ]
            }
        },
        "vsphere:index/getTag:getTag": {
            "description": "The `vsphere.Tag` data source can be used to reference tags that are not\nmanaged by this provider. Its attributes are exactly the same as the `vsphere.Tag`\nresource, and, like importing, the data source takes a name and\ncategory to search on. The `id` and other attributes are then populated with\nthe data found by the search.\n\n\u003e **NOTE:** Tagging is not supported on direct ESXi hosts connections and\nrequires vCenter Server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = vsphere.getTagCategory({\n    name: \"example-category\",\n});\nconst tag = category.then(category =\u003e vsphere.getTag({\n    name: \"example-tag\",\n    categoryId: category.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"example-category\")\ntag = vsphere.get_tag(name=\"example-tag\",\n    category_id=category.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"example-category\",\n    });\n\n    var tag = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"example-tag\",\n        CategoryId = category.Apply(getTagCategoryResult =\u003e getTagCategoryResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcategory, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"example-category\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"example-tag\",\n\t\t\tCategoryId: category.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport com.pulumi.vsphere.inputs.GetTagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var category = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"example-category\")\n            .build());\n\n        final var tag = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"example-tag\")\n            .categoryId(category.applyValue(getTagCategoryResult -\u003e getTagCategoryResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  category:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: example-category\n  tag:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: example-tag\n        categoryId: ${category.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The ID of the tag category in which the tag is\nlocated.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the tag.\n"
                    }
                },
                "type": "object",
                "required": [
                    "categoryId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "categoryId",
                    "description",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getTagCategory:getTagCategory": {
            "description": "The `vsphere.TagCategory` data source can be used to reference tag categories\nthat are not managed by this provider. Its attributes are the same as the\n`vsphere.TagCategory` resource, and, like importing,\nthe data source uses a name and category as search criteria. The `id` and other\nattributes are populated with the data found by the search.\n\n\u003e **NOTE:** Tagging is not supported on direct ESXi hosts connections and\nrequires vCenter Server.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = vsphere.getTagCategory({\n    name: \"example-category\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"example-category\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"example-category\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"example-category\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var category = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"example-category\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  category:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: example-category\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getTagCategory.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the tag category.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTagCategory.\n",
                "properties": {
                    "associableTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "cardinality": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "associableTypes",
                    "cardinality",
                    "description",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getVappContainer:getVappContainer": {
            "description": "The `vsphere.VappContainer` data source can be used to discover the ID of a\nvApp container in vSphere. This is useful to return the ID of a vApp container\nthat you want to use to create virtual machines in using the\n`vsphere.VirtualMachine` resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst pool = datacenter.then(datacenter =\u003e vsphere.getVappContainer({\n    name: \"vapp-container-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\npool = vsphere.get_vapp_container(name=\"vapp-container-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var pool = VSphere.GetVappContainer.Invoke(new()\n    {\n        Name = \"vapp-container-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVappContainer(ctx, \u0026vsphere.LookupVappContainerArgs{\n\t\t\tName:         \"vapp-container-01\",\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetVappContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var pool = VsphereFunctions.getVappContainer(GetVappContainerArgs.builder()\n            .name(\"vapp-container-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  pool:\n    fn::invoke:\n      Function: vsphere:getVappContainer\n      Arguments:\n        name: vapp-container-01\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter in which the vApp container is located.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container. This can be a name or\npath.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getVirtualMachine:getVirtualMachine": {
            "description": "The `vsphere.VirtualMachine` data source can be used to find the UUID of an\nexisting virtual machine or template. The most common purpose is for finding\nthe UUID of a template to be used as the source for cloning to a new\n`vsphere.VirtualMachine` resource. It also\nreads the guest ID so that can be supplied as well.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nIn the following example, a virtual machine template is returned by its\nunique name within the `vsphere.Datacenter`.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst template = datacenter.then(datacenter =\u003e vsphere.getVirtualMachine({\n    name: \"ubuntu-server-template\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ntemplate = vsphere.get_virtual_machine(name=\"ubuntu-server-template\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var template = VSphere.GetVirtualMachine.Invoke(new()\n    {\n        Name = \"ubuntu-server-template\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026vsphere.LookupVirtualMachineArgs{\n\t\t\tName:         pulumi.StringRef(\"ubuntu-server-template\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetVirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var template = VsphereFunctions.getVirtualMachine(GetVirtualMachineArgs.builder()\n            .name(\"ubuntu-server-template\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  template:\n    fn::invoke:\n      Function: vsphere:getVirtualMachine\n      Arguments:\n        name: ubuntu-server-template\n        datacenterId: ${datacenter.id}\n```\nIn the following example, each virtual machine template is returned by its\nunique full path within the `vsphere.Datacenter`.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst productionTemplate = datacenter.then(datacenter =\u003e vsphere.getVirtualMachine({\n    name: \"production/templates/ubuntu-server-template\",\n    datacenterId: datacenter.id,\n}));\nconst developmentTemplate = datacenter.then(datacenter =\u003e vsphere.getVirtualMachine({\n    name: \"development/templates/ubuntu-server-template\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nproduction_template = vsphere.get_virtual_machine(name=\"production/templates/ubuntu-server-template\",\n    datacenter_id=datacenter.id)\ndevelopment_template = vsphere.get_virtual_machine(name=\"development/templates/ubuntu-server-template\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var productionTemplate = VSphere.GetVirtualMachine.Invoke(new()\n    {\n        Name = \"production/templates/ubuntu-server-template\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var developmentTemplate = VSphere.GetVirtualMachine.Invoke(new()\n    {\n        Name = \"development/templates/ubuntu-server-template\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026vsphere.LookupVirtualMachineArgs{\n\t\t\tName:         pulumi.StringRef(\"production/templates/ubuntu-server-template\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026vsphere.LookupVirtualMachineArgs{\n\t\t\tName:         pulumi.StringRef(\"development/templates/ubuntu-server-template\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetVirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var productionTemplate = VsphereFunctions.getVirtualMachine(GetVirtualMachineArgs.builder()\n            .name(\"production/templates/ubuntu-server-template\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var developmentTemplate = VsphereFunctions.getVirtualMachine(GetVirtualMachineArgs.builder()\n            .name(\"development/templates/ubuntu-server-template\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  productionTemplate:\n    fn::invoke:\n      Function: vsphere:getVirtualMachine\n      Arguments:\n        name: production/templates/ubuntu-server-template\n        datacenterId: ${datacenter.id}\n  developmentTemplate:\n    fn::invoke:\n      Function: vsphere:getVirtualMachine\n      Arguments:\n        name: development/templates/ubuntu-server-template\n        datacenterId: ${datacenter.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getVirtualMachine.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The alternate guest name of the virtual machine when\n`guest_id` is a non-specific operating system, like `otherGuest` or `otherGuest64`.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "The user-provided description of this virtual machine.\n"
                    },
                    "bootDelay": {
                        "type": "integer"
                    },
                    "bootRetryDelay": {
                        "type": "integer"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "type": "integer"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "cpuReservation": {
                        "type": "integer"
                    },
                    "cpuShareCount": {
                        "type": "integer"
                    },
                    "cpuShareLevel": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the virtual machine is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the `id` attribute from an empty\n`vsphere.Datacenter` data source.\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean"
                    },
                    "enableDiskUuid": {
                        "type": "boolean"
                    },
                    "enableLogging": {
                        "type": "boolean"
                    },
                    "eptRviMode": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "extraConfigRebootRequired": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware type for this virtual machine. Can be `bios` or `efi`.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID of the virtual machine or template.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version number on this virtual machine.\n"
                    },
                    "hvMode": {
                        "type": "string"
                    },
                    "ideControllerScanCount": {
                        "type": "integer"
                    },
                    "latencySensitivity": {
                        "type": "string"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "type": "integer"
                    },
                    "memoryReservation": {
                        "type": "integer"
                    },
                    "memoryShareCount": {
                        "type": "integer"
                    },
                    "memoryShareLevel": {
                        "type": "string"
                    },
                    "moid": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual machine. This can be a name or\nthe full path relative to the datacenter. This is required if a UUID lookup\nis not performed.\n"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per socket for this virtual machine.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The total number of virtual processor cores assigned to this\nvirtual machine.\n"
                    },
                    "replaceTrigger": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean"
                    },
                    "sataControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer",
                        "description": "The number of SCSI controllers to\nscan for disk attributes and controller types on. Default: `1`.\n\n\u003e **NOTE:** For best results, ensure that all the disks on any templates you\nuse with this data source reside on the primary controller, and leave this\nvalue at the default. See the `vsphere.VirtualMachine`\nresource documentation for the significance of this setting, specifically the\nadditional requirements and notes for cloning section.\n"
                    },
                    "storagePolicyId": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean"
                    },
                    "toolsUpgradePolicy": {
                        "type": "string"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "Specify this field for a UUID lookup, `name` and `datacenter_id`\nare not required if this is specified.\n"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp"
                    },
                    "vbsEnabled": {
                        "type": "boolean"
                    },
                    "vvtdEnabled": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getVirtualMachine.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The alternate guest name of the virtual machine when\n`guest_id` is a non-specific operating system, like `otherGuest` or `otherGuest64`.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "The user-provided description of this virtual machine.\n"
                    },
                    "bootDelay": {
                        "type": "integer"
                    },
                    "bootRetryDelay": {
                        "type": "integer"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean"
                    },
                    "changeVersion": {
                        "type": "string"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "type": "integer"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "cpuReservation": {
                        "type": "integer"
                    },
                    "cpuShareCount": {
                        "type": "integer"
                    },
                    "cpuShareLevel": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "defaultIpAddress": {
                        "type": "string",
                        "description": "Whenever possible, this is the first IPv4 address that is reachable through\nthe default gateway configured on the machine, then the first reachable IPv6\naddress, and then the first general discovered address if neither exist. If\nVMware Tools is not running on the virtual machine, or if the VM is powered\noff, this value will be blank.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/getVirtualMachineDisk:getVirtualMachineDisk"
                        },
                        "description": "Information about each of the disks on this virtual machine or\ntemplate. These are sorted by bus and unit number so that they can be applied\nto a `vsphere.VirtualMachine` resource in the order the resource expects\nwhile cloning. This is useful for discovering certain disk settings while\nperforming a linked clone, as all settings that are output by this data\nsource must be the same on the destination virtual machine as the source.\nOnly the first number of controllers defined by `scsi_controller_scan_count`\nare scanned for disks. The sub-attributes are:\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean"
                    },
                    "enableDiskUuid": {
                        "type": "boolean"
                    },
                    "enableLogging": {
                        "type": "boolean"
                    },
                    "eptRviMode": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "extraConfigRebootRequired": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware type for this virtual machine. Can be `bios` or `efi`.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID of the virtual machine or template.\n"
                    },
                    "guestIpAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IP addresses as reported by VMware Tools.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version number on this virtual machine.\n"
                    },
                    "hvMode": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ideControllerScanCount": {
                        "type": "integer"
                    },
                    "latencySensitivity": {
                        "type": "string"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "type": "integer"
                    },
                    "memoryReservation": {
                        "type": "integer"
                    },
                    "memoryShareCount": {
                        "type": "integer"
                    },
                    "memoryShareLevel": {
                        "type": "string"
                    },
                    "moid": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean"
                    },
                    "networkInterfaceTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The network interface types for each network\ninterface found on the virtual machine, in device bus order. Will be one of\n`e1000`, `e1000e`, `pcnet32`, `sriov`, `vmxnet2`, `vmxnet3vrdma`, or `vmxnet3`.\n"
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/getVirtualMachineNetworkInterface:getVirtualMachineNetworkInterface"
                        },
                        "description": "Information about each of the network interfaces on this \nvirtual machine or template. These are sorted by device bus order so that they\ncan be applied to a `vsphere.VirtualMachine` resource in the order the resource\nexpects while cloning. This is useful for discovering certain network interface\nsettings while performing a linked clone, as all settings that are output by this\ndata source must be the same on the destination virtual machine as the source.\nThe sub-attributes are:\n"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per socket for this virtual machine.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The total number of virtual processor cores assigned to this\nvirtual machine.\n"
                    },
                    "replaceTrigger": {
                        "type": "string"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean"
                    },
                    "sataControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiBusSharing": {
                        "type": "string",
                        "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Only the first number of\ncontrollers defined by `scsi_controller_scan_count` are scanned.\n"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "type": "string",
                        "description": "The common type of all SCSI controllers on this virtual machine.\nWill be one of `lsilogic` (LSI Logic Parallel), `lsilogic-sas` (LSI Logic\nSAS), `pvscsi` (VMware Paravirtual), `buslogic` (BusLogic), or `mixed` when\nthere are multiple controller types. Only the first number of controllers\ndefined by `scsi_controller_scan_count` are scanned.\n"
                    },
                    "storagePolicyId": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean"
                    },
                    "toolsUpgradePolicy": {
                        "type": "string"
                    },
                    "uuid": {
                        "type": "string"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp"
                    },
                    "vappTransports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "vbsEnabled": {
                        "type": "boolean"
                    },
                    "vvtdEnabled": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "annotation",
                    "changeVersion",
                    "cpuShareCount",
                    "defaultIpAddress",
                    "disks",
                    "guestId",
                    "guestIpAddresses",
                    "hardwareVersion",
                    "memoryShareCount",
                    "moid",
                    "networkInterfaceTypes",
                    "networkInterfaces",
                    "scsiBusSharing",
                    "scsiType",
                    "storagePolicyId",
                    "uuid",
                    "vappTransports",
                    "id"
                ]
            }
        },
        "vsphere:index/getVmfsDisks:getVmfsDisks": {
            "description": "The `vsphere.getVmfsDisks` data source can be used to discover the storage\ndevices available on an ESXi host. This data source can be combined with the\n`vsphere.VmfsDatastore` resource to create VMFS\ndatastores based off a set of discovered disks.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst vmfsDisks = host.then(host =\u003e vsphere.getVmfsDisks({\n    hostSystemId: host.id,\n    rescan: true,\n    filter: \"mpx.vmhba1:C0:T[12]:L0\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nvmfs_disks = vsphere.get_vmfs_disks(host_system_id=host.id,\n    rescan=True,\n    filter=\"mpx.vmhba1:C0:T[12]:L0\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vmfsDisks = VSphere.GetVmfsDisks.Invoke(new()\n    {\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        Rescan = true,\n        Filter = \"mpx.vmhba1:C0:T[12]:L0\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetVmfsDisks(ctx, \u0026vsphere.GetVmfsDisksArgs{\n\t\t\tHostSystemId: host.Id,\n\t\t\tRescan:       pulumi.BoolRef(true),\n\t\t\tFilter:       pulumi.StringRef(\"mpx.vmhba1:C0:T[12]:L0\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetVmfsDisksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var vmfsDisks = VsphereFunctions.getVmfsDisks(GetVmfsDisksArgs.builder()\n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .rescan(true)\n            .filter(\"mpx.vmhba1:C0:T[12]:L0\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  vmfsDisks:\n    fn::invoke:\n      Function: vsphere:getVmfsDisks\n      Arguments:\n        hostSystemId: ${host.id}\n        rescan: true\n        filter: mpx.vmhba1:C0:T[12]:L0\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getVmfsDisks.\n",
                "properties": {
                    "filter": {
                        "type": "string",
                        "description": "A regular expression to filter the disks against. Only\ndisks with canonical names that match will be included.\n\n\u003e **NOTE:** Using a `filter` is recommended if there is any chance the host\nwill have any specific storage devices added to it that may affect the order of\nthe output `disks` attribute below, which is lexicographically sorted.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to look for disks on.\n"
                    },
                    "rescan": {
                        "type": "boolean",
                        "description": "Whether or not to rescan storage adapters before\nsearching for disks. This may lengthen the time it takes to perform the\nsearch. Default: `false`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostSystemId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVmfsDisks.\n",
                "properties": {
                    "disks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A lexicographically sorted list of devices discovered by the\noperation, matching the supplied `filter`, if provided.\n"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "hostSystemId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rescan": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "disks",
                    "hostSystemId",
                    "id"
                ]
            }
        }
    }
}