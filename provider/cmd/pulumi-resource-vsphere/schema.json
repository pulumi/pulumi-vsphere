{
    "name": "vsphere",
    "description": "A Pulumi package for creating vsphere resources",
    "keywords": [
        "pulumi",
        "vsphere"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vsphere` Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere).",
    "repository": "https://github.com/pulumi/pulumi-vsphere",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "vsphere": "VSphere"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating vsphere resources",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vsphere` repo](https://github.com/pulumi/pulumi-vsphere/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vsphere` repo](https://github.com/hashicorp/terraform-provider-vsphere/issues).",
            "devDependencies": {
                "@types/node": "^10.9.2"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vsphere` repo](https://github.com/pulumi/pulumi-vsphere/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vsphere` repo](https://github.com/hashicorp/terraform-provider-vsphere/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "defaults": [
            "password",
            "user"
        ]
    },
    "types": {
        "vsphere:index/ComputeClusterHostImage:ComputeClusterHostImage": {
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterHostImageComponent:ComputeClusterHostImageComponent"
                    },
                    "description": "List of custom components.\n"
                },
                "esxVersion": {
                    "type": "string",
                    "description": "The ESXi version which the image is based on.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/ComputeClusterHostImageComponent:ComputeClusterHostImageComponent": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The identifier for the component.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version to use.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup": {
            "properties": {
                "cache": {
                    "type": "string",
                    "description": "Cache disk.\n"
                },
                "storages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of storage disks.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/ComputeClusterVsanFaultDomain:ComputeClusterVsanFaultDomain": {
            "properties": {
                "faultDomains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanFaultDomainFaultDomain:ComputeClusterVsanFaultDomainFaultDomain"
                    },
                    "description": "The configuration for single fault domain.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/ComputeClusterVsanFaultDomainFaultDomain:ComputeClusterVsanFaultDomainFaultDomain": {
            "properties": {
                "hostIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the fault domain.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "hostIds",
                "name"
            ]
        },
        "vsphere:index/ComputeClusterVsanStretchedCluster:ComputeClusterVsanStretchedCluster": {
            "properties": {
                "preferredFaultDomainHostIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the first fault domain.\n"
                },
                "preferredFaultDomainName": {
                    "type": "string",
                    "description": "The name of prepferred fault domain.\n"
                },
                "secondaryFaultDomainHostIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the second fault domain.\n"
                },
                "secondaryFaultDomainName": {
                    "type": "string",
                    "description": "The name of secondary fault domain.\n"
                },
                "witnessNode": {
                    "type": "string",
                    "description": "The managed object IDs of the host selected as witness node when enable stretched cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "preferredFaultDomainHostIds",
                "secondaryFaultDomainHostIds",
                "witnessNode"
            ]
        },
        "vsphere:index/ContentLibraryPublication:ContentLibraryPublication": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "Method to authenticate users. Must be `NONE` or `BASIC`.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "Password used by subscribers to authenticate.\n",
                    "willReplaceOnChanges": true
                },
                "publishUrl": {
                    "type": "string",
                    "description": "The URL of the published content library.\n",
                    "willReplaceOnChanges": true
                },
                "published": {
                    "type": "boolean",
                    "description": "Publish the content library. Default `false`.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Username used by subscribers to authenticate. Currently can only be `vcsp`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "password",
                        "publishUrl",
                        "username"
                    ]
                }
            }
        },
        "vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.\n",
                    "willReplaceOnChanges": true
                },
                "automaticSync": {
                    "type": "boolean",
                    "description": "Enable automatic synchronization with the published library. Default `false`.\n",
                    "willReplaceOnChanges": true
                },
                "onDemand": {
                    "type": "boolean",
                    "description": "Download the library from a content only when needed. Default `true`.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "Password used for authentication.\n",
                    "willReplaceOnChanges": true
                },
                "subscriptionUrl": {
                    "type": "string",
                    "description": "URL of the published content library.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Username used for authentication.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "password",
                        "username"
                    ]
                }
            }
        },
        "vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer",
                    "description": "The minimum VLAN to use in the range.\n"
                },
                "minVlan": {
                    "type": "integer",
                    "description": "The minimum VLAN to use in the range.\n"
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost": {
            "properties": {
                "devices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name of the physical NIC to be added to the proxy switch.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host this specification applies to.\n"
                }
            },
            "type": "object",
            "required": [
                "hostSystemId"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping": {
            "properties": {
                "primaryVlanId": {
                    "type": "integer",
                    "description": "The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n"
                },
                "pvlanType": {
                    "type": "string",
                    "description": "The private VLAN type. Valid values are promiscuous, community and isolated.\n"
                },
                "secondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n"
                }
            },
            "type": "object",
            "required": [
                "primaryVlanId",
                "pvlanType",
                "secondaryVlanId"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer",
                    "description": "The minimum VLAN to use in the range.\n"
                },
                "minVlan": {
                    "type": "integer",
                    "description": "The minimum VLAN to use in the range.\n"
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission": {
            "properties": {
                "isGroup": {
                    "type": "boolean",
                    "description": "Whether `user_or_group` field refers to a user or a\ngroup. True for a group and false for a user.\n"
                },
                "propagate": {
                    "type": "boolean",
                    "description": "Whether or not this permission propagates down the\nhierarchy to sub-entities.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The role id of the role to be given to the user on\nthe specified entity.\n"
                },
                "userOrGroup": {
                    "type": "string",
                    "description": "The user/group getting the permission.\n"
                }
            },
            "type": "object",
            "required": [
                "isGroup",
                "propagate",
                "roleId",
                "userOrGroup"
            ]
        },
        "vsphere:index/GuestOsCustomizationSpec:GuestOsCustomizationSpec": {
            "properties": {
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of DNS servers for a virtual network adapter with a static IP address.\n"
                },
                "dnsSuffixLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS search domains to add to the DNS configuration on the virtual machine.\n"
                },
                "ipv4Gateway": {
                    "type": "string",
                    "description": "The IPv4 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.\n"
                },
                "ipv6Gateway": {
                    "type": "string",
                    "description": "The IPv6 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.\n"
                },
                "linuxOptions": {
                    "$ref": "#/types/vsphere:index/GuestOsCustomizationSpecLinuxOptions:GuestOsCustomizationSpecLinuxOptions",
                    "description": "A list of configuration options specific to Linux virtual machines.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/GuestOsCustomizationSpecNetworkInterface:GuestOsCustomizationSpecNetworkInterface"
                    },
                    "description": "A specification of network interface configuration options.\n"
                },
                "windowsOptions": {
                    "$ref": "#/types/vsphere:index/GuestOsCustomizationSpecWindowsOptions:GuestOsCustomizationSpecWindowsOptions",
                    "description": "A list of configuration options specific to Windows virtual machines.\n"
                },
                "windowsSysprepText": {
                    "type": "string",
                    "description": "Use this option to specify a windows sysprep file directly.\n",
                    "secret": true
                }
            },
            "type": "object"
        },
        "vsphere:index/GuestOsCustomizationSpecLinuxOptions:GuestOsCustomizationSpecLinuxOptions": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "The domain name for this virtual machine.\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "The hostname for this virtual machine.\n"
                },
                "hwClockUtc": {
                    "type": "boolean",
                    "description": "Specifies whether or not the hardware clock should be in UTC or not.\n"
                },
                "scriptText": {
                    "type": "string",
                    "description": "The customization script to run before and or after guest customization\n",
                    "secret": true
                },
                "timeZone": {
                    "type": "string",
                    "description": "Customize the time zone on the VM. This should be a time zone-style entry, like America/Los_Angeles.\n"
                }
            },
            "type": "object",
            "required": [
                "domain",
                "hostName"
            ]
        },
        "vsphere:index/GuestOsCustomizationSpecNetworkInterface:GuestOsCustomizationSpecNetworkInterface": {
            "properties": {
                "dnsDomain": {
                    "type": "string",
                    "description": "A DNS search domain to add to the DNS configuration on the virtual machine.\n"
                },
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Network-interface specific DNS settings for Windows operating systems. Ignored on Linux.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "The IPv4 address assigned to this network adapter. If left blank, DHCP is used.\n"
                },
                "ipv4Netmask": {
                    "type": "integer",
                    "description": "The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is selected.\n"
                },
                "ipv6Address": {
                    "type": "string",
                    "description": "The IPv6 address assigned to this network adapter. If left blank, default auto-configuration is used.\n"
                },
                "ipv6Netmask": {
                    "type": "integer",
                    "description": "The IPv6 CIDR netmask for the supplied IP address. Ignored if auto-configuration is selected.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/GuestOsCustomizationSpecWindowsOptions:GuestOsCustomizationSpecWindowsOptions": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "The new administrator password for this virtual machine.\n",
                    "secret": true
                },
                "autoLogon": {
                    "type": "boolean",
                    "description": "Specifies whether or not the VM automatically logs on as Administrator.\n"
                },
                "autoLogonCount": {
                    "type": "integer",
                    "description": "Specifies how many times the VM should auto-logon the Administrator account when auto_logon is true.\n"
                },
                "computerName": {
                    "type": "string",
                    "description": "The host name for this virtual machine.\n"
                },
                "domainAdminPassword": {
                    "type": "string",
                    "description": "The password of the domain administrator used to join this virtual machine to the domain.\n",
                    "secret": true
                },
                "domainAdminUser": {
                    "type": "string",
                    "description": "The user account of the domain administrator used to join this virtual machine to the domain.\n"
                },
                "domainOu": {
                    "type": "string",
                    "description": "The MachineObjectOU which specifies the full LDAP path name of the OU to which the virtual machine belongs.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the user of this virtual machine.\n"
                },
                "joinDomain": {
                    "type": "string",
                    "description": "The domain that the virtual machine should join.\n"
                },
                "organizationName": {
                    "type": "string",
                    "description": "The organization name this virtual machine is being installed for.\n"
                },
                "productKey": {
                    "type": "string",
                    "description": "The product key for this virtual machine.\n",
                    "secret": true
                },
                "runOnceCommandLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of commands to run at first user logon, after guest customization.\n"
                },
                "timeZone": {
                    "type": "integer",
                    "description": "The new time zone for the virtual machine. This is a sysprep-dictated timezone code.\n"
                },
                "workgroup": {
                    "type": "string",
                    "description": "The workgroup for this virtual machine if not joining a domain.\n"
                }
            },
            "type": "object",
            "required": [
                "computerName"
            ]
        },
        "vsphere:index/HostPortGroupPort:HostPortGroupPort": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n"
                },
                "macAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The MAC addresses of the network service of the virtual machine connected on this port.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type type of the entity connected on this port. Possible values are host (VMKkernel), systemManagement (service console), virtualMachine, or unknown.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "macAddresses",
                        "type"
                    ]
                }
            }
        },
        "vsphere:index/HostService:HostService": {
            "properties": {
                "ntpd": {
                    "$ref": "#/types/vsphere:index/HostServiceNtpd:HostServiceNtpd",
                    "description": "service has three settings, `enabled` sets service to running or not running, `policy` sets service based on setting of `on` which sets service to \"Start and stop with host\", `off` which sets service to \"Start and stop manually\", `automatic` which sets service to \"Start and stop with port usage\".\n\n\u003e **NOTE:** `services` only supports ntpd service today.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/HostServiceNtpd:HostServiceNtpd": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the NTP service is enabled. Default is false.\n"
                },
                "ntpServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "policy": {
                    "type": "string",
                    "description": "The policy for the NTP service. Valid values are 'Start and stop with host', 'Start and stop manually', 'Start and stop with port usage'.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ntpServers"
                    ]
                }
            }
        },
        "vsphere:index/OfflineSoftwareDepotComponent:OfflineSoftwareDepotComponent": {
            "properties": {
                "displayName": {
                    "type": "string",
                    "description": "The name of the component. Useful for easier identification.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The identifier of the component.\n"
                },
                "versions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of available versions of the component.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "displayName",
                        "key",
                        "versions"
                    ]
                }
            }
        },
        "vsphere:index/SupervisorEgressCidr:SupervisorEgressCidr": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Network address.\n"
                },
                "prefix": {
                    "type": "integer",
                    "description": "Subnet prefix.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "prefix"
            ]
        },
        "vsphere:index/SupervisorIngressCidr:SupervisorIngressCidr": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Network address.\n"
                },
                "prefix": {
                    "type": "integer",
                    "description": "Subnet prefix.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "prefix"
            ]
        },
        "vsphere:index/SupervisorManagementNetwork:SupervisorManagementNetwork": {
            "properties": {
                "addressCount": {
                    "type": "integer",
                    "description": "Number of addresses to allocate. Starts from 'starting_address'\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway IP address.\n"
                },
                "network": {
                    "type": "string",
                    "description": "ID of the network. (e.g. a distributed port group).\n"
                },
                "startingAddress": {
                    "type": "string",
                    "description": "Starting address of the management network range.\n"
                },
                "subnetMask": {
                    "type": "string",
                    "description": "Subnet mask.\n"
                }
            },
            "type": "object",
            "required": [
                "addressCount",
                "gateway",
                "network",
                "startingAddress",
                "subnetMask"
            ]
        },
        "vsphere:index/SupervisorNamespace:SupervisorNamespace": {
            "properties": {
                "contentLibraries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of content libraries.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the namespace.\n"
                },
                "vmClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of virtual machine classes.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "vsphere:index/SupervisorPodCidr:SupervisorPodCidr": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Network address.\n"
                },
                "prefix": {
                    "type": "integer",
                    "description": "Subnet prefix.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "prefix"
            ]
        },
        "vsphere:index/SupervisorServiceCidr:SupervisorServiceCidr": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Network address.\n"
                },
                "prefix": {
                    "type": "integer",
                    "description": "Subnet prefix.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "prefix"
            ]
        },
        "vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom": {
            "properties": {
                "clientDevice": {
                    "type": "boolean",
                    "description": "Indicates whether the device should be mapped to a remote client device\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID the ISO is located on.\n"
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.\n"
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to the ISO file on the datastore.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceAddress",
                        "key"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineClone:VirtualMachineClone": {
            "properties": {
                "customizationSpec": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizationSpec:VirtualMachineCloneCustomizationSpec",
                    "description": "The customization specification for the virtual machine post-clone.\n"
                },
                "customize": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize",
                    "description": "The customization specification for the virtual machine post-clone.\n"
                },
                "linkedClone": {
                    "type": "boolean",
                    "description": "Whether or not to create a linked clone when cloning. When this option is used, the source VM must have a single snapshot associated with it.\n"
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Mapping of ovf networks to the networks to use in vSphere.\n"
                },
                "ovfStorageMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Mapping of ovf storage to the datastores to use in vSphere.\n"
                },
                "templateUuid": {
                    "type": "string",
                    "description": "The UUID of the source virtual machine or template.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout, in minutes, to wait for the virtual machine clone to complete.\n"
                }
            },
            "type": "object",
            "required": [
                "templateUuid"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomizationSpec:VirtualMachineCloneCustomizationSpec": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The UUID of the virtual machine.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for guest OS customization to complete before returning with an error. Setting this value to 0 or a negative value skips the waiter. Default: 10.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize": {
            "properties": {
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of DNS servers for a virtual network adapter with a static IP address.\n"
                },
                "dnsSuffixLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS search domains to add to the DNS configuration on the virtual machine.\n"
                },
                "ipv4Gateway": {
                    "type": "string",
                    "description": "The IPv4 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.\n"
                },
                "ipv6Gateway": {
                    "type": "string",
                    "description": "The IPv6 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.\n"
                },
                "linuxOptions": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions",
                    "description": "A list of configuration options specific to Linux virtual machines.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface"
                    },
                    "description": "A specification of network interface configuration options.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for guest OS customization to complete before returning with an error. Setting this value to 0 or a negative value skips the waiter. Default: 10.\n"
                },
                "windowsOptions": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions",
                    "description": "A list of configuration options specific to Windows virtual machines.\n"
                },
                "windowsSysprepText": {
                    "type": "string",
                    "description": "Use this option to specify a windows sysprep file directly.\n",
                    "secret": true
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "The domain name for this virtual machine.\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "The hostname for this virtual machine.\n"
                },
                "hwClockUtc": {
                    "type": "boolean",
                    "description": "Specifies whether or not the hardware clock should be in UTC or not.\n"
                },
                "scriptText": {
                    "type": "string",
                    "description": "The customization script to run before and or after guest customization\n",
                    "secret": true
                },
                "timeZone": {
                    "type": "string",
                    "description": "Customize the time zone on the VM. This should be a time zone-style entry, like America/Los_Angeles.\n"
                }
            },
            "type": "object",
            "required": [
                "domain",
                "hostName"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface": {
            "properties": {
                "dnsDomain": {
                    "type": "string",
                    "description": "A DNS search domain to add to the DNS configuration on the virtual machine.\n"
                },
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Network-interface specific DNS settings for Windows operating systems. Ignored on Linux.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "The IPv4 address assigned to this network adapter. If left blank, DHCP is used.\n"
                },
                "ipv4Netmask": {
                    "type": "integer",
                    "description": "The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is selected.\n"
                },
                "ipv6Address": {
                    "type": "string",
                    "description": "The IPv6 address assigned to this network adapter. If left blank, default auto-configuration is used.\n"
                },
                "ipv6Netmask": {
                    "type": "integer",
                    "description": "The IPv6 CIDR netmask for the supplied IP address. Ignored if auto-configuration is selected.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "The new administrator password for this virtual machine.\n",
                    "secret": true
                },
                "autoLogon": {
                    "type": "boolean",
                    "description": "Specifies whether or not the VM automatically logs on as Administrator.\n"
                },
                "autoLogonCount": {
                    "type": "integer",
                    "description": "Specifies how many times the VM should auto-logon the Administrator account when auto_logon is true.\n"
                },
                "computerName": {
                    "type": "string",
                    "description": "The host name for this virtual machine.\n"
                },
                "domainAdminPassword": {
                    "type": "string",
                    "description": "The password of the domain administrator used to join this virtual machine to the domain.\n",
                    "secret": true
                },
                "domainAdminUser": {
                    "type": "string",
                    "description": "The user account of the domain administrator used to join this virtual machine to the domain.\n"
                },
                "domainOu": {
                    "type": "string",
                    "description": "The MachineObjectOU which specifies the full LDAP path name of the OU to which the virtual machine belongs.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the user of this virtual machine.\n"
                },
                "joinDomain": {
                    "type": "string",
                    "description": "The domain that the virtual machine should join.\n"
                },
                "organizationName": {
                    "type": "string",
                    "description": "The organization name this virtual machine is being installed for.\n"
                },
                "productKey": {
                    "type": "string",
                    "description": "The product key for this virtual machine.\n",
                    "secret": true
                },
                "runOnceCommandLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of commands to run at first user logon, after guest customization.\n"
                },
                "timeZone": {
                    "type": "integer",
                    "description": "The new time zone for the virtual machine. This is a sysprep-dictated timezone code.\n"
                },
                "workgroup": {
                    "type": "string",
                    "description": "The workgroup for this virtual machine if not joining a domain.\n"
                }
            },
            "type": "object",
            "required": [
                "computerName"
            ]
        },
        "vsphere:index/VirtualMachineDisk:VirtualMachineDisk": {
            "properties": {
                "attach": {
                    "type": "boolean",
                    "description": "If this is true, the disk is attached instead of created. Implies keep_on_remove.\n"
                },
                "controllerType": {
                    "type": "string",
                    "description": "The type of controller the disk should be connected to. Must be 'scsi', 'sata', 'nvme', or 'ide'.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID for this virtual disk, if different than the virtual machine.\n"
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.\n"
                },
                "diskMode": {
                    "type": "string",
                    "description": "The mode of this this virtual disk for purposes of writes and snapshotting. Can be one of append, independent_nonpersistent, independent_persistent, nonpersistent, persistent, or undoable.\n"
                },
                "diskSharing": {
                    "type": "string",
                    "description": "The sharing mode of this virtual disk. Can be one of sharingMultiWriter or sharingNone.\n"
                },
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "The virtual disk file zeroing policy when thin_provision is not true. The default is false, which lazily-zeros the disk, speeding up thick-provisioned disk creation time.\n"
                },
                "ioLimit": {
                    "type": "integer",
                    "description": "The upper limit of IOPS that this disk can use.\n"
                },
                "ioReservation": {
                    "type": "integer",
                    "description": "The I/O guarantee that this disk has, in IOPS.\n"
                },
                "ioShareCount": {
                    "type": "integer",
                    "description": "The share count for this disk when the share level is custom.\n"
                },
                "ioShareLevel": {
                    "type": "string",
                    "description": "The share allocation level for this disk. Can be one of low, normal, high, or custom.\n"
                },
                "keepOnRemove": {
                    "type": "boolean",
                    "description": "Set to true to keep the underlying VMDK file when removing this virtual disk from configuration.\n"
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n"
                },
                "label": {
                    "type": "string",
                    "description": "A unique label for this disk.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full path of the virtual disk. This can only be provided if attach is set to true, otherwise it is a read-only value.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GB.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The ID of the storage policy to assign to the virtual disk in VM.\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "If true, this disk is thin provisioned, with space for the file being allocated on an as-needed basis.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The unique device number for this disk. This number determines where on the SCSI bus this device will be attached.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual machine. Also exposed as the `id` of the resource.\n"
                },
                "writeThrough": {
                    "type": "boolean",
                    "description": "If true, writes for this disk are sent directly to the filesystem immediately instead of being buffered.\n"
                }
            },
            "type": "object",
            "required": [
                "label"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "datastoreId",
                        "deviceAddress",
                        "key",
                        "label",
                        "path",
                        "storagePolicyId",
                        "uuid"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The controller type. Can be one of e1000, e1000e, sriov, vmxnet3, or vrdma.\n"
                },
                "bandwidthLimit": {
                    "type": "integer",
                    "description": "The upper bandwidth limit of this network interface, in Mbits/sec.\n"
                },
                "bandwidthReservation": {
                    "type": "integer",
                    "description": "The bandwidth reservation of this network interface, in Mbits/sec.\n"
                },
                "bandwidthShareCount": {
                    "type": "integer",
                    "description": "The share count for this network interface when the share level is custom.\n"
                },
                "bandwidthShareLevel": {
                    "type": "string",
                    "description": "The bandwidth share allocation level for this interface. Can be one of low, normal, high, or custom.\n"
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.\n"
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of this network interface. Can only be manually set if use_static_mac is true.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The ID of the network to connect this network interface to.\n"
                },
                "ovfMapping": {
                    "type": "string",
                    "description": "Mapping of network interface to OVF network.\n",
                    "willReplaceOnChanges": true
                },
                "physicalFunction": {
                    "type": "string",
                    "description": "The ID of the Physical SR-IOV NIC to attach to, e.g. '0000:d8:00.0'\n"
                },
                "useStaticMac": {
                    "type": "boolean",
                    "description": "If true, the mac_address field is treated as a static MAC address and set accordingly.\n"
                }
            },
            "type": "object",
            "required": [
                "networkId"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bandwidthShareCount",
                        "deviceAddress",
                        "key",
                        "macAddress",
                        "networkId"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy": {
            "properties": {
                "allowUnverifiedSslCert": {
                    "type": "boolean",
                    "description": "Allow unverified ssl certificates while deploying ovf/ova from url.\n"
                },
                "deploymentOption": {
                    "type": "string",
                    "description": "The Deployment option to be chosen. If empty, the default option is used.\n",
                    "willReplaceOnChanges": true
                },
                "diskProvisioning": {
                    "type": "string",
                    "description": "An optional disk provisioning. If set, all the disks in the deployed ovf will have the same specified disk type (e.g., thin provisioned).\n",
                    "willReplaceOnChanges": true
                },
                "enableHiddenProperties": {
                    "type": "boolean",
                    "description": "Allow properties with ovf:userConfigurable=false to be set.\n",
                    "willReplaceOnChanges": true
                },
                "ipAllocationPolicy": {
                    "type": "string",
                    "description": "The IP allocation policy.\n",
                    "willReplaceOnChanges": true
                },
                "ipProtocol": {
                    "type": "string",
                    "description": "The IP protocol.\n",
                    "willReplaceOnChanges": true
                },
                "localOvfPath": {
                    "type": "string",
                    "description": "The absolute path to the ovf/ova file in the local system.\n",
                    "willReplaceOnChanges": true
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The mapping of name of network identifiers from the ovf descriptor to network UUID in the VI infrastructure.\n",
                    "willReplaceOnChanges": true
                },
                "remoteOvfUrl": {
                    "type": "string",
                    "description": "URL to the remote ovf/ova file to be deployed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineVapp:VirtualMachineVapp": {
            "properties": {
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of customizable vApp properties and their values. Allows customization of VMs cloned from OVF templates which have customizable vApp properties.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineVtpm:VirtualMachineVtpm": {
            "properties": {
                "version": {
                    "type": "string",
                    "description": "The version of the TPM device. Default is 2.0.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule": {
            "properties": {
                "includeDatastoresWithTags": {
                    "type": "boolean",
                    "description": "Include datastores with the given tags or exclude. Default `true`.\n"
                },
                "tagCategory": {
                    "type": "string",
                    "description": "Name of the tag category.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Name of tags to select from the given category.\n"
                }
            },
            "type": "object",
            "required": [
                "tagCategory",
                "tags"
            ]
        },
        "vsphere:index/VnicIpv4:VnicIpv4": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n"
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP is not set.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "address of the interface, if DHCP is not set.\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "netmask of the interface, if DHCP is not set.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/VnicIpv6:VnicIpv6": {
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IPv6 addresses\n"
                },
                "autoconfig": {
                    "type": "boolean",
                    "description": "Use IPv6 Autoconfiguration (RFC2462).\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n"
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP or autoconfig is not set.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/getGuestOsCustomizationSpec:getGuestOsCustomizationSpec": {
            "properties": {
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS servers for a virtual network adapter with a static IP address.\n"
                },
                "dnsSuffixLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS search domains to add to the DNS configuration on the virtual machine.\n"
                },
                "linuxOptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/getGuestOsCustomizationSpecLinuxOption:getGuestOsCustomizationSpecLinuxOption"
                    },
                    "description": "A list of configuration options specific to Linux.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/getGuestOsCustomizationSpecNetworkInterface:getGuestOsCustomizationSpecNetworkInterface"
                    },
                    "description": "A specification of network interface configuration options.\n"
                },
                "windowsOptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/getGuestOsCustomizationSpecWindowsOption:getGuestOsCustomizationSpecWindowsOption"
                    },
                    "description": "A list of configuration options specific to Windows.\n"
                },
                "windowsSysprepText": {
                    "type": "string",
                    "description": "Use this option to specify use of a Windows Sysprep file.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "dnsServerLists",
                "dnsSuffixLists",
                "linuxOptions",
                "networkInterfaces",
                "windowsOptions",
                "windowsSysprepText"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getGuestOsCustomizationSpecLinuxOption:getGuestOsCustomizationSpecLinuxOption": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "The domain name for this virtual machine.\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "The hostname for this virtual machine.\n"
                },
                "hwClockUtc": {
                    "type": "boolean",
                    "description": "Specifies whether or not the hardware clock should be in UTC or not.\n"
                },
                "scriptText": {
                    "type": "string",
                    "description": "The customization script to run before and or after guest customization.\n",
                    "secret": true
                },
                "timeZone": {
                    "type": "string",
                    "description": "Set the time zone on the guest operating system. For a list of the acceptable values for Linux customization specifications, see [List of Time Zone Database Zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) on Wikipedia.\n"
                }
            },
            "type": "object",
            "required": [
                "domain",
                "hostName",
                "hwClockUtc",
                "scriptText",
                "timeZone"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getGuestOsCustomizationSpecNetworkInterface:getGuestOsCustomizationSpecNetworkInterface": {
            "properties": {
                "dnsDomain": {
                    "type": "string",
                    "description": "A DNS search domain to add to the DNS configuration on the virtual machine.\n"
                },
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Network-interface specific DNS settings for Windows operating systems. Ignored on Linux.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "The IPv4 address assigned to this network adapter. If left blank, DHCP is used.\n"
                },
                "ipv4Netmask": {
                    "type": "integer",
                    "description": "The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is selected.\n"
                },
                "ipv6Address": {
                    "type": "string",
                    "description": "The IPv6 address assigned to this network adapter. If left blank, default auto-configuration is used.\n"
                },
                "ipv6Netmask": {
                    "type": "integer",
                    "description": "The IPv6 CIDR netmask for the supplied IP address. Ignored if auto-configuration is selected.\n"
                }
            },
            "type": "object",
            "required": [
                "dnsDomain",
                "dnsServerLists",
                "ipv4Address",
                "ipv4Netmask",
                "ipv6Address",
                "ipv6Netmask"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getGuestOsCustomizationSpecWindowsOption:getGuestOsCustomizationSpecWindowsOption": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "The new administrator password for this virtual machine.\n",
                    "secret": true
                },
                "autoLogon": {
                    "type": "boolean",
                    "description": "Specifies whether or not the guest operating system automatically logs on as Administrator.\n"
                },
                "autoLogonCount": {
                    "type": "integer",
                    "description": "Specifies how many times the guest operating system should auto-logon the Administrator account when `auto_logon` is `true`.\n"
                },
                "computerName": {
                    "type": "string",
                    "description": "The hostname for this virtual machine.\n"
                },
                "domainAdminPassword": {
                    "type": "string",
                    "description": "The user account used to join this virtual machine to the Active Directory domain.\n",
                    "secret": true
                },
                "domainAdminUser": {
                    "type": "string",
                    "description": "The user account of the domain administrator used to join this virtual machine to the domain.\n"
                },
                "domainOu": {
                    "type": "string",
                    "description": "The MachineObjectOU which specifies the full LDAP path name of the OU to which the virtual machine belongs.\n"
                },
                "joinDomain": {
                    "type": "string",
                    "description": "The Active Directory domain for the virtual machine to join.\n"
                },
                "runOnceCommandLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of commands to run at first user logon, after guest customization.\n"
                },
                "timeZone": {
                    "type": "integer",
                    "description": "The new time zone for the virtual machine. This is a sysprep-dictated timezone code.\n"
                },
                "workgroup": {
                    "type": "string",
                    "description": "The workgroup for this virtual machine if not joining an Active Directory domain.\n"
                }
            },
            "type": "object",
            "required": [
                "adminPassword",
                "autoLogon",
                "autoLogonCount",
                "computerName",
                "domainAdminUser",
                "domainOu",
                "joinDomain",
                "runOnceCommandLists",
                "timeZone",
                "workgroup"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getHostVgpuProfileVgpuProfile:getHostVgpuProfileVgpuProfile": {
            "properties": {
                "diskSnapshotSupported": {
                    "type": "boolean",
                    "description": "Indicates whether the GPU plugin on this host is\ncapable of disk-only snapshots when VM is not powered off.\n"
                },
                "memorySnapshotSupported": {
                    "type": "boolean",
                    "description": "Indicates whether the GPU plugin on this host\nis capable of memory snapshots.\n"
                },
                "migrateSupported": {
                    "type": "boolean",
                    "description": "Indicates whether the GPU plugin on this host is\ncapable of migration.\n"
                },
                "suspendSupported": {
                    "type": "boolean",
                    "description": "Indicates whether the GPU plugin on this host is\ncapable of suspend-resume.\n"
                },
                "vgpu": {
                    "type": "string",
                    "description": "Name of a particular vGPU available as a shared GPU device (vGPU\nprofile).\n"
                }
            },
            "type": "object",
            "required": [
                "diskSnapshotSupported",
                "memorySnapshotSupported",
                "migrateSupported",
                "suspendSupported",
                "vgpu"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getNetworkFilter:getNetworkFilter": {
            "properties": {
                "networkType": {
                    "type": "string",
                    "description": "This is required if you have multiple port groups with the same name. This will be one of `DistributedVirtualPortgroup` for distributed port groups, `Network` for standard (host-based) port groups, or `OpaqueNetwork` for networks managed externally, such as those managed by NSX.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/getVirtualMachineDisk:getVirtualMachineDisk": {
            "properties": {
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been eager zeroed.\n"
                },
                "label": {
                    "type": "string",
                    "description": "The label for the disk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GIB.\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been thin provisioned.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The disk number on the storage bus.\n"
                }
            },
            "type": "object",
            "required": [
                "eagerlyScrub",
                "label",
                "size",
                "thinProvisioned",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getVirtualMachineNetworkInterface:getVirtualMachineNetworkInterface": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The network interface types for each network interface found\non the virtual machine, in device bus order. Will be one of `e1000`,\n`e1000e`, `vmxnet3vrdma`, or `vmxnet3`.\n"
                },
                "bandwidthLimit": {
                    "type": "integer",
                    "description": "The upper bandwidth limit of this network interface,\nin Mbits/sec.\n"
                },
                "bandwidthReservation": {
                    "type": "integer",
                    "description": "The bandwidth reservation of this network\ninterface, in Mbits/sec.\n"
                },
                "bandwidthShareCount": {
                    "type": "integer",
                    "description": "The share count for this network interface when the\nshare level is custom.\n"
                },
                "bandwidthShareLevel": {
                    "type": "string",
                    "description": "The bandwidth share allocation level for this\ninterface. Can be one of `low`, `normal`, `high`, or `custom`.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of this network interface.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The managed object reference ID of the network this interface\nis connected to.\n"
                },
                "physicalFunction": {
                    "type": "string",
                    "description": "The ID of the Physical SR-IOV NIC to attach to, e.g. '0000:d8:00.0'\n"
                }
            },
            "type": "object",
            "required": [
                "adapterType",
                "bandwidthShareCount",
                "macAddress",
                "networkId",
                "physicalFunction"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp": {
            "properties": {
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of customizable vApp properties and their values. Allows customization of VMs cloned from OVF templates which have customizable vApp properties.\n"
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the vsphere package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n"
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n"
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n"
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n"
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n"
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n"
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n"
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n"
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "inputProperties": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "methods": {
            "terraformConfig": "pulumi:providers:vsphere/terraformConfig"
        }
    },
    "resources": {
        "vsphere:index/computeCluster:ComputeCluster": {
            "description": "\u003e **A note on the naming of this resource:** VMware refers to clusters of\nhosts in the UI and documentation as _clusters_, _HA clusters_, or _DRS\nclusters_. All of these refer to the same kind of resource (with the latter two\nreferring to specific features of clustering). We use\n`vsphere.ComputeCluster` to differentiate host clusters from _datastore\nclusters_, which are clusters of datastores that can be used to distribute load\nand ensure fault tolerance via distribution of virtual machines. Datastore\nclusters can also be managed through the provider, via the\n`vsphere.DatastoreCluster` resource.\n\nThe `vsphere.ComputeCluster` resource can be used to create and manage\nclusters of hosts allowing for resource control of compute resources, load\nbalancing through DRS, and high availability through vSphere HA.\n\nFor more information on vSphere clusters and DRS, see [this\npage][ref-vsphere-drs-clusters]. For more information on vSphere HA, see [this\npage][ref-vsphere-ha-clusters].\n\n[ref-vsphere-drs-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-resource-management-8-0/creating-a-drs-cluster.html\n[ref-vsphere-ha-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-availability.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on\ndirect ESXi connections.\n\n## Import\n\nAn existing cluster can be imported into this resource via the\n\npath to the cluster, via the following command:\n\nhcl\n\nvariable \"datacenter\" {\n\n  default = \"dc-01\"\n\n}\n\ndata \"vsphere_datacenter\" \"datacenter\" {\n\n  name = var.datacenter\n\n}\n\nresource \"vsphere_compute_cluster\" \"compute_cluster\" {\n\n  name            = \"cluster-01\"\n\n  datacenter_id   = data.vsphere_datacenter.datacenter.id\n\n}\n\nhcl\n\nresource \"vsphere_compute_cluster\" \"compute_cluster\" {\n\n  name                      = \"cluster-01\"\n\n  datacenter_id             = data.vsphere_datacenter.datacenter.id\n\n  vsan_enabled              = true\n\n  vsan_performance_enabled  = true\n\n  host_system_ids           = [for host in data.vsphere_host.host : host.id]\n\n  dpm_automation_level      = \"automated\"\n\n  drs_automation_level      = \"fullyAutomated\"\n\n  drs_enabled               = true\n\n  ha_datastore_apd_response = \"restartConservative\"\n\n  ha_datastore_pdl_response = \"restartAggressive\"\n\n  ... etc.\n\nconsole\n\n```sh\n$ pulumi import vsphere:index/computeCluster:ComputeCluster compute_cluster /dc-01/host/cluster-01\n```\n\nThe above would import the cluster named `cluster-01` that is located in\n\nthe `dc-01` datacenter.\n\n",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power operations in this cluster. Can be one of manual or automated.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual\nmachines in the cluster. Requires that DRS be enabled.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This\naffects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher\nsetting.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or\nfullyAutomated.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "When true, allows individual VM overrides within this cluster to be set.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate\nmore imbalance while a higher setting will tolerate less.\n"
                },
                "drsScaleDescendantsShares": {
                    "type": "string",
                    "description": "Enable scalable shares for all descendants of this cluster.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists\nfor testing and is not recommended in normal use.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated\nfailover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS\nwill ignore the host when making recommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual\nmachine operations. The maximum is one less than the number of hosts in the cluster.\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces\nwarnings only, whereas a value of 100 disables the setting.\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are\npermitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,\nslotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service\nissues.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by\nsubtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting\nfrom the total amount of resources in the cluster. Disable to supply user-defined values.\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in\nthe cluster to reserve for failover.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in\nthe cluster to reserve for failover.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values\nto CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines\ncurrently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an\naffected datastore clears in the middle of an APD event. Can be one of none or reset.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or\nrestartAggressive.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute\nthe response action defined in ha_datastore_apd_response.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when\nha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or\nallFeasibleDsWithUserPreference.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.\nCan be one of none, powerOff, or shutdown.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to\nfailures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move\non to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as\nfailed. The value is in seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay in seconds after ready condition is met. A VM is considered ready at this point.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,\nhigh, or highest.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before\nproceeding with the next priority.\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout for each host maintenance mode operation when removing hosts from a cluster.\n"
                },
                "hostImage": {
                    "$ref": "#/types/vsphere:index/ComputeClusterHostImage:ComputeClusterHostImage",
                    "description": "Details about the host image which should be applied to the cluster.\n"
                },
                "hostManaged": {
                    "type": "boolean",
                    "description": "Must be set if cluster enrollment is managed from host resource.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that\nthis cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update providers configured for this cluster.\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this\ncannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID of the primary\nresource pool for this cluster. This can be passed directly to the\n`resource_pool_id`\nattribute of the\n`vsphere.VirtualMachine` resource.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "vsanCompressionEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN compression service is enabled for the cluster.\n"
                },
                "vsanDedupEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN deduplication service is enabled for the cluster.\n"
                },
                "vsanDiskGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                    },
                    "description": "A list of disk UUIDs to add to the vSAN cluster.\n"
                },
                "vsanDitEncryptionEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN data-in-transit encryption is enabled for the cluster.\n"
                },
                "vsanDitRekeyInterval": {
                    "type": "integer",
                    "description": "When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).\n"
                },
                "vsanEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN service is enabled for the cluster.\n"
                },
                "vsanEsaEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN ESA service is enabled for the cluster.\n"
                },
                "vsanFaultDomains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanFaultDomain:ComputeClusterVsanFaultDomain"
                    },
                    "description": "The configuration for vSAN fault domains.\n"
                },
                "vsanNetworkDiagnosticModeEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN network diagnostic mode is enabled for the cluster.\n"
                },
                "vsanPerformanceEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN performance service is enabled for the cluster.\n"
                },
                "vsanRemoteDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the vSAN datastore to be mounted on the cluster.\n"
                },
                "vsanStretchedCluster": {
                    "$ref": "#/types/vsphere:index/ComputeClusterVsanStretchedCluster:ComputeClusterVsanStretchedCluster",
                    "description": "The configuration for stretched cluster.\n"
                },
                "vsanUnmapEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN unmap service is enabled for the cluster.\n"
                },
                "vsanVerboseModeEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN verbose mode is enabled for the cluster.\n"
                }
            },
            "required": [
                "datacenterId",
                "name",
                "resourcePoolId",
                "vsanDiskGroups",
                "vsanDitRekeyInterval"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power operations in this cluster. Can be one of manual or automated.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual\nmachines in the cluster. Requires that DRS be enabled.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This\naffects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher\nsetting.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or\nfullyAutomated.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "When true, allows individual VM overrides within this cluster to be set.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate\nmore imbalance while a higher setting will tolerate less.\n"
                },
                "drsScaleDescendantsShares": {
                    "type": "string",
                    "description": "Enable scalable shares for all descendants of this cluster.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists\nfor testing and is not recommended in normal use.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated\nfailover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS\nwill ignore the host when making recommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual\nmachine operations. The maximum is one less than the number of hosts in the cluster.\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces\nwarnings only, whereas a value of 100 disables the setting.\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are\npermitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,\nslotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service\nissues.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by\nsubtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting\nfrom the total amount of resources in the cluster. Disable to supply user-defined values.\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in\nthe cluster to reserve for failover.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in\nthe cluster to reserve for failover.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values\nto CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines\ncurrently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an\naffected datastore clears in the middle of an APD event. Can be one of none or reset.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or\nrestartAggressive.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute\nthe response action defined in ha_datastore_apd_response.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when\nha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or\nallFeasibleDsWithUserPreference.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.\nCan be one of none, powerOff, or shutdown.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to\nfailures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move\non to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as\nfailed. The value is in seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay in seconds after ready condition is met. A VM is considered ready at this point.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,\nhigh, or highest.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before\nproceeding with the next priority.\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout for each host maintenance mode operation when removing hosts from a cluster.\n"
                },
                "hostImage": {
                    "$ref": "#/types/vsphere:index/ComputeClusterHostImage:ComputeClusterHostImage",
                    "description": "Details about the host image which should be applied to the cluster.\n"
                },
                "hostManaged": {
                    "type": "boolean",
                    "description": "Must be set if cluster enrollment is managed from host resource.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that\nthis cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update providers configured for this cluster.\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this\ncannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "vsanCompressionEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN compression service is enabled for the cluster.\n"
                },
                "vsanDedupEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN deduplication service is enabled for the cluster.\n"
                },
                "vsanDiskGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                    },
                    "description": "A list of disk UUIDs to add to the vSAN cluster.\n"
                },
                "vsanDitEncryptionEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN data-in-transit encryption is enabled for the cluster.\n"
                },
                "vsanDitRekeyInterval": {
                    "type": "integer",
                    "description": "When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).\n"
                },
                "vsanEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN service is enabled for the cluster.\n"
                },
                "vsanEsaEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN ESA service is enabled for the cluster.\n"
                },
                "vsanFaultDomains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanFaultDomain:ComputeClusterVsanFaultDomain"
                    },
                    "description": "The configuration for vSAN fault domains.\n"
                },
                "vsanNetworkDiagnosticModeEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN network diagnostic mode is enabled for the cluster.\n"
                },
                "vsanPerformanceEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN performance service is enabled for the cluster.\n"
                },
                "vsanRemoteDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the vSAN datastore to be mounted on the cluster.\n"
                },
                "vsanStretchedCluster": {
                    "$ref": "#/types/vsphere:index/ComputeClusterVsanStretchedCluster:ComputeClusterVsanStretchedCluster",
                    "description": "The configuration for stretched cluster.\n"
                },
                "vsanUnmapEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN unmap service is enabled for the cluster.\n"
                },
                "vsanVerboseModeEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN verbose mode is enabled for the cluster.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter Server.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power operations in this cluster. Can be one of manual or automated.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual\nmachines in the cluster. Requires that DRS be enabled.\n"
                    },
                    "dpmThreshold": {
                        "type": "integer",
                        "description": "A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This\naffects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher\nsetting.\n"
                    },
                    "drsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Advanced configuration options for DRS and DPM.\n"
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or\nfullyAutomated.\n"
                    },
                    "drsEnablePredictiveDrs": {
                        "type": "boolean",
                        "description": "When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.\n"
                    },
                    "drsEnableVmOverrides": {
                        "type": "boolean",
                        "description": "When true, allows individual VM overrides within this cluster to be set.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Enable DRS for this cluster.\n"
                    },
                    "drsMigrationThreshold": {
                        "type": "integer",
                        "description": "A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate\nmore imbalance while a higher setting will tolerate less.\n"
                    },
                    "drsScaleDescendantsShares": {
                        "type": "string",
                        "description": "Enable scalable shares for all descendants of this cluster.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                    },
                    "forceEvacuateOnDestroy": {
                        "type": "boolean",
                        "description": "Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists\nfor testing and is not recommended in normal use.\n"
                    },
                    "haAdmissionControlFailoverHostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated\nfailover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS\nwill ignore the host when making recommendations.\n"
                    },
                    "haAdmissionControlHostFailureTolerance": {
                        "type": "integer",
                        "description": "The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual\nmachine operations. The maximum is one less than the number of hosts in the cluster.\n"
                    },
                    "haAdmissionControlPerformanceTolerance": {
                        "type": "integer",
                        "description": "The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces\nwarnings only, whereas a value of 100 disables the setting.\n"
                    },
                    "haAdmissionControlPolicy": {
                        "type": "string",
                        "description": "The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are\npermitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,\nslotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service\nissues.\n"
                    },
                    "haAdmissionControlResourcePercentageAutoCompute": {
                        "type": "boolean",
                        "description": "When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by\nsubtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting\nfrom the total amount of resources in the cluster. Disable to supply user-defined values.\n"
                    },
                    "haAdmissionControlResourcePercentageCpu": {
                        "type": "integer",
                        "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in\nthe cluster to reserve for failover.\n"
                    },
                    "haAdmissionControlResourcePercentageMemory": {
                        "type": "integer",
                        "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in\nthe cluster to reserve for failover.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitCpu": {
                        "type": "integer",
                        "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitMemory": {
                        "type": "integer",
                        "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.\n"
                    },
                    "haAdmissionControlSlotPolicyUseExplicitSize": {
                        "type": "boolean",
                        "description": "When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values\nto CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines\ncurrently in the cluster.\n"
                    },
                    "haAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Advanced configuration options for vSphere HA.\n"
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an\naffected datastore clears in the middle of an APD event. Can be one of none or reset.\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or\nrestartAggressive.\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute\nthe response action defined in ha_datastore_apd_response.\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.\n"
                    },
                    "haEnabled": {
                        "type": "boolean",
                        "description": "Enable vSphere HA for this cluster.\n"
                    },
                    "haHeartbeatDatastoreIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when\nha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.\n"
                    },
                    "haHeartbeatDatastorePolicy": {
                        "type": "string",
                        "description": "The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or\nallFeasibleDsWithUserPreference.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.\nCan be one of none, powerOff, or shutdown.\n"
                    },
                    "haHostMonitoring": {
                        "type": "string",
                        "description": "Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.\n"
                    },
                    "haVmComponentProtection": {
                        "type": "string",
                        "description": "Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to\nfailures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.\n"
                    },
                    "haVmDependencyRestartCondition": {
                        "type": "string",
                        "description": "The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move\non to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as\nfailed. The value is in seconds.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                    },
                    "haVmRestartAdditionalDelay": {
                        "type": "integer",
                        "description": "Additional delay in seconds after ready condition is met. A VM is considered ready at this point.\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,\nhigh, or highest.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before\nproceeding with the next priority.\n"
                    },
                    "hostClusterExitTimeout": {
                        "type": "integer",
                        "description": "The timeout for each host maintenance mode operation when removing hosts from a cluster.\n"
                    },
                    "hostImage": {
                        "$ref": "#/types/vsphere:index/ComputeClusterHostImage:ComputeClusterHostImage",
                        "description": "Details about the host image which should be applied to the cluster.\n"
                    },
                    "hostManaged": {
                        "type": "boolean",
                        "description": "Must be set if cluster enrollment is managed from host resource.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of the hosts to put in the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the cluster.\n"
                    },
                    "proactiveHaAutomationLevel": {
                        "type": "string",
                        "description": "The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.\n"
                    },
                    "proactiveHaEnabled": {
                        "type": "boolean",
                        "description": "Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.\n"
                    },
                    "proactiveHaModerateRemediation": {
                        "type": "string",
                        "description": "The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that\nthis cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.\n"
                    },
                    "proactiveHaProviderIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of IDs for health update providers configured for this cluster.\n"
                    },
                    "proactiveHaSevereRemediation": {
                        "type": "string",
                        "description": "The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this\ncannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.\n"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID of the primary\nresource pool for this cluster. This can be passed directly to the\n`resource_pool_id`\nattribute of the\n`vsphere.VirtualMachine` resource.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "vsanCompressionEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN compression service is enabled for the cluster.\n"
                    },
                    "vsanDedupEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN deduplication service is enabled for the cluster.\n"
                    },
                    "vsanDiskGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                        },
                        "description": "A list of disk UUIDs to add to the vSAN cluster.\n"
                    },
                    "vsanDitEncryptionEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN data-in-transit encryption is enabled for the cluster.\n"
                    },
                    "vsanDitRekeyInterval": {
                        "type": "integer",
                        "description": "When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).\n"
                    },
                    "vsanEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN service is enabled for the cluster.\n"
                    },
                    "vsanEsaEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN ESA service is enabled for the cluster.\n"
                    },
                    "vsanFaultDomains": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/ComputeClusterVsanFaultDomain:ComputeClusterVsanFaultDomain"
                        },
                        "description": "The configuration for vSAN fault domains.\n"
                    },
                    "vsanNetworkDiagnosticModeEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN network diagnostic mode is enabled for the cluster.\n"
                    },
                    "vsanPerformanceEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN performance service is enabled for the cluster.\n"
                    },
                    "vsanRemoteDatastoreIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of the vSAN datastore to be mounted on the cluster.\n"
                    },
                    "vsanStretchedCluster": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanStretchedCluster:ComputeClusterVsanStretchedCluster",
                        "description": "The configuration for stretched cluster.\n"
                    },
                    "vsanUnmapEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN unmap service is enabled for the cluster.\n"
                    },
                    "vsanVerboseModeEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN verbose mode is enabled for the cluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterHostGroup:ComputeClusterHostGroup": {
            "description": "The `vsphere.ComputeClusterHostGroup` resource can be used to manage groups\nof hosts in a cluster, either created by the\n`vsphere.ComputeCluster` resource or looked up\nby the `vsphere.ComputeCluster` data source.\n\n\nThis resource mainly serves as an input to the\n`vsphere.ComputeClusterVmHostRule`\nresource - see the documentation for that resource for further details on how\nto use host groups.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n## Import\n\nAn existing group can be imported into this resource by\n\nsupplying both the path to the cluster, and the name of the host group. If the\n\nname or cluster is not found, or if the group is of a different type, an error\n\nwill be returned. An example is below:\n\n```sh\n$ pulumi import vsphere:index/computeClusterHostGroup:ComputeClusterHostGroup cluster_host_group \\\n```\n\n  '{\"compute_cluster_path\": \"/dc1/host/cluster1\", \\\n\n  \"name\": \"pulumi-test-cluster-host-group\"}'\n\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterVmGroup`\nresource. Make sure your names are unique across both resources.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterVmGroup`\nresource. Make sure your names are unique across both resources.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterHostGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to put in the cluster.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterVmGroup`\nresource. Make sure your names are unique across both resources.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAffinityRule:ComputeClusterVmAffinityRule": {
            "description": "The `vsphere.ComputeClusterVmAffinityRule` resource can be used to\nmanage virtual machine affinity rules in a cluster, either created by the\n`vsphere.ComputeCluster` resource or looked up\nby the `vsphere.ComputeCluster` data source.\n\nThis rule can be used to tell a set of virtual machines to run together on the\nsame host within a cluster. When configured, DRS will make a best effort to\nensure that the virtual machines run on the same host, or prevent any operation\nthat would keep that from happening, depending on the value of the\n`mandatory` flag.\n\n\u003e An affinity rule can only be used to place virtual machines on the same\n_non-specific_ hosts. It cannot be used to pin virtual machines to a host.\nTo enable this capability, use the\n`vsphere.ComputeClusterVmHostRule`\nresource.\n\n\u003e **NOTE:** This resource requires vCenter Server and is not available on\ndirect ESXi host connections.\n\n## Example Usage\n\nThe following example creates two virtual machines in a cluster using the\n`vsphere.VirtualMachine` resource, creating the\nvirtual machines in the cluster looked up by the\n`vsphere.ComputeCluster` data source. It\nthen creates an affinity rule for these two virtual machines, ensuring they\nwill run on the same host whenever possible.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore-01\",\n    datacenterId: datacenter.id,\n}));\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"VM Network\",\n    datacenterId: datacenter.id,\n}));\nconst vm: vsphere.VirtualMachine[] = [];\nfor (const range = {value: 0}; range.value \u003c 2; range.value++) {\n    vm.push(new vsphere.VirtualMachine(`vm-${range.value}`, {\n        name: `foo-${range.value}`,\n        resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n        datastoreId: datastore.then(datastore =\u003e datastore.id),\n        numCpus: 1,\n        memory: 1024,\n        guestId: \"otherLinux64Guest\",\n        networkInterfaces: [{\n            networkId: network.then(network =\u003e network.id),\n        }],\n        disks: [{\n            label: \"disk0\",\n            size: 20,\n        }],\n    }));\n}\nconst vmAffinityRule = new vsphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\", {\n    name: \"vm-affinity-rule\",\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: vm.map((v, k) =\u003e [k, v]).map(([k, v]) =\u003e (v.id)),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore-01\",\n    datacenter_id=datacenter.id)\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"VM Network\",\n    datacenter_id=datacenter.id)\nvm = []\nfor range in [{\"value\": i} for i in range(0, 2)]:\n    vm.append(vsphere.VirtualMachine(f\"vm-{range['value']}\",\n        name=f\"foo-{range['value']}\",\n        resource_pool_id=cluster.resource_pool_id,\n        datastore_id=datastore.id,\n        num_cpus=1,\n        memory=1024,\n        guest_id=\"otherLinux64Guest\",\n        network_interfaces=[{\n            \"network_id\": network.id,\n        }],\n        disks=[{\n            \"label\": \"disk0\",\n            \"size\": 20,\n        }]))\nvm_affinity_rule = vsphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\",\n    name=\"vm-affinity-rule\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[v.id for k, v in vm])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"VM Network\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vm = new List\u003cVSphere.VirtualMachine\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c 2; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        vm.Add(new VSphere.VirtualMachine($\"vm-{range.Value}\", new()\n        {\n            Name = $\"foo-{range.Value}\",\n            ResourcePoolId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n            DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n            NumCpus = 1,\n            Memory = 1024,\n            GuestId = \"otherLinux64Guest\",\n            NetworkInterfaces = new[]\n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n                },\n            },\n            Disks = new[]\n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n        }));\n    }\n    var vmAffinityRule = new VSphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\", new()\n    {\n        Name = \"vm-affinity-rule\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        VirtualMachineIds = vm.Select((value, i) =\u003e new { Key = i.ToString(), Value = pair.Value }).Select(v =\u003e \n        {\n            return v.Id;\n        }).ToList(),\n    });\n\n});\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nThe following example creates an affinity rule for a set of virtual machines\nin the cluster by looking up the virtual machine UUIDs from the\n`vsphere.VirtualMachine` data source.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vms = [\n    \"foo-0\",\n    \"foo-1\",\n];\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst vmsGetVirtualMachine = (new Array(vms.length)).map((_, i) =\u003e i).map(__index =\u003e (vsphere.getVirtualMachine({\n    name: vms[__index],\n    datacenterId: _arg0_.id,\n})));\nconst vmAffinityRule = new vsphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\", {\n    name: \"vm-affinity-rule\",\n    enabled: true,\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: vmsGetVirtualMachine.map(__item =\u003e __item.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvms = [\n    \"foo-0\",\n    \"foo-1\",\n]\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nvms_get_virtual_machine = [vsphere.get_virtual_machine(name=vms[__index],\n    datacenter_id=datacenter.id) for __index in range(len(vms))]\nvm_affinity_rule = vsphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\",\n    name=\"vm-affinity-rule\",\n    enabled=True,\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[__item.id for __item in vms_get_virtual_machine])\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing rule can be imported into this resource by supplying\n\nboth the path to the cluster, and the name the rule. If the name or cluster is\n\nnot found, or if the rule is of a different type, an error will be returned. An\n\nexample is below:\n\n```sh\n$ pulumi import vsphere:index/computeClusterVmAffinityRule:ComputeClusterVmAffinityRule vm_affinity_rule \\\n```\n\n  '{\"compute_cluster_path\": \"/dc-01/host/cluster-01\", \\\n\n  \"name\": \"vm-affinity-rule\"}'\n\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAntiAffinityRule:ComputeClusterVmAntiAffinityRule": {
            "description": "\n\n## Import\n\nAn existing rule can be imported into this resource by supplying\n\nboth the path to the cluster, and the name the rule. If the name or cluster is\n\nnot found, or if the rule is of a different type, an error will be returned. An\n\nexample is below:\n\n```sh\n$ pulumi import vsphere:index/computeClusterVmAntiAffinityRule:ComputeClusterVmAntiAffinityRule vm_anti_affinity_rule \\\n```\n\n  '{\"compute_cluster_path\": \"/dc-01/host/cluster-01\", \\\n\n  \"name\": \"vm-anti-affinity-rule\"}'\n\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmDependencyRule:ComputeClusterVmDependencyRule": {
            "description": "The `vsphere.ComputeClusterVmDependencyRule` resource can be used to manage\nVM dependency rules in a cluster, either created by the\n`vsphere.ComputeCluster` resource or looked up\nby the `vsphere.ComputeCluster` data source.\n\nA virtual machine dependency rule applies to vSphere HA, and allows\nuser-defined startup orders for virtual machines in the case of host failure.\nVirtual machines are supplied via groups, which can be managed via the\n`vsphere.ComputeClusterVmGroup`\nresource.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n## Example Usage\n\nThe example below creates two virtual machine in a cluster using the\n`vsphere.VirtualMachine` resource in a cluster\nlooked up by the `vsphere.ComputeCluster`\ndata source. It then creates a group with this virtual machine. Two groups are created, each with one of the created VMs. Finally, a rule is created to ensure that `vm1` starts before `vm2`.\n\n\u003e Note how `dependency_vm_group_name` and\n`vm_group_name` are sourced off of the `name` attributes from\nthe `vsphere.ComputeClusterVmGroup`\nresource. This is to ensure that the rule is not created before the groups\nexist, which may not possibly happen in the event that the names came from a\n\"static\" source such as a variable.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore1\",\n    datacenterId: datacenter.id,\n}));\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"network1\",\n    datacenterId: datacenter.id,\n}));\nconst vm1 = new vsphere.VirtualMachine(\"vm1\", {\n    name: \"test1\",\n    resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n    datastoreId: datastore.then(datastore =\u003e datastore.id),\n    numCpus: 2,\n    memory: 2048,\n    guestId: \"otherLinux64Guest\",\n    networkInterfaces: [{\n        networkId: network.then(network =\u003e network.id),\n    }],\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n});\nconst vm2 = new vsphere.VirtualMachine(\"vm2\", {\n    name: \"test2\",\n    resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n    datastoreId: datastore.then(datastore =\u003e datastore.id),\n    numCpus: 2,\n    memory: 2048,\n    guestId: \"otherLinux64Guest\",\n    networkInterfaces: [{\n        networkId: network.then(network =\u003e network.id),\n    }],\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n});\nconst clusterVmGroup1 = new vsphere.ComputeClusterVmGroup(\"cluster_vm_group1\", {\n    name: \"test-cluster-vm-group1\",\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: [vm1.id],\n});\nconst clusterVmGroup2 = new vsphere.ComputeClusterVmGroup(\"cluster_vm_group2\", {\n    name: \"test-cluster-vm-group2\",\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: [vm2.id],\n});\nconst clusterVmDependencyRule = new vsphere.ComputeClusterVmDependencyRule(\"cluster_vm_dependency_rule\", {\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    name: \"test-cluster-vm-dependency-rule\",\n    dependencyVmGroupName: clusterVmGroup1.name,\n    vmGroupName: clusterVmGroup2.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore1\",\n    datacenter_id=datacenter.id)\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"network1\",\n    datacenter_id=datacenter.id)\nvm1 = vsphere.VirtualMachine(\"vm1\",\n    name=\"test1\",\n    resource_pool_id=cluster.resource_pool_id,\n    datastore_id=datastore.id,\n    num_cpus=2,\n    memory=2048,\n    guest_id=\"otherLinux64Guest\",\n    network_interfaces=[{\n        \"network_id\": network.id,\n    }],\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }])\nvm2 = vsphere.VirtualMachine(\"vm2\",\n    name=\"test2\",\n    resource_pool_id=cluster.resource_pool_id,\n    datastore_id=datastore.id,\n    num_cpus=2,\n    memory=2048,\n    guest_id=\"otherLinux64Guest\",\n    network_interfaces=[{\n        \"network_id\": network.id,\n    }],\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }])\ncluster_vm_group1 = vsphere.ComputeClusterVmGroup(\"cluster_vm_group1\",\n    name=\"test-cluster-vm-group1\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[vm1.id])\ncluster_vm_group2 = vsphere.ComputeClusterVmGroup(\"cluster_vm_group2\",\n    name=\"test-cluster-vm-group2\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[vm2.id])\ncluster_vm_dependency_rule = vsphere.ComputeClusterVmDependencyRule(\"cluster_vm_dependency_rule\",\n    compute_cluster_id=cluster.id,\n    name=\"test-cluster-vm-dependency-rule\",\n    dependency_vm_group_name=cluster_vm_group1.name,\n    vm_group_name=cluster_vm_group2.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"network1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vm1 = new VSphere.VirtualMachine(\"vm1\", new()\n    {\n        Name = \"test1\",\n        ResourcePoolId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n        DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        NumCpus = 2,\n        Memory = 2048,\n        GuestId = \"otherLinux64Guest\",\n        NetworkInterfaces = new[]\n        {\n            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n            {\n                NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n            },\n        },\n        Disks = new[]\n        {\n            new VSphere.Inputs.VirtualMachineDiskArgs\n            {\n                Label = \"disk0\",\n                Size = 20,\n            },\n        },\n    });\n\n    var vm2 = new VSphere.VirtualMachine(\"vm2\", new()\n    {\n        Name = \"test2\",\n        ResourcePoolId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n        DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        NumCpus = 2,\n        Memory = 2048,\n        GuestId = \"otherLinux64Guest\",\n        NetworkInterfaces = new[]\n        {\n            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n            {\n                NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n            },\n        },\n        Disks = new[]\n        {\n            new VSphere.Inputs.VirtualMachineDiskArgs\n            {\n                Label = \"disk0\",\n                Size = 20,\n            },\n        },\n    });\n\n    var clusterVmGroup1 = new VSphere.ComputeClusterVmGroup(\"cluster_vm_group1\", new()\n    {\n        Name = \"test-cluster-vm-group1\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        VirtualMachineIds = new[]\n        {\n            vm1.Id,\n        },\n    });\n\n    var clusterVmGroup2 = new VSphere.ComputeClusterVmGroup(\"cluster_vm_group2\", new()\n    {\n        Name = \"test-cluster-vm-group2\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        VirtualMachineIds = new[]\n        {\n            vm2.Id,\n        },\n    });\n\n    var clusterVmDependencyRule = new VSphere.ComputeClusterVmDependencyRule(\"cluster_vm_dependency_rule\", new()\n    {\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        Name = \"test-cluster-vm-dependency-rule\",\n        DependencyVmGroupName = clusterVmGroup1.Name,\n        VmGroupName = clusterVmGroup2.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnetwork, err := vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"network1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvm1, err := vsphere.NewVirtualMachine(ctx, \"vm1\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tName:           pulumi.String(\"test1\"),\n\t\t\tResourcePoolId: pulumi.String(cluster.ResourcePoolId),\n\t\t\tDatastoreId:    pulumi.String(datastore.Id),\n\t\t\tNumCpus:        pulumi.Int(2),\n\t\t\tMemory:         pulumi.Int(2048),\n\t\t\tGuestId:        pulumi.String(\"otherLinux64Guest\"),\n\t\t\tNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\t\t\t\t\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\n\t\t\t\t\tNetworkId: pulumi.String(network.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDisks: vsphere.VirtualMachineDiskArray{\n\t\t\t\t\u0026vsphere.VirtualMachineDiskArgs{\n\t\t\t\t\tLabel: pulumi.String(\"disk0\"),\n\t\t\t\t\tSize:  pulumi.Int(20),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvm2, err := vsphere.NewVirtualMachine(ctx, \"vm2\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tName:           pulumi.String(\"test2\"),\n\t\t\tResourcePoolId: pulumi.String(cluster.ResourcePoolId),\n\t\t\tDatastoreId:    pulumi.String(datastore.Id),\n\t\t\tNumCpus:        pulumi.Int(2),\n\t\t\tMemory:         pulumi.Int(2048),\n\t\t\tGuestId:        pulumi.String(\"otherLinux64Guest\"),\n\t\t\tNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\t\t\t\t\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\n\t\t\t\t\tNetworkId: pulumi.String(network.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDisks: vsphere.VirtualMachineDiskArray{\n\t\t\t\t\u0026vsphere.VirtualMachineDiskArgs{\n\t\t\t\t\tLabel: pulumi.String(\"disk0\"),\n\t\t\t\t\tSize:  pulumi.Int(20),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclusterVmGroup1, err := vsphere.NewComputeClusterVmGroup(ctx, \"cluster_vm_group1\", \u0026vsphere.ComputeClusterVmGroupArgs{\n\t\t\tName:             pulumi.String(\"test-cluster-vm-group1\"),\n\t\t\tComputeClusterId: pulumi.String(cluster.Id),\n\t\t\tVirtualMachineIds: pulumi.StringArray{\n\t\t\t\tvm1.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclusterVmGroup2, err := vsphere.NewComputeClusterVmGroup(ctx, \"cluster_vm_group2\", \u0026vsphere.ComputeClusterVmGroupArgs{\n\t\t\tName:             pulumi.String(\"test-cluster-vm-group2\"),\n\t\t\tComputeClusterId: pulumi.String(cluster.Id),\n\t\t\tVirtualMachineIds: pulumi.StringArray{\n\t\t\t\tvm2.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewComputeClusterVmDependencyRule(ctx, \"cluster_vm_dependency_rule\", \u0026vsphere.ComputeClusterVmDependencyRuleArgs{\n\t\t\tComputeClusterId:      pulumi.String(cluster.Id),\n\t\t\tName:                  pulumi.String(\"test-cluster-vm-dependency-rule\"),\n\t\t\tDependencyVmGroupName: clusterVmGroup1.Name,\n\t\t\tVmGroupName:           clusterVmGroup2.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;\nimport com.pulumi.vsphere.ComputeClusterVmGroup;\nimport com.pulumi.vsphere.ComputeClusterVmGroupArgs;\nimport com.pulumi.vsphere.ComputeClusterVmDependencyRule;\nimport com.pulumi.vsphere.ComputeClusterVmDependencyRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"network1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var vm1 = new VirtualMachine(\"vm1\", VirtualMachineArgs.builder()\n            .name(\"test1\")\n            .resourcePoolId(cluster.resourcePoolId())\n            .datastoreId(datastore.id())\n            .numCpus(2)\n            .memory(2048)\n            .guestId(\"otherLinux64Guest\")\n            .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                .networkId(network.id())\n                .build())\n            .disks(VirtualMachineDiskArgs.builder()\n                .label(\"disk0\")\n                .size(20)\n                .build())\n            .build());\n\n        var vm2 = new VirtualMachine(\"vm2\", VirtualMachineArgs.builder()\n            .name(\"test2\")\n            .resourcePoolId(cluster.resourcePoolId())\n            .datastoreId(datastore.id())\n            .numCpus(2)\n            .memory(2048)\n            .guestId(\"otherLinux64Guest\")\n            .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                .networkId(network.id())\n                .build())\n            .disks(VirtualMachineDiskArgs.builder()\n                .label(\"disk0\")\n                .size(20)\n                .build())\n            .build());\n\n        var clusterVmGroup1 = new ComputeClusterVmGroup(\"clusterVmGroup1\", ComputeClusterVmGroupArgs.builder()\n            .name(\"test-cluster-vm-group1\")\n            .computeClusterId(cluster.id())\n            .virtualMachineIds(vm1.id())\n            .build());\n\n        var clusterVmGroup2 = new ComputeClusterVmGroup(\"clusterVmGroup2\", ComputeClusterVmGroupArgs.builder()\n            .name(\"test-cluster-vm-group2\")\n            .computeClusterId(cluster.id())\n            .virtualMachineIds(vm2.id())\n            .build());\n\n        var clusterVmDependencyRule = new ComputeClusterVmDependencyRule(\"clusterVmDependencyRule\", ComputeClusterVmDependencyRuleArgs.builder()\n            .computeClusterId(cluster.id())\n            .name(\"test-cluster-vm-dependency-rule\")\n            .dependencyVmGroupName(clusterVmGroup1.name())\n            .vmGroupName(clusterVmGroup2.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vm1:\n    type: vsphere:VirtualMachine\n    properties:\n      name: test1\n      resourcePoolId: ${cluster.resourcePoolId}\n      datastoreId: ${datastore.id}\n      numCpus: 2\n      memory: 2048\n      guestId: otherLinux64Guest\n      networkInterfaces:\n        - networkId: ${network.id}\n      disks:\n        - label: disk0\n          size: 20\n  vm2:\n    type: vsphere:VirtualMachine\n    properties:\n      name: test2\n      resourcePoolId: ${cluster.resourcePoolId}\n      datastoreId: ${datastore.id}\n      numCpus: 2\n      memory: 2048\n      guestId: otherLinux64Guest\n      networkInterfaces:\n        - networkId: ${network.id}\n      disks:\n        - label: disk0\n          size: 20\n  clusterVmGroup1:\n    type: vsphere:ComputeClusterVmGroup\n    name: cluster_vm_group1\n    properties:\n      name: test-cluster-vm-group1\n      computeClusterId: ${cluster.id}\n      virtualMachineIds:\n        - ${vm1.id}\n  clusterVmGroup2:\n    type: vsphere:ComputeClusterVmGroup\n    name: cluster_vm_group2\n    properties:\n      name: test-cluster-vm-group2\n      computeClusterId: ${cluster.id}\n      virtualMachineIds:\n        - ${vm2.id}\n  clusterVmDependencyRule:\n    type: vsphere:ComputeClusterVmDependencyRule\n    name: cluster_vm_dependency_rule\n    properties:\n      computeClusterId: ${cluster.id}\n      name: test-cluster-vm-dependency-rule\n      dependencyVmGroupName: ${clusterVmGroup1.name}\n      vmGroupName: ${clusterVmGroup2.name}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  datastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: datastore1\n        datacenterId: ${datacenter.id}\n  cluster:\n    fn::invoke:\n      function: vsphere:getComputeCluster\n      arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n  network:\n    fn::invoke:\n      function: vsphere:getNetwork\n      arguments:\n        name: network1\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing rule can be imported into this resource by supplying\n\nboth the path to the cluster, and the name the rule. If the name or cluster is\n\nnot found, or if the rule is of a different type, an error will be returned. An\n\nexample is below:\n\n```sh\n$ pulumi import vsphere:index/computeClusterVmDependencyRule:ComputeClusterVmDependencyRule cluster_vm_dependency_rule \\\n```\n\n  '{\"compute_cluster_path\": \"/dc1/host/cluster1\", \\\n\n  \"name\": \"pulumi-test-cluster-vm-dependency-rule\"}'\n\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "required": [
                "computeClusterId",
                "dependencyVmGroupName",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "dependencyVmGroupName",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmDependencyRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "dependencyVmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmGroup:ComputeClusterVmGroup": {
            "description": "The `vsphere.ComputeClusterVmGroup` resource can be used to manage groups of\nvirtual machines in a cluster, either created by the\n[`vsphere.ComputeCluster`][tf-vsphere-cluster-resource] resource or looked up\nby the [`vsphere.ComputeCluster`][tf-vsphere-cluster-data-source] data source.\n\n[tf-vsphere-cluster-resource]: /docs/providers/vsphere/r/compute_cluster.html\n[tf-vsphere-cluster-data-source]: /docs/providers/vsphere/d/compute_cluster.html\n\nThis resource mainly serves as an input to the\n[`vsphere.ComputeClusterVmDependencyRule`][tf-vsphere-cluster-vm-dependency-rule-resource]\nand\n[`vsphere.ComputeClusterVmHostRule`][tf-vsphere-cluster-vm-host-rule-resource]\nresources. See the individual resource documentation pages for more information.\n\n[tf-vsphere-cluster-vm-dependency-rule-resource]: /docs/providers/vsphere/r/compute_cluster_vm_dependency_rule.html\n[tf-vsphere-cluster-vm-host-rule-resource]: /docs/providers/vsphere/r/compute_cluster_vm_host_rule.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n## Example Usage\n\nThe example below creates two virtual machines in a cluster using the\n`vsphere.VirtualMachine` resource, creating the\nvirtual machine in the cluster looked up by the\n`vsphere.ComputeCluster` data source. It\nthen creates a group from these two virtual machines.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore1\",\n    datacenterId: datacenter.id,\n}));\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"network1\",\n    datacenterId: datacenter.id,\n}));\nconst vm: vsphere.VirtualMachine[] = [];\nfor (const range = {value: 0}; range.value \u003c 2; range.value++) {\n    vm.push(new vsphere.VirtualMachine(`vm-${range.value}`, {\n        name: `test-${range.value}`,\n        resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n        datastoreId: datastore.then(datastore =\u003e datastore.id),\n        numCpus: 2,\n        memory: 2048,\n        guestId: \"otherLinux64Guest\",\n        networkInterfaces: [{\n            networkId: network.then(network =\u003e network.id),\n        }],\n        disks: [{\n            label: \"disk0\",\n            size: 20,\n        }],\n    }));\n}\nconst clusterVmGroup = new vsphere.ComputeClusterVmGroup(\"cluster_vm_group\", {\n    name: \"test-cluster-vm-group\",\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: [vm.map(__item =\u003e __item.id)],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore1\",\n    datacenter_id=datacenter.id)\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"network1\",\n    datacenter_id=datacenter.id)\nvm = []\nfor range in [{\"value\": i} for i in range(0, 2)]:\n    vm.append(vsphere.VirtualMachine(f\"vm-{range['value']}\",\n        name=f\"test-{range['value']}\",\n        resource_pool_id=cluster.resource_pool_id,\n        datastore_id=datastore.id,\n        num_cpus=2,\n        memory=2048,\n        guest_id=\"otherLinux64Guest\",\n        network_interfaces=[{\n            \"network_id\": network.id,\n        }],\n        disks=[{\n            \"label\": \"disk0\",\n            \"size\": 20,\n        }]))\ncluster_vm_group = vsphere.ComputeClusterVmGroup(\"cluster_vm_group\",\n    name=\"test-cluster-vm-group\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[[__item.id for __item in vm]])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"network1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vm = new List\u003cVSphere.VirtualMachine\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c 2; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        vm.Add(new VSphere.VirtualMachine($\"vm-{range.Value}\", new()\n        {\n            Name = $\"test-{range.Value}\",\n            ResourcePoolId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n            DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n            NumCpus = 2,\n            Memory = 2048,\n            GuestId = \"otherLinux64Guest\",\n            NetworkInterfaces = new[]\n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n                },\n            },\n            Disks = new[]\n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n        }));\n    }\n    var clusterVmGroup = new VSphere.ComputeClusterVmGroup(\"cluster_vm_group\", new()\n    {\n        Name = \"test-cluster-vm-group\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        VirtualMachineIds = new[]\n        {\n            vm.Select(__item =\u003e __item.Id).ToList(),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\nfunc main() {\npulumi.Run(func(ctx *pulumi.Context) error {\ndatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\nName: pulumi.StringRef(\"dc-01\"),\n}, nil);\nif err != nil {\nreturn err\n}\ndatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\nName: \"datastore1\",\nDatacenterId: pulumi.StringRef(datacenter.Id),\n}, nil);\nif err != nil {\nreturn err\n}\ncluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\nName: \"cluster-01\",\nDatacenterId: pulumi.StringRef(datacenter.Id),\n}, nil);\nif err != nil {\nreturn err\n}\nnetwork, err := vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\nName: \"network1\",\nDatacenterId: pulumi.StringRef(datacenter.Id),\n}, nil);\nif err != nil {\nreturn err\n}\nvar vm []*vsphere.VirtualMachine\nfor index := 0; index \u003c 2; index++ {\n    key0 := index\n    val0 := index\n__res, err := vsphere.NewVirtualMachine(ctx, fmt.Sprintf(\"vm-%v\", key0), \u0026vsphere.VirtualMachineArgs{\nName: pulumi.Sprintf(\"test-%v\", val0),\nResourcePoolId: pulumi.String(cluster.ResourcePoolId),\nDatastoreId: pulumi.String(datastore.Id),\nNumCpus: pulumi.Int(2),\nMemory: pulumi.Int(2048),\nGuestId: pulumi.String(\"otherLinux64Guest\"),\nNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\nNetworkId: pulumi.String(network.Id),\n},\n},\nDisks: vsphere.VirtualMachineDiskArray{\n\u0026vsphere.VirtualMachineDiskArgs{\nLabel: pulumi.String(\"disk0\"),\nSize: pulumi.Int(20),\n},\n},\n})\nif err != nil {\nreturn err\n}\nvm = append(vm, __res)\n}\n_, err = vsphere.NewComputeClusterVmGroup(ctx, \"cluster_vm_group\", \u0026vsphere.ComputeClusterVmGroupArgs{\nName: pulumi.String(\"test-cluster-vm-group\"),\nComputeClusterId: pulumi.String(cluster.Id),\nVirtualMachineIds: pulumi.StringArray{\npulumi.String(%!v(PANIC=Format method: fatal: A failure has occurred: unlowered splat expression @ example.pp:42,27-35)),\n},\n})\nif err != nil {\nreturn err\n}\nreturn nil\n})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;\nimport com.pulumi.vsphere.ComputeClusterVmGroup;\nimport com.pulumi.vsphere.ComputeClusterVmGroupArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"network1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        for (var i = 0; i \u003c 2; i++) {\n            new VirtualMachine(\"vm-\" + i, VirtualMachineArgs.builder()\n                .name(String.format(\"test-%s\", range.value()))\n                .resourcePoolId(cluster.resourcePoolId())\n                .datastoreId(datastore.id())\n                .numCpus(2)\n                .memory(2048)\n                .guestId(\"otherLinux64Guest\")\n                .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                    .networkId(network.id())\n                    .build())\n                .disks(VirtualMachineDiskArgs.builder()\n                    .label(\"disk0\")\n                    .size(20)\n                    .build())\n                .build());\n\n        \n}\n        var clusterVmGroup = new ComputeClusterVmGroup(\"clusterVmGroup\", ComputeClusterVmGroupArgs.builder()\n            .name(\"test-cluster-vm-group\")\n            .computeClusterId(cluster.id())\n            .virtualMachineIds(vm.stream().map(element -\u003e element.id()).collect(toList()))\n            .build());\n\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing group can be imported into this resource by\n\nsupplying both the path to the cluster, and the name of the VM group. If the\n\nname or cluster is not found, or if the group is of a different type, an error\n\nwill be returned. An example is below:\n\n```sh\n$ pulumi import vsphere:index/computeClusterVmGroup:ComputeClusterVmGroup cluster_vm_group \\\n```\n\n  '{\"compute_cluster_path\": \"/dc1/host/cluster1\", \\\n\n  \"name\": \"pulumi-test-cluster-vm-group\"}'\n\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterHostGroup`\nresource. Make sure your names are unique across both resources.\n\n\u003e **NOTE:** To update a existing VM group, you must first import the group with `import` command in\nimport section. When importing a VM group, validate that all virtual machines that\nneed to be in the group are included in the `virtual_machine_ids`; otherwise, any virtual machines\nthat are not in `virtual_machine_ids` the included will be removed from the group.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterHostGroup`\nresource. Make sure your names are unique across both resources.\n\n\u003e **NOTE:** To update a existing VM group, you must first import the group with `import` command in\nimport section. When importing a VM group, validate that all virtual machines that\nneed to be in the group are included in the `virtual_machine_ids`; otherwise, any virtual machines\nthat are not in `virtual_machine_ids` the included will be removed from the group.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines in this\ngroup.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterHostGroup`\nresource. Make sure your names are unique across both resources.\n\n\u003e **NOTE:** To update a existing VM group, you must first import the group with `import` command in\nimport section. When importing a VM group, validate that all virtual machines that\nneed to be in the group are included in the `virtual_machine_ids`; otherwise, any virtual machines\nthat are not in `virtual_machine_ids` the included will be removed from the group.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmHostRule:ComputeClusterVmHostRule": {
            "description": "The `vsphere.ComputeClusterVmHostRule` resource can be used to manage\nVM-to-host rules in a cluster, either created by the\n`vsphere.ComputeCluster` resource or looked up\nby the `vsphere.ComputeCluster` data source.\n\nThis resource can create both _affinity rules_, where virtual machines run on\nspecified hosts, or _anti-affinity_ rules, where virtual machines run on hosts\noutside of the ones specified in the rule. Virtual machines and hosts are\nsupplied via groups, which can be managed via the\n`vsphere.ComputeClusterVmGroup` and\n`vsphere.ComputeClusterHostGroup`\nresources.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n## Example Usage\n\nThe example below creates a virtual machine in a cluster using the\n`vsphere.VirtualMachine` resource in a cluster\nlooked up by the `vsphere.ComputeCluster`\ndata source. It then creates a group with this virtual machine. It also creates\na host group off of the host looked up via the\n`vsphere.Host` data source. Finally, this\nvirtual machine is configured to run specifically on that host via a\n`vsphere.ComputeClusterVmHostRule` resource.\n\n\u003e Note how `vm_group_name` and\n`affinity_host_group_name` are sourced off of the\n`name` attributes from the\n`vsphere.ComputeClusterVmGroup` and\n`vsphere.ComputeClusterHostGroup`\nresources. This is to ensure that the rule is not created before the groups\nexist, which may not possibly happen in the event that the names came from a\n\"static\" source such as a variable.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore1\",\n    datacenterId: datacenter.id,\n}));\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"network1\",\n    datacenterId: datacenter.id,\n}));\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    name: \"test\",\n    resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n    datastoreId: datastore.then(datastore =\u003e datastore.id),\n    numCpus: 2,\n    memory: 2048,\n    guestId: \"otherLinux64Guest\",\n    networkInterfaces: [{\n        networkId: network.then(network =\u003e network.id),\n    }],\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n});\nconst clusterVmGroup = new vsphere.ComputeClusterVmGroup(\"cluster_vm_group\", {\n    name: \"test-cluster-vm-group\",\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: [vm.id],\n});\nconst clusterHostGroup = new vsphere.ComputeClusterHostGroup(\"cluster_host_group\", {\n    name: \"test-cluster-vm-group\",\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    hostSystemIds: [host.then(host =\u003e host.id)],\n});\nconst clusterVmHostRule = new vsphere.ComputeClusterVmHostRule(\"cluster_vm_host_rule\", {\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    name: \"test-cluster-vm-host-rule\",\n    vmGroupName: clusterVmGroup.name,\n    affinityHostGroupName: clusterHostGroup.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore1\",\n    datacenter_id=datacenter.id)\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"network1\",\n    datacenter_id=datacenter.id)\nvm = vsphere.VirtualMachine(\"vm\",\n    name=\"test\",\n    resource_pool_id=cluster.resource_pool_id,\n    datastore_id=datastore.id,\n    num_cpus=2,\n    memory=2048,\n    guest_id=\"otherLinux64Guest\",\n    network_interfaces=[{\n        \"network_id\": network.id,\n    }],\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }])\ncluster_vm_group = vsphere.ComputeClusterVmGroup(\"cluster_vm_group\",\n    name=\"test-cluster-vm-group\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[vm.id])\ncluster_host_group = vsphere.ComputeClusterHostGroup(\"cluster_host_group\",\n    name=\"test-cluster-vm-group\",\n    compute_cluster_id=cluster.id,\n    host_system_ids=[host.id])\ncluster_vm_host_rule = vsphere.ComputeClusterVmHostRule(\"cluster_vm_host_rule\",\n    compute_cluster_id=cluster.id,\n    name=\"test-cluster-vm-host-rule\",\n    vm_group_name=cluster_vm_group.name,\n    affinity_host_group_name=cluster_host_group.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"network1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vm = new VSphere.VirtualMachine(\"vm\", new()\n    {\n        Name = \"test\",\n        ResourcePoolId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n        DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        NumCpus = 2,\n        Memory = 2048,\n        GuestId = \"otherLinux64Guest\",\n        NetworkInterfaces = new[]\n        {\n            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n            {\n                NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n            },\n        },\n        Disks = new[]\n        {\n            new VSphere.Inputs.VirtualMachineDiskArgs\n            {\n                Label = \"disk0\",\n                Size = 20,\n            },\n        },\n    });\n\n    var clusterVmGroup = new VSphere.ComputeClusterVmGroup(\"cluster_vm_group\", new()\n    {\n        Name = \"test-cluster-vm-group\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        VirtualMachineIds = new[]\n        {\n            vm.Id,\n        },\n    });\n\n    var clusterHostGroup = new VSphere.ComputeClusterHostGroup(\"cluster_host_group\", new()\n    {\n        Name = \"test-cluster-vm-group\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        HostSystemIds = new[]\n        {\n            host.Apply(getHostResult =\u003e getHostResult.Id),\n        },\n    });\n\n    var clusterVmHostRule = new VSphere.ComputeClusterVmHostRule(\"cluster_vm_host_rule\", new()\n    {\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        Name = \"test-cluster-vm-host-rule\",\n        VmGroupName = clusterVmGroup.Name,\n        AffinityHostGroupName = clusterHostGroup.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnetwork, err := vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"network1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvm, err := vsphere.NewVirtualMachine(ctx, \"vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tName:           pulumi.String(\"test\"),\n\t\t\tResourcePoolId: pulumi.String(cluster.ResourcePoolId),\n\t\t\tDatastoreId:    pulumi.String(datastore.Id),\n\t\t\tNumCpus:        pulumi.Int(2),\n\t\t\tMemory:         pulumi.Int(2048),\n\t\t\tGuestId:        pulumi.String(\"otherLinux64Guest\"),\n\t\t\tNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\t\t\t\t\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\n\t\t\t\t\tNetworkId: pulumi.String(network.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDisks: vsphere.VirtualMachineDiskArray{\n\t\t\t\t\u0026vsphere.VirtualMachineDiskArgs{\n\t\t\t\t\tLabel: pulumi.String(\"disk0\"),\n\t\t\t\t\tSize:  pulumi.Int(20),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclusterVmGroup, err := vsphere.NewComputeClusterVmGroup(ctx, \"cluster_vm_group\", \u0026vsphere.ComputeClusterVmGroupArgs{\n\t\t\tName:             pulumi.String(\"test-cluster-vm-group\"),\n\t\t\tComputeClusterId: pulumi.String(cluster.Id),\n\t\t\tVirtualMachineIds: pulumi.StringArray{\n\t\t\t\tvm.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclusterHostGroup, err := vsphere.NewComputeClusterHostGroup(ctx, \"cluster_host_group\", \u0026vsphere.ComputeClusterHostGroupArgs{\n\t\t\tName:             pulumi.String(\"test-cluster-vm-group\"),\n\t\t\tComputeClusterId: pulumi.String(cluster.Id),\n\t\t\tHostSystemIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(host.Id),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewComputeClusterVmHostRule(ctx, \"cluster_vm_host_rule\", \u0026vsphere.ComputeClusterVmHostRuleArgs{\n\t\t\tComputeClusterId:      pulumi.String(cluster.Id),\n\t\t\tName:                  pulumi.String(\"test-cluster-vm-host-rule\"),\n\t\t\tVmGroupName:           clusterVmGroup.Name,\n\t\t\tAffinityHostGroupName: clusterHostGroup.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;\nimport com.pulumi.vsphere.ComputeClusterVmGroup;\nimport com.pulumi.vsphere.ComputeClusterVmGroupArgs;\nimport com.pulumi.vsphere.ComputeClusterHostGroup;\nimport com.pulumi.vsphere.ComputeClusterHostGroupArgs;\nimport com.pulumi.vsphere.ComputeClusterVmHostRule;\nimport com.pulumi.vsphere.ComputeClusterVmHostRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"network1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var vm = new VirtualMachine(\"vm\", VirtualMachineArgs.builder()\n            .name(\"test\")\n            .resourcePoolId(cluster.resourcePoolId())\n            .datastoreId(datastore.id())\n            .numCpus(2)\n            .memory(2048)\n            .guestId(\"otherLinux64Guest\")\n            .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                .networkId(network.id())\n                .build())\n            .disks(VirtualMachineDiskArgs.builder()\n                .label(\"disk0\")\n                .size(20)\n                .build())\n            .build());\n\n        var clusterVmGroup = new ComputeClusterVmGroup(\"clusterVmGroup\", ComputeClusterVmGroupArgs.builder()\n            .name(\"test-cluster-vm-group\")\n            .computeClusterId(cluster.id())\n            .virtualMachineIds(vm.id())\n            .build());\n\n        var clusterHostGroup = new ComputeClusterHostGroup(\"clusterHostGroup\", ComputeClusterHostGroupArgs.builder()\n            .name(\"test-cluster-vm-group\")\n            .computeClusterId(cluster.id())\n            .hostSystemIds(host.id())\n            .build());\n\n        var clusterVmHostRule = new ComputeClusterVmHostRule(\"clusterVmHostRule\", ComputeClusterVmHostRuleArgs.builder()\n            .computeClusterId(cluster.id())\n            .name(\"test-cluster-vm-host-rule\")\n            .vmGroupName(clusterVmGroup.name())\n            .affinityHostGroupName(clusterHostGroup.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      name: test\n      resourcePoolId: ${cluster.resourcePoolId}\n      datastoreId: ${datastore.id}\n      numCpus: 2\n      memory: 2048\n      guestId: otherLinux64Guest\n      networkInterfaces:\n        - networkId: ${network.id}\n      disks:\n        - label: disk0\n          size: 20\n  clusterVmGroup:\n    type: vsphere:ComputeClusterVmGroup\n    name: cluster_vm_group\n    properties:\n      name: test-cluster-vm-group\n      computeClusterId: ${cluster.id}\n      virtualMachineIds:\n        - ${vm.id}\n  clusterHostGroup:\n    type: vsphere:ComputeClusterHostGroup\n    name: cluster_host_group\n    properties:\n      name: test-cluster-vm-group\n      computeClusterId: ${cluster.id}\n      hostSystemIds:\n        - ${host.id}\n  clusterVmHostRule:\n    type: vsphere:ComputeClusterVmHostRule\n    name: cluster_vm_host_rule\n    properties:\n      computeClusterId: ${cluster.id}\n      name: test-cluster-vm-host-rule\n      vmGroupName: ${clusterVmGroup.name}\n      affinityHostGroupName: ${clusterHostGroup.name}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  datastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: datastore1\n        datacenterId: ${datacenter.id}\n  cluster:\n    fn::invoke:\n      function: vsphere:getComputeCluster\n      arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  network:\n    fn::invoke:\n      function: vsphere:getNetwork\n      arguments:\n        name: network1\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing rule can be imported into this resource by supplying\n\nboth the path to the cluster, and the name the rule. If the name or cluster is\n\nnot found, or if the rule is of a different type, an error will be returned. An\n\nexample is below:\n\n```sh\n$ pulumi import vsphere:index/computeClusterVmHostRule:ComputeClusterVmHostRule cluster_vm_host_rule \\\n```\n\n  '{\"compute_cluster_path\": \"/dc1/host/cluster1\", \\\n\n  \"name\": \"pulumi-test-cluster-vm-host-rule\"}'\n\n",
            "properties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** One of `affinity_host_group_name` or\n`anti_affinity_host_group_name` must be\ndefined, but not both.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** One of `affinity_host_group_name` or\n`anti_affinity_host_group_name` must be\ndefined, but not both.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmHostRule resources.\n",
                "properties": {
                    "affinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                    },
                    "antiAffinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                    },
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** One of `affinity_host_group_name` or\n`anti_affinity_host_group_name` must be\ndefined, but not both.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the virtual machine group to use\nwith this rule.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibrary:ContentLibrary": {
            "description": "The `vsphere.ContentLibrary` resource can be used to manage content libraries.\n\n\u003e **NOTE:** This resource requires a vCenter Server instance and is not available on direct ESXi host connections.\n\n## Example Usage\n\nThe following example creates a publishing content library using the datastore named `publisher-datastore` as the storage backing.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenterA = vsphere.getDatacenter({\n    name: \"dc-01-a\",\n});\nconst publisherDatastore = datacenterA.then(datacenterA =\u003e vsphere.getDatastore({\n    name: \"publisher-datastore\",\n    datacenterId: datacenterA.id,\n}));\nconst publisherContentLibrary = new vsphere.ContentLibrary(\"publisher_content_library\", {\n    name: \"Publisher Content Library\",\n    description: \"A publishing content library.\",\n    storageBackings: [publisherDatastore.then(publisherDatastore =\u003e publisherDatastore.id)],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter_a = vsphere.get_datacenter(name=\"dc-01-a\")\npublisher_datastore = vsphere.get_datastore(name=\"publisher-datastore\",\n    datacenter_id=datacenter_a.id)\npublisher_content_library = vsphere.ContentLibrary(\"publisher_content_library\",\n    name=\"Publisher Content Library\",\n    description=\"A publishing content library.\",\n    storage_backings=[publisher_datastore.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenterA = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01-a\",\n    });\n\n    var publisherDatastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"publisher-datastore\",\n        DatacenterId = datacenterA.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var publisherContentLibrary = new VSphere.ContentLibrary(\"publisher_content_library\", new()\n    {\n        Name = \"Publisher Content Library\",\n        Description = \"A publishing content library.\",\n        StorageBackings = new[]\n        {\n            publisherDatastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenterA, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01-a\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpublisherDatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"publisher-datastore\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenterA.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewContentLibrary(ctx, \"publisher_content_library\", \u0026vsphere.ContentLibraryArgs{\n\t\t\tName:        pulumi.String(\"Publisher Content Library\"),\n\t\t\tDescription: pulumi.String(\"A publishing content library.\"),\n\t\t\tStorageBackings: pulumi.StringArray{\n\t\t\t\tpulumi.String(publisherDatastore.Id),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.ContentLibrary;\nimport com.pulumi.vsphere.ContentLibraryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenterA = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01-a\")\n            .build());\n\n        final var publisherDatastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"publisher-datastore\")\n            .datacenterId(datacenterA.id())\n            .build());\n\n        var publisherContentLibrary = new ContentLibrary(\"publisherContentLibrary\", ContentLibraryArgs.builder()\n            .name(\"Publisher Content Library\")\n            .description(\"A publishing content library.\")\n            .storageBackings(publisherDatastore.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  publisherContentLibrary:\n    type: vsphere:ContentLibrary\n    name: publisher_content_library\n    properties:\n      name: Publisher Content Library\n      description: A publishing content library.\n      storageBackings:\n        - ${publisherDatastore.id}\nvariables:\n  datacenterA:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01-a\n  publisherDatastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: publisher-datastore\n        datacenterId: ${datacenterA.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nThe next example creates a subscribed content library using the URL of the publisher content library as the source and the datastore named `subscriber-datastore` as the storage backing.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenterB = vsphere.getDatacenter({\n    name: \"dc-01-b\",\n});\nconst subscriberDatastore = datacenterB.then(datacenterB =\u003e vsphere.getDatastore({\n    name: \"subscriber-datastore\",\n    datacenterId: datacenterB.id,\n}));\nconst subscriberContentLibrary = new vsphere.ContentLibrary(\"subscriber_content_library\", {\n    name: \"Subscriber Content Library\",\n    description: \"A subscribing content library.\",\n    storageBackings: [subscriberDatastore.then(subscriberDatastore =\u003e subscriberDatastore.id)],\n    subscription: {\n        subscriptionUrl: \"https://vc-01-a.example.com:443/cls/vcsp/lib/f42a4b25-844a-44ec-9063-a3a5e9cc88c7/lib.json\",\n        automaticSync: true,\n        onDemand: false,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter_b = vsphere.get_datacenter(name=\"dc-01-b\")\nsubscriber_datastore = vsphere.get_datastore(name=\"subscriber-datastore\",\n    datacenter_id=datacenter_b.id)\nsubscriber_content_library = vsphere.ContentLibrary(\"subscriber_content_library\",\n    name=\"Subscriber Content Library\",\n    description=\"A subscribing content library.\",\n    storage_backings=[subscriber_datastore.id],\n    subscription={\n        \"subscription_url\": \"https://vc-01-a.example.com:443/cls/vcsp/lib/f42a4b25-844a-44ec-9063-a3a5e9cc88c7/lib.json\",\n        \"automatic_sync\": True,\n        \"on_demand\": False,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenterB = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01-b\",\n    });\n\n    var subscriberDatastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"subscriber-datastore\",\n        DatacenterId = datacenterB.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var subscriberContentLibrary = new VSphere.ContentLibrary(\"subscriber_content_library\", new()\n    {\n        Name = \"Subscriber Content Library\",\n        Description = \"A subscribing content library.\",\n        StorageBackings = new[]\n        {\n            subscriberDatastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        },\n        Subscription = new VSphere.Inputs.ContentLibrarySubscriptionArgs\n        {\n            SubscriptionUrl = \"https://vc-01-a.example.com:443/cls/vcsp/lib/f42a4b25-844a-44ec-9063-a3a5e9cc88c7/lib.json\",\n            AutomaticSync = true,\n            OnDemand = false,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenterB, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01-b\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsubscriberDatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"subscriber-datastore\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenterB.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewContentLibrary(ctx, \"subscriber_content_library\", \u0026vsphere.ContentLibraryArgs{\n\t\t\tName:        pulumi.String(\"Subscriber Content Library\"),\n\t\t\tDescription: pulumi.String(\"A subscribing content library.\"),\n\t\t\tStorageBackings: pulumi.StringArray{\n\t\t\t\tpulumi.String(subscriberDatastore.Id),\n\t\t\t},\n\t\t\tSubscription: \u0026vsphere.ContentLibrarySubscriptionArgs{\n\t\t\t\tSubscriptionUrl: pulumi.String(\"https://vc-01-a.example.com:443/cls/vcsp/lib/f42a4b25-844a-44ec-9063-a3a5e9cc88c7/lib.json\"),\n\t\t\t\tAutomaticSync:   pulumi.Bool(true),\n\t\t\t\tOnDemand:        pulumi.Bool(false),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.ContentLibrary;\nimport com.pulumi.vsphere.ContentLibraryArgs;\nimport com.pulumi.vsphere.inputs.ContentLibrarySubscriptionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenterB = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01-b\")\n            .build());\n\n        final var subscriberDatastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"subscriber-datastore\")\n            .datacenterId(datacenterB.id())\n            .build());\n\n        var subscriberContentLibrary = new ContentLibrary(\"subscriberContentLibrary\", ContentLibraryArgs.builder()\n            .name(\"Subscriber Content Library\")\n            .description(\"A subscribing content library.\")\n            .storageBackings(subscriberDatastore.id())\n            .subscription(ContentLibrarySubscriptionArgs.builder()\n                .subscriptionUrl(\"https://vc-01-a.example.com:443/cls/vcsp/lib/f42a4b25-844a-44ec-9063-a3a5e9cc88c7/lib.json\")\n                .automaticSync(true)\n                .onDemand(false)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  subscriberContentLibrary:\n    type: vsphere:ContentLibrary\n    name: subscriber_content_library\n    properties:\n      name: Subscriber Content Library\n      description: A subscribing content library.\n      storageBackings:\n        - ${subscriberDatastore.id}\n      subscription:\n        subscriptionUrl: https://vc-01-a.example.com:443/cls/vcsp/lib/f42a4b25-844a-44ec-9063-a3a5e9cc88c7/lib.json\n        automaticSync: true\n        onDemand: false\nvariables:\n  datacenterB:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01-b\n  subscriberDatastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: subscriber-datastore\n        datacenterId: ${datacenterB.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing content library can be imported into this resource by supplying the content library ID. For example:\n\n```sh\n$ pulumi import vsphere:index/contentLibrary:ContentLibrary vsphere_content_library publisher_content_library f42a4b25-844a-44ec-9063-a3a5e9cc88c7\n```\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the content library.\n"
                },
                "publication": {
                    "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                    "description": "Options to publish a local content library.\n"
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID of the datastore on which to store the content library items.\n"
                },
                "subscription": {
                    "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                    "description": "Options subscribe to a published content library.\n"
                }
            },
            "required": [
                "name",
                "publication",
                "storageBackings"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the content library.\n",
                    "willReplaceOnChanges": true
                },
                "publication": {
                    "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                    "description": "Options to publish a local content library.\n",
                    "willReplaceOnChanges": true
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID of the datastore on which to store the content library items.\n",
                    "willReplaceOnChanges": true
                },
                "subscription": {
                    "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                    "description": "Options subscribe to a published content library.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "storageBackings"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibrary resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description for the content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "publication": {
                        "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                        "description": "Options to publish a local content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageBackings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object reference ID of the datastore on which to store the content library items.\n",
                        "willReplaceOnChanges": true
                    },
                    "subscription": {
                        "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                        "description": "Options subscribe to a published content library.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibraryItem:ContentLibraryItem": {
            "description": "The `vsphere.ContentLibraryItem` resource can be used to create items in a\nvSphere content library. The `file_url` must be accessible from the vSphere\nenvironment as it will be downloaded from the specified location and stored\non the content library's storage backing.\n\n## Example Usage\n\nThe first example below imports an OVF Template to a content\nlibrary.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst contentLibrary = vsphere.getContentLibrary({\n    name: \"clb-01\",\n});\nconst contentLibraryItem = new vsphere.ContentLibraryItem(\"content_library_item\", {\n    name: \"ovf-linux-ubuntu-server-lts\",\n    description: \"Ubuntu Server LTS OVF Template\",\n    fileUrl: \"https://releases.example.com/ubuntu/ubuntu/ubuntu-live-server-amd64.ovf\",\n    libraryId: contentLibrary.then(contentLibrary =\u003e contentLibrary.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncontent_library = vsphere.get_content_library(name=\"clb-01\")\ncontent_library_item = vsphere.ContentLibraryItem(\"content_library_item\",\n    name=\"ovf-linux-ubuntu-server-lts\",\n    description=\"Ubuntu Server LTS OVF Template\",\n    file_url=\"https://releases.example.com/ubuntu/ubuntu/ubuntu-live-server-amd64.ovf\",\n    library_id=content_library.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var contentLibrary = VSphere.GetContentLibrary.Invoke(new()\n    {\n        Name = \"clb-01\",\n    });\n\n    var contentLibraryItem = new VSphere.ContentLibraryItem(\"content_library_item\", new()\n    {\n        Name = \"ovf-linux-ubuntu-server-lts\",\n        Description = \"Ubuntu Server LTS OVF Template\",\n        FileUrl = \"https://releases.example.com/ubuntu/ubuntu/ubuntu-live-server-amd64.ovf\",\n        LibraryId = contentLibrary.Apply(getContentLibraryResult =\u003e getContentLibraryResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcontentLibrary, err := vsphere.LookupContentLibrary(ctx, \u0026vsphere.LookupContentLibraryArgs{\n\t\t\tName: \"clb-01\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewContentLibraryItem(ctx, \"content_library_item\", \u0026vsphere.ContentLibraryItemArgs{\n\t\t\tName:        pulumi.String(\"ovf-linux-ubuntu-server-lts\"),\n\t\t\tDescription: pulumi.String(\"Ubuntu Server LTS OVF Template\"),\n\t\t\tFileUrl:     pulumi.String(\"https://releases.example.com/ubuntu/ubuntu/ubuntu-live-server-amd64.ovf\"),\n\t\t\tLibraryId:   pulumi.String(contentLibrary.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetContentLibraryArgs;\nimport com.pulumi.vsphere.ContentLibraryItem;\nimport com.pulumi.vsphere.ContentLibraryItemArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var contentLibrary = VsphereFunctions.getContentLibrary(GetContentLibraryArgs.builder()\n            .name(\"clb-01\")\n            .build());\n\n        var contentLibraryItem = new ContentLibraryItem(\"contentLibraryItem\", ContentLibraryItemArgs.builder()\n            .name(\"ovf-linux-ubuntu-server-lts\")\n            .description(\"Ubuntu Server LTS OVF Template\")\n            .fileUrl(\"https://releases.example.com/ubuntu/ubuntu/ubuntu-live-server-amd64.ovf\")\n            .libraryId(contentLibrary.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  contentLibraryItem:\n    type: vsphere:ContentLibraryItem\n    name: content_library_item\n    properties:\n      name: ovf-linux-ubuntu-server-lts\n      description: Ubuntu Server LTS OVF Template\n      fileUrl: https://releases.example.com/ubuntu/ubuntu/ubuntu-live-server-amd64.ovf\n      libraryId: ${contentLibrary.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  contentLibrary:\n    fn::invoke:\n      function: vsphere:getContentLibrary\n      arguments:\n        name: clb-01\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nThe next example imports an .iso image to a content library.\n\n[tf-vsphere-vm-resource]: /docs/providers/vsphere/r/virtual_machine.html\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst contentLibrary = vsphere.getContentLibrary({\n    name: \"clb-01\",\n});\nconst contentLibraryItem = new vsphere.ContentLibraryItem(\"content_library_item\", {\n    name: \"iso-linux-ubuntu-server-lts\",\n    description: \"Ubuntu Server LTS .iso\",\n    type: \"iso\",\n    fileUrl: \"https://releases.example.com/ubuntu/ubuntu-live-server-amd64.iso\",\n    libraryId: contentLibrary.then(contentLibrary =\u003e contentLibrary.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncontent_library = vsphere.get_content_library(name=\"clb-01\")\ncontent_library_item = vsphere.ContentLibraryItem(\"content_library_item\",\n    name=\"iso-linux-ubuntu-server-lts\",\n    description=\"Ubuntu Server LTS .iso\",\n    type=\"iso\",\n    file_url=\"https://releases.example.com/ubuntu/ubuntu-live-server-amd64.iso\",\n    library_id=content_library.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var contentLibrary = VSphere.GetContentLibrary.Invoke(new()\n    {\n        Name = \"clb-01\",\n    });\n\n    var contentLibraryItem = new VSphere.ContentLibraryItem(\"content_library_item\", new()\n    {\n        Name = \"iso-linux-ubuntu-server-lts\",\n        Description = \"Ubuntu Server LTS .iso\",\n        Type = \"iso\",\n        FileUrl = \"https://releases.example.com/ubuntu/ubuntu-live-server-amd64.iso\",\n        LibraryId = contentLibrary.Apply(getContentLibraryResult =\u003e getContentLibraryResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcontentLibrary, err := vsphere.LookupContentLibrary(ctx, \u0026vsphere.LookupContentLibraryArgs{\n\t\t\tName: \"clb-01\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewContentLibraryItem(ctx, \"content_library_item\", \u0026vsphere.ContentLibraryItemArgs{\n\t\t\tName:        pulumi.String(\"iso-linux-ubuntu-server-lts\"),\n\t\t\tDescription: pulumi.String(\"Ubuntu Server LTS .iso\"),\n\t\t\tType:        pulumi.String(\"iso\"),\n\t\t\tFileUrl:     pulumi.String(\"https://releases.example.com/ubuntu/ubuntu-live-server-amd64.iso\"),\n\t\t\tLibraryId:   pulumi.String(contentLibrary.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetContentLibraryArgs;\nimport com.pulumi.vsphere.ContentLibraryItem;\nimport com.pulumi.vsphere.ContentLibraryItemArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var contentLibrary = VsphereFunctions.getContentLibrary(GetContentLibraryArgs.builder()\n            .name(\"clb-01\")\n            .build());\n\n        var contentLibraryItem = new ContentLibraryItem(\"contentLibraryItem\", ContentLibraryItemArgs.builder()\n            .name(\"iso-linux-ubuntu-server-lts\")\n            .description(\"Ubuntu Server LTS .iso\")\n            .type(\"iso\")\n            .fileUrl(\"https://releases.example.com/ubuntu/ubuntu-live-server-amd64.iso\")\n            .libraryId(contentLibrary.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  contentLibraryItem:\n    type: vsphere:ContentLibraryItem\n    name: content_library_item\n    properties:\n      name: iso-linux-ubuntu-server-lts\n      description: Ubuntu Server LTS .iso\n      type: iso\n      fileUrl: https://releases.example.com/ubuntu/ubuntu-live-server-amd64.iso\n      libraryId: ${contentLibrary.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  contentLibrary:\n    fn::invoke:\n      function: vsphere:getContentLibrary\n      arguments:\n        name: clb-01\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nThe last example imports a virtual machine image to a content library from an\nexisting virtual machine.\n\n[tf-vsphere-vm-resource]: /docs/providers/vsphere/r/virtual_machine.html\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst contentLibrary = vsphere.getContentLibrary({\n    name: \"clb-01\",\n});\nconst contentLibraryItem = new vsphere.ContentLibraryItem(\"content_library_item\", {\n    name: \"tpl-linux-ubuntu-server-lts\",\n    description: \"Ubuntu Server LTS\",\n    sourceUuid: \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n    libraryId: contentLibrary.then(contentLibrary =\u003e contentLibrary.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncontent_library = vsphere.get_content_library(name=\"clb-01\")\ncontent_library_item = vsphere.ContentLibraryItem(\"content_library_item\",\n    name=\"tpl-linux-ubuntu-server-lts\",\n    description=\"Ubuntu Server LTS\",\n    source_uuid=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n    library_id=content_library.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var contentLibrary = VSphere.GetContentLibrary.Invoke(new()\n    {\n        Name = \"clb-01\",\n    });\n\n    var contentLibraryItem = new VSphere.ContentLibraryItem(\"content_library_item\", new()\n    {\n        Name = \"tpl-linux-ubuntu-server-lts\",\n        Description = \"Ubuntu Server LTS\",\n        SourceUuid = \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n        LibraryId = contentLibrary.Apply(getContentLibraryResult =\u003e getContentLibraryResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcontentLibrary, err := vsphere.LookupContentLibrary(ctx, \u0026vsphere.LookupContentLibraryArgs{\n\t\t\tName: \"clb-01\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewContentLibraryItem(ctx, \"content_library_item\", \u0026vsphere.ContentLibraryItemArgs{\n\t\t\tName:        pulumi.String(\"tpl-linux-ubuntu-server-lts\"),\n\t\t\tDescription: pulumi.String(\"Ubuntu Server LTS\"),\n\t\t\tSourceUuid:  pulumi.String(\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"),\n\t\t\tLibraryId:   pulumi.String(contentLibrary.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetContentLibraryArgs;\nimport com.pulumi.vsphere.ContentLibraryItem;\nimport com.pulumi.vsphere.ContentLibraryItemArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var contentLibrary = VsphereFunctions.getContentLibrary(GetContentLibraryArgs.builder()\n            .name(\"clb-01\")\n            .build());\n\n        var contentLibraryItem = new ContentLibraryItem(\"contentLibraryItem\", ContentLibraryItemArgs.builder()\n            .name(\"tpl-linux-ubuntu-server-lts\")\n            .description(\"Ubuntu Server LTS\")\n            .sourceUuid(\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\")\n            .libraryId(contentLibrary.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  contentLibraryItem:\n    type: vsphere:ContentLibraryItem\n    name: content_library_item\n    properties:\n      name: tpl-linux-ubuntu-server-lts\n      description: Ubuntu Server LTS\n      sourceUuid: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n      libraryId: ${contentLibrary.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  contentLibrary:\n    fn::invoke:\n      function: vsphere:getContentLibrary\n      arguments:\n        name: clb-01\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing content library item can be imported into this resource by\n\nsupplying the content library ID. An example is below:\n\n```sh\n$ pulumi import vsphere:index/contentLibraryItem:ContentLibraryItem vsphere_content_library_item iso-linux-ubuntu-server-lts xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n```\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library item.\n"
                },
                "fileUrl": {
                    "type": "string",
                    "description": "File to import as the content library item.\n"
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the content library in which to create the item.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the content library.\n"
                },
                "sourceUuid": {
                    "type": "string",
                    "description": "Virtual machine UUID to clone to content library.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\nOne of \"ovf\", \"iso\", or \"vm-template\". Default: `ovf`.\n"
                }
            },
            "required": [
                "libraryId",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library item.\n",
                    "willReplaceOnChanges": true
                },
                "fileUrl": {
                    "type": "string",
                    "description": "File to import as the content library item.\n",
                    "willReplaceOnChanges": true
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the content library in which to create the item.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the content library.\n",
                    "willReplaceOnChanges": true
                },
                "sourceUuid": {
                    "type": "string",
                    "description": "Virtual machine UUID to clone to content library.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\nOne of \"ovf\", \"iso\", or \"vm-template\". Default: `ovf`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "libraryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibraryItem resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description for the content library item.\n",
                        "willReplaceOnChanges": true
                    },
                    "fileUrl": {
                        "type": "string",
                        "description": "File to import as the content library item.\n",
                        "willReplaceOnChanges": true
                    },
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the content library in which to create the item.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the item to be created in the content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceUuid": {
                        "type": "string",
                        "description": "Virtual machine UUID to clone to content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of content library item.\nOne of \"ovf\", \"iso\", or \"vm-template\". Default: `ovf`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/customAttribute:CustomAttribute": {
            "description": "The `vsphere.CustomAttribute` resource can be used to create and manage custom\nattributes, which allow users to associate user-specific meta-information with\nvSphere managed objects. Custom attribute values must be strings and are stored\non the vCenter Server and not the managed object.\n\nFor more information about custom attributes, click [here][ext-custom-attributes].\n\n[ext-custom-attributes]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vcenter-and-host-management-8-0/vsphere-tags-and-attributes-host-management/custom-attributes-in-the-vsphere-client-host-management.html\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand require vCenter Server.\n\n## Example Usage\n\nThis example creates a custom attribute named `test-attribute`. The \nresulting custom attribute can be assigned to VMs only.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst attribute = new vsphere.CustomAttribute(\"attribute\", {\n    name: \"test-attribute\",\n    managedObjectType: \"VirtualMachine\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nattribute = vsphere.CustomAttribute(\"attribute\",\n    name=\"test-attribute\",\n    managed_object_type=\"VirtualMachine\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attribute = new VSphere.CustomAttribute(\"attribute\", new()\n    {\n        Name = \"test-attribute\",\n        ManagedObjectType = \"VirtualMachine\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewCustomAttribute(ctx, \"attribute\", \u0026vsphere.CustomAttributeArgs{\n\t\t\tName:              pulumi.String(\"test-attribute\"),\n\t\t\tManagedObjectType: pulumi.String(\"VirtualMachine\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.CustomAttribute;\nimport com.pulumi.vsphere.CustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var attribute = new CustomAttribute(\"attribute\", CustomAttributeArgs.builder()\n            .name(\"test-attribute\")\n            .managedObjectType(\"VirtualMachine\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  attribute:\n    type: vsphere:CustomAttribute\n    properties:\n      name: test-attribute\n      managedObjectType: VirtualMachine\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing custom attribute can be imported into this resource\n\nvia its name, using the following command:\n\n```sh\n$ pulumi import vsphere:index/customAttribute:CustomAttribute attribute terraform-test-attribute\n```\n\n",
            "properties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, review the Managed Object Types. Forces a new resource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, review the Managed Object Types. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomAttribute resources.\n",
                "properties": {
                    "managedObjectType": {
                        "type": "string",
                        "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, review the Managed Object Types. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datacenter:Datacenter": {
            "description": "Provides a VMware vSphere datacenter resource. This can be used as the primary\ncontainer of inventory objects such as hosts and virtual machines.\n\n## Example Usage\n\n### Create datacenter on the root folder\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodDatacenter = new vsphere.Datacenter(\"prod_datacenter\", {name: \"my_prod_datacenter\"});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_datacenter = vsphere.Datacenter(\"prod_datacenter\", name=\"my_prod_datacenter\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodDatacenter = new VSphere.Datacenter(\"prod_datacenter\", new()\n    {\n        Name = \"my_prod_datacenter\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDatacenter(ctx, \"prod_datacenter\", \u0026vsphere.DatacenterArgs{\n\t\t\tName: pulumi.String(\"my_prod_datacenter\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.Datacenter;\nimport com.pulumi.vsphere.DatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var prodDatacenter = new Datacenter(\"prodDatacenter\", DatacenterArgs.builder()\n            .name(\"my_prod_datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodDatacenter:\n    type: vsphere:Datacenter\n    name: prod_datacenter\n    properties:\n      name: my_prod_datacenter\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Create datacenter on a subfolder\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst researchDatacenter = new vsphere.Datacenter(\"research_datacenter\", {\n    name: \"my_research_datacenter\",\n    folder: \"/research/\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nresearch_datacenter = vsphere.Datacenter(\"research_datacenter\",\n    name=\"my_research_datacenter\",\n    folder=\"/research/\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var researchDatacenter = new VSphere.Datacenter(\"research_datacenter\", new()\n    {\n        Name = \"my_research_datacenter\",\n        Folder = \"/research/\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDatacenter(ctx, \"research_datacenter\", \u0026vsphere.DatacenterArgs{\n\t\t\tName:   pulumi.String(\"my_research_datacenter\"),\n\t\t\tFolder: pulumi.String(\"/research/\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.Datacenter;\nimport com.pulumi.vsphere.DatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var researchDatacenter = new Datacenter(\"researchDatacenter\", DatacenterArgs.builder()\n            .name(\"my_research_datacenter\")\n            .folder(\"/research/\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  researchDatacenter:\n    type: vsphere:Datacenter\n    name: research_datacenter\n    properties:\n      name: my_research_datacenter\n      folder: /research/\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing datacenter can be imported into this resource\n\nvia supplying the full path to the datacenter. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```sh\n$ pulumi import vsphere:index/datacenter:Datacenter dc /dc1\n```\n\nThe above would import the datacenter named `dc1`.\n\n",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value\nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "Managed object ID of this datacenter.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "moid",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value\nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Datacenter resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to value\nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "moid": {
                        "type": "string",
                        "description": "Managed object ID of this datacenter.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreCluster:DatastoreCluster": {
            "description": "The `vsphere.DatastoreCluster` resource can be used to create and manage\ndatastore clusters. This can be used to create groups of datastores with a\nshared management interface, allowing for resource control and load balancing\nthrough Storage DRS.\n\nFor more information on vSphere datastore clusters and Storage DRS, see [this\npage][ref-vsphere-datastore-clusters].\n\n[ref-vsphere-datastore-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-resource-management-8-0/creating-a-datastore-cluster.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** Storage DRS requires a vSphere Enterprise Plus license.\n\n## Import\n\nAn existing datastore cluster can be imported into this resource\n\nvia the path to the cluster, via the following command:\n\n```sh\n$ pulumi import vsphere:index/datastoreCluster:DatastoreCluster datastore_cluster /dc1/datastore/ds-cluster\n```\n\nThe above would import the datastore cluster named `ds-cluster` that is located\n\nin the `dc1` datacenter.\n\n",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for storage DRS.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all virtual machines in this storage cluster.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When true, storage DRS keeps VMDKs for individual VMs on the same datastore by default.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The threshold, in GB, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in percent, of difference between space utilization in datastores before storage DRS makes decisions to\nbalance the space.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in milliseconds, that storage DRS uses to make recommendations to move disks from this\ndatastore.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for this datastore cluster.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load in datastores in the cluster before storage DRS makes recommendations to balance the load.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable IOPS of all virtual machines on the datastore before storage DRS makes recommendations to\nmove VMs off of a datastore.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent, of actual estimated performance of the datastore (in IOPS) that storage DRS uses to make\nrecommendations to move VMs off of a datastore when the total reservable IOPS exceeds the threshold.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS threshold to use, percent in the event of automatic, or manual threshold in the event of manual.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "datacenterId",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for storage DRS.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all virtual machines in this storage cluster.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When true, storage DRS keeps VMDKs for individual VMs on the same datastore by default.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The threshold, in GB, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in percent, of difference between space utilization in datastores before storage DRS makes decisions to\nbalance the space.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in milliseconds, that storage DRS uses to make recommendations to move disks from this\ndatastore.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for this datastore cluster.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load in datastores in the cluster before storage DRS makes recommendations to balance the load.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable IOPS of all virtual machines on the datastore before storage DRS makes recommendations to\nmove VMs off of a datastore.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent, of actual estimated performance of the datastore (in IOPS) that storage DRS uses to make\nrecommendations to move VMs off of a datastore when the total reservable IOPS exceeds the threshold.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS threshold to use, percent in the event of automatic, or manual threshold in the event of manual.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore cluster.\n"
                    },
                    "sdrsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Advanced configuration options for storage DRS.\n"
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "The default automation level for all virtual machines in this storage cluster.\n"
                    },
                    "sdrsDefaultIntraVmAffinity": {
                        "type": "boolean",
                        "description": "When true, storage DRS keeps VMDKs for individual VMs on the same datastore by default.\n"
                    },
                    "sdrsEnabled": {
                        "type": "boolean",
                        "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                    },
                    "sdrsFreeSpaceThreshold": {
                        "type": "integer",
                        "description": "The threshold, in GB, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                    },
                    "sdrsFreeSpaceThresholdMode": {
                        "type": "string",
                        "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                    },
                    "sdrsFreeSpaceUtilizationDifference": {
                        "type": "integer",
                        "description": "The threshold, in percent, of difference between space utilization in datastores before storage DRS makes decisions to\nbalance the space.\n"
                    },
                    "sdrsIoBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when correcting I/O load imbalances.\n"
                    },
                    "sdrsIoLatencyThreshold": {
                        "type": "integer",
                        "description": "The I/O latency threshold, in milliseconds, that storage DRS uses to make recommendations to move disks from this\ndatastore.\n"
                    },
                    "sdrsIoLoadBalanceEnabled": {
                        "type": "boolean",
                        "description": "Enable I/O load balancing for this datastore cluster.\n"
                    },
                    "sdrsIoLoadImbalanceThreshold": {
                        "type": "integer",
                        "description": "The difference between load in datastores in the cluster before storage DRS makes recommendations to balance the load.\n"
                    },
                    "sdrsIoReservableIopsThreshold": {
                        "type": "integer",
                        "description": "The threshold of reservable IOPS of all virtual machines on the datastore before storage DRS makes recommendations to\nmove VMs off of a datastore.\n"
                    },
                    "sdrsIoReservablePercentThreshold": {
                        "type": "integer",
                        "description": "The threshold, in percent, of actual estimated performance of the datastore (in IOPS) that storage DRS uses to make\nrecommendations to move VMs off of a datastore when the total reservable IOPS exceeds the threshold.\n"
                    },
                    "sdrsIoReservableThresholdMode": {
                        "type": "string",
                        "description": "The reservable IOPS threshold to use, percent in the event of automatic, or manual threshold in the event of manual.\n"
                    },
                    "sdrsLoadBalanceInterval": {
                        "type": "integer",
                        "description": "The storage DRS poll interval, in minutes.\n"
                    },
                    "sdrsPolicyEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when correcting storage and VM policy violations.\n"
                    },
                    "sdrsRuleEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when correcting affinity rule violations.\n"
                    },
                    "sdrsSpaceBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when correcting disk space imbalances.\n"
                    },
                    "sdrsSpaceUtilizationThreshold": {
                        "type": "integer",
                        "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                    },
                    "sdrsVmEvacuationAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when generating recommendations for datastore evacuation.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreClusterVmAntiAffinityRule:DatastoreClusterVmAntiAffinityRule": {
            "description": "The `vsphere.DatastoreClusterVmAntiAffinityRule` resource can be used to\nmanage VM anti-affinity rules in a datastore cluster, either created by the\n`vsphere.DatastoreCluster` resource or looked up\nby the `vsphere.DatastoreCluster` data source.\n\nThis rule can be used to tell a set to virtual machines to run on different\ndatastores within a cluster, useful for preventing single points of failure in\napplication cluster scenarios. When configured, Storage DRS will make a best effort to\nensure that the virtual machines run on different datastores, or prevent any\noperation that would keep that from happening, depending on the value of the\n`mandatory` flag.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** Storage DRS requires a vSphere Enterprise Plus license.\n\n## Example Usage\n\nThe example below creates two virtual machines in a cluster using the\n`vsphere.VirtualMachine` resource, creating the\nvirtual machines in the datastore cluster looked up by the\n`vsphere.DatastoreCluster` data\nsource. It then creates an anti-affinity rule for these two virtual machines,\nensuring they will run on different datastores whenever possible.\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastoreCluster = datacenter.then(datacenter =\u003e vsphere.getDatastoreCluster({\n    name: \"datastore-cluster1\",\n    datacenterId: datacenter.id,\n}));\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"network1\",\n    datacenterId: datacenter.id,\n}));\nconst vm: vsphere.VirtualMachine[] = [];\nfor (const range = {value: 0}; range.value \u003c 2; range.value++) {\n    vm.push(new vsphere.VirtualMachine(`vm-${range.value}`, {\n        name: `test-${range.value}`,\n        resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n        datastoreClusterId: datastoreCluster.then(datastoreCluster =\u003e datastoreCluster.id),\n        numCpus: 2,\n        memory: 2048,\n        guestId: \"otherLinux64Guest\",\n        networkInterfaces: [{\n            networkId: network.then(network =\u003e network.id),\n        }],\n        disks: [{\n            label: \"disk0\",\n            size: 20,\n        }],\n    }));\n}\nconst clusterVmAntiAffinityRule = new vsphere.DatastoreClusterVmAntiAffinityRule(\"cluster_vm_anti_affinity_rule\", {\n    name: \"test-datastore-cluster-vm-anti-affinity-rule\",\n    datastoreClusterId: datastoreCluster.then(datastoreCluster =\u003e datastoreCluster.id),\n    virtualMachineIds: [vm.map(__item =\u003e __item.id)],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore_cluster = vsphere.get_datastore_cluster(name=\"datastore-cluster1\",\n    datacenter_id=datacenter.id)\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"network1\",\n    datacenter_id=datacenter.id)\nvm = []\nfor range in [{\"value\": i} for i in range(0, 2)]:\n    vm.append(vsphere.VirtualMachine(f\"vm-{range['value']}\",\n        name=f\"test-{range['value']}\",\n        resource_pool_id=cluster.resource_pool_id,\n        datastore_cluster_id=datastore_cluster.id,\n        num_cpus=2,\n        memory=2048,\n        guest_id=\"otherLinux64Guest\",\n        network_interfaces=[{\n            \"network_id\": network.id,\n        }],\n        disks=[{\n            \"label\": \"disk0\",\n            \"size\": 20,\n        }]))\ncluster_vm_anti_affinity_rule = vsphere.DatastoreClusterVmAntiAffinityRule(\"cluster_vm_anti_affinity_rule\",\n    name=\"test-datastore-cluster-vm-anti-affinity-rule\",\n    datastore_cluster_id=datastore_cluster.id,\n    virtual_machine_ids=[[__item.id for __item in vm]])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastoreCluster = VSphere.GetDatastoreCluster.Invoke(new()\n    {\n        Name = \"datastore-cluster1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"network1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vm = new List\u003cVSphere.VirtualMachine\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c 2; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        vm.Add(new VSphere.VirtualMachine($\"vm-{range.Value}\", new()\n        {\n            Name = $\"test-{range.Value}\",\n            ResourcePoolId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n            DatastoreClusterId = datastoreCluster.Apply(getDatastoreClusterResult =\u003e getDatastoreClusterResult.Id),\n            NumCpus = 2,\n            Memory = 2048,\n            GuestId = \"otherLinux64Guest\",\n            NetworkInterfaces = new[]\n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n                },\n            },\n            Disks = new[]\n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n        }));\n    }\n    var clusterVmAntiAffinityRule = new VSphere.DatastoreClusterVmAntiAffinityRule(\"cluster_vm_anti_affinity_rule\", new()\n    {\n        Name = \"test-datastore-cluster-vm-anti-affinity-rule\",\n        DatastoreClusterId = datastoreCluster.Apply(getDatastoreClusterResult =\u003e getDatastoreClusterResult.Id),\n        VirtualMachineIds = new[]\n        {\n            vm.Select(__item =\u003e __item.Id).ToList(),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\nfunc main() {\npulumi.Run(func(ctx *pulumi.Context) error {\ndatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\nName: pulumi.StringRef(\"dc-01\"),\n}, nil);\nif err != nil {\nreturn err\n}\ndatastoreCluster, err := vsphere.LookupDatastoreCluster(ctx, \u0026vsphere.LookupDatastoreClusterArgs{\nName: \"datastore-cluster1\",\nDatacenterId: pulumi.StringRef(datacenter.Id),\n}, nil);\nif err != nil {\nreturn err\n}\ncluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\nName: \"cluster-01\",\nDatacenterId: pulumi.StringRef(datacenter.Id),\n}, nil);\nif err != nil {\nreturn err\n}\nnetwork, err := vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\nName: \"network1\",\nDatacenterId: pulumi.StringRef(datacenter.Id),\n}, nil);\nif err != nil {\nreturn err\n}\nvar vm []*vsphere.VirtualMachine\nfor index := 0; index \u003c 2; index++ {\n    key0 := index\n    val0 := index\n__res, err := vsphere.NewVirtualMachine(ctx, fmt.Sprintf(\"vm-%v\", key0), \u0026vsphere.VirtualMachineArgs{\nName: pulumi.Sprintf(\"test-%v\", val0),\nResourcePoolId: pulumi.String(cluster.ResourcePoolId),\nDatastoreClusterId: pulumi.String(datastoreCluster.Id),\nNumCpus: pulumi.Int(2),\nMemory: pulumi.Int(2048),\nGuestId: pulumi.String(\"otherLinux64Guest\"),\nNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\nNetworkId: pulumi.String(network.Id),\n},\n},\nDisks: vsphere.VirtualMachineDiskArray{\n\u0026vsphere.VirtualMachineDiskArgs{\nLabel: pulumi.String(\"disk0\"),\nSize: pulumi.Int(20),\n},\n},\n})\nif err != nil {\nreturn err\n}\nvm = append(vm, __res)\n}\n_, err = vsphere.NewDatastoreClusterVmAntiAffinityRule(ctx, \"cluster_vm_anti_affinity_rule\", \u0026vsphere.DatastoreClusterVmAntiAffinityRuleArgs{\nName: pulumi.String(\"test-datastore-cluster-vm-anti-affinity-rule\"),\nDatastoreClusterId: pulumi.String(datastoreCluster.Id),\nVirtualMachineIds: pulumi.StringArray{\npulumi.String(%!v(PANIC=Format method: fatal: A failure has occurred: unlowered splat expression @ example.pp:42,28-36)),\n},\n})\nif err != nil {\nreturn err\n}\nreturn nil\n})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreClusterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;\nimport com.pulumi.vsphere.DatastoreClusterVmAntiAffinityRule;\nimport com.pulumi.vsphere.DatastoreClusterVmAntiAffinityRuleArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastoreCluster = VsphereFunctions.getDatastoreCluster(GetDatastoreClusterArgs.builder()\n            .name(\"datastore-cluster1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"network1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        for (var i = 0; i \u003c 2; i++) {\n            new VirtualMachine(\"vm-\" + i, VirtualMachineArgs.builder()\n                .name(String.format(\"test-%s\", range.value()))\n                .resourcePoolId(cluster.resourcePoolId())\n                .datastoreClusterId(datastoreCluster.id())\n                .numCpus(2)\n                .memory(2048)\n                .guestId(\"otherLinux64Guest\")\n                .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                    .networkId(network.id())\n                    .build())\n                .disks(VirtualMachineDiskArgs.builder()\n                    .label(\"disk0\")\n                    .size(20)\n                    .build())\n                .build());\n\n        \n}\n        var clusterVmAntiAffinityRule = new DatastoreClusterVmAntiAffinityRule(\"clusterVmAntiAffinityRule\", DatastoreClusterVmAntiAffinityRuleArgs.builder()\n            .name(\"test-datastore-cluster-vm-anti-affinity-rule\")\n            .datastoreClusterId(datastoreCluster.id())\n            .virtualMachineIds(vm.stream().map(element -\u003e element.id()).collect(toList()))\n            .build());\n\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing rule can be imported into this resource by supplying\n\nboth the path to the cluster, and the name the rule. If the name or cluster is\n\nnot found, or if the rule is of a different type, an error will be returned. An\n\nexample is below:\n\n```sh\n$ pulumi import vsphere:index/datastoreClusterVmAntiAffinityRule:DatastoreClusterVmAntiAffinityRule cluster_vm_anti_affinity_rule \\\n```\n\n  '{\"compute_cluster_path\": \"/dc1/datastore/cluster1\", \\\n\n  \"name\": \"pulumi-test-datastore-cluster-vm-anti-affinity-rule\"}'\n\n",
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n\n\u003e **NOTE:** The minimum length of `virtual_machine_ids` is 2.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n\n\u003e **NOTE:** The minimum length of `virtual_machine_ids` is 2.\n"
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n\n\u003e **NOTE:** The minimum length of `virtual_machine_ids` is 2.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedPortGroup:DistributedPortGroup": {
            "description": "The `vsphere.DistributedPortGroup` resource can be used to manage\ndistributed port groups connected to vSphere Distributed Switches (VDS).\nA vSphere Distributed Switch can be managed by the\n`vsphere.DistributedVirtualSwitch` resource.\n\nDistributed port groups can be used as networks for virtual machines, allowing\nthe virtual machines to use the networking supplied by a vSphere Distributed\nSwitch, with a set of policies that apply to that individual network, if\ndesired.\n\n* For an overview on vSphere networking concepts, refer to the vSphere\n  [product documentation][ref-vsphere-net-concepts].\n\n* For more information on distributed port groups, refer to the vSphere\n  [product documentation][ref-vsphere-dvportgroup].\n\n[ref-vsphere-net-concepts]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/introduction-to-vsphere-networking.html\n[ref-vsphere-dvportgroup]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches/dvport-groups.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on\ndirect ESXi host connections.\n\n## Example Usage\n\nThe configuration below builds on the example given in the\n`vsphere.DistributedVirtualSwitch` resource by\nadding the `vsphere.DistributedPortGroup` resource, attaching itself to the\nvSphere Distributed Switch and assigning VLAN ID 1000.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst config = new pulumi.Config();\nconst hosts = config.getObject\u003cany\u003e(\"hosts\") || [\n    \"esxi-01.example.com\",\n    \"esxi-02.example.com\",\n    \"esxi-03.example.com\",\n];\nconst networkInterfaces = config.getObject\u003cany\u003e(\"networkInterfaces\") || [\n    \"vmnic0\",\n    \"vmnic1\",\n    \"vmnic2\",\n    \"vmnic3\",\n];\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = (new Array(hosts.length)).map((_, i) =\u003e i).map(__index =\u003e (vsphere.getHost({\n    name: hosts[__index],\n    datacenterId: _arg0_.id,\n})));\nconst vds = new vsphere.DistributedVirtualSwitch(\"vds\", {\n    name: \"vds-01\",\n    datacenterId: datacenter.then(datacenter =\u003e datacenter.id),\n    uplinks: [\n        \"uplink1\",\n        \"uplink2\",\n        \"uplink3\",\n        \"uplink4\",\n    ],\n    activeUplinks: [\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    standbyUplinks: [\n        \"uplink3\",\n        \"uplink4\",\n    ],\n    hosts: [\n        {\n            hostSystemId: host[0].then(host =\u003e host.id),\n            devices: [networkInterfaces],\n        },\n        {\n            hostSystemId: host[1].then(host =\u003e host.id),\n            devices: [networkInterfaces],\n        },\n        {\n            hostSystemId: host[2].then(host =\u003e host.id),\n            devices: [networkInterfaces],\n        },\n    ],\n});\nconst pg = new vsphere.DistributedPortGroup(\"pg\", {\n    name: \"pg-01\",\n    distributedVirtualSwitchUuid: vds.id,\n    vlanId: 1000,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nconfig = pulumi.Config()\nhosts = config.get_object(\"hosts\")\nif hosts is None:\n    hosts = [\n        \"esxi-01.example.com\",\n        \"esxi-02.example.com\",\n        \"esxi-03.example.com\",\n    ]\nnetwork_interfaces = config.get_object(\"networkInterfaces\")\nif network_interfaces is None:\n    network_interfaces = [\n        \"vmnic0\",\n        \"vmnic1\",\n        \"vmnic2\",\n        \"vmnic3\",\n    ]\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = [vsphere.get_host(name=hosts[__index],\n    datacenter_id=datacenter.id) for __index in range(len(hosts))]\nvds = vsphere.DistributedVirtualSwitch(\"vds\",\n    name=\"vds-01\",\n    datacenter_id=datacenter.id,\n    uplinks=[\n        \"uplink1\",\n        \"uplink2\",\n        \"uplink3\",\n        \"uplink4\",\n    ],\n    active_uplinks=[\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    standby_uplinks=[\n        \"uplink3\",\n        \"uplink4\",\n    ],\n    hosts=[\n        {\n            \"host_system_id\": host[0].id,\n            \"devices\": [network_interfaces],\n        },\n        {\n            \"host_system_id\": host[1].id,\n            \"devices\": [network_interfaces],\n        },\n        {\n            \"host_system_id\": host[2].id,\n            \"devices\": [network_interfaces],\n        },\n    ])\npg = vsphere.DistributedPortGroup(\"pg\",\n    name=\"pg-01\",\n    distributed_virtual_switch_uuid=vds.id,\n    vlan_id=1000)\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Overriding VDS policies\n\nAll of the default port policies available in the\n`vsphere.DistributedVirtualSwitch` resource can be overridden on the port\ngroup level by specifying new settings for them.\n\nAs an example, we also take this example from the\n`vsphere.DistributedVirtualSwitch` resource where we manually specify our\nuplink count and uplink order. While the vSphere Distributed Switch has a\ndefault policy of using the first uplink as an active uplink and the second\none as a standby, the overridden port group policy means that both uplinks\nwill be used as active uplinks in this specific port group.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vds = new vsphere.DistributedVirtualSwitch(\"vds\", {\n    name: \"vds-01\",\n    datacenterId: datacenter.id,\n    uplinks: [\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    activeUplinks: [\"uplink1\"],\n    standbyUplinks: [\"uplink2\"],\n});\nconst pg = new vsphere.DistributedPortGroup(\"pg\", {\n    name: \"pg-01\",\n    distributedVirtualSwitchUuid: vds.id,\n    vlanId: 1000,\n    activeUplinks: [\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    standbyUplinks: [],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvds = vsphere.DistributedVirtualSwitch(\"vds\",\n    name=\"vds-01\",\n    datacenter_id=datacenter[\"id\"],\n    uplinks=[\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    active_uplinks=[\"uplink1\"],\n    standby_uplinks=[\"uplink2\"])\npg = vsphere.DistributedPortGroup(\"pg\",\n    name=\"pg-01\",\n    distributed_virtual_switch_uuid=vds.id,\n    vlan_id=1000,\n    active_uplinks=[\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    standby_uplinks=[])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vds = new VSphere.DistributedVirtualSwitch(\"vds\", new()\n    {\n        Name = \"vds-01\",\n        DatacenterId = datacenter.Id,\n        Uplinks = new[]\n        {\n            \"uplink1\",\n            \"uplink2\",\n        },\n        ActiveUplinks = new[]\n        {\n            \"uplink1\",\n        },\n        StandbyUplinks = new[]\n        {\n            \"uplink2\",\n        },\n    });\n\n    var pg = new VSphere.DistributedPortGroup(\"pg\", new()\n    {\n        Name = \"pg-01\",\n        DistributedVirtualSwitchUuid = vds.Id,\n        VlanId = 1000,\n        ActiveUplinks = new[]\n        {\n            \"uplink1\",\n            \"uplink2\",\n        },\n        StandbyUplinks = new[] {},\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tvds, err := vsphere.NewDistributedVirtualSwitch(ctx, \"vds\", \u0026vsphere.DistributedVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"vds-01\"),\n\t\t\tDatacenterId: pulumi.Any(datacenter.Id),\n\t\t\tUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"uplink1\"),\n\t\t\t\tpulumi.String(\"uplink2\"),\n\t\t\t},\n\t\t\tActiveUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"uplink1\"),\n\t\t\t},\n\t\t\tStandbyUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"uplink2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewDistributedPortGroup(ctx, \"pg\", \u0026vsphere.DistributedPortGroupArgs{\n\t\t\tName:                         pulumi.String(\"pg-01\"),\n\t\t\tDistributedVirtualSwitchUuid: vds.ID(),\n\t\t\tVlanId:                       pulumi.Int(1000),\n\t\t\tActiveUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"uplink1\"),\n\t\t\t\tpulumi.String(\"uplink2\"),\n\t\t\t},\n\t\t\tStandbyUplinks: pulumi.StringArray{},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.DistributedVirtualSwitch;\nimport com.pulumi.vsphere.DistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.DistributedPortGroup;\nimport com.pulumi.vsphere.DistributedPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vds = new DistributedVirtualSwitch(\"vds\", DistributedVirtualSwitchArgs.builder()\n            .name(\"vds-01\")\n            .datacenterId(datacenter.id())\n            .uplinks(            \n                \"uplink1\",\n                \"uplink2\")\n            .activeUplinks(\"uplink1\")\n            .standbyUplinks(\"uplink2\")\n            .build());\n\n        var pg = new DistributedPortGroup(\"pg\", DistributedPortGroupArgs.builder()\n            .name(\"pg-01\")\n            .distributedVirtualSwitchUuid(vds.id())\n            .vlanId(1000)\n            .activeUplinks(            \n                \"uplink1\",\n                \"uplink2\")\n            .standbyUplinks()\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vds:\n    type: vsphere:DistributedVirtualSwitch\n    properties:\n      name: vds-01\n      datacenterId: ${datacenter.id}\n      uplinks:\n        - uplink1\n        - uplink2\n      activeUplinks:\n        - uplink1\n      standbyUplinks:\n        - uplink2\n  pg:\n    type: vsphere:DistributedPortGroup\n    properties:\n      name: pg-01\n      distributedVirtualSwitchUuid: ${vds.id}\n      vlanId: 1000\n      activeUplinks:\n        - uplink1\n        - uplink2\n      standbyUplinks: []\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing port group can be imported into this resource using\n\nthe managed object id of the port group, via the following command:\n\n```sh\n$ pulumi import vsphere:index/distributedPortGroup:DistributedPortGroup pg /dc-01/network/pg-01\n```\n\nThe above would import the port group named `pg-01` that is located in the `dc-01`\n\ndatacenter.\n\n",
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n\n\u003e **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`\nmay lead to errors when the port count grows past the amount specified.  If you\nspecify `number_of_ports`, you may wish to set `auto_expand` to `false`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the blocked setting of an individual port to override the setting in the portgroup.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "The current version of the port group configuration,\nincremented by subsequent updates to the port group.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the VDS to add the\nport group to. Forces a new resource if changed.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The generated UUID of the port group.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a live port to be moved in and out of the portgroup.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network resource pool of an individual port to override the setting in the portgroup.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n\n[ext-vsphere-portname-format]: https://developer.broadcom.com/xapis/virtual-infrastructure-json-api/latest/data-structures/DVPortgroupConfigInfo/\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow security policy settings on a port to override those on the portgroup.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the traffic shaping policies of an individual port to override the settings in the portgroup.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any filter policies set on the individual port to override those in the portgroup.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the uplink teaming policies on a port to override those on the portgroup.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the VLAN configuration on a port to override those on the portgroup.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "directpathGen2Allowed",
                "distributedVirtualSwitchUuid",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "key",
                "lacpEnabled",
                "lacpMode",
                "name",
                "netflowEnabled",
                "notifySwitches",
                "numberOfPorts",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "vlanId",
                "vlanRanges"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n\n\u003e **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`\nmay lead to errors when the port count grows past the amount specified.  If you\nspecify `number_of_ports`, you may wish to set `auto_expand` to `false`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the blocked setting of an individual port to override the setting in the portgroup.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the VDS to add the\nport group to. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a live port to be moved in and out of the portgroup.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network resource pool of an individual port to override the setting in the portgroup.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n\n[ext-vsphere-portname-format]: https://developer.broadcom.com/xapis/virtual-infrastructure-json-api/latest/data-structures/DVPortgroupConfigInfo/\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow security policy settings on a port to override those on the portgroup.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the traffic shaping policies of an individual port to override the settings in the portgroup.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any filter policies set on the individual port to override those in the portgroup.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the uplink teaming policies on a port to override those on the portgroup.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the VLAN configuration on a port to override those on the portgroup.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "requiredInputs": [
                "distributedVirtualSwitchUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedPortGroup resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "autoExpand": {
                        "type": "boolean",
                        "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n\n\u003e **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`\nmay lead to errors when the port count grows past the amount specified.  If you\nspecify `number_of_ports`, you may wish to set `auto_expand` to `false`.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Indicates whether to block all ports by default.\n"
                    },
                    "blockOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the blocked setting of an individual port to override the setting in the portgroup.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing on the ports this policy applies to.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "The current version of the port group configuration,\nincremented by subsequent updates to the port group.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description for the port group.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "The ID of the VDS to add the\nport group to. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The generated UUID of the port group.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable LACP on all uplink ports.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                    },
                    "livePortMovingAllowed": {
                        "type": "boolean",
                        "description": "Allow a live port to be moved in and out of the portgroup.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether to enable netflow on all ports.\n"
                    },
                    "netflowOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.\n"
                    },
                    "networkResourcePoolKey": {
                        "type": "string",
                        "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                    },
                    "networkResourcePoolOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the network resource pool of an individual port to override the setting in the portgroup.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                    },
                    "portConfigResetAtDisconnect": {
                        "type": "boolean",
                        "description": "Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.\n"
                    },
                    "portNameFormat": {
                        "type": "string",
                        "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n\n[ext-vsphere-portname-format]: https://developer.broadcom.com/xapis/virtual-infrastructure-json-api/latest/data-structures/DVPortgroupConfigInfo/\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "The secondary VLAN ID for this port.\n"
                    },
                    "securityPolicyOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow security policy settings on a port to override those on the portgroup.\n"
                    },
                    "shapingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the traffic shaping policies of an individual port to override the settings in the portgroup.\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                    },
                    "trafficFilterOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow any filter policies set on the individual port to override those in the portgroup.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                    },
                    "uplinkTeamingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the uplink teaming policies on a port to override those on the portgroup.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the VLAN configuration on a port to override those on the portgroup.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                        },
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch": {
            "description": "The `vsphere.DistributedVirtualSwitch` resource can be used to manage vSphere\nDistributed Switches (VDS).\n\nAn essential component of a distributed, scalable vSphere infrastructure, the\nVDS provides centralized management and monitoring of the networking\nconfiguration for all the hosts that are associated with the switch.\nIn addition to adding distributed port groups\n(see the `vsphere.DistributedPortGroup` resource)\nthat can be used as networks for virtual machines, a VDS can be configured to\nperform advanced high availability, traffic shaping, network monitoring, etc.\n\nFor an overview on vSphere networking concepts, see\n[this page][ref-vsphere-net-concepts].\n\nFor more information on the VDS, see [this page][ref-vsphere-vds].\n\n[ref-vsphere-net-concepts]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches/dvport-groups.html\n[ref-vsphere-vds]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/basic-networking-with-vnetwork-distributed-switches.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on\ndirect ESXi host connections.\n\n## Example Usage\n\nThe following example below demonstrates a \"standard\" example of configuring a\nVDS in a 3-node vSphere datacenter named `dc1`, across 4 NICs with two being\nused as active, and two being used as passive. Note that the NIC failover order\npropagates to any port groups configured on this VDS and can be overridden.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst config = new pulumi.Config();\nconst hosts = config.getObject\u003cany\u003e(\"hosts\") || [\n    \"esxi-01.example.com\",\n    \"esxi-02.example.com\",\n    \"esxi-03.example.com\",\n];\nconst networkInterfaces = config.getObject\u003cany\u003e(\"networkInterfaces\") || [\n    \"vmnic0\",\n    \"vmnic1\",\n    \"vmnic2\",\n    \"vmnic3\",\n];\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = (new Array(hosts.length)).map((_, i) =\u003e i).map(__index =\u003e (vsphere.getHost({\n    name: hosts[__index],\n    datacenterId: _arg0_.id,\n})));\nconst vds = new vsphere.DistributedVirtualSwitch(\"vds\", {\n    name: \"vds-01\",\n    datacenterId: datacenter.then(datacenter =\u003e datacenter.id),\n    uplinks: [\n        \"uplink1\",\n        \"uplink2\",\n        \"uplink3\",\n        \"uplink4\",\n    ],\n    activeUplinks: [\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    standbyUplinks: [\n        \"uplink3\",\n        \"uplink4\",\n    ],\n    hosts: [\n        {\n            hostSystemId: host[0].then(host =\u003e host.id),\n            devices: [networkInterfaces],\n        },\n        {\n            hostSystemId: host[1].then(host =\u003e host.id),\n            devices: [networkInterfaces],\n        },\n        {\n            hostSystemId: host[2].then(host =\u003e host.id),\n            devices: [networkInterfaces],\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nconfig = pulumi.Config()\nhosts = config.get_object(\"hosts\")\nif hosts is None:\n    hosts = [\n        \"esxi-01.example.com\",\n        \"esxi-02.example.com\",\n        \"esxi-03.example.com\",\n    ]\nnetwork_interfaces = config.get_object(\"networkInterfaces\")\nif network_interfaces is None:\n    network_interfaces = [\n        \"vmnic0\",\n        \"vmnic1\",\n        \"vmnic2\",\n        \"vmnic3\",\n    ]\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = [vsphere.get_host(name=hosts[__index],\n    datacenter_id=datacenter.id) for __index in range(len(hosts))]\nvds = vsphere.DistributedVirtualSwitch(\"vds\",\n    name=\"vds-01\",\n    datacenter_id=datacenter.id,\n    uplinks=[\n        \"uplink1\",\n        \"uplink2\",\n        \"uplink3\",\n        \"uplink4\",\n    ],\n    active_uplinks=[\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    standby_uplinks=[\n        \"uplink3\",\n        \"uplink4\",\n    ],\n    hosts=[\n        {\n            \"host_system_id\": host[0].id,\n            \"devices\": [network_interfaces],\n        },\n        {\n            \"host_system_id\": host[1].id,\n            \"devices\": [network_interfaces],\n        },\n        {\n            \"host_system_id\": host[2].id,\n            \"devices\": [network_interfaces],\n        },\n    ])\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Uplink name and count control\n\nThe following abridged example below demonstrates how you can manage the number\nof uplinks, and the name of the uplinks via the `uplinks` parameter.\n\nNote that if you change the uplink naming and count after creating the VDS, you\nmay need to explicitly specify `active_uplinks` and `standby_uplinks` as these\nvalues are saved to state after creation, regardless of being\nspecified in config, and will drift if not modified, causing errors.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vds = new vsphere.DistributedVirtualSwitch(\"vds\", {\n    name: \"vds-01\",\n    datacenterId: datacenter.id,\n    uplinks: [\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    activeUplinks: [\"uplink1\"],\n    standbyUplinks: [\"uplink2\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvds = vsphere.DistributedVirtualSwitch(\"vds\",\n    name=\"vds-01\",\n    datacenter_id=datacenter[\"id\"],\n    uplinks=[\n        \"uplink1\",\n        \"uplink2\",\n    ],\n    active_uplinks=[\"uplink1\"],\n    standby_uplinks=[\"uplink2\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vds = new VSphere.DistributedVirtualSwitch(\"vds\", new()\n    {\n        Name = \"vds-01\",\n        DatacenterId = datacenter.Id,\n        Uplinks = new[]\n        {\n            \"uplink1\",\n            \"uplink2\",\n        },\n        ActiveUplinks = new[]\n        {\n            \"uplink1\",\n        },\n        StandbyUplinks = new[]\n        {\n            \"uplink2\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDistributedVirtualSwitch(ctx, \"vds\", \u0026vsphere.DistributedVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"vds-01\"),\n\t\t\tDatacenterId: pulumi.Any(datacenter.Id),\n\t\t\tUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"uplink1\"),\n\t\t\t\tpulumi.String(\"uplink2\"),\n\t\t\t},\n\t\t\tActiveUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"uplink1\"),\n\t\t\t},\n\t\t\tStandbyUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"uplink2\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.DistributedVirtualSwitch;\nimport com.pulumi.vsphere.DistributedVirtualSwitchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vds = new DistributedVirtualSwitch(\"vds\", DistributedVirtualSwitchArgs.builder()\n            .name(\"vds-01\")\n            .datacenterId(datacenter.id())\n            .uplinks(            \n                \"uplink1\",\n                \"uplink2\")\n            .activeUplinks(\"uplink1\")\n            .standbyUplinks(\"uplink2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vds:\n    type: vsphere:DistributedVirtualSwitch\n    properties:\n      name: vds-01\n      datacenterId: ${datacenter.id}\n      uplinks:\n        - uplink1\n        - uplink2\n      activeUplinks:\n        - uplink1\n      standbyUplinks:\n        - uplink2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003e **NOTE:** The default uplink names when a VDS is created are `uplink1`\nthrough to `uplink4`, however this default is not guaranteed to be stable and\nyou are encouraged to set your own.\n\n## Import\n\nAn existing VDS can be imported into this resource via the path\n\nto the VDS, via the following command:\n\n```sh\n$ pulumi import vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch vds /dc-01/network/vds-01\n```\n\nThe above would import the VDS named `vds-01` that is located in the `dc-01`\n\ndatacenter.\n\n",
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "backupnfcMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                },
                "backupnfcShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "The current version of the VDS configuration, incremented\nby subsequent updates to the VDS.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the VDS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nVDS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for VDS.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand requires vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VDS will be\ncreated. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the VDS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder in which to create the VDS.\nForces a new resource if changed.\n"
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "A host member specification.\n"
                },
                "ignoreOtherPvlanMappings": {
                    "type": "boolean",
                    "description": "Whether to ignore existing PVLAN mappings not managed by this resource.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the VDS. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the VDS.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the VDS. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VDS.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which active flows are forced to be exported to the collector.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the netflow collector, using IPv4 or IPv6.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "The port for the netflow collector.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which idle flows are forced to be exported to the collector.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to traffic that has both source and destination served by the same host.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation Domain ID for the netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all\npackets are analyzed.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The network I/O control version to use. Can be one of version2 or version3.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "pvlanMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                    },
                    "description": "A private VLAN (PVLAN) mapping.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS\nacross hosts.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the VDS. BY default, a VDS is created\nat the latest version supported by the vSphere version if not specified.\nA VDS can be upgraded to a newer version, but can not be downgraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "backupnfcMaximumMbit",
                "backupnfcReservationMbit",
                "backupnfcShareCount",
                "backupnfcShareLevel",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "datacenterId",
                "directpathGen2Allowed",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "faulttoleranceMaximumMbit",
                "faulttoleranceReservationMbit",
                "faulttoleranceShareCount",
                "faulttoleranceShareLevel",
                "hbrMaximumMbit",
                "hbrReservationMbit",
                "hbrShareCount",
                "hbrShareLevel",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "iscsiMaximumMbit",
                "iscsiReservationMbit",
                "iscsiShareCount",
                "iscsiShareLevel",
                "lacpApiVersion",
                "lacpEnabled",
                "lacpMode",
                "managementMaximumMbit",
                "managementReservationMbit",
                "managementShareCount",
                "managementShareLevel",
                "maxMtu",
                "multicastFilteringMode",
                "name",
                "netflowEnabled",
                "networkResourceControlVersion",
                "nfsMaximumMbit",
                "nfsReservationMbit",
                "nfsShareCount",
                "nfsShareLevel",
                "notifySwitches",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "uplinks",
                "vdpMaximumMbit",
                "vdpReservationMbit",
                "vdpShareCount",
                "vdpShareLevel",
                "version",
                "virtualmachineMaximumMbit",
                "virtualmachineReservationMbit",
                "virtualmachineShareCount",
                "virtualmachineShareLevel",
                "vlanId",
                "vlanRanges",
                "vmotionMaximumMbit",
                "vmotionReservationMbit",
                "vmotionShareCount",
                "vmotionShareLevel",
                "vsanMaximumMbit",
                "vsanReservationMbit",
                "vsanShareCount",
                "vsanShareLevel"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "backupnfcMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                },
                "backupnfcShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the VDS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nVDS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for VDS.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand requires vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VDS will be\ncreated. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the VDS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder in which to create the VDS.\nForces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "A host member specification.\n"
                },
                "ignoreOtherPvlanMappings": {
                    "type": "boolean",
                    "description": "Whether to ignore existing PVLAN mappings not managed by this resource.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the VDS. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the VDS.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the VDS. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VDS.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which active flows are forced to be exported to the collector.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the netflow collector, using IPv4 or IPv6.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "The port for the netflow collector.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which idle flows are forced to be exported to the collector.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to traffic that has both source and destination served by the same host.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation Domain ID for the netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all\npackets are analyzed.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The network I/O control version to use. Can be one of version2 or version3.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "pvlanMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                    },
                    "description": "A private VLAN (PVLAN) mapping.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS\nacross hosts.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the VDS. BY default, a VDS is created\nat the latest version supported by the vSphere version if not specified.\nA VDS can be upgraded to a newer version, but can not be downgraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedVirtualSwitch resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "backupnfcMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                    },
                    "backupnfcReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                    },
                    "backupnfcShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                    },
                    "backupnfcShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Indicates whether to block all ports by default.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing on the ports this policy applies to.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "The current version of the VDS configuration, incremented\nby subsequent updates to the VDS.\n"
                    },
                    "contactDetail": {
                        "type": "string",
                        "description": "The detailed contact information for the person\nwho is responsible for the VDS.\n"
                    },
                    "contactName": {
                        "type": "string",
                        "description": "The name of the person who is responsible for the\nVDS.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue strings to set for VDS.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand requires vCenter Server.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter where the VDS will be\ncreated. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A detailed description for the VDS.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "faulttoleranceMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                    },
                    "faulttoleranceShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder in which to create the VDS.\nForces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "hbrMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                    },
                    "hbrShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                        },
                        "description": "A host member specification.\n"
                    },
                    "ignoreOtherPvlanMappings": {
                        "type": "boolean",
                        "description": "Whether to ignore existing PVLAN mappings not managed by this resource.\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ipv4Address": {
                        "type": "string",
                        "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments.\n"
                    },
                    "iscsiMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                    },
                    "iscsiShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "lacpApiVersion": {
                        "type": "string",
                        "description": "The Link Aggregation Control Protocol group\nversion to use with the VDS. Possible values are `singleLag` and\n`multipleLag`.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable LACP on all uplink ports.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                    },
                    "managementMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                    },
                    "managementShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "maxMtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the VDS.\n"
                    },
                    "multicastFilteringMode": {
                        "type": "string",
                        "description": "The multicast filtering mode to use\nwith the VDS. Can be one of `legacyFiltering` or `snooping`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VDS.\n"
                    },
                    "netflowActiveFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which active flows are forced to be exported to the collector.\n"
                    },
                    "netflowCollectorIpAddress": {
                        "type": "string",
                        "description": "IP address for the netflow collector, using IPv4 or IPv6.\n"
                    },
                    "netflowCollectorPort": {
                        "type": "integer",
                        "description": "The port for the netflow collector.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether to enable netflow on all ports.\n"
                    },
                    "netflowIdleFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which idle flows are forced to be exported to the collector.\n"
                    },
                    "netflowInternalFlowsOnly": {
                        "type": "boolean",
                        "description": "Whether to limit analysis to traffic that has both source and destination served by the same host.\n"
                    },
                    "netflowObservationDomainId": {
                        "type": "integer",
                        "description": "The observation Domain ID for the netflow collector.\n"
                    },
                    "netflowSamplingRate": {
                        "type": "integer",
                        "description": "The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all\npackets are analyzed.\n"
                    },
                    "networkResourceControlEnabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.\n"
                    },
                    "networkResourceControlVersion": {
                        "type": "string",
                        "description": "The network I/O control version to use. Can be one of version2 or version3.\n"
                    },
                    "nfsMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                    },
                    "nfsShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "The secondary VLAN ID for this port.\n"
                    },
                    "pvlanMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                        },
                        "description": "A private VLAN (PVLAN) mapping.\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                    },
                    "uplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS\nacross hosts.\n"
                    },
                    "vdpMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                    },
                    "vdpShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the VDS. BY default, a VDS is created\nat the latest version supported by the vSphere version if not specified.\nA VDS can be upgraded to a newer version, but can not be downgraded.\n"
                    },
                    "virtualmachineMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                    },
                    "virtualmachineShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                        },
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vmotionMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                    },
                    "vmotionShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vsanMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                    },
                    "vsanShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping": {
            "properties": {
                "distributedVirtualSwitchId": {
                    "type": "string",
                    "description": "The ID of the distributed virtual switch to attach this mapping to.\n"
                },
                "primaryVlanId": {
                    "type": "integer",
                    "description": "The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n"
                },
                "pvlanType": {
                    "type": "string",
                    "description": "The private VLAN type. Valid values are promiscuous, community and isolated.\n"
                },
                "secondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n"
                }
            },
            "required": [
                "distributedVirtualSwitchId",
                "primaryVlanId",
                "pvlanType",
                "secondaryVlanId"
            ],
            "inputProperties": {
                "distributedVirtualSwitchId": {
                    "type": "string",
                    "description": "The ID of the distributed virtual switch to attach this mapping to.\n",
                    "willReplaceOnChanges": true
                },
                "primaryVlanId": {
                    "type": "integer",
                    "description": "The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n",
                    "willReplaceOnChanges": true
                },
                "pvlanType": {
                    "type": "string",
                    "description": "The private VLAN type. Valid values are promiscuous, community and isolated.\n",
                    "willReplaceOnChanges": true
                },
                "secondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "distributedVirtualSwitchId",
                "primaryVlanId",
                "pvlanType",
                "secondaryVlanId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedVirtualSwitchPvlanMapping resources.\n",
                "properties": {
                    "distributedVirtualSwitchId": {
                        "type": "string",
                        "description": "The ID of the distributed virtual switch to attach this mapping to.\n",
                        "willReplaceOnChanges": true
                    },
                    "primaryVlanId": {
                        "type": "integer",
                        "description": "The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n",
                        "willReplaceOnChanges": true
                    },
                    "pvlanType": {
                        "type": "string",
                        "description": "The private VLAN type. Valid values are promiscuous, community and isolated.\n",
                        "willReplaceOnChanges": true
                    },
                    "secondaryVlanId": {
                        "type": "integer",
                        "description": "The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/dpmHostOverride:DpmHostOverride": {
            "description": "The `vsphere.DpmHostOverride` resource can be used to add a DPM override to a\ncluster for a particular host. This allows you to control the power management\nsettings for individual hosts in the cluster while leaving any unspecified ones\nat the default power management settings.\n\nFor more information on DPM within vSphere clusters, see [this\npage][ref-vsphere-cluster-dpm].\n\n[ref-vsphere-cluster-dpm]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-resource-management-8-0/using-drs-clusters-to-manage-resources/managing-power-resources.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n## Import\n\nAn existing override can be imported into this resource by\n\nsupplying both the path to the cluster, and the path to the host, to `terraform\n\nimport`. If no override exists, an error will be given.  An example is below:\n\n```sh\n$ pulumi import vsphere:index/dpmHostOverride:DpmHostOverride dpm_host_override \\\n```\n\n  '{\"compute_cluster_path\": \"/dc1/host/cluster1\", \\\n\n  \"host_path\": \"/dc1/host/esxi1\"}'\n\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`dpm_enabled` or `dpm_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n"
                }
            },
            "required": [
                "computeClusterId",
                "hostSystemId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`dpm_enabled` or `dpm_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DpmHostOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`dpm_enabled` or `dpm_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for this host. Default:\n`false`.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of the host.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/drsVmOverride:DrsVmOverride": {
            "description": "The `vsphere.DrsVmOverride` resource can be used to add a DRS override to a\ncluster for a specific virtual machine. With this resource, one can enable or\ndisable DRS and control the automation level for a single virtual machine\nwithout affecting the rest of the cluster.\n\nFor more information on vSphere clusters and DRS, see [this\npage][ref-vsphere-drs-clusters].\n\n[ref-vsphere-drs-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-resource-management-8-0/creating-a-drs-cluster.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n## Example Usage\n\nThe example below creates a virtual machine in a cluster using the\n`vsphere.VirtualMachine` resource, creating the\nvirtual machine in the cluster looked up by the\n`vsphere.ComputeCluster` data source, but also\npinning the VM to a host defined by the\n`vsphere.Host` data source, which is assumed to\nbe a host within the cluster. To ensure that the VM stays on this host and does\nnot need to be migrated back at any point in time, an override is entered using\nthe `vsphere.DrsVmOverride` resource that disables DRS for this virtual\nmachine, ensuring that it does not move.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore1\",\n    datacenterId: datacenter.id,\n}));\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"network1\",\n    datacenterId: datacenter.id,\n}));\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    name: \"test\",\n    resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n    hostSystemId: host.then(host =\u003e host.id),\n    datastoreId: datastore.then(datastore =\u003e datastore.id),\n    numCpus: 2,\n    memory: 2048,\n    guestId: \"otherLinux64Guest\",\n    networkInterfaces: [{\n        networkId: network.then(network =\u003e network.id),\n    }],\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n});\nconst drsVmOverride = new vsphere.DrsVmOverride(\"drs_vm_override\", {\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineId: vm.id,\n    drsEnabled: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore1\",\n    datacenter_id=datacenter.id)\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"network1\",\n    datacenter_id=datacenter.id)\nvm = vsphere.VirtualMachine(\"vm\",\n    name=\"test\",\n    resource_pool_id=cluster.resource_pool_id,\n    host_system_id=host.id,\n    datastore_id=datastore.id,\n    num_cpus=2,\n    memory=2048,\n    guest_id=\"otherLinux64Guest\",\n    network_interfaces=[{\n        \"network_id\": network.id,\n    }],\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }])\ndrs_vm_override = vsphere.DrsVmOverride(\"drs_vm_override\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_id=vm.id,\n    drs_enabled=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"network1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vm = new VSphere.VirtualMachine(\"vm\", new()\n    {\n        Name = \"test\",\n        ResourcePoolId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        NumCpus = 2,\n        Memory = 2048,\n        GuestId = \"otherLinux64Guest\",\n        NetworkInterfaces = new[]\n        {\n            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n            {\n                NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n            },\n        },\n        Disks = new[]\n        {\n            new VSphere.Inputs.VirtualMachineDiskArgs\n            {\n                Label = \"disk0\",\n                Size = 20,\n            },\n        },\n    });\n\n    var drsVmOverride = new VSphere.DrsVmOverride(\"drs_vm_override\", new()\n    {\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        VirtualMachineId = vm.Id,\n        DrsEnabled = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnetwork, err := vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"network1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvm, err := vsphere.NewVirtualMachine(ctx, \"vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tName:           pulumi.String(\"test\"),\n\t\t\tResourcePoolId: pulumi.String(cluster.ResourcePoolId),\n\t\t\tHostSystemId:   pulumi.String(host.Id),\n\t\t\tDatastoreId:    pulumi.String(datastore.Id),\n\t\t\tNumCpus:        pulumi.Int(2),\n\t\t\tMemory:         pulumi.Int(2048),\n\t\t\tGuestId:        pulumi.String(\"otherLinux64Guest\"),\n\t\t\tNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\t\t\t\t\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\n\t\t\t\t\tNetworkId: pulumi.String(network.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDisks: vsphere.VirtualMachineDiskArray{\n\t\t\t\t\u0026vsphere.VirtualMachineDiskArgs{\n\t\t\t\t\tLabel: pulumi.String(\"disk0\"),\n\t\t\t\t\tSize:  pulumi.Int(20),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewDrsVmOverride(ctx, \"drs_vm_override\", \u0026vsphere.DrsVmOverrideArgs{\n\t\t\tComputeClusterId: pulumi.String(cluster.Id),\n\t\t\tVirtualMachineId: vm.ID(),\n\t\t\tDrsEnabled:       pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;\nimport com.pulumi.vsphere.DrsVmOverride;\nimport com.pulumi.vsphere.DrsVmOverrideArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"network1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var vm = new VirtualMachine(\"vm\", VirtualMachineArgs.builder()\n            .name(\"test\")\n            .resourcePoolId(cluster.resourcePoolId())\n            .hostSystemId(host.id())\n            .datastoreId(datastore.id())\n            .numCpus(2)\n            .memory(2048)\n            .guestId(\"otherLinux64Guest\")\n            .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                .networkId(network.id())\n                .build())\n            .disks(VirtualMachineDiskArgs.builder()\n                .label(\"disk0\")\n                .size(20)\n                .build())\n            .build());\n\n        var drsVmOverride = new DrsVmOverride(\"drsVmOverride\", DrsVmOverrideArgs.builder()\n            .computeClusterId(cluster.id())\n            .virtualMachineId(vm.id())\n            .drsEnabled(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      name: test\n      resourcePoolId: ${cluster.resourcePoolId}\n      hostSystemId: ${host.id}\n      datastoreId: ${datastore.id}\n      numCpus: 2\n      memory: 2048\n      guestId: otherLinux64Guest\n      networkInterfaces:\n        - networkId: ${network.id}\n      disks:\n        - label: disk0\n          size: 20\n  drsVmOverride:\n    type: vsphere:DrsVmOverride\n    name: drs_vm_override\n    properties:\n      computeClusterId: ${cluster.id}\n      virtualMachineId: ${vm.id}\n      drsEnabled: false\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  datastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: datastore1\n        datacenterId: ${datacenter.id}\n  cluster:\n    fn::invoke:\n      function: vsphere:getComputeCluster\n      arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  network:\n    fn::invoke:\n      function: vsphere:getNetwork\n      arguments:\n        name: network1\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing override can be imported into this resource by\n\nsupplying both the path to the cluster, and the path to the virtual machine, to\n\n`pulumi import`. If no override exists, an error will be given.  An example\n\nis below:\n\n```sh\n$ pulumi import vsphere:index/drsVmOverride:DrsVmOverride drs_vm_override \\\n```\n\n  '{\"compute_cluster_path\": \"/dc1/host/cluster1\", \\\n\n  \"virtual_machine_path\": \"/dc1/vm/srv1\"}'\n\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`drs_enabled` or `drs_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`drs_enabled` or `drs_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DrsVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`drs_enabled` or `drs_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/entityPermissions:EntityPermissions": {
            "properties": {
                "entityId": {
                    "type": "string",
                    "description": "The managed object id (uuid for some entities) on\nwhich permissions are to be created.\n"
                },
                "entityType": {
                    "type": "string",
                    "description": "The managed object type, types can be found in the\nmanaged object type section\n[here](https://developer.broadcom.com/xapis/vsphere-web-services-api/latest/).\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                    },
                    "description": "The permissions to be given on this entity. Keep\nthe permissions sorted alphabetically on `user_or_group` for a better user\nexperience.\n"
                }
            },
            "required": [
                "entityId",
                "entityType",
                "permissions"
            ],
            "inputProperties": {
                "entityId": {
                    "type": "string",
                    "description": "The managed object id (uuid for some entities) on\nwhich permissions are to be created.\n"
                },
                "entityType": {
                    "type": "string",
                    "description": "The managed object type, types can be found in the\nmanaged object type section\n[here](https://developer.broadcom.com/xapis/vsphere-web-services-api/latest/).\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                    },
                    "description": "The permissions to be given on this entity. Keep\nthe permissions sorted alphabetically on `user_or_group` for a better user\nexperience.\n"
                }
            },
            "requiredInputs": [
                "entityId",
                "entityType",
                "permissions"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityPermissions resources.\n",
                "properties": {
                    "entityId": {
                        "type": "string",
                        "description": "The managed object id (uuid for some entities) on\nwhich permissions are to be created.\n"
                    },
                    "entityType": {
                        "type": "string",
                        "description": "The managed object type, types can be found in the\nmanaged object type section\n[here](https://developer.broadcom.com/xapis/vsphere-web-services-api/latest/).\n"
                    },
                    "permissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                        },
                        "description": "The permissions to be given on this entity. Keep\nthe permissions sorted alphabetically on `user_or_group` for a better user\nexperience.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/file:File": {
            "description": "## Example Usage\n\n### Uploading a File\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuVmdkUpload = new vsphere.File(\"ubuntu_vmdk_upload\", {\n    datacenter: \"dc-01\",\n    datastore: \"datastore-01\",\n    sourceFile: \"/my/src/path/custom_ubuntu.vmdk\",\n    destinationFile: \"/my/dst/path/custom_ubuntu.vmdk\",\n    createDirectories: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_vmdk_upload = vsphere.File(\"ubuntu_vmdk_upload\",\n    datacenter=\"dc-01\",\n    datastore=\"datastore-01\",\n    source_file=\"/my/src/path/custom_ubuntu.vmdk\",\n    destination_file=\"/my/dst/path/custom_ubuntu.vmdk\",\n    create_directories=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuVmdkUpload = new VSphere.File(\"ubuntu_vmdk_upload\", new()\n    {\n        Datacenter = \"dc-01\",\n        Datastore = \"datastore-01\",\n        SourceFile = \"/my/src/path/custom_ubuntu.vmdk\",\n        DestinationFile = \"/my/dst/path/custom_ubuntu.vmdk\",\n        CreateDirectories = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewFile(ctx, \"ubuntu_vmdk_upload\", \u0026vsphere.FileArgs{\n\t\t\tDatacenter:        pulumi.String(\"dc-01\"),\n\t\t\tDatastore:         pulumi.String(\"datastore-01\"),\n\t\t\tSourceFile:        pulumi.String(\"/my/src/path/custom_ubuntu.vmdk\"),\n\t\t\tDestinationFile:   pulumi.String(\"/my/dst/path/custom_ubuntu.vmdk\"),\n\t\t\tCreateDirectories: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.File;\nimport com.pulumi.vsphere.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntuVmdkUpload = new File(\"ubuntuVmdkUpload\", FileArgs.builder()\n            .datacenter(\"dc-01\")\n            .datastore(\"datastore-01\")\n            .sourceFile(\"/my/src/path/custom_ubuntu.vmdk\")\n            .destinationFile(\"/my/dst/path/custom_ubuntu.vmdk\")\n            .createDirectories(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuVmdkUpload:\n    type: vsphere:File\n    name: ubuntu_vmdk_upload\n    properties:\n      datacenter: dc-01\n      datastore: datastore-01\n      sourceFile: /my/src/path/custom_ubuntu.vmdk\n      destinationFile: /my/dst/path/custom_ubuntu.vmdk\n      createDirectories: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Copying a File\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuCopy = new vsphere.File(\"ubuntu_copy\", {\n    sourceDatacenter: \"dc-01\",\n    datacenter: \"dc-01\",\n    sourceDatastore: \"datastore-01\",\n    datastore: \"datastore-01\",\n    sourceFile: \"/my/src/path/custom_ubuntu.vmdk\",\n    destinationFile: \"/my/dst/path/custom_ubuntu.vmdk\",\n    createDirectories: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_copy = vsphere.File(\"ubuntu_copy\",\n    source_datacenter=\"dc-01\",\n    datacenter=\"dc-01\",\n    source_datastore=\"datastore-01\",\n    datastore=\"datastore-01\",\n    source_file=\"/my/src/path/custom_ubuntu.vmdk\",\n    destination_file=\"/my/dst/path/custom_ubuntu.vmdk\",\n    create_directories=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuCopy = new VSphere.File(\"ubuntu_copy\", new()\n    {\n        SourceDatacenter = \"dc-01\",\n        Datacenter = \"dc-01\",\n        SourceDatastore = \"datastore-01\",\n        Datastore = \"datastore-01\",\n        SourceFile = \"/my/src/path/custom_ubuntu.vmdk\",\n        DestinationFile = \"/my/dst/path/custom_ubuntu.vmdk\",\n        CreateDirectories = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewFile(ctx, \"ubuntu_copy\", \u0026vsphere.FileArgs{\n\t\t\tSourceDatacenter:  pulumi.String(\"dc-01\"),\n\t\t\tDatacenter:        pulumi.String(\"dc-01\"),\n\t\t\tSourceDatastore:   pulumi.String(\"datastore-01\"),\n\t\t\tDatastore:         pulumi.String(\"datastore-01\"),\n\t\t\tSourceFile:        pulumi.String(\"/my/src/path/custom_ubuntu.vmdk\"),\n\t\t\tDestinationFile:   pulumi.String(\"/my/dst/path/custom_ubuntu.vmdk\"),\n\t\t\tCreateDirectories: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.File;\nimport com.pulumi.vsphere.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntuCopy = new File(\"ubuntuCopy\", FileArgs.builder()\n            .sourceDatacenter(\"dc-01\")\n            .datacenter(\"dc-01\")\n            .sourceDatastore(\"datastore-01\")\n            .datastore(\"datastore-01\")\n            .sourceFile(\"/my/src/path/custom_ubuntu.vmdk\")\n            .destinationFile(\"/my/dst/path/custom_ubuntu.vmdk\")\n            .createDirectories(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuCopy:\n    type: vsphere:File\n    name: ubuntu_copy\n    properties:\n      sourceDatacenter: dc-01\n      datacenter: dc-01\n      sourceDatastore: datastore-01\n      datastore: datastore-01\n      sourceFile: /my/src/path/custom_ubuntu.vmdk\n      destinationFile: /my/dst/path/custom_ubuntu.vmdk\n      createDirectories: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter on first apply if any are missing for copy operation.\n\n\u003e **NOTE:** Any directory created as part of the `create_directories` argument\nwill not be deleted when the resource is destroyed. New directories are not\ncreated if the `destination_file` path is changed in subsequent applies.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter to which the file will be\nuploaded.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore to which to upload the\nfile.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on the destination `datastore` in vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter from which the file\nwill be copied. Forces a new resource if changed.\n"
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore from which file will\nbe copied. Forces a new resource if changed.\n"
                },
                "sourceFile": {
                    "type": "string"
                }
            },
            "required": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "inputProperties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter on first apply if any are missing for copy operation.\n\n\u003e **NOTE:** Any directory created as part of the `create_directories` argument\nwill not be deleted when the resource is destroyed. New directories are not\ncreated if the `destination_file` path is changed in subsequent applies.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter to which the file will be\nuploaded.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore to which to upload the\nfile.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on the destination `datastore` in vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter from which the file\nwill be copied. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore from which file will\nbe copied. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "sourceFile": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering File resources.\n",
                "properties": {
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Create directories in `destination_file`\npath parameter on first apply if any are missing for copy operation.\n\n\u003e **NOTE:** Any directory created as part of the `create_directories` argument\nwill not be deleted when the resource is destroyed. New directories are not\ncreated if the `destination_file` path is changed in subsequent applies.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of a datacenter to which the file will be\nuploaded.\n"
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore to which to upload the\nfile.\n"
                    },
                    "destinationFile": {
                        "type": "string",
                        "description": "The path to where the file should be uploaded\nor copied to on the destination `datastore` in vSphere.\n"
                    },
                    "sourceDatacenter": {
                        "type": "string",
                        "description": "The name of a datacenter from which the file\nwill be copied. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceDatastore": {
                        "type": "string",
                        "description": "The name of the datastore from which file will\nbe copied. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceFile": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/folder:Folder": {
            "description": "The `vsphere.Folder` resource can be used to manage vSphere inventory folders.\nThe resource supports creating folders of the 5 major types - datacenter\nfolders, host and cluster folders, virtual machine folders, storage folders,\nand network folders.\n\nPaths are always relative to the specific type of folder you are creating.\nA subfolder is discovered by parsing the relative path specified in `path`, so\n`foo/bar` will create a folder named `bar` in the parent folder `foo`, as long\nas that folder exists.\n\n## Example Usage\n\nThe basic example below creates a virtual machine folder named\n`test-folder` in the default datacenter's VM hierarchy. \n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({});\nconst folder = new vsphere.Folder(\"folder\", {\n    path: \"test-folder\",\n    type: \"vm\",\n    datacenterId: datacenter.then(datacenter =\u003e datacenter.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter()\nfolder = vsphere.Folder(\"folder\",\n    path=\"test-folder\",\n    type=\"vm\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke();\n\n    var folder = new VSphere.Folder(\"folder\", new()\n    {\n        Path = \"test-folder\",\n        Type = \"vm\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewFolder(ctx, \"folder\", \u0026vsphere.FolderArgs{\n\t\t\tPath:         pulumi.String(\"test-folder\"),\n\t\t\tType:         pulumi.String(\"vm\"),\n\t\t\tDatacenterId: pulumi.String(datacenter.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.Folder;\nimport com.pulumi.vsphere.FolderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .build());\n\n        var folder = new Folder(\"folder\", FolderArgs.builder()\n            .path(\"test-folder\")\n            .type(\"vm\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  folder:\n    type: vsphere:Folder\n    properties:\n      path: test-folder\n      type: vm\n      datacenterId: ${datacenter.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example with subfolders\n\nThe below example builds off of the above by first creating a folder named\n`test-parent`, and then locating `test-folder` in that\nfolder. To ensure the parent is created first, we create an interpolation\ndependency off the parent's `path` attribute.\n\nNote that if you change parents (for example, went from the above basic\nconfiguration to this one), your folder will be moved to be under the correct\nparent.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({});\nconst parent = new vsphere.Folder(\"parent\", {\n    path: \"test-parent\",\n    type: \"vm\",\n    datacenterId: datacenter.then(datacenter =\u003e datacenter.id),\n});\nconst folder = new vsphere.Folder(\"folder\", {\n    path: pulumi.interpolate`${parent.path}/test-folder`,\n    type: \"vm\",\n    datacenterId: datacenter.then(datacenter =\u003e datacenter.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter()\nparent = vsphere.Folder(\"parent\",\n    path=\"test-parent\",\n    type=\"vm\",\n    datacenter_id=datacenter.id)\nfolder = vsphere.Folder(\"folder\",\n    path=parent.path.apply(lambda path: f\"{path}/test-folder\"),\n    type=\"vm\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke();\n\n    var parent = new VSphere.Folder(\"parent\", new()\n    {\n        Path = \"test-parent\",\n        Type = \"vm\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var folder = new VSphere.Folder(\"folder\", new()\n    {\n        Path = parent.Path.Apply(path =\u003e $\"{path}/test-folder\"),\n        Type = \"vm\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tparent, err := vsphere.NewFolder(ctx, \"parent\", \u0026vsphere.FolderArgs{\n\t\t\tPath:         pulumi.String(\"test-parent\"),\n\t\t\tType:         pulumi.String(\"vm\"),\n\t\t\tDatacenterId: pulumi.String(datacenter.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewFolder(ctx, \"folder\", \u0026vsphere.FolderArgs{\n\t\t\tPath: parent.Path.ApplyT(func(path string) (string, error) {\n\t\t\t\treturn fmt.Sprintf(\"%v/test-folder\", path), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t\tType:         pulumi.String(\"vm\"),\n\t\t\tDatacenterId: pulumi.String(datacenter.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.Folder;\nimport com.pulumi.vsphere.FolderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .build());\n\n        var parent = new Folder(\"parent\", FolderArgs.builder()\n            .path(\"test-parent\")\n            .type(\"vm\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var folder = new Folder(\"folder\", FolderArgs.builder()\n            .path(parent.path().applyValue(_path -\u003e String.format(\"%s/test-folder\", _path)))\n            .type(\"vm\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  parent:\n    type: vsphere:Folder\n    properties:\n      path: test-parent\n      type: vm\n      datacenterId: ${datacenter.id}\n  folder:\n    type: vsphere:Folder\n    properties:\n      path: ${parent.path}/test-folder\n      type: vm\n      datacenterId: ${datacenter.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing folder can be imported into this resource via\n\nits full path, via the following command:\n\n```sh\n$ pulumi import vsphere:index/folder:Folder folder /default-dc/vm/terraform-test-folder\n```\n\nThe above command would import the folder from our examples above, the VM\n\nfolder named `terraform-test-folder` located in the datacenter named\n\n`default-dc`.\n\n",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n\n\u003e **NOTE:** `path` can be modified - the resulting behavior is dependent on\nwhat section of `path` you are modifying. If you are modifying the parent (so\nany part before the last `/`), your folder will be moved to that new parent. If\nmodifying the name (the part after the last `/`), your folder will be renamed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "path",
                "type"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n\n\u003e **NOTE:** `path` can be modified - the resulting behavior is dependent on\nwhat section of `path` you are modifying. If you are modifying the parent (so\nany part before the last `/`), your folder will be moved to that new parent. If\nmodifying the name (the part after the last `/`), your folder will be renamed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "path",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Folder resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n\n\u003e **NOTE:** `path` can be modified - the resulting behavior is dependent on\nwhat section of `path` you are modifying. If you are modifying the parent (so\nany part before the last `/`), your folder will be moved to that new parent. If\nmodifying the name (the part after the last `/`), your folder will be renamed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/guestOsCustomization:GuestOsCustomization": {
            "description": "The `vsphere.GuestOsCustomization` resource can be used to a customization specification for a guest operating system.\n\n\u003e **NOTE:** The name attribute is unique identifier for the guest OS spec per VC.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst windows = new vsphere.GuestOsCustomization(\"windows\", {\n    name: \"windows\",\n    type: \"Windows\",\n    spec: {\n        windowsOptions: {\n            runOnceCommandLists: [\n                \"command-1\",\n                \"command-2\",\n            ],\n            computerName: \"windows\",\n            autoLogon: false,\n            autoLogonCount: 0,\n            adminPassword: \"VMware1!\",\n            timeZone: 4,\n            workgroup: \"workgroup\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nwindows = vsphere.GuestOsCustomization(\"windows\",\n    name=\"windows\",\n    type=\"Windows\",\n    spec={\n        \"windows_options\": {\n            \"run_once_command_lists\": [\n                \"command-1\",\n                \"command-2\",\n            ],\n            \"computer_name\": \"windows\",\n            \"auto_logon\": False,\n            \"auto_logon_count\": 0,\n            \"admin_password\": \"VMware1!\",\n            \"time_zone\": 4,\n            \"workgroup\": \"workgroup\",\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var windows = new VSphere.GuestOsCustomization(\"windows\", new()\n    {\n        Name = \"windows\",\n        Type = \"Windows\",\n        Spec = new VSphere.Inputs.GuestOsCustomizationSpecArgs\n        {\n            WindowsOptions = new VSphere.Inputs.GuestOsCustomizationSpecWindowsOptionsArgs\n            {\n                RunOnceCommandLists = new[]\n                {\n                    \"command-1\",\n                    \"command-2\",\n                },\n                ComputerName = \"windows\",\n                AutoLogon = false,\n                AutoLogonCount = 0,\n                AdminPassword = \"VMware1!\",\n                TimeZone = 4,\n                Workgroup = \"workgroup\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewGuestOsCustomization(ctx, \"windows\", \u0026vsphere.GuestOsCustomizationArgs{\n\t\t\tName: pulumi.String(\"windows\"),\n\t\t\tType: pulumi.String(\"Windows\"),\n\t\t\tSpec: \u0026vsphere.GuestOsCustomizationSpecArgs{\n\t\t\t\tWindowsOptions: \u0026vsphere.GuestOsCustomizationSpecWindowsOptionsArgs{\n\t\t\t\t\tRunOnceCommandLists: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"command-1\"),\n\t\t\t\t\t\tpulumi.String(\"command-2\"),\n\t\t\t\t\t},\n\t\t\t\t\tComputerName:   pulumi.String(\"windows\"),\n\t\t\t\t\tAutoLogon:      pulumi.Bool(false),\n\t\t\t\t\tAutoLogonCount: pulumi.Int(0),\n\t\t\t\t\tAdminPassword:  pulumi.String(\"VMware1!\"),\n\t\t\t\t\tTimeZone:       pulumi.Int(4),\n\t\t\t\t\tWorkgroup:      pulumi.String(\"workgroup\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.GuestOsCustomization;\nimport com.pulumi.vsphere.GuestOsCustomizationArgs;\nimport com.pulumi.vsphere.inputs.GuestOsCustomizationSpecArgs;\nimport com.pulumi.vsphere.inputs.GuestOsCustomizationSpecWindowsOptionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var windows = new GuestOsCustomization(\"windows\", GuestOsCustomizationArgs.builder()\n            .name(\"windows\")\n            .type(\"Windows\")\n            .spec(GuestOsCustomizationSpecArgs.builder()\n                .windowsOptions(GuestOsCustomizationSpecWindowsOptionsArgs.builder()\n                    .runOnceCommandLists(                    \n                        \"command-1\",\n                        \"command-2\")\n                    .computerName(\"windows\")\n                    .autoLogon(false)\n                    .autoLogonCount(0)\n                    .adminPassword(\"VMware1!\")\n                    .timeZone(4)\n                    .workgroup(\"workgroup\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  windows:\n    type: vsphere:GuestOsCustomization\n    properties:\n      name: windows\n      type: Windows\n      spec:\n        windowsOptions:\n          runOnceCommandLists:\n            - command-1\n            - command-2\n          computerName: windows\n          autoLogon: false\n          autoLogonCount: 0\n          adminPassword: VMware1!\n          timeZone: 4\n          workgroup: workgroup\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "changeVersion": {
                    "type": "string",
                    "description": "The number of last changed version to the customization specification.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description for the customization specification.\n"
                },
                "lastUpdateTime": {
                    "type": "string",
                    "description": "The time of last modification to the customization specification.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the customization specification is the unique identifier per vCenter Server instance.\n"
                },
                "spec": {
                    "$ref": "#/types/vsphere:index/GuestOsCustomizationSpec:GuestOsCustomizationSpec",
                    "description": "Container object for the Guest OS properties about to be customized . See virtual machine customizations\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of customization specification: One among: Windows, Linux.\n"
                }
            },
            "required": [
                "changeVersion",
                "lastUpdateTime",
                "name",
                "spec",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description for the customization specification.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the customization specification is the unique identifier per vCenter Server instance.\n"
                },
                "spec": {
                    "$ref": "#/types/vsphere:index/GuestOsCustomizationSpec:GuestOsCustomizationSpec",
                    "description": "Container object for the Guest OS properties about to be customized . See virtual machine customizations\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of customization specification: One among: Windows, Linux.\n"
                }
            },
            "requiredInputs": [
                "spec",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GuestOsCustomization resources.\n",
                "properties": {
                    "changeVersion": {
                        "type": "string",
                        "description": "The number of last changed version to the customization specification.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description for the customization specification.\n"
                    },
                    "lastUpdateTime": {
                        "type": "string",
                        "description": "The time of last modification to the customization specification.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the customization specification is the unique identifier per vCenter Server instance.\n"
                    },
                    "spec": {
                        "$ref": "#/types/vsphere:index/GuestOsCustomizationSpec:GuestOsCustomizationSpec",
                        "description": "Container object for the Guest OS properties about to be customized . See virtual machine customizations\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of customization specification: One among: Windows, Linux.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/haVmOverride:HaVmOverride": {
            "description": "The `vsphere.HaVmOverride` resource can be used to add an override for\nvSphere HA settings on a cluster for a specific virtual machine. With this\nresource, one can control specific HA settings so that they are different than\nthe cluster default, accommodating the needs of that specific virtual machine,\nwhile not affecting the rest of the cluster.\n\nFor more information on vSphere HA, see [this page][ref-vsphere-ha-clusters].\n\n[ref-vsphere-ha-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-availability.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n## Example Usage\n\nThe example below creates a virtual machine in a cluster using the\n`vsphere.VirtualMachine` resource, creating the\nvirtual machine in the cluster looked up by the\n`vsphere.ComputeCluster` data source.\n\nConsidering a scenario where this virtual machine is of high value to the\napplication or organization for which it does its work, it's been determined in\nthe event of a host failure, that this should be one of the first virtual\nmachines to be started by vSphere HA during recovery. Hence, it\n`ha_vm_restart_priority` has been set to `highest`,\nwhich, assuming that the default restart priority is `medium` and no other\nvirtual machine has been assigned the `highest` priority, will mean that this\nVM will be started before any other virtual machine in the event of host\nfailure.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore1\",\n    datacenterId: datacenter.id,\n}));\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"network1\",\n    datacenterId: datacenter.id,\n}));\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    name: \"test\",\n    resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n    datastoreId: datastore.then(datastore =\u003e datastore.id),\n    numCpus: 2,\n    memory: 2048,\n    guestId: \"otherLinux64Guest\",\n    networkInterfaces: [{\n        networkId: network.then(network =\u003e network.id),\n    }],\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n});\nconst haVmOverride = new vsphere.HaVmOverride(\"ha_vm_override\", {\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineId: vm.id,\n    haVmRestartPriority: \"highest\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore1\",\n    datacenter_id=datacenter.id)\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"network1\",\n    datacenter_id=datacenter.id)\nvm = vsphere.VirtualMachine(\"vm\",\n    name=\"test\",\n    resource_pool_id=cluster.resource_pool_id,\n    datastore_id=datastore.id,\n    num_cpus=2,\n    memory=2048,\n    guest_id=\"otherLinux64Guest\",\n    network_interfaces=[{\n        \"network_id\": network.id,\n    }],\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }])\nha_vm_override = vsphere.HaVmOverride(\"ha_vm_override\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_id=vm.id,\n    ha_vm_restart_priority=\"highest\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"network1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vm = new VSphere.VirtualMachine(\"vm\", new()\n    {\n        Name = \"test\",\n        ResourcePoolId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n        DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        NumCpus = 2,\n        Memory = 2048,\n        GuestId = \"otherLinux64Guest\",\n        NetworkInterfaces = new[]\n        {\n            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n            {\n                NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n            },\n        },\n        Disks = new[]\n        {\n            new VSphere.Inputs.VirtualMachineDiskArgs\n            {\n                Label = \"disk0\",\n                Size = 20,\n            },\n        },\n    });\n\n    var haVmOverride = new VSphere.HaVmOverride(\"ha_vm_override\", new()\n    {\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        VirtualMachineId = vm.Id,\n        HaVmRestartPriority = \"highest\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnetwork, err := vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"network1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvm, err := vsphere.NewVirtualMachine(ctx, \"vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tName:           pulumi.String(\"test\"),\n\t\t\tResourcePoolId: pulumi.String(cluster.ResourcePoolId),\n\t\t\tDatastoreId:    pulumi.String(datastore.Id),\n\t\t\tNumCpus:        pulumi.Int(2),\n\t\t\tMemory:         pulumi.Int(2048),\n\t\t\tGuestId:        pulumi.String(\"otherLinux64Guest\"),\n\t\t\tNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\t\t\t\t\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\n\t\t\t\t\tNetworkId: pulumi.String(network.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDisks: vsphere.VirtualMachineDiskArray{\n\t\t\t\t\u0026vsphere.VirtualMachineDiskArgs{\n\t\t\t\t\tLabel: pulumi.String(\"disk0\"),\n\t\t\t\t\tSize:  pulumi.Int(20),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHaVmOverride(ctx, \"ha_vm_override\", \u0026vsphere.HaVmOverrideArgs{\n\t\t\tComputeClusterId:    pulumi.String(cluster.Id),\n\t\t\tVirtualMachineId:    vm.ID(),\n\t\t\tHaVmRestartPriority: pulumi.String(\"highest\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;\nimport com.pulumi.vsphere.HaVmOverride;\nimport com.pulumi.vsphere.HaVmOverrideArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"network1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var vm = new VirtualMachine(\"vm\", VirtualMachineArgs.builder()\n            .name(\"test\")\n            .resourcePoolId(cluster.resourcePoolId())\n            .datastoreId(datastore.id())\n            .numCpus(2)\n            .memory(2048)\n            .guestId(\"otherLinux64Guest\")\n            .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                .networkId(network.id())\n                .build())\n            .disks(VirtualMachineDiskArgs.builder()\n                .label(\"disk0\")\n                .size(20)\n                .build())\n            .build());\n\n        var haVmOverride = new HaVmOverride(\"haVmOverride\", HaVmOverrideArgs.builder()\n            .computeClusterId(cluster.id())\n            .virtualMachineId(vm.id())\n            .haVmRestartPriority(\"highest\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      name: test\n      resourcePoolId: ${cluster.resourcePoolId}\n      datastoreId: ${datastore.id}\n      numCpus: 2\n      memory: 2048\n      guestId: otherLinux64Guest\n      networkInterfaces:\n        - networkId: ${network.id}\n      disks:\n        - label: disk0\n          size: 20\n  haVmOverride:\n    type: vsphere:HaVmOverride\n    name: ha_vm_override\n    properties:\n      computeClusterId: ${cluster.id}\n      virtualMachineId: ${vm.id}\n      haVmRestartPriority: highest\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  datastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: datastore1\n        datacenterId: ${datacenter.id}\n  cluster:\n    fn::invoke:\n      function: vsphere:getComputeCluster\n      arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n  network:\n    fn::invoke:\n      function: vsphere:getNetwork\n      arguments:\n        name: network1\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing override can be imported into this resource by\n\nsupplying both the path to the cluster, and the path to the virtual machine, to\n\n`pulumi import`. If no override exists, an error will be given.  An example\n\nis below:\n\n```sh\n$ pulumi import vsphere:index/haVmOverride:HaVmOverride ha_vm_override \\\n```\n\n  '{\"compute_cluster_path\": \"/dc1/host/cluster1\", \\\n\n  \"virtual_machine_path\": \"/dc1/vm/srv1\"}'\n\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object ID of the cluster.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine if an APD status on an affected datastore clears in the middle of an\nAPD event. Can be one of useClusterDefault, none or reset.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, restartConservative, or restartAggressive.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in seconds to wait after an APD timeout event to execute the response action defined in\nha_datastore_apd_response. Specify -1 to use the cluster setting.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine when the cluster has detected a permanent device loss to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, or restartAggressive.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual machine when a host is isolated from the rest of the cluster. Can be one of\nclusterIsolationResponse, none, powerOff, or shutdown.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual machine is not received within this configured interval, the virtual machine is marked\nas failed. The value is in seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will perform to this virtual machine when responding to a failure event.\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after powering on this virtual machine before monitoring for heartbeats.\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use for this virtual machine. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or not the cluster's default settings or the VM override settings specified in this resource are used\nfor virtual machine monitoring. The default is true (use cluster defaults) - set to false to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for this virtual machine when vSphere detects a host failure. Can be one of clusterRestartPriority,\nlowest, low, medium, high, or highest.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that vSphere HA will wait for the virtual machine to be ready. Use -1 to use the cluster\ndefault.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The managed object ID of the virtual machine.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object ID of the cluster.\n",
                    "willReplaceOnChanges": true
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine if an APD status on an affected datastore clears in the middle of an\nAPD event. Can be one of useClusterDefault, none or reset.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, restartConservative, or restartAggressive.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in seconds to wait after an APD timeout event to execute the response action defined in\nha_datastore_apd_response. Specify -1 to use the cluster setting.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine when the cluster has detected a permanent device loss to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, or restartAggressive.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual machine when a host is isolated from the rest of the cluster. Can be one of\nclusterIsolationResponse, none, powerOff, or shutdown.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual machine is not received within this configured interval, the virtual machine is marked\nas failed. The value is in seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will perform to this virtual machine when responding to a failure event.\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after powering on this virtual machine before monitoring for heartbeats.\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use for this virtual machine. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or not the cluster's default settings or the VM override settings specified in this resource are used\nfor virtual machine monitoring. The default is true (use cluster defaults) - set to false to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for this virtual machine when vSphere detects a host failure. Can be one of clusterRestartPriority,\nlowest, low, medium, high, or highest.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that vSphere HA will wait for the virtual machine to be ready. Use -1 to use the cluster\ndefault.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The managed object ID of the virtual machine.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HaVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object ID of the cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "Controls the action to take on this virtual machine if an APD status on an affected datastore clears in the middle of an\nAPD event. Can be one of useClusterDefault, none or reset.\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this virtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, restartConservative, or restartAggressive.\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "Controls the delay in seconds to wait after an APD timeout event to execute the response action defined in\nha_datastore_apd_response. Specify -1 to use the cluster setting.\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this virtual machine when the cluster has detected a permanent device loss to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, or restartAggressive.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on this virtual machine when a host is isolated from the rest of the cluster. Can be one of\nclusterIsolationResponse, none, powerOff, or shutdown.\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "If a heartbeat from this virtual machine is not received within this configured interval, the virtual machine is marked\nas failed. The value is in seconds.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will perform to this virtual machine when responding to a failure event.\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after powering on this virtual machine before monitoring for heartbeats.\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use for this virtual machine. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                    },
                    "haVmMonitoringUseClusterDefaults": {
                        "type": "boolean",
                        "description": "Determines whether or not the cluster's default settings or the VM override settings specified in this resource are used\nfor virtual machine monitoring. The default is true (use cluster defaults) - set to false to have overrides take effect.\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The restart priority for this virtual machine when vSphere detects a host failure. Can be one of clusterRestartPriority,\nlowest, low, medium, high, or highest.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds, that vSphere HA will wait for the virtual machine to be ready. Use -1 to use the cluster\ndefault.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The managed object ID of the virtual machine.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/host:Host": {
            "description": "Provides a VMware vSphere host resource. This represents an ESXi host that\ncan be used either as a member of a cluster or as a standalone host.\n\n## Example Usage\n\n### Create a standalone host\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst thumbprint = vsphere.getHostThumbprint({\n    address: \"esxi-01.example.com\",\n    insecure: true,\n});\nconst esx_01 = new vsphere.Host(\"esx-01\", {\n    hostname: \"esxi-01.example.com\",\n    username: \"root\",\n    password: \"password\",\n    license: \"00000-00000-00000-00000-00000\",\n    thumbprint: thumbprint.then(thumbprint =\u003e thumbprint.id),\n    datacenter: datacenter.then(datacenter =\u003e datacenter.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nthumbprint = vsphere.get_host_thumbprint(address=\"esxi-01.example.com\",\n    insecure=True)\nesx_01 = vsphere.Host(\"esx-01\",\n    hostname=\"esxi-01.example.com\",\n    username=\"root\",\n    password=\"password\",\n    license=\"00000-00000-00000-00000-00000\",\n    thumbprint=thumbprint.id,\n    datacenter=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var thumbprint = VSphere.GetHostThumbprint.Invoke(new()\n    {\n        Address = \"esxi-01.example.com\",\n        Insecure = true,\n    });\n\n    var esx_01 = new VSphere.Host(\"esx-01\", new()\n    {\n        Hostname = \"esxi-01.example.com\",\n        Username = \"root\",\n        Password = \"password\",\n        License = \"00000-00000-00000-00000-00000\",\n        Thumbprint = thumbprint.Apply(getHostThumbprintResult =\u003e getHostThumbprintResult.Id),\n        Datacenter = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthumbprint, err := vsphere.GetHostThumbprint(ctx, \u0026vsphere.GetHostThumbprintArgs{\n\t\t\tAddress:  \"esxi-01.example.com\",\n\t\t\tInsecure: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHost(ctx, \"esx-01\", \u0026vsphere.HostArgs{\n\t\t\tHostname:   pulumi.String(\"esxi-01.example.com\"),\n\t\t\tUsername:   pulumi.String(\"root\"),\n\t\t\tPassword:   pulumi.String(\"password\"),\n\t\t\tLicense:    pulumi.String(\"00000-00000-00000-00000-00000\"),\n\t\t\tThumbprint: pulumi.String(thumbprint.Id),\n\t\t\tDatacenter: pulumi.String(datacenter.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostThumbprintArgs;\nimport com.pulumi.vsphere.Host;\nimport com.pulumi.vsphere.HostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var thumbprint = VsphereFunctions.getHostThumbprint(GetHostThumbprintArgs.builder()\n            .address(\"esxi-01.example.com\")\n            .insecure(true)\n            .build());\n\n        var esx_01 = new Host(\"esx-01\", HostArgs.builder()\n            .hostname(\"esxi-01.example.com\")\n            .username(\"root\")\n            .password(\"password\")\n            .license(\"00000-00000-00000-00000-00000\")\n            .thumbprint(thumbprint.id())\n            .datacenter(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  esx-01:\n    type: vsphere:Host\n    properties:\n      hostname: esxi-01.example.com\n      username: root\n      password: password\n      license: 00000-00000-00000-00000-00000\n      thumbprint: ${thumbprint.id}\n      datacenter: ${datacenter.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  thumbprint:\n    fn::invoke:\n      function: vsphere:getHostThumbprint\n      arguments:\n        address: esxi-01.example.com\n        insecure: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing host can be imported into this resource by supplying\n\nthe host's ID.\n\n[docs-import]: /docs/import/index.html\n\nObtain the host's ID using the data source. For example:\n\nhcl\n\ndata \"vsphere_datacenter\" \"datacenter\" {\n\n  name = \"dc-01\"\n\n}\n\ndata \"vsphere_host\" \"host\" {\n\n  name          = \"esxi-01.example.com\"\n\n  datacenter_id = data.vsphere_datacenter.datacenter.id\n\n}\n\noutput \"host_id\" {\n\n  value = data.vsphere_host.host.id\n\n}\n\nNext, create a resource configuration, For example:\n\nhcl\n\ndata \"vsphere_datacenter\" \"datacenter\" {\n\n  name = \"dc-01\"\n\n}\n\ndata \"vsphere_host_thumbprint\" \"thumbprint\" {\n\n  address = \"esxi-01.example.com\"\n\n  insecure = true\n\n}\n\nresource \"vsphere_host\" \"esx-01\" {\n\n  hostname   = \"esxi-01.example.com\"\n\n  username   = \"root\"\n\n  password   = \"password\"\n\n  thumbprint = data.vsphere_host_thumbprint.thumbprint.id\n\n  datacenter = data.vsphere_datacenter.datacenter.id\n\n}\n\nhcl\n\nresource \"vsphere_host\" \"esx-01\" {\n\n  hostname   = \"esxi-01.example.com\"\n\n  username   = \"root\"\n\n  password   = \"password\"\n\n  license    = \"00000-00000-00000-00000-00000\"\n\n  thumbprint = data.vsphere_host_thumbprint.thumbprint.id\n\n  cluster    = data.vsphere_compute_cluster.cluster.id\n\n  services {\n\n    ntpd {\n\n      enabled     = true\n\n      policy      = \"on\"\n\n      ntp_servers = [\"pool.ntp.org\"]\n\n    }\n\n}\n\nconsole\n\n```sh\n$ pulumi import vsphere:index/host:Host esx-01 host-123\n```\n\nThe above would import the host `esxi-01.example.com` with the host ID `host-123`.\n\n",
            "properties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster_managed`.\n"
                },
                "clusterManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconnected.\nDefault is `false`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute IDs and string\nvalues to apply to the resource. Please refer to the\n`vsphere_custom_attributes` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n\n[docs-host-thumbprint-data-source]: /docs/providers/vsphere/d/host_thumbprint.html\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to `true` then it will force the host to be added,\neven if the host is already connected to a different vCenter Server instance.\nDefault is `false`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host.\nDefault is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n",
                    "secret": true
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/HostService:HostService"
                    },
                    "description": "Set Services on host, the settings to be set are based on service being set as part of import.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. Please\nrefer to the `vsphere.Tag` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Tagging support is not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the\nCA that signed the host's certificate should be trusted. If the CA is not\ntrusted and no thumbprint is set then the operation will fail. See data source\n[`vsphere.getHostThumbprint`][docs-host-thumbprint-data-source].\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "required": [
                "hostname",
                "password",
                "username"
            ],
            "inputProperties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster_managed`.\n"
                },
                "clusterManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconnected.\nDefault is `false`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute IDs and string\nvalues to apply to the resource. Please refer to the\n`vsphere_custom_attributes` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n\n[docs-host-thumbprint-data-source]: /docs/providers/vsphere/d/host_thumbprint.html\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to `true` then it will force the host to be added,\neven if the host is already connected to a different vCenter Server instance.\nDefault is `false`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host.\nDefault is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n",
                    "secret": true
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/HostService:HostService"
                    },
                    "description": "Set Services on host, the settings to be set are based on service being set as part of import.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. Please\nrefer to the `vsphere.Tag` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Tagging support is not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the\nCA that signed the host's certificate should be trusted. If the CA is not\ntrusted and no thumbprint is set then the operation will fail. See data source\n[`vsphere.getHostThumbprint`][docs-host-thumbprint-data-source].\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "requiredInputs": [
                "hostname",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Host resources.\n",
                "properties": {
                    "cluster": {
                        "type": "string",
                        "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster_managed`.\n"
                    },
                    "clusterManaged": {
                        "type": "boolean",
                        "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                    },
                    "connected": {
                        "type": "boolean",
                        "description": "If set to false then the host will be disconnected.\nDefault is `false`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute IDs and string\nvalues to apply to the resource. Please refer to the\n`vsphere_custom_attributes` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n\n[docs-host-thumbprint-data-source]: /docs/providers/vsphere/d/host_thumbprint.html\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                    },
                    "force": {
                        "type": "boolean",
                        "description": "If set to `true` then it will force the host to be added,\neven if the host is already connected to a different vCenter Server instance.\nDefault is `false`.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "FQDN or IP address of the host to be added.\n"
                    },
                    "license": {
                        "type": "string",
                        "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                    },
                    "lockdown": {
                        "type": "string",
                        "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                    },
                    "maintenance": {
                        "type": "boolean",
                        "description": "Set the management state of the host.\nDefault is `false`.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password that will be used by vSphere to authenticate\nto the host.\n",
                        "secret": true
                    },
                    "services": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/HostService:HostService"
                        },
                        "description": "Set Services on host, the settings to be set are based on service being set as part of import.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. Please\nrefer to the `vsphere.Tag` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Tagging support is not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                    },
                    "thumbprint": {
                        "type": "string",
                        "description": "Host's certificate SHA-1 thumbprint. If not set the\nCA that signed the host's certificate should be trusted. If the CA is not\ntrusted and no thumbprint is set then the operation will fail. See data source\n[`vsphere.getHostThumbprint`][docs-host-thumbprint-data-source].\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostPortGroup:HostPortGroup": {
            "description": "The `vsphere.HostPortGroup` resource can be used to manage port groups on\nESXi hosts. These port groups are connected to standard switches, which\ncan be managed by the `vsphere.HostVirtualSwitch`\nresource.\n\nFor an overview on vSphere networking concepts, see [the product documentation][ref-vsphere-net-concepts].\n\n[ref-vsphere-net-concepts]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/introduction-to-vsphere-networking.html\n\n## Example Usage\n\n**Create a Virtual Switch and Bind a Port Group:**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst hostVirtualSwitch = new vsphere.HostVirtualSwitch(\"host_virtual_switch\", {\n    name: \"switch-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    activeNics: [\"vmnic0\"],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    name: \"portgroup-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    virtualSwitchName: hostVirtualSwitch.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nhost_virtual_switch = vsphere.HostVirtualSwitch(\"host_virtual_switch\",\n    name=\"switch-01\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    active_nics=[\"vmnic0\"],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    name=\"portgroup-01\",\n    host_system_id=host.id,\n    virtual_switch_name=host_virtual_switch.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hostVirtualSwitch = new VSphere.HostVirtualSwitch(\"host_virtual_switch\", new()\n    {\n        Name = \"switch-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic0\",\n            \"vmnic1\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic0\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic1\",\n        },\n    });\n\n    var pg = new VSphere.HostPortGroup(\"pg\", new()\n    {\n        Name = \"portgroup-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        VirtualSwitchName = hostVirtualSwitch.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostVirtualSwitch, err := vsphere.NewHostVirtualSwitch(ctx, \"host_virtual_switch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"switch-01\"),\n\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tName:              pulumi.String(\"portgroup-01\"),\n\t\t\tHostSystemId:      pulumi.String(host.Id),\n\t\t\tVirtualSwitchName: hostVirtualSwitch.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport com.pulumi.vsphere.HostPortGroup;\nimport com.pulumi.vsphere.HostPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var hostVirtualSwitch = new HostVirtualSwitch(\"hostVirtualSwitch\", HostVirtualSwitchArgs.builder()\n            .name(\"switch-01\")\n            .hostSystemId(host.id())\n            .networkAdapters(            \n                \"vmnic0\",\n                \"vmnic1\")\n            .activeNics(\"vmnic0\")\n            .standbyNics(\"vmnic1\")\n            .build());\n\n        var pg = new HostPortGroup(\"pg\", HostPortGroupArgs.builder()\n            .name(\"portgroup-01\")\n            .hostSystemId(host.id())\n            .virtualSwitchName(hostVirtualSwitch.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hostVirtualSwitch:\n    type: vsphere:HostVirtualSwitch\n    name: host_virtual_switch\n    properties:\n      name: switch-01\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic0\n        - vmnic1\n      activeNics:\n        - vmnic0\n      standbyNics:\n        - vmnic1\n  pg:\n    type: vsphere:HostPortGroup\n    properties:\n      name: portgroup-01\n      hostSystemId: ${host.id}\n      virtualSwitchName: ${hostVirtualSwitch.name}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n**Create a Port Group with a VLAN and ab Override:**\n\nThis example sets the trunk mode VLAN (`4095`, which passes through all tags)\nand sets\n`allow_promiscuous`\nto ensure that all traffic is seen on the port. The setting overrides\nthe implicit default of `false` set on the standard switch.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst hostVirtualSwitch = new vsphere.HostVirtualSwitch(\"host_virtual_switch\", {\n    name: \"switch-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    activeNics: [\"vmnic0\"],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    name: \"portgroup-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    virtualSwitchName: hostVirtualSwitch.name,\n    vlanId: 4095,\n    allowPromiscuous: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nhost_virtual_switch = vsphere.HostVirtualSwitch(\"host_virtual_switch\",\n    name=\"switch-01\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    active_nics=[\"vmnic0\"],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    name=\"portgroup-01\",\n    host_system_id=host.id,\n    virtual_switch_name=host_virtual_switch.name,\n    vlan_id=4095,\n    allow_promiscuous=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hostVirtualSwitch = new VSphere.HostVirtualSwitch(\"host_virtual_switch\", new()\n    {\n        Name = \"switch-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic0\",\n            \"vmnic1\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic0\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic1\",\n        },\n    });\n\n    var pg = new VSphere.HostPortGroup(\"pg\", new()\n    {\n        Name = \"portgroup-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        VirtualSwitchName = hostVirtualSwitch.Name,\n        VlanId = 4095,\n        AllowPromiscuous = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostVirtualSwitch, err := vsphere.NewHostVirtualSwitch(ctx, \"host_virtual_switch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"switch-01\"),\n\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tName:              pulumi.String(\"portgroup-01\"),\n\t\t\tHostSystemId:      pulumi.String(host.Id),\n\t\t\tVirtualSwitchName: hostVirtualSwitch.Name,\n\t\t\tVlanId:            pulumi.Int(4095),\n\t\t\tAllowPromiscuous:  pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport com.pulumi.vsphere.HostPortGroup;\nimport com.pulumi.vsphere.HostPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var hostVirtualSwitch = new HostVirtualSwitch(\"hostVirtualSwitch\", HostVirtualSwitchArgs.builder()\n            .name(\"switch-01\")\n            .hostSystemId(host.id())\n            .networkAdapters(            \n                \"vmnic0\",\n                \"vmnic1\")\n            .activeNics(\"vmnic0\")\n            .standbyNics(\"vmnic1\")\n            .build());\n\n        var pg = new HostPortGroup(\"pg\", HostPortGroupArgs.builder()\n            .name(\"portgroup-01\")\n            .hostSystemId(host.id())\n            .virtualSwitchName(hostVirtualSwitch.name())\n            .vlanId(4095)\n            .allowPromiscuous(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hostVirtualSwitch:\n    type: vsphere:HostVirtualSwitch\n    name: host_virtual_switch\n    properties:\n      name: switch-01\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic0\n        - vmnic1\n      activeNics:\n        - vmnic0\n      standbyNics:\n        - vmnic1\n  pg:\n    type: vsphere:HostPortGroup\n    properties:\n      name: portgroup-01\n      hostSystemId: ${host.id}\n      virtualSwitchName: ${hostVirtualSwitch.name}\n      vlanId: 4095\n      allowPromiscuous: true\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing host port group can be imported into this resource\n\nusing the host port group's ID. An example is below:\n\n```sh\n$ pulumi import vsphere:index/hostPortGroup:HostPortGroup management tf-HostPortGroup:host-123:management\n```\n\nThe above would import the `management` host port group from host with ID `host-123`.\n\n",
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "computedPolicy": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/HostPortGroupPort:HostPortGroupPort"
                    },
                    "description": "A list of ports that currently exist and are used on this port group.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "required": [
                "computedPolicy",
                "hostSystemId",
                "key",
                "name",
                "ports",
                "virtualSwitchName"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "requiredInputs": [
                "hostSystemId",
                "virtualSwitchName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostPortGroup resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active network adapters used for load balancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                    },
                    "computedPolicy": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The key for this port group as returned from the vSphere API.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.  Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "ports": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/HostPortGroupPort:HostPortGroupPort"
                        },
                        "description": "A list of ports that currently exist and are used on this port group.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Enable traffic shaping on this virtual switch or port group.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby network adapters used for failover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                    },
                    "virtualSwitchName": {
                        "type": "string",
                        "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostVirtualSwitch:HostVirtualSwitch": {
            "description": "The `vsphere.HostVirtualSwitch` resource can be used to manage vSphere\nstandard switches on an ESXi host. These switches can be used as a backing for\nstandard port groups, which can be managed by the\n`vsphere.HostPortGroup` resource.\n\nFor an overview on vSphere networking concepts, see [this\npage][ref-vsphere-net-concepts].\n\n[ref-vsphere-net-concepts]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-networking-8-0/introduction-to-vsphere-networking.html\n\n## Example Usage\n\n### Create a virtual switch with one active and one standby NIC\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst _switch = new vsphere.HostVirtualSwitch(\"switch\", {\n    name: \"vSwitchTest\",\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    activeNics: [\"vmnic0\"],\n    standbyNics: [\"vmnic1\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nswitch = vsphere.HostVirtualSwitch(\"switch\",\n    name=\"vSwitchTest\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    active_nics=[\"vmnic0\"],\n    standby_nics=[\"vmnic1\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var @switch = new VSphere.HostVirtualSwitch(\"switch\", new()\n    {\n        Name = \"vSwitchTest\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic0\",\n            \"vmnic1\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic0\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic1\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostVirtualSwitch(ctx, \"switch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"vSwitchTest\"),\n\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var switch_ = new HostVirtualSwitch(\"switch\", HostVirtualSwitchArgs.builder()\n            .name(\"vSwitchTest\")\n            .hostSystemId(host.id())\n            .networkAdapters(            \n                \"vmnic0\",\n                \"vmnic1\")\n            .activeNics(\"vmnic0\")\n            .standbyNics(\"vmnic1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  switch:\n    type: vsphere:HostVirtualSwitch\n    properties:\n      name: vSwitchTest\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic0\n        - vmnic1\n      activeNics:\n        - vmnic0\n      standbyNics:\n        - vmnic1\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Create a virtual switch with extra networking policy options\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst _switch = new vsphere.HostVirtualSwitch(\"switch\", {\n    name: \"vSwitchTest\",\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    activeNics: [\"vmnic0\"],\n    standbyNics: [\"vmnic1\"],\n    teamingPolicy: \"failover_explicit\",\n    allowPromiscuous: false,\n    allowForgedTransmits: false,\n    allowMacChanges: false,\n    shapingEnabled: true,\n    shapingAverageBandwidth: 50000000,\n    shapingPeakBandwidth: 100000000,\n    shapingBurstSize: 1000000000,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nswitch = vsphere.HostVirtualSwitch(\"switch\",\n    name=\"vSwitchTest\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    active_nics=[\"vmnic0\"],\n    standby_nics=[\"vmnic1\"],\n    teaming_policy=\"failover_explicit\",\n    allow_promiscuous=False,\n    allow_forged_transmits=False,\n    allow_mac_changes=False,\n    shaping_enabled=True,\n    shaping_average_bandwidth=50000000,\n    shaping_peak_bandwidth=100000000,\n    shaping_burst_size=1000000000)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var @switch = new VSphere.HostVirtualSwitch(\"switch\", new()\n    {\n        Name = \"vSwitchTest\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic0\",\n            \"vmnic1\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic0\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic1\",\n        },\n        TeamingPolicy = \"failover_explicit\",\n        AllowPromiscuous = false,\n        AllowForgedTransmits = false,\n        AllowMacChanges = false,\n        ShapingEnabled = true,\n        ShapingAverageBandwidth = 50000000,\n        ShapingPeakBandwidth = 100000000,\n        ShapingBurstSize = 1000000000,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostVirtualSwitch(ctx, \"switch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"vSwitchTest\"),\n\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tTeamingPolicy:           pulumi.String(\"failover_explicit\"),\n\t\t\tAllowPromiscuous:        pulumi.Bool(false),\n\t\t\tAllowForgedTransmits:    pulumi.Bool(false),\n\t\t\tAllowMacChanges:         pulumi.Bool(false),\n\t\t\tShapingEnabled:          pulumi.Bool(true),\n\t\t\tShapingAverageBandwidth: pulumi.Int(50000000),\n\t\t\tShapingPeakBandwidth:    pulumi.Int(100000000),\n\t\t\tShapingBurstSize:        pulumi.Int(1000000000),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var switch_ = new HostVirtualSwitch(\"switch\", HostVirtualSwitchArgs.builder()\n            .name(\"vSwitchTest\")\n            .hostSystemId(host.id())\n            .networkAdapters(            \n                \"vmnic0\",\n                \"vmnic1\")\n            .activeNics(\"vmnic0\")\n            .standbyNics(\"vmnic1\")\n            .teamingPolicy(\"failover_explicit\")\n            .allowPromiscuous(false)\n            .allowForgedTransmits(false)\n            .allowMacChanges(false)\n            .shapingEnabled(true)\n            .shapingAverageBandwidth(50000000)\n            .shapingPeakBandwidth(100000000)\n            .shapingBurstSize(1000000000)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  switch:\n    type: vsphere:HostVirtualSwitch\n    properties:\n      name: vSwitchTest\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic0\n        - vmnic1\n      activeNics:\n        - vmnic0\n      standbyNics:\n        - vmnic1\n      teamingPolicy: failover_explicit\n      allowPromiscuous: false\n      allowForgedTransmits: false\n      allowMacChanges: false\n      shapingEnabled: true\n      shapingAverageBandwidth: 5e+07\n      shapingPeakBandwidth: 1e+08\n      shapingBurstSize: 1e+09\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing vSwitch can be imported into this resource by its ID.\n\nThe convention of the id is a prefix, the host system [managed objectID][docs-about-morefs], and the virtual switch\n\nname. An example would be `tf-HostVirtualSwitch:host-10:vSwitchTerraformTest`.\n\nImport can the be done via the following command:\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n\n```sh\n$ pulumi import vsphere:index/hostVirtualSwitch:HostVirtualSwitch switch tf-HostVirtualSwitch:host-10:vSwitchTerraformTest\n```\n\nThe above would import the vSwitch named `vSwitchTerraformTest` that is located in the `host-10`\n\nvSphere host.\n\n",
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "Determines how often, in seconds, a beacon should be sent to probe for the validity of a link.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid values are cdp and lldp.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n"
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of network adapters to bind to this virtual switch.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n\n\u003e **NOTE:** Changing the port count requires a reboot of the host. This provider\nwill not restart the host for you.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                }
            },
            "required": [
                "activeNics",
                "hostSystemId",
                "name",
                "networkAdapters"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "Determines how often, in seconds, a beacon should be sent to probe for the validity of a link.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid values are cdp and lldp.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of network adapters to bind to this virtual switch.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n\n\u003e **NOTE:** Changing the port count requires a reboot of the host. This provider\nwill not restart the host for you.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                }
            },
            "requiredInputs": [
                "activeNics",
                "hostSystemId",
                "networkAdapters"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostVirtualSwitch resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active network adapters used for load balancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "beaconInterval": {
                        "type": "integer",
                        "description": "Determines how often, in seconds, a beacon should be sent to probe for the validity of a link.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type. Valid values are cdp and lldp.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkAdapters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of network adapters to bind to this virtual switch.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n\n\u003e **NOTE:** Changing the port count requires a reboot of the host. This provider\nwill not restart the host for you.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Enable traffic shaping on this virtual switch or port group.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby network adapters used for failover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/license:License": {
            "description": "Provides a VMware vSphere license resource. This can be used to add and remove license keys.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  licenseKey:\n    type: vsphere:License\n    properties:\n      licenseKey: 452CQ-2EK54-K8742-00000-00000\n      labels:\n        - vpxClientLicenseLabel: Hello World\n          workflow: Hello World\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "editionKey": {
                    "type": "string",
                    "description": "The product edition of the license key.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name for the license.\n"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of units (example: CPUs) contained in the license.\n"
                },
                "used": {
                    "type": "integer",
                    "description": "The number of units (example: CPUs) assigned to this license.\n"
                }
            },
            "required": [
                "editionKey",
                "licenseKey",
                "name",
                "total",
                "used"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "licenseKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering License resources.\n",
                "properties": {
                    "editionKey": {
                        "type": "string",
                        "description": "The product edition of the license key.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                    },
                    "licenseKey": {
                        "type": "string",
                        "description": "The license key to add.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name for the license.\n"
                    },
                    "total": {
                        "type": "integer",
                        "description": "Total number of units (example: CPUs) contained in the license.\n"
                    },
                    "used": {
                        "type": "integer",
                        "description": "The number of units (example: CPUs) assigned to this license.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/nasDatastore:NasDatastore": {
            "description": "The `vsphere.NasDatastore` resource can be used to create and manage NAS\ndatastores on an ESXi host or a set of hosts. The resource supports mounting\nNFS v3 and v4.1 shares to be used as datastores.\n\n\u003e **NOTE:** Unlike `vsphere.VmfsDatastore`, a NAS\ndatastore is only mounted on the hosts you choose to mount it on. To mount on\nmultiple hosts, you must specify each host that you want to add in the\n`host_system_ids` argument.\n\n## Import\n\nAn existing NAS datastore can be imported into this resource via\n\nits managed object ID, via the following command:\n\n```sh\n$ pulumi import vsphere:index/nasDatastore:NasDatastore datastore datastore-123\n```\n\nYou need a tool like [`govc`][ext-govc] that can display managed object IDs.\n\n[ext-govc]: https://github.com/vmware/govmomi/tree/master/govc\n\nIn the case of govc, you can locate a managed object ID from an inventory path\n\nby doing the following:\n\n$ govc ls -i /dc/datastore/terraform-test\n\nDatastore:datastore-123\n\n",
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n"
                },
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "protocolEndpoint": {
                    "type": "boolean",
                    "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nservers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n"
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n"
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "freeSpace",
                "hostSystemIds",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "protocolEndpoint",
                "remoteHosts",
                "remotePath",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nservers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "hostSystemIds",
                "remoteHosts",
                "remotePath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NasDatastore resources.\n",
                "properties": {
                    "accessMode": {
                        "type": "string",
                        "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "protocolEndpoint": {
                        "type": "boolean",
                        "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                    },
                    "remoteHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The hostnames or IP addresses of the remote\nservers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "remotePath": {
                        "type": "string",
                        "description": "The remote path of the mount point. Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "securityType": {
                        "type": "string",
                        "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/offlineSoftwareDepot:OfflineSoftwareDepot": {
            "description": "Provides a VMware vSphere offline software depot resource.\n\n## Example Usage\n\n",
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/OfflineSoftwareDepotComponent:OfflineSoftwareDepotComponent"
                    },
                    "description": "The list of custom components in the depot.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The URL where the depot source is hosted.\n"
                }
            },
            "required": [
                "components",
                "location"
            ],
            "inputProperties": {
                "location": {
                    "type": "string",
                    "description": "The URL where the depot source is hosted.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "location"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OfflineSoftwareDepot resources.\n",
                "properties": {
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/OfflineSoftwareDepotComponent:OfflineSoftwareDepotComponent"
                        },
                        "description": "The list of custom components in the depot.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The URL where the depot source is hosted.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/resourcePool:ResourcePool": {
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource pool can grow beyond the specified value, if the parent resource pool has\nunreserved resources.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The utilization of a resource pool will not exceed this limit, even if there are available resources. Set to -1 for\nunlimited.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed available to the resource pool.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for\nshares. Can be one of low, normal, high, or custom.\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set,\ncpu_share_level must be custom.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource pool can grow beyond the specified value, if the parent resource pool has\nunreserved resources.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The utilization of a resource pool will not exceed this limit, even if there are available resources. Set to -1 for\nunlimited.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of memory (MB) that is guaranteed available to the resource pool.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for\nshares. Can be one of low, normal, high, or custom.\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set,\nmemory_share_level must be custom.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The ID of the root resource pool of the compute resource the resource pool is in.\n"
                },
                "scaleDescendantsShares": {
                    "type": "string",
                    "description": "Determines if the shares of all descendants of the resource pool are scaled up or down when the shares of the resource\npool are scaled up or down.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource pool can grow beyond the specified value, if the parent resource pool has\nunreserved resources.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The utilization of a resource pool will not exceed this limit, even if there are available resources. Set to -1 for\nunlimited.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed available to the resource pool.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for\nshares. Can be one of low, normal, high, or custom.\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set,\ncpu_share_level must be custom.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource pool can grow beyond the specified value, if the parent resource pool has\nunreserved resources.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The utilization of a resource pool will not exceed this limit, even if there are available resources. Set to -1 for\nunlimited.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of memory (MB) that is guaranteed available to the resource pool.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for\nshares. Can be one of low, normal, high, or custom.\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set,\nmemory_share_level must be custom.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The ID of the root resource pool of the compute resource the resource pool is in.\n"
                },
                "scaleDescendantsShares": {
                    "type": "string",
                    "description": "Determines if the shares of all descendants of the resource pool are scaled up or down when the shares of the resource\npool are scaled up or down.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourcePool resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource pool can grow beyond the specified value, if the parent resource pool has\nunreserved resources.\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The utilization of a resource pool will not exceed this limit, even if there are available resources. Set to -1 for\nunlimited.\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed available to the resource pool.\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for\nshares. Can be one of low, normal, high, or custom.\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set,\ncpu_share_level must be custom.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource pool can grow beyond the specified value, if the parent resource pool has\nunreserved resources.\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The utilization of a resource pool will not exceed this limit, even if there are available resources. Set to -1 for\nunlimited.\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of memory (MB) that is guaranteed available to the resource pool.\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for\nshares. Can be one of low, normal, high, or custom.\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set,\nmemory_share_level must be custom.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of resource pool.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The ID of the root resource pool of the compute resource the resource pool is in.\n"
                    },
                    "scaleDescendantsShares": {
                        "type": "string",
                        "description": "Determines if the shares of all descendants of the resource pool are scaled up or down when the shares of the resource\npool are scaled up or down.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/role:Role": {
            "description": "\n\n## Import\n\nAn existing role can be imported into this resource by supplying the role id. An example is below:\n\n```sh\n$ pulumi import vsphere:index/role:Role role1 -709298051\n```\n\nUse [`vsphere_role` data source][ref-vsphere-role-data-source]\n\nto read information about system roles.\n\n[ref-vsphere-role-data-source]: /docs/providers/vsphere/d/vsphere_role.html\n\n",
            "properties": {
                "label": {
                    "type": "string",
                    "description": "The display label of the role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "rolePrivileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to be associated with this role.\n"
                }
            },
            "required": [
                "label",
                "name"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "rolePrivileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to be associated with this role.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "label": {
                        "type": "string",
                        "description": "The display label of the role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges to be associated with this role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/storageDrsVmOverride:StorageDrsVmOverride": {
            "description": "The `vsphere.StorageDrsVmOverride` resource can be used to add a Storage DRS\noverride to a datastore cluster for a specific virtual machine. With this\nresource, one can enable or disable Storage DRS, and control the automation\nlevel and disk affinity for a single virtual machine without affecting the rest\nof the datastore cluster.\n\nFor more information on vSphere datastore clusters and Storage DRS, see [this\npage][ref-vsphere-datastore-clusters].\n\n[ref-vsphere-datastore-clusters]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-resource-management-8-0/creating-a-datastore-cluster.html\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastoreCluster = datacenter.then(datacenter =\u003e vsphere.getDatastoreCluster({\n    name: \"datastore-cluster1\",\n    datacenterId: datacenter.id,\n}));\nconst memberDatastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore-cluster1-member1\",\n    datacenterId: datacenter.id,\n}));\nconst pool = datacenter.then(datacenter =\u003e vsphere.getResourcePool({\n    name: \"cluster1/Resources\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"public\",\n    datacenterId: datacenter.id,\n}));\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    name: \"test\",\n    resourcePoolId: pool.then(pool =\u003e pool.id),\n    datastoreId: memberDatastore.then(memberDatastore =\u003e memberDatastore.id),\n    numCpus: 2,\n    memory: 1024,\n    guestId: \"otherLinux64Guest\",\n    networkInterfaces: [{\n        networkId: network.then(network =\u003e network.id),\n    }],\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n});\nconst drsVmOverride = new vsphere.StorageDrsVmOverride(\"drs_vm_override\", {\n    datastoreClusterId: datastoreCluster.then(datastoreCluster =\u003e datastoreCluster.id),\n    virtualMachineId: vm.id,\n    sdrsEnabled: \"false\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore_cluster = vsphere.get_datastore_cluster(name=\"datastore-cluster1\",\n    datacenter_id=datacenter.id)\nmember_datastore = vsphere.get_datastore(name=\"datastore-cluster1-member1\",\n    datacenter_id=datacenter.id)\npool = vsphere.get_resource_pool(name=\"cluster1/Resources\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"public\",\n    datacenter_id=datacenter.id)\nvm = vsphere.VirtualMachine(\"vm\",\n    name=\"test\",\n    resource_pool_id=pool.id,\n    datastore_id=member_datastore.id,\n    num_cpus=2,\n    memory=1024,\n    guest_id=\"otherLinux64Guest\",\n    network_interfaces=[{\n        \"network_id\": network.id,\n    }],\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }])\ndrs_vm_override = vsphere.StorageDrsVmOverride(\"drs_vm_override\",\n    datastore_cluster_id=datastore_cluster.id,\n    virtual_machine_id=vm.id,\n    sdrs_enabled=\"false\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastoreCluster = VSphere.GetDatastoreCluster.Invoke(new()\n    {\n        Name = \"datastore-cluster1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var memberDatastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore-cluster1-member1\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var pool = VSphere.GetResourcePool.Invoke(new()\n    {\n        Name = \"cluster1/Resources\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"public\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vm = new VSphere.VirtualMachine(\"vm\", new()\n    {\n        Name = \"test\",\n        ResourcePoolId = pool.Apply(getResourcePoolResult =\u003e getResourcePoolResult.Id),\n        DatastoreId = memberDatastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        NumCpus = 2,\n        Memory = 1024,\n        GuestId = \"otherLinux64Guest\",\n        NetworkInterfaces = new[]\n        {\n            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n            {\n                NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n            },\n        },\n        Disks = new[]\n        {\n            new VSphere.Inputs.VirtualMachineDiskArgs\n            {\n                Label = \"disk0\",\n                Size = 20,\n            },\n        },\n    });\n\n    var drsVmOverride = new VSphere.StorageDrsVmOverride(\"drs_vm_override\", new()\n    {\n        DatastoreClusterId = datastoreCluster.Apply(getDatastoreClusterResult =\u003e getDatastoreClusterResult.Id),\n        VirtualMachineId = vm.Id,\n        SdrsEnabled = \"false\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdatastoreCluster, err := vsphere.LookupDatastoreCluster(ctx, \u0026vsphere.LookupDatastoreClusterArgs{\n\t\t\tName:         \"datastore-cluster1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmemberDatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore-cluster1-member1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpool, err := vsphere.LookupResourcePool(ctx, \u0026vsphere.LookupResourcePoolArgs{\n\t\t\tName:         pulumi.StringRef(\"cluster1/Resources\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnetwork, err := vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"public\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvm, err := vsphere.NewVirtualMachine(ctx, \"vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tName:           pulumi.String(\"test\"),\n\t\t\tResourcePoolId: pulumi.String(pool.Id),\n\t\t\tDatastoreId:    pulumi.String(memberDatastore.Id),\n\t\t\tNumCpus:        pulumi.Int(2),\n\t\t\tMemory:         pulumi.Int(1024),\n\t\t\tGuestId:        pulumi.String(\"otherLinux64Guest\"),\n\t\t\tNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\t\t\t\t\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\n\t\t\t\t\tNetworkId: pulumi.String(network.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDisks: vsphere.VirtualMachineDiskArray{\n\t\t\t\t\u0026vsphere.VirtualMachineDiskArgs{\n\t\t\t\t\tLabel: pulumi.String(\"disk0\"),\n\t\t\t\t\tSize:  pulumi.Int(20),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewStorageDrsVmOverride(ctx, \"drs_vm_override\", \u0026vsphere.StorageDrsVmOverrideArgs{\n\t\t\tDatastoreClusterId: pulumi.String(datastoreCluster.Id),\n\t\t\tVirtualMachineId:   vm.ID(),\n\t\t\tSdrsEnabled:        pulumi.String(\"false\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreClusterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.inputs.GetResourcePoolArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;\nimport com.pulumi.vsphere.StorageDrsVmOverride;\nimport com.pulumi.vsphere.StorageDrsVmOverrideArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastoreCluster = VsphereFunctions.getDatastoreCluster(GetDatastoreClusterArgs.builder()\n            .name(\"datastore-cluster1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var memberDatastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore-cluster1-member1\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var pool = VsphereFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"cluster1/Resources\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"public\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var vm = new VirtualMachine(\"vm\", VirtualMachineArgs.builder()\n            .name(\"test\")\n            .resourcePoolId(pool.id())\n            .datastoreId(memberDatastore.id())\n            .numCpus(2)\n            .memory(1024)\n            .guestId(\"otherLinux64Guest\")\n            .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                .networkId(network.id())\n                .build())\n            .disks(VirtualMachineDiskArgs.builder()\n                .label(\"disk0\")\n                .size(20)\n                .build())\n            .build());\n\n        var drsVmOverride = new StorageDrsVmOverride(\"drsVmOverride\", StorageDrsVmOverrideArgs.builder()\n            .datastoreClusterId(datastoreCluster.id())\n            .virtualMachineId(vm.id())\n            .sdrsEnabled(\"false\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      name: test\n      resourcePoolId: ${pool.id}\n      datastoreId: ${memberDatastore.id}\n      numCpus: 2\n      memory: 1024\n      guestId: otherLinux64Guest\n      networkInterfaces:\n        - networkId: ${network.id}\n      disks:\n        - label: disk0\n          size: 20\n  drsVmOverride:\n    type: vsphere:StorageDrsVmOverride\n    name: drs_vm_override\n    properties:\n      datastoreClusterId: ${datastoreCluster.id}\n      virtualMachineId: ${vm.id}\n      sdrsEnabled: false\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  datastoreCluster:\n    fn::invoke:\n      function: vsphere:getDatastoreCluster\n      arguments:\n        name: datastore-cluster1\n        datacenterId: ${datacenter.id}\n  memberDatastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: datastore-cluster1-member1\n        datacenterId: ${datacenter.id}\n  pool:\n    fn::invoke:\n      function: vsphere:getResourcePool\n      arguments:\n        name: cluster1/Resources\n        datacenterId: ${datacenter.id}\n  network:\n    fn::invoke:\n      function: vsphere:getNetwork\n      arguments:\n        name: public\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing override can be imported into this resource by\n\nsupplying both the path to the datastore cluster and the path to the virtual\n\nmachine to `pulumi import`. If no override exists, an error will be given.\n\nAn example is below:\n\n```sh\n$ pulumi import vsphere:index/storageDrsVmOverride:StorageDrsVmOverride drs_vm_override \\\n```\n\n  '{\"datastore_cluster_path\": \"/dc1/datastore/ds-cluster\", \\\n\n  \"virtual_machine_path\": \"/dc1/vm/srv1\"}'\n\n",
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageDrsVmOverride resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                    },
                    "sdrsEnabled": {
                        "type": "string",
                        "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                    },
                    "sdrsIntraVmAffinity": {
                        "type": "string",
                        "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/supervisor:Supervisor": {
            "description": "Provides a resource for configuring Workload Management.\n\n## Example Usage\n\n### S\n\n**Enable Workload Management on a compute cluster**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vmClass = new vsphere.VirtualMachineClass(\"vm_class\", {\n    name: \"custom-class\",\n    cpus: 4,\n    memory: 4096,\n});\nconst supervisor = new vsphere.Supervisor(\"supervisor\", {\n    cluster: \"\u003ccompute_cluster_id\u003e\",\n    storagePolicy: \"\u003cstorage_policy_name\u003e\",\n    contentLibrary: \"\u003ccontent_library_id\u003e\",\n    mainDns: \"10.0.0.250\",\n    workerDns: \"10.0.0.250\",\n    edgeCluster: \"\u003cedge_cluster_id\u003e\",\n    dvsUuid: \"\u003cdistributed_switch_uuid\u003e\",\n    sizingHint: \"MEDIUM\",\n    managementNetwork: {\n        network: \"\u003cportgroup_id\u003e\",\n        subnetMask: \"255.255.255.0\",\n        startingAddress: \"10.0.0.150\",\n        gateway: \"10.0.0.250\",\n        addressCount: 5,\n    },\n    ingressCidrs: [{\n        address: \"10.10.10.0\",\n        prefix: 24,\n    }],\n    egressCidrs: [{\n        address: \"10.10.11.0\",\n        prefix: 24,\n    }],\n    podCidrs: [{\n        address: \"10.244.10.0\",\n        prefix: 23,\n    }],\n    serviceCidr: {\n        address: \"10.10.12.0\",\n        prefix: 24,\n    },\n    searchDomains: \"vsphere.local\",\n    namespaces: [{\n        name: \"custom-namespace\",\n        contentLibraries: [],\n        vmClasses: [vmClass.id],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvm_class = vsphere.VirtualMachineClass(\"vm_class\",\n    name=\"custom-class\",\n    cpus=4,\n    memory=4096)\nsupervisor = vsphere.Supervisor(\"supervisor\",\n    cluster=\"\u003ccompute_cluster_id\u003e\",\n    storage_policy=\"\u003cstorage_policy_name\u003e\",\n    content_library=\"\u003ccontent_library_id\u003e\",\n    main_dns=\"10.0.0.250\",\n    worker_dns=\"10.0.0.250\",\n    edge_cluster=\"\u003cedge_cluster_id\u003e\",\n    dvs_uuid=\"\u003cdistributed_switch_uuid\u003e\",\n    sizing_hint=\"MEDIUM\",\n    management_network={\n        \"network\": \"\u003cportgroup_id\u003e\",\n        \"subnet_mask\": \"255.255.255.0\",\n        \"starting_address\": \"10.0.0.150\",\n        \"gateway\": \"10.0.0.250\",\n        \"address_count\": 5,\n    },\n    ingress_cidrs=[{\n        \"address\": \"10.10.10.0\",\n        \"prefix\": 24,\n    }],\n    egress_cidrs=[{\n        \"address\": \"10.10.11.0\",\n        \"prefix\": 24,\n    }],\n    pod_cidrs=[{\n        \"address\": \"10.244.10.0\",\n        \"prefix\": 23,\n    }],\n    service_cidr={\n        \"address\": \"10.10.12.0\",\n        \"prefix\": 24,\n    },\n    search_domains=\"vsphere.local\",\n    namespaces=[{\n        \"name\": \"custom-namespace\",\n        \"content_libraries\": [],\n        \"vm_classes\": [vm_class.id],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vmClass = new VSphere.VirtualMachineClass(\"vm_class\", new()\n    {\n        Name = \"custom-class\",\n        Cpus = 4,\n        Memory = 4096,\n    });\n\n    var supervisor = new VSphere.Supervisor(\"supervisor\", new()\n    {\n        Cluster = \"\u003ccompute_cluster_id\u003e\",\n        StoragePolicy = \"\u003cstorage_policy_name\u003e\",\n        ContentLibrary = \"\u003ccontent_library_id\u003e\",\n        MainDns = \"10.0.0.250\",\n        WorkerDns = \"10.0.0.250\",\n        EdgeCluster = \"\u003cedge_cluster_id\u003e\",\n        DvsUuid = \"\u003cdistributed_switch_uuid\u003e\",\n        SizingHint = \"MEDIUM\",\n        ManagementNetwork = new VSphere.Inputs.SupervisorManagementNetworkArgs\n        {\n            Network = \"\u003cportgroup_id\u003e\",\n            SubnetMask = \"255.255.255.0\",\n            StartingAddress = \"10.0.0.150\",\n            Gateway = \"10.0.0.250\",\n            AddressCount = 5,\n        },\n        IngressCidrs = new[]\n        {\n            new VSphere.Inputs.SupervisorIngressCidrArgs\n            {\n                Address = \"10.10.10.0\",\n                Prefix = 24,\n            },\n        },\n        EgressCidrs = new[]\n        {\n            new VSphere.Inputs.SupervisorEgressCidrArgs\n            {\n                Address = \"10.10.11.0\",\n                Prefix = 24,\n            },\n        },\n        PodCidrs = new[]\n        {\n            new VSphere.Inputs.SupervisorPodCidrArgs\n            {\n                Address = \"10.244.10.0\",\n                Prefix = 23,\n            },\n        },\n        ServiceCidr = new VSphere.Inputs.SupervisorServiceCidrArgs\n        {\n            Address = \"10.10.12.0\",\n            Prefix = 24,\n        },\n        SearchDomains = \"vsphere.local\",\n        Namespaces = new[]\n        {\n            new VSphere.Inputs.SupervisorNamespaceArgs\n            {\n                Name = \"custom-namespace\",\n                ContentLibraries = new() { },\n                VmClasses = new[]\n                {\n                    vmClass.Id,\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tvmClass, err := vsphere.NewVirtualMachineClass(ctx, \"vm_class\", \u0026vsphere.VirtualMachineClassArgs{\n\t\t\tName:   pulumi.String(\"custom-class\"),\n\t\t\tCpus:   pulumi.Int(4),\n\t\t\tMemory: pulumi.Int(4096),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewSupervisor(ctx, \"supervisor\", \u0026vsphere.SupervisorArgs{\n\t\t\tCluster:        pulumi.String(\"\u003ccompute_cluster_id\u003e\"),\n\t\t\tStoragePolicy:  pulumi.String(\"\u003cstorage_policy_name\u003e\"),\n\t\t\tContentLibrary: pulumi.String(\"\u003ccontent_library_id\u003e\"),\n\t\t\tMainDns:        pulumi.StringArray(\"10.0.0.250\"),\n\t\t\tWorkerDns:      pulumi.StringArray(\"10.0.0.250\"),\n\t\t\tEdgeCluster:    pulumi.String(\"\u003cedge_cluster_id\u003e\"),\n\t\t\tDvsUuid:        pulumi.String(\"\u003cdistributed_switch_uuid\u003e\"),\n\t\t\tSizingHint:     pulumi.String(\"MEDIUM\"),\n\t\t\tManagementNetwork: \u0026vsphere.SupervisorManagementNetworkArgs{\n\t\t\t\tNetwork:         pulumi.String(\"\u003cportgroup_id\u003e\"),\n\t\t\t\tSubnetMask:      pulumi.String(\"255.255.255.0\"),\n\t\t\t\tStartingAddress: pulumi.String(\"10.0.0.150\"),\n\t\t\t\tGateway:         pulumi.String(\"10.0.0.250\"),\n\t\t\t\tAddressCount:    pulumi.Int(5),\n\t\t\t},\n\t\t\tIngressCidrs: vsphere.SupervisorIngressCidrArray{\n\t\t\t\t\u0026vsphere.SupervisorIngressCidrArgs{\n\t\t\t\t\tAddress: pulumi.String(\"10.10.10.0\"),\n\t\t\t\t\tPrefix:  pulumi.Int(24),\n\t\t\t\t},\n\t\t\t},\n\t\t\tEgressCidrs: vsphere.SupervisorEgressCidrArray{\n\t\t\t\t\u0026vsphere.SupervisorEgressCidrArgs{\n\t\t\t\t\tAddress: pulumi.String(\"10.10.11.0\"),\n\t\t\t\t\tPrefix:  pulumi.Int(24),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPodCidrs: vsphere.SupervisorPodCidrArray{\n\t\t\t\t\u0026vsphere.SupervisorPodCidrArgs{\n\t\t\t\t\tAddress: pulumi.String(\"10.244.10.0\"),\n\t\t\t\t\tPrefix:  pulumi.Int(23),\n\t\t\t\t},\n\t\t\t},\n\t\t\tServiceCidr: \u0026vsphere.SupervisorServiceCidrArgs{\n\t\t\t\tAddress: pulumi.String(\"10.10.12.0\"),\n\t\t\t\tPrefix:  pulumi.Int(24),\n\t\t\t},\n\t\t\tSearchDomains: pulumi.String(\"vsphere.local\"),\n\t\t\tNamespaces: vsphere.SupervisorNamespaceArray{\n\t\t\t\t\u0026vsphere.SupervisorNamespaceArgs{\n\t\t\t\t\tName:             pulumi.String(\"custom-namespace\"),\n\t\t\t\t\tContentLibraries: pulumi.StringArray{},\n\t\t\t\t\tVmClasses: pulumi.StringArray{\n\t\t\t\t\t\tvmClass.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachineClass;\nimport com.pulumi.vsphere.VirtualMachineClassArgs;\nimport com.pulumi.vsphere.Supervisor;\nimport com.pulumi.vsphere.SupervisorArgs;\nimport com.pulumi.vsphere.inputs.SupervisorManagementNetworkArgs;\nimport com.pulumi.vsphere.inputs.SupervisorIngressCidrArgs;\nimport com.pulumi.vsphere.inputs.SupervisorEgressCidrArgs;\nimport com.pulumi.vsphere.inputs.SupervisorPodCidrArgs;\nimport com.pulumi.vsphere.inputs.SupervisorServiceCidrArgs;\nimport com.pulumi.vsphere.inputs.SupervisorNamespaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vmClass = new VirtualMachineClass(\"vmClass\", VirtualMachineClassArgs.builder()\n            .name(\"custom-class\")\n            .cpus(4)\n            .memory(4096)\n            .build());\n\n        var supervisor = new Supervisor(\"supervisor\", SupervisorArgs.builder()\n            .cluster(\"\u003ccompute_cluster_id\u003e\")\n            .storagePolicy(\"\u003cstorage_policy_name\u003e\")\n            .contentLibrary(\"\u003ccontent_library_id\u003e\")\n            .mainDns(\"10.0.0.250\")\n            .workerDns(\"10.0.0.250\")\n            .edgeCluster(\"\u003cedge_cluster_id\u003e\")\n            .dvsUuid(\"\u003cdistributed_switch_uuid\u003e\")\n            .sizingHint(\"MEDIUM\")\n            .managementNetwork(SupervisorManagementNetworkArgs.builder()\n                .network(\"\u003cportgroup_id\u003e\")\n                .subnetMask(\"255.255.255.0\")\n                .startingAddress(\"10.0.0.150\")\n                .gateway(\"10.0.0.250\")\n                .addressCount(5)\n                .build())\n            .ingressCidrs(SupervisorIngressCidrArgs.builder()\n                .address(\"10.10.10.0\")\n                .prefix(24)\n                .build())\n            .egressCidrs(SupervisorEgressCidrArgs.builder()\n                .address(\"10.10.11.0\")\n                .prefix(24)\n                .build())\n            .podCidrs(SupervisorPodCidrArgs.builder()\n                .address(\"10.244.10.0\")\n                .prefix(23)\n                .build())\n            .serviceCidr(SupervisorServiceCidrArgs.builder()\n                .address(\"10.10.12.0\")\n                .prefix(24)\n                .build())\n            .searchDomains(\"vsphere.local\")\n            .namespaces(SupervisorNamespaceArgs.builder()\n                .name(\"custom-namespace\")\n                .contentLibraries()\n                .vmClasses(vmClass.id())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vmClass:\n    type: vsphere:VirtualMachineClass\n    name: vm_class\n    properties:\n      name: custom-class\n      cpus: 4\n      memory: 4096\n  supervisor:\n    type: vsphere:Supervisor\n    properties:\n      cluster: \u003ccompute_cluster_id\u003e\n      storagePolicy: \u003cstorage_policy_name\u003e\n      contentLibrary: \u003ccontent_library_id\u003e\n      mainDns: 10.0.0.250\n      workerDns: 10.0.0.250\n      edgeCluster: \u003cedge_cluster_id\u003e\n      dvsUuid: \u003cdistributed_switch_uuid\u003e\n      sizingHint: MEDIUM\n      managementNetwork:\n        network: \u003cportgroup_id\u003e\n        subnetMask: 255.255.255.0\n        startingAddress: 10.0.0.150\n        gateway: 10.0.0.250\n        addressCount: 5\n      ingressCidrs:\n        - address: 10.10.10.0\n          prefix: 24\n      egressCidrs:\n        - address: 10.10.11.0\n          prefix: 24\n      podCidrs:\n        - address: 10.244.10.0\n          prefix: 23\n      serviceCidr:\n        address: 10.10.12.0\n        prefix: 24\n      searchDomains: vsphere.local\n      namespaces:\n        - name: custom-namespace\n          contentLibraries: []\n          vmClasses:\n            - ${vmClass.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "cluster": {
                    "type": "string",
                    "description": "The identifier of the compute cluster.\n"
                },
                "contentLibrary": {
                    "type": "string",
                    "description": "The identifier of the subscribed content library.\n"
                },
                "dvsUuid": {
                    "type": "string",
                    "description": "The UUID of the distributed switch.\n"
                },
                "edgeCluster": {
                    "type": "string",
                    "description": "The identifier of the NSX Edge Cluster.\n"
                },
                "egressCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorEgressCidr:SupervisorEgressCidr"
                    },
                    "description": "CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.\n"
                },
                "ingressCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorIngressCidr:SupervisorIngressCidr"
                    },
                    "description": "CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.\n"
                },
                "mainDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the primary DNS servers.\n"
                },
                "mainNtps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the primary NTP servers.\n"
                },
                "managementNetwork": {
                    "$ref": "#/types/vsphere:index/SupervisorManagementNetwork:SupervisorManagementNetwork",
                    "description": "The configuration for the management network which the control plane VMs will be connected to.\n* * `network` - ID of the network. (e.g. a distributed port group).\n* * `starting_address` - Starting address of the management network range.\n* * `subnet_mask` - Subnet mask.\n* * `gateway` - Gateway IP address.\n* * `address_count` - Number of addresses to allocate. Starts from `starting_address`\n"
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorNamespace:SupervisorNamespace"
                    },
                    "description": "The list of namespaces to create in the Supervisor cluster\n"
                },
                "podCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorPodCidr:SupervisorPodCidr"
                    },
                    "description": "CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.\n"
                },
                "searchDomains": {
                    "type": "string",
                    "description": "List of DNS search domains.\n"
                },
                "serviceCidr": {
                    "$ref": "#/types/vsphere:index/SupervisorServiceCidr:SupervisorServiceCidr",
                    "description": "CIDR block from which Kubernetes allocates service cluster IP addresses.\n"
                },
                "sizingHint": {
                    "type": "string",
                    "description": "The size of the Kubernetes API server.\n"
                },
                "storagePolicy": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "workerDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the DNS servers to use for the worker nodes.\n"
                },
                "workerNtps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the NTP servers to use for the worker nodes.\n"
                }
            },
            "required": [
                "cluster",
                "contentLibrary",
                "dvsUuid",
                "edgeCluster",
                "egressCidrs",
                "ingressCidrs",
                "mainDns",
                "mainNtps",
                "managementNetwork",
                "podCidrs",
                "searchDomains",
                "serviceCidr",
                "sizingHint",
                "storagePolicy",
                "workerDns",
                "workerNtps"
            ],
            "inputProperties": {
                "cluster": {
                    "type": "string",
                    "description": "The identifier of the compute cluster.\n"
                },
                "contentLibrary": {
                    "type": "string",
                    "description": "The identifier of the subscribed content library.\n"
                },
                "dvsUuid": {
                    "type": "string",
                    "description": "The UUID of the distributed switch.\n"
                },
                "edgeCluster": {
                    "type": "string",
                    "description": "The identifier of the NSX Edge Cluster.\n"
                },
                "egressCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorEgressCidr:SupervisorEgressCidr"
                    },
                    "description": "CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.\n"
                },
                "ingressCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorIngressCidr:SupervisorIngressCidr"
                    },
                    "description": "CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.\n"
                },
                "mainDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the primary DNS servers.\n"
                },
                "mainNtps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the primary NTP servers.\n"
                },
                "managementNetwork": {
                    "$ref": "#/types/vsphere:index/SupervisorManagementNetwork:SupervisorManagementNetwork",
                    "description": "The configuration for the management network which the control plane VMs will be connected to.\n* * `network` - ID of the network. (e.g. a distributed port group).\n* * `starting_address` - Starting address of the management network range.\n* * `subnet_mask` - Subnet mask.\n* * `gateway` - Gateway IP address.\n* * `address_count` - Number of addresses to allocate. Starts from `starting_address`\n"
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorNamespace:SupervisorNamespace"
                    },
                    "description": "The list of namespaces to create in the Supervisor cluster\n"
                },
                "podCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorPodCidr:SupervisorPodCidr"
                    },
                    "description": "CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.\n"
                },
                "searchDomains": {
                    "type": "string",
                    "description": "List of DNS search domains.\n"
                },
                "serviceCidr": {
                    "$ref": "#/types/vsphere:index/SupervisorServiceCidr:SupervisorServiceCidr",
                    "description": "CIDR block from which Kubernetes allocates service cluster IP addresses.\n"
                },
                "sizingHint": {
                    "type": "string",
                    "description": "The size of the Kubernetes API server.\n"
                },
                "storagePolicy": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "workerDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the DNS servers to use for the worker nodes.\n"
                },
                "workerNtps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the NTP servers to use for the worker nodes.\n"
                }
            },
            "requiredInputs": [
                "cluster",
                "contentLibrary",
                "dvsUuid",
                "edgeCluster",
                "egressCidrs",
                "ingressCidrs",
                "mainDns",
                "mainNtps",
                "managementNetwork",
                "podCidrs",
                "searchDomains",
                "serviceCidr",
                "sizingHint",
                "storagePolicy",
                "workerDns",
                "workerNtps"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Supervisor resources.\n",
                "properties": {
                    "cluster": {
                        "type": "string",
                        "description": "The identifier of the compute cluster.\n"
                    },
                    "contentLibrary": {
                        "type": "string",
                        "description": "The identifier of the subscribed content library.\n"
                    },
                    "dvsUuid": {
                        "type": "string",
                        "description": "The UUID of the distributed switch.\n"
                    },
                    "edgeCluster": {
                        "type": "string",
                        "description": "The identifier of the NSX Edge Cluster.\n"
                    },
                    "egressCidrs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/SupervisorEgressCidr:SupervisorEgressCidr"
                        },
                        "description": "CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.\n"
                    },
                    "ingressCidrs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/SupervisorIngressCidr:SupervisorIngressCidr"
                        },
                        "description": "CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.\n"
                    },
                    "mainDns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of addresses of the primary DNS servers.\n"
                    },
                    "mainNtps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of addresses of the primary NTP servers.\n"
                    },
                    "managementNetwork": {
                        "$ref": "#/types/vsphere:index/SupervisorManagementNetwork:SupervisorManagementNetwork",
                        "description": "The configuration for the management network which the control plane VMs will be connected to.\n* * `network` - ID of the network. (e.g. a distributed port group).\n* * `starting_address` - Starting address of the management network range.\n* * `subnet_mask` - Subnet mask.\n* * `gateway` - Gateway IP address.\n* * `address_count` - Number of addresses to allocate. Starts from `starting_address`\n"
                    },
                    "namespaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/SupervisorNamespace:SupervisorNamespace"
                        },
                        "description": "The list of namespaces to create in the Supervisor cluster\n"
                    },
                    "podCidrs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/SupervisorPodCidr:SupervisorPodCidr"
                        },
                        "description": "CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.\n"
                    },
                    "searchDomains": {
                        "type": "string",
                        "description": "List of DNS search domains.\n"
                    },
                    "serviceCidr": {
                        "$ref": "#/types/vsphere:index/SupervisorServiceCidr:SupervisorServiceCidr",
                        "description": "CIDR block from which Kubernetes allocates service cluster IP addresses.\n"
                    },
                    "sizingHint": {
                        "type": "string",
                        "description": "The size of the Kubernetes API server.\n"
                    },
                    "storagePolicy": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    },
                    "workerDns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of addresses of the DNS servers to use for the worker nodes.\n"
                    },
                    "workerNtps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of addresses of the NTP servers to use for the worker nodes.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tag:Tag": {
            "description": "The `vsphere.Tag` resource can be used to create and manage tags, which allow\nyou to attach metadata to objects in the vSphere inventory to make these\nobjects more sortable and searchable.\n\nFor more information about tags, click [here][ext-tags-general].\n\n[ext-tags-general]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-tags-and-attributes.html\n\n## Example Usage\n\nThis example creates a tag named `test-tag`. This tag is assigned the\n`test-category` category, which was created by the\n`vsphere.TagCategory` resource. The resulting\ntag can be assigned to VMs and datastores only, and can be the only value in\nthe category that can be assigned, as per the restrictions defined by the\ncategory.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = new vsphere.TagCategory(\"category\", {\n    name: \"test-category\",\n    cardinality: \"SINGLE\",\n    description: \"Managed by Pulumi\",\n    associableTypes: [\n        \"VirtualMachine\",\n        \"Datastore\",\n    ],\n});\nconst tag = new vsphere.Tag(\"tag\", {\n    name: \"test-tag\",\n    categoryId: category.id,\n    description: \"Managed by Pulumi\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.TagCategory(\"category\",\n    name=\"test-category\",\n    cardinality=\"SINGLE\",\n    description=\"Managed by Pulumi\",\n    associable_types=[\n        \"VirtualMachine\",\n        \"Datastore\",\n    ])\ntag = vsphere.Tag(\"tag\",\n    name=\"test-tag\",\n    category_id=category.id,\n    description=\"Managed by Pulumi\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = new VSphere.TagCategory(\"category\", new()\n    {\n        Name = \"test-category\",\n        Cardinality = \"SINGLE\",\n        Description = \"Managed by Pulumi\",\n        AssociableTypes = new[]\n        {\n            \"VirtualMachine\",\n            \"Datastore\",\n        },\n    });\n\n    var tag = new VSphere.Tag(\"tag\", new()\n    {\n        Name = \"test-tag\",\n        CategoryId = category.Id,\n        Description = \"Managed by Pulumi\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcategory, err := vsphere.NewTagCategory(ctx, \"category\", \u0026vsphere.TagCategoryArgs{\n\t\t\tName:        pulumi.String(\"test-category\"),\n\t\t\tCardinality: pulumi.String(\"SINGLE\"),\n\t\t\tDescription: pulumi.String(\"Managed by Pulumi\"),\n\t\t\tAssociableTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"VirtualMachine\"),\n\t\t\t\tpulumi.String(\"Datastore\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewTag(ctx, \"tag\", \u0026vsphere.TagArgs{\n\t\t\tName:        pulumi.String(\"test-tag\"),\n\t\t\tCategoryId:  category.ID(),\n\t\t\tDescription: pulumi.String(\"Managed by Pulumi\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.TagCategory;\nimport com.pulumi.vsphere.TagCategoryArgs;\nimport com.pulumi.vsphere.Tag;\nimport com.pulumi.vsphere.TagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var category = new TagCategory(\"category\", TagCategoryArgs.builder()\n            .name(\"test-category\")\n            .cardinality(\"SINGLE\")\n            .description(\"Managed by Pulumi\")\n            .associableTypes(            \n                \"VirtualMachine\",\n                \"Datastore\")\n            .build());\n\n        var tag = new Tag(\"tag\", TagArgs.builder()\n            .name(\"test-tag\")\n            .categoryId(category.id())\n            .description(\"Managed by Pulumi\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  category:\n    type: vsphere:TagCategory\n    properties:\n      name: test-category\n      cardinality: SINGLE\n      description: Managed by Pulumi\n      associableTypes:\n        - VirtualMachine\n        - Datastore\n  tag:\n    type: vsphere:Tag\n    properties:\n      name: test-tag\n      categoryId: ${category.id}\n      description: Managed by Pulumi\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using Tags in a Supported Resource\n\nTags can be applied to vSphere resources via the `tags` argument\nin any supported resource.\n\nThe following example builds on the above example by creating a\n`vsphere.VirtualMachine` and applying the\ncreated tag to it:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = new vsphere.TagCategory(\"category\", {\n    name: \"test-category\",\n    cardinality: \"SINGLE\",\n    description: \"Managed by Pulumi\",\n    associableTypes: [\n        \"VirtualMachine\",\n        \"Datastore\",\n    ],\n});\nconst tag = new vsphere.Tag(\"tag\", {\n    name: \"test-tag\",\n    categoryId: category.id,\n    description: \"Managed by Pulumi\",\n});\nconst web = new vsphere.VirtualMachine(\"web\", {tags: [tag.id]});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.TagCategory(\"category\",\n    name=\"test-category\",\n    cardinality=\"SINGLE\",\n    description=\"Managed by Pulumi\",\n    associable_types=[\n        \"VirtualMachine\",\n        \"Datastore\",\n    ])\ntag = vsphere.Tag(\"tag\",\n    name=\"test-tag\",\n    category_id=category.id,\n    description=\"Managed by Pulumi\")\nweb = vsphere.VirtualMachine(\"web\", tags=[tag.id])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = new VSphere.TagCategory(\"category\", new()\n    {\n        Name = \"test-category\",\n        Cardinality = \"SINGLE\",\n        Description = \"Managed by Pulumi\",\n        AssociableTypes = new[]\n        {\n            \"VirtualMachine\",\n            \"Datastore\",\n        },\n    });\n\n    var tag = new VSphere.Tag(\"tag\", new()\n    {\n        Name = \"test-tag\",\n        CategoryId = category.Id,\n        Description = \"Managed by Pulumi\",\n    });\n\n    var web = new VSphere.VirtualMachine(\"web\", new()\n    {\n        Tags = new[]\n        {\n            tag.Id,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcategory, err := vsphere.NewTagCategory(ctx, \"category\", \u0026vsphere.TagCategoryArgs{\n\t\t\tName:        pulumi.String(\"test-category\"),\n\t\t\tCardinality: pulumi.String(\"SINGLE\"),\n\t\t\tDescription: pulumi.String(\"Managed by Pulumi\"),\n\t\t\tAssociableTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"VirtualMachine\"),\n\t\t\t\tpulumi.String(\"Datastore\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttag, err := vsphere.NewTag(ctx, \"tag\", \u0026vsphere.TagArgs{\n\t\t\tName:        pulumi.String(\"test-tag\"),\n\t\t\tCategoryId:  category.ID(),\n\t\t\tDescription: pulumi.String(\"Managed by Pulumi\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVirtualMachine(ctx, \"web\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\ttag.ID(),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.TagCategory;\nimport com.pulumi.vsphere.TagCategoryArgs;\nimport com.pulumi.vsphere.Tag;\nimport com.pulumi.vsphere.TagArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var category = new TagCategory(\"category\", TagCategoryArgs.builder()\n            .name(\"test-category\")\n            .cardinality(\"SINGLE\")\n            .description(\"Managed by Pulumi\")\n            .associableTypes(            \n                \"VirtualMachine\",\n                \"Datastore\")\n            .build());\n\n        var tag = new Tag(\"tag\", TagArgs.builder()\n            .name(\"test-tag\")\n            .categoryId(category.id())\n            .description(\"Managed by Pulumi\")\n            .build());\n\n        var web = new VirtualMachine(\"web\", VirtualMachineArgs.builder()\n            .tags(tag.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  category:\n    type: vsphere:TagCategory\n    properties:\n      name: test-category\n      cardinality: SINGLE\n      description: Managed by Pulumi\n      associableTypes:\n        - VirtualMachine\n        - Datastore\n  tag:\n    type: vsphere:Tag\n    properties:\n      name: test-tag\n      categoryId: ${category.id}\n      description: Managed by Pulumi\n  web:\n    type: vsphere:VirtualMachine\n    properties:\n      tags:\n        - ${tag.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing tag can be imported into this resource by supplying\n\nboth the tag's category name and the name of the tag as a JSON string to\n\n`pulumi import`, as per the example below:\n\n```sh\n$ pulumi import vsphere:index/tag:Tag tag \\\n```\n\n  '{\"category_name\": \"pulumi-test-category\", \"tag_name\": \"pulumi-test-tag\"}'\n\n",
            "properties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "required": [
                "categoryId",
                "name"
            ],
            "inputProperties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "requiredInputs": [
                "categoryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tag resources.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the tag.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tagCategory:TagCategory": {
            "description": "The `vsphere.TagCategory` resource can be used to create and manage tag\ncategories, which determine how tags are grouped together and applied to\nspecific objects.\n\nFor more information about tags, click [here][ext-tags-general].\n\n[ext-tags-general]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-tags-and-attributes.html\n\n## Example Usage\n\nThis example creates a tag category named `test-category`, with\nsingle cardinality (meaning that only one tag in this category can be assigned\nto an object at any given time). Tags in this category can only be assigned to\nVMs and datastores.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = new vsphere.TagCategory(\"category\", {\n    name: \"test-category\",\n    description: \"Managed by Pulumi\",\n    cardinality: \"SINGLE\",\n    associableTypes: [\n        \"VirtualMachine\",\n        \"Datastore\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.TagCategory(\"category\",\n    name=\"test-category\",\n    description=\"Managed by Pulumi\",\n    cardinality=\"SINGLE\",\n    associable_types=[\n        \"VirtualMachine\",\n        \"Datastore\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = new VSphere.TagCategory(\"category\", new()\n    {\n        Name = \"test-category\",\n        Description = \"Managed by Pulumi\",\n        Cardinality = \"SINGLE\",\n        AssociableTypes = new[]\n        {\n            \"VirtualMachine\",\n            \"Datastore\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewTagCategory(ctx, \"category\", \u0026vsphere.TagCategoryArgs{\n\t\t\tName:        pulumi.String(\"test-category\"),\n\t\t\tDescription: pulumi.String(\"Managed by Pulumi\"),\n\t\t\tCardinality: pulumi.String(\"SINGLE\"),\n\t\t\tAssociableTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"VirtualMachine\"),\n\t\t\t\tpulumi.String(\"Datastore\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.TagCategory;\nimport com.pulumi.vsphere.TagCategoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var category = new TagCategory(\"category\", TagCategoryArgs.builder()\n            .name(\"test-category\")\n            .description(\"Managed by Pulumi\")\n            .cardinality(\"SINGLE\")\n            .associableTypes(            \n                \"VirtualMachine\",\n                \"Datastore\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  category:\n    type: vsphere:TagCategory\n    properties:\n      name: test-category\n      description: Managed by Pulumi\n      cardinality: SINGLE\n      associableTypes:\n        - VirtualMachine\n        - Datastore\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing tag category can be imported into this resource via\n\nits name, using the following command:\n\n```sh\n$ pulumi import vsphere:index/tagCategory:TagCategory category terraform-test-category\n```\n\n",
            "properties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n\n\u003e **NOTE:** You can add associable types to a category, but you cannot remove\nthem. Attempting to do so will result in an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "required": [
                "associableTypes",
                "cardinality",
                "name"
            ],
            "inputProperties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n\n\u003e **NOTE:** You can add associable types to a category, but you cannot remove\nthem. Attempting to do so will result in an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "requiredInputs": [
                "associableTypes",
                "cardinality"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagCategory resources.\n",
                "properties": {
                    "associableTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                    },
                    "cardinality": {
                        "type": "string",
                        "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the category.\n\n\u003e **NOTE:** You can add associable types to a category, but you cannot remove\nthem. Attempting to do so will result in an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappContainer:VappContainer": {
            "description": "The `vsphere.VappContainer` resource can be used to create and manage\nvApps.\n\nFor more information on vSphere vApps, see the VMware vSphere [product documentation][ref-vsphere-vapp].\n\n[ref-vsphere-vapp]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-virtual-machine-administration-guide-8-0/managing-multi-tiered-applications-with-vsphere-vapp-in-the-vsphere-web-clientvsphere-vm-admin.html\n\n## Basic Example\n\nThe example below sets up a vSphere vApp container in a compute cluster which uses\nthe default settings for CPU and memory reservations, shares, and limits. The compute cluster\nneeds to already exist in vSphere.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst computeCluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst vappContainer = new vsphere.VappContainer(\"vapp_container\", {\n    name: \"vapp-01\",\n    parentResourcePoolId: computeCluster.then(computeCluster =\u003e computeCluster.resourcePoolId),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncompute_cluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nvapp_container = vsphere.VappContainer(\"vapp_container\",\n    name=\"vapp-01\",\n    parent_resource_pool_id=compute_cluster.resource_pool_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vappContainer = new VSphere.VappContainer(\"vapp_container\", new()\n    {\n        Name = \"vapp-01\",\n        ParentResourcePoolId = computeCluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcomputeCluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVappContainer(ctx, \"vapp_container\", \u0026vsphere.VappContainerArgs{\n\t\t\tName:                 pulumi.String(\"vapp-01\"),\n\t\t\tParentResourcePoolId: pulumi.String(computeCluster.ResourcePoolId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.VappContainer;\nimport com.pulumi.vsphere.VappContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var vappContainer = new VappContainer(\"vappContainer\", VappContainerArgs.builder()\n            .name(\"vapp-01\")\n            .parentResourcePoolId(computeCluster.resourcePoolId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vappContainer:\n    type: vsphere:VappContainer\n    name: vapp_container\n    properties:\n      name: vapp-01\n      parentResourcePoolId: ${computeCluster.resourcePoolId}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  computeCluster:\n    fn::invoke:\n      function: vsphere:getComputeCluster\n      arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example with a Virtual Machine\n\nThe example below builds off the basic example, but includes a virtual machine\nin the new vApp container. To accomplish this, the `resource_pool_id` of the\nvirtual machine is set to the `id` of the vApp container.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst computeCluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore-01\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"VM Network\",\n    datacenterId: datacenter.id,\n}));\nconst vappContainer = new vsphere.VappContainer(\"vapp_container\", {\n    name: \"vapp-01\",\n    parentResourcePoolId: computeCluster.then(computeCluster =\u003e computeCluster.resourcePoolId),\n});\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    name: \"foo\",\n    resourcePoolId: vappContainerVsphereVappContainer.id,\n    datastoreId: datastore.then(datastore =\u003e datastore.id),\n    numCpus: 1,\n    memory: 1024,\n    guestId: \"ubuntu64Guest\",\n    networkInterfaces: [{\n        networkId: network.then(network =\u003e network.id),\n    }],\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncompute_cluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\ndatastore = vsphere.get_datastore(name=\"datastore-01\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"VM Network\",\n    datacenter_id=datacenter.id)\nvapp_container = vsphere.VappContainer(\"vapp_container\",\n    name=\"vapp-01\",\n    parent_resource_pool_id=compute_cluster.resource_pool_id)\nvm = vsphere.VirtualMachine(\"vm\",\n    name=\"foo\",\n    resource_pool_id=vapp_container_vsphere_vapp_container[\"id\"],\n    datastore_id=datastore.id,\n    num_cpus=1,\n    memory=1024,\n    guest_id=\"ubuntu64Guest\",\n    network_interfaces=[{\n        \"network_id\": network.id,\n    }],\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"VM Network\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vappContainer = new VSphere.VappContainer(\"vapp_container\", new()\n    {\n        Name = \"vapp-01\",\n        ParentResourcePoolId = computeCluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n    });\n\n    var vm = new VSphere.VirtualMachine(\"vm\", new()\n    {\n        Name = \"foo\",\n        ResourcePoolId = vappContainerVsphereVappContainer.Id,\n        DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        NumCpus = 1,\n        Memory = 1024,\n        GuestId = \"ubuntu64Guest\",\n        NetworkInterfaces = new[]\n        {\n            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n            {\n                NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n            },\n        },\n        Disks = new[]\n        {\n            new VSphere.Inputs.VirtualMachineDiskArgs\n            {\n                Label = \"disk0\",\n                Size = 20,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcomputeCluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnetwork, err := vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"VM Network\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVappContainer(ctx, \"vapp_container\", \u0026vsphere.VappContainerArgs{\n\t\t\tName:                 pulumi.String(\"vapp-01\"),\n\t\t\tParentResourcePoolId: pulumi.String(computeCluster.ResourcePoolId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVirtualMachine(ctx, \"vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tName:           pulumi.String(\"foo\"),\n\t\t\tResourcePoolId: pulumi.Any(vappContainerVsphereVappContainer.Id),\n\t\t\tDatastoreId:    pulumi.String(datastore.Id),\n\t\t\tNumCpus:        pulumi.Int(1),\n\t\t\tMemory:         pulumi.Int(1024),\n\t\t\tGuestId:        pulumi.String(\"ubuntu64Guest\"),\n\t\t\tNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\t\t\t\t\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\n\t\t\t\t\tNetworkId: pulumi.String(network.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDisks: vsphere.VirtualMachineDiskArray{\n\t\t\t\t\u0026vsphere.VirtualMachineDiskArgs{\n\t\t\t\t\tLabel: pulumi.String(\"disk0\"),\n\t\t\t\t\tSize:  pulumi.Int(20),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport com.pulumi.vsphere.VappContainer;\nimport com.pulumi.vsphere.VappContainerArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"VM Network\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var vappContainer = new VappContainer(\"vappContainer\", VappContainerArgs.builder()\n            .name(\"vapp-01\")\n            .parentResourcePoolId(computeCluster.resourcePoolId())\n            .build());\n\n        var vm = new VirtualMachine(\"vm\", VirtualMachineArgs.builder()\n            .name(\"foo\")\n            .resourcePoolId(vappContainerVsphereVappContainer.id())\n            .datastoreId(datastore.id())\n            .numCpus(1)\n            .memory(1024)\n            .guestId(\"ubuntu64Guest\")\n            .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                .networkId(network.id())\n                .build())\n            .disks(VirtualMachineDiskArgs.builder()\n                .label(\"disk0\")\n                .size(20)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vappContainer:\n    type: vsphere:VappContainer\n    name: vapp_container\n    properties:\n      name: vapp-01\n      parentResourcePoolId: ${computeCluster.resourcePoolId}\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      name: foo\n      resourcePoolId: ${vappContainerVsphereVappContainer.id}\n      datastoreId: ${datastore.id}\n      numCpus: 1\n      memory: 1024\n      guestId: ubuntu64Guest\n      networkInterfaces:\n        - networkId: ${network.id}\n      disks:\n        - label: disk0\n          size: 20\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  computeCluster:\n    fn::invoke:\n      function: vsphere:getComputeCluster\n      arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n  datastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: datastore-01\n        datacenterId: ${datacenter.id}\n  network:\n    fn::invoke:\n      function: vsphere:getNetwork\n      arguments:\n        name: VM Network\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing vApp container can be imported into this resource via\n\nthe path to the vApp container, using the following command:\n\nExample:\n\n```sh\n$ pulumi import vsphere:index/vappContainer:VappContainer vapp_container /dc-01/host/cluster-01/Resources/resource-pool-01/vapp-01\n```\n\nThe example above would import the vApp container named `vapp-01` that is\n\nlocated in the resource pool `resource-pool-01` that is part of the host cluster\n\n`cluster-01` in the `dc-01` datacenter.\n\n",
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappContainer resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container.\n"
                    },
                    "parentFolderId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappEntity:VappEntity": {
            "description": "The `vsphere.VappEntity` resource can be used to describe the behavior of an\nentity (virtual machine or sub-vApp container) in a vApp container.\n\nFor more information on vSphere vApps, see [this\npage][ref-vsphere-vapp].\n\n[ref-vsphere-vapp]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/create-a-vapp-h5-and-flex.html\n\n## Example Usage\n\nThe basic example below sets up a vApp container and a virtual machine in a\ncompute cluster and then creates a vApp entity to change the virtual machine's\npower on behavior in the vApp container.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst config = new pulumi.Config();\nconst datacenter = config.get(\"datacenter\") || \"dc-01\";\nconst cluster = config.get(\"cluster\") || \"cluster-01\";\nconst datacenterGetDatacenter = vsphere.getDatacenter({\n    name: datacenter,\n});\nconst computeCluster = datacenterGetDatacenter.then(datacenterGetDatacenter =\u003e vsphere.getComputeCluster({\n    name: cluster,\n    datacenterId: datacenterGetDatacenter.id,\n}));\nconst network = datacenterGetDatacenter.then(datacenterGetDatacenter =\u003e vsphere.getNetwork({\n    name: \"network1\",\n    datacenterId: datacenterGetDatacenter.id,\n}));\nconst datastore = datacenterGetDatacenter.then(datacenterGetDatacenter =\u003e vsphere.getDatastore({\n    name: \"datastore1\",\n    datacenterId: datacenterGetDatacenter.id,\n}));\nconst vappContainer = new vsphere.VappContainer(\"vapp_container\", {\n    name: \"vapp-container-test\",\n    parentResourcePoolId: computeCluster.then(computeCluster =\u003e computeCluster.id),\n});\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    name: \"virtual-machine-test\",\n    resourcePoolId: vappContainer.id,\n    datastoreId: datastore.then(datastore =\u003e datastore.id),\n    numCpus: 2,\n    memory: 1024,\n    guestId: \"ubuntu64Guest\",\n    disks: [{\n        label: \"disk0\",\n        size: 1,\n    }],\n    networkInterfaces: [{\n        networkId: network.then(network =\u003e network.id),\n    }],\n});\nconst vappEntity = new vsphere.VappEntity(\"vapp_entity\", {\n    targetId: vm.moid,\n    containerId: vappContainer.id,\n    startAction: \"none\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nconfig = pulumi.Config()\ndatacenter = config.get(\"datacenter\")\nif datacenter is None:\n    datacenter = \"dc-01\"\ncluster = config.get(\"cluster\")\nif cluster is None:\n    cluster = \"cluster-01\"\ndatacenter_get_datacenter = vsphere.get_datacenter(name=datacenter)\ncompute_cluster = vsphere.get_compute_cluster(name=cluster,\n    datacenter_id=datacenter_get_datacenter.id)\nnetwork = vsphere.get_network(name=\"network1\",\n    datacenter_id=datacenter_get_datacenter.id)\ndatastore = vsphere.get_datastore(name=\"datastore1\",\n    datacenter_id=datacenter_get_datacenter.id)\nvapp_container = vsphere.VappContainer(\"vapp_container\",\n    name=\"vapp-container-test\",\n    parent_resource_pool_id=compute_cluster.id)\nvm = vsphere.VirtualMachine(\"vm\",\n    name=\"virtual-machine-test\",\n    resource_pool_id=vapp_container.id,\n    datastore_id=datastore.id,\n    num_cpus=2,\n    memory=1024,\n    guest_id=\"ubuntu64Guest\",\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 1,\n    }],\n    network_interfaces=[{\n        \"network_id\": network.id,\n    }])\nvapp_entity = vsphere.VappEntity(\"vapp_entity\",\n    target_id=vm.moid,\n    container_id=vapp_container.id,\n    start_action=\"none\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Config();\n    var datacenter = config.Get(\"datacenter\") ?? \"dc-01\";\n    var cluster = config.Get(\"cluster\") ?? \"cluster-01\";\n    var datacenterGetDatacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = datacenter,\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = cluster,\n        DatacenterId = datacenterGetDatacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"network1\",\n        DatacenterId = datacenterGetDatacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore1\",\n        DatacenterId = datacenterGetDatacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vappContainer = new VSphere.VappContainer(\"vapp_container\", new()\n    {\n        Name = \"vapp-container-test\",\n        ParentResourcePoolId = computeCluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n    });\n\n    var vm = new VSphere.VirtualMachine(\"vm\", new()\n    {\n        Name = \"virtual-machine-test\",\n        ResourcePoolId = vappContainer.Id,\n        DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n        NumCpus = 2,\n        Memory = 1024,\n        GuestId = \"ubuntu64Guest\",\n        Disks = new[]\n        {\n            new VSphere.Inputs.VirtualMachineDiskArgs\n            {\n                Label = \"disk0\",\n                Size = 1,\n            },\n        },\n        NetworkInterfaces = new[]\n        {\n            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n            {\n                NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n            },\n        },\n    });\n\n    var vappEntity = new VSphere.VappEntity(\"vapp_entity\", new()\n    {\n        TargetId = vm.Moid,\n        ContainerId = vappContainer.Id,\n        StartAction = \"none\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcfg := config.New(ctx, \"\")\n\t\tdatacenter := \"dc-01\"\n\t\tif param := cfg.Get(\"datacenter\"); param != \"\" {\n\t\t\tdatacenter = param\n\t\t}\n\t\tcluster := \"cluster-01\"\n\t\tif param := cfg.Get(\"cluster\"); param != \"\" {\n\t\t\tcluster = param\n\t\t}\n\t\tdatacenterGetDatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(datacenter),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcomputeCluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         cluster,\n\t\t\tDatacenterId: pulumi.StringRef(datacenterGetDatacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnetwork, err := vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"network1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenterGetDatacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdatastore, err := vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore1\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenterGetDatacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvappContainer, err := vsphere.NewVappContainer(ctx, \"vapp_container\", \u0026vsphere.VappContainerArgs{\n\t\t\tName:                 pulumi.String(\"vapp-container-test\"),\n\t\t\tParentResourcePoolId: pulumi.String(computeCluster.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvm, err := vsphere.NewVirtualMachine(ctx, \"vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tName:           pulumi.String(\"virtual-machine-test\"),\n\t\t\tResourcePoolId: vappContainer.ID(),\n\t\t\tDatastoreId:    pulumi.String(datastore.Id),\n\t\t\tNumCpus:        pulumi.Int(2),\n\t\t\tMemory:         pulumi.Int(1024),\n\t\t\tGuestId:        pulumi.String(\"ubuntu64Guest\"),\n\t\t\tDisks: vsphere.VirtualMachineDiskArray{\n\t\t\t\t\u0026vsphere.VirtualMachineDiskArgs{\n\t\t\t\t\tLabel: pulumi.String(\"disk0\"),\n\t\t\t\t\tSize:  pulumi.Int(1),\n\t\t\t\t},\n\t\t\t},\n\t\t\tNetworkInterfaces: vsphere.VirtualMachineNetworkInterfaceArray{\n\t\t\t\t\u0026vsphere.VirtualMachineNetworkInterfaceArgs{\n\t\t\t\t\tNetworkId: pulumi.String(network.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVappEntity(ctx, \"vapp_entity\", \u0026vsphere.VappEntityArgs{\n\t\t\tTargetId:    vm.Moid,\n\t\t\tContainerId: vappContainer.ID(),\n\t\t\tStartAction: pulumi.String(\"none\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport com.pulumi.vsphere.VappContainer;\nimport com.pulumi.vsphere.VappContainerArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineDiskArgs;\nimport com.pulumi.vsphere.inputs.VirtualMachineNetworkInterfaceArgs;\nimport com.pulumi.vsphere.VappEntity;\nimport com.pulumi.vsphere.VappEntityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var datacenter = config.get(\"datacenter\").orElse(\"dc-01\");\n        final var cluster = config.get(\"cluster\").orElse(\"cluster-01\");\n        final var datacenterGetDatacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(datacenter)\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(cluster)\n            .datacenterId(datacenterGetDatacenter.id())\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"network1\")\n            .datacenterId(datacenterGetDatacenter.id())\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore1\")\n            .datacenterId(datacenterGetDatacenter.id())\n            .build());\n\n        var vappContainer = new VappContainer(\"vappContainer\", VappContainerArgs.builder()\n            .name(\"vapp-container-test\")\n            .parentResourcePoolId(computeCluster.id())\n            .build());\n\n        var vm = new VirtualMachine(\"vm\", VirtualMachineArgs.builder()\n            .name(\"virtual-machine-test\")\n            .resourcePoolId(vappContainer.id())\n            .datastoreId(datastore.id())\n            .numCpus(2)\n            .memory(1024)\n            .guestId(\"ubuntu64Guest\")\n            .disks(VirtualMachineDiskArgs.builder()\n                .label(\"disk0\")\n                .size(1)\n                .build())\n            .networkInterfaces(VirtualMachineNetworkInterfaceArgs.builder()\n                .networkId(network.id())\n                .build())\n            .build());\n\n        var vappEntity = new VappEntity(\"vappEntity\", VappEntityArgs.builder()\n            .targetId(vm.moid())\n            .containerId(vappContainer.id())\n            .startAction(\"none\")\n            .build());\n\n    }\n}\n```\n```yaml\nconfiguration:\n  datacenter:\n    type: string\n    default: dc-01\n  cluster:\n    type: string\n    default: cluster-01\nresources:\n  vappContainer:\n    type: vsphere:VappContainer\n    name: vapp_container\n    properties:\n      name: vapp-container-test\n      parentResourcePoolId: ${computeCluster.id}\n  vappEntity:\n    type: vsphere:VappEntity\n    name: vapp_entity\n    properties:\n      targetId: ${vm.moid}\n      containerId: ${vappContainer.id}\n      startAction: none\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      name: virtual-machine-test\n      resourcePoolId: ${vappContainer.id}\n      datastoreId: ${datastore.id}\n      numCpus: 2\n      memory: 1024\n      guestId: ubuntu64Guest\n      disks:\n        - label: disk0\n          size: 1\n      networkInterfaces:\n        - networkId: ${network.id}\nvariables:\n  datacenterGetDatacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: ${datacenter}\n  computeCluster:\n    fn::invoke:\n      function: vsphere:getComputeCluster\n      arguments:\n        name: ${cluster}\n        datacenterId: ${datacenterGetDatacenter.id}\n  network:\n    fn::invoke:\n      function: vsphere:getNetwork\n      arguments:\n        name: network1\n        datacenterId: ${datacenterGetDatacenter.id}\n  datastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: datastore1\n        datacenterId: ${datacenterGetDatacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing vApp entity can be imported into this resource via\n\nthe ID of the vApp Entity.\n\n```sh\n$ pulumi import vsphere:index/vappEntity:VappEntity vapp_entity vm-123:res-456\n```\n\nThe above would import the vApp entity that governs the behavior of the virtual\n\nmachine with a [managed object ID][docs-about-morefs] of vm-123 in the vApp\n\ncontainer with the [managed object ID][docs-about-morefs] res-456.\n\n",
            "properties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n"
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "required": [
                "containerId",
                "targetId"
            ],
            "inputProperties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n",
                    "willReplaceOnChanges": true
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n",
                    "willReplaceOnChanges": true
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "requiredInputs": [
                "containerId",
                "targetId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappEntity resources.\n",
                "properties": {
                    "containerId": {
                        "type": "string",
                        "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n",
                        "willReplaceOnChanges": true
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "startAction": {
                        "type": "string",
                        "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                    },
                    "startDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                    },
                    "startOrder": {
                        "type": "integer",
                        "description": "Order to start and stop target in vApp. Default: 1\n"
                    },
                    "stopAction": {
                        "type": "string",
                        "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                    },
                    "stopDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "targetId": {
                        "type": "string",
                        "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n",
                        "willReplaceOnChanges": true
                    },
                    "waitForGuest": {
                        "type": "boolean",
                        "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualDisk:VirtualDisk": {
            "description": "The `vsphere.VirtualDisk` resource can be used to create virtual disks outside\nof any given `vsphere.VirtualMachine`\nresource. These disks can be attached to a virtual machine by creating a disk\nblock with the `attach` parameter.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = vsphere.getDatacenter({\n    name: \"datastore-01\",\n});\nconst virtualDisk = new vsphere.VirtualDisk(\"virtual_disk\", {\n    size: 40,\n    type: \"thin\",\n    vmdkPath: \"/foo/foo.vmdk\",\n    createDirectories: true,\n    datacenter: datacenter.then(datacenter =\u003e datacenter.name),\n    datastore: datastoreVsphereDatastore.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datacenter(name=\"datastore-01\")\nvirtual_disk = vsphere.VirtualDisk(\"virtual_disk\",\n    size=40,\n    type=\"thin\",\n    vmdk_path=\"/foo/foo.vmdk\",\n    create_directories=True,\n    datacenter=datacenter.name,\n    datastore=datastore_vsphere_datastore[\"name\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"datastore-01\",\n    });\n\n    var virtualDisk = new VSphere.VirtualDisk(\"virtual_disk\", new()\n    {\n        Size = 40,\n        Type = \"thin\",\n        VmdkPath = \"/foo/foo.vmdk\",\n        CreateDirectories = true,\n        Datacenter = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Name),\n        Datastore = datastoreVsphereDatastore.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"datastore-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVirtualDisk(ctx, \"virtual_disk\", \u0026vsphere.VirtualDiskArgs{\n\t\t\tSize:              pulumi.Int(40),\n\t\t\tType:              pulumi.String(\"thin\"),\n\t\t\tVmdkPath:          pulumi.String(\"/foo/foo.vmdk\"),\n\t\t\tCreateDirectories: pulumi.Bool(true),\n\t\t\tDatacenter:        pulumi.String(datacenter.Name),\n\t\t\tDatastore:         pulumi.Any(datastoreVsphereDatastore.Name),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.VirtualDisk;\nimport com.pulumi.vsphere.VirtualDiskArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastore = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"datastore-01\")\n            .build());\n\n        var virtualDisk = new VirtualDisk(\"virtualDisk\", VirtualDiskArgs.builder()\n            .size(40)\n            .type(\"thin\")\n            .vmdkPath(\"/foo/foo.vmdk\")\n            .createDirectories(true)\n            .datacenter(datacenter.name())\n            .datastore(datastoreVsphereDatastore.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  virtualDisk:\n    type: vsphere:VirtualDisk\n    name: virtual_disk\n    properties:\n      size: 40\n      type: thin\n      vmdkPath: /foo/foo.vmdk\n      createDirectories: true\n      datacenter: ${datacenter.name}\n      datastore: ${datastoreVsphereDatastore.name}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  datastore:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: datastore-01\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing virtual disk can be imported into this resource\n\nvia supplying the full datastore path to the virtual disk. An example is below:\n\n```sh\n$ pulumi import vsphere:index/virtualDisk:VirtualDisk virtual_disk \\\n```\n\n  '{\"virtual_disk_path\": \"/dc-01/[datastore-01]foo/bar.vmdk\", \\ \"create_directories\": \"true\"}'\n\nThe above would import the virtual disk located at `foo/bar.vmdk` in the `datastore-01`\n\ndatastore of the `dc-01` datacenter with `create_directories` set as `true`.\n\n",
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n\n\u003e **NOTE:** `adapter_type` is **deprecated**: it does not dictate the type of\ncontroller that the virtual disk will be attached to on the virtual machine.\nPlease see the `scsi_type` parameter\nin the `vsphere.VirtualMachine` resource for information on how to control\ndisk controller types. This parameter will be removed in future versions of the\nvSphere provider.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere.VirtualMachine instead"
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n\n\u003e **NOTE:** Any directory created as part of the operation when\n`create_directories` is enabled will not be deleted when the resource is\ndestroyed.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when ESXi or if there is only one datacenter in\nyour infrastructure.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB). Decreasing the size of a disk is not possible.\nIf a disk of a smaller size is required then the original has to be destroyed along with its data and a new one has to be\ncreated.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n\n[docs-vmware-vm-disk-provisioning]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-single-host-management-vmware-host-client-8-0/virtual-machine-management-with-the-vsphere-host-client-vSphereSingleHostManagementVMwareHostClient/configuring-virtual-machines-in-the-vsphere-host-client-vSphereSingleHostManagementVMwareHostClient/virtual-disk-configuration-vSphereSingleHostManagementVMwareHostClient/about-virtual-disk-provisioning-policies-vSphereSingleHostManagementVMwareHostClient.html\n"
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n"
                }
            },
            "required": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "inputProperties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n\n\u003e **NOTE:** `adapter_type` is **deprecated**: it does not dictate the type of\ncontroller that the virtual disk will be attached to on the virtual machine.\nPlease see the `scsi_type` parameter\nin the `vsphere.VirtualMachine` resource for information on how to control\ndisk controller types. This parameter will be removed in future versions of the\nvSphere provider.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere.VirtualMachine instead",
                    "willReplaceOnChanges": true
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n\n\u003e **NOTE:** Any directory created as part of the operation when\n`create_directories` is enabled will not be deleted when the resource is\ndestroyed.\n",
                    "willReplaceOnChanges": true
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when ESXi or if there is only one datacenter in\nyour infrastructure.\n",
                    "willReplaceOnChanges": true
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n",
                    "willReplaceOnChanges": true
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB). Decreasing the size of a disk is not possible.\nIf a disk of a smaller size is required then the original has to be destroyed along with its data and a new one has to be\ncreated.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n\n[docs-vmware-vm-disk-provisioning]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-single-host-management-vmware-host-client-8-0/virtual-machine-management-with-the-vsphere-host-client-vSphereSingleHostManagementVMwareHostClient/configuring-virtual-machines-in-the-vsphere-host-client-vSphereSingleHostManagementVMwareHostClient/virtual-disk-configuration-vSphereSingleHostManagementVMwareHostClient/about-virtual-disk-provisioning-policies-vSphereSingleHostManagementVMwareHostClient.html\n",
                    "willReplaceOnChanges": true
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualDisk resources.\n",
                "properties": {
                    "adapterType": {
                        "type": "string",
                        "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n\n\u003e **NOTE:** `adapter_type` is **deprecated**: it does not dictate the type of\ncontroller that the virtual disk will be attached to on the virtual machine.\nPlease see the `scsi_type` parameter\nin the `vsphere.VirtualMachine` resource for information on how to control\ndisk controller types. This parameter will be removed in future versions of the\nvSphere provider.\n",
                        "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere.VirtualMachine instead",
                        "willReplaceOnChanges": true
                    },
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n\n\u003e **NOTE:** Any directory created as part of the operation when\n`create_directories` is enabled will not be deleted when the resource is\ndestroyed.\n",
                        "willReplaceOnChanges": true
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when ESXi or if there is only one datacenter in\nyour infrastructure.\n",
                        "willReplaceOnChanges": true
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore in which to create the\ndisk.\n",
                        "willReplaceOnChanges": true
                    },
                    "size": {
                        "type": "integer",
                        "description": "Size of the disk (in GB). Decreasing the size of a disk is not possible.\nIf a disk of a smaller size is required then the original has to be destroyed along with its data and a new one has to be\ncreated.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n\n[docs-vmware-vm-disk-provisioning]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-single-host-management-vmware-host-client-8-0/virtual-machine-management-with-the-vsphere-host-client-vSphereSingleHostManagementVMwareHostClient/configuring-virtual-machines-in-the-vsphere-host-client-vSphereSingleHostManagementVMwareHostClient/virtual-disk-configuration-vSphereSingleHostManagementVMwareHostClient/about-virtual-disk-provisioning-policies-vSphereSingleHostManagementVMwareHostClient.html\n",
                        "willReplaceOnChanges": true
                    },
                    "vmdkPath": {
                        "type": "string",
                        "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachine:VirtualMachine": {
            "description": "\n\n## Import\n\n### Additional Importing Requirements\n\nMany of the requirements for [cloning](#additional-requirements-and-notes-for-cloning) apply to importing. Although importing writes directly to the Terraform state, some rules can not be enforced during import time, so every effort should be made to ensure the correctness of the configuration before the import.\n\nThe following requirements apply to import:\n\n* The disks must have a [`label`](#label) argument assigned in a convention matching `Hard Disk`, starting with disk number 0, based on each virtual disk order on the SCSI bus. As an example, a disk on SCSI controller `0` with a unit number of `0` would be labeled as `Hard Disk 0`, a disk on the same controller with a unit number of `1` would be `Hard Disk 1`, but the next disk, which is on SCSI controller `1` with a unit number of `0`, still becomes `Hard Disk 2`.\n\n* Disks are always imported with [`keep_on_remove`](#keep_on_remove) enabled until the first `pulumi up` run which will remove the setting for known disks. This process safeguards against naming or accounting mistakes in the disk configuration.\n\n* The storage controller count for the resource is set to the number of contiguous storage controllers found, starting with the controller at SCSI bus number `0`. If no storage controllers are discovered, the virtual machine is not eligible for import. For maximum compatibility, ensure that the virtual machine has the exact number of storage controllers needed and set the storage controller count accordingly.\n\nAfter importing, you should run `pulumi preview`. Unless you have changed anything else in the configuration that would cause other attributes to change. The only difference should be configuration-only changes, which are typically comprised of:\n\n* The [`imported`](#imported) flag will transition from `true` to `false`.\n\n* The [`keep_on_remove`](#keep_on_remove) of known disks will transition from `true` to `false`.\n\n* Configuration supplied in the [`clone`](#clone) block, if present, will be persisted to state. This initial persistence operation does not perform any cloning or customization actions, nor does it force a new resource. After the first apply operation, further changes to `clone` will force the creation of a new resource.\n\nThese changes only update Terraform state when applied. Hence, it is safe to run when the virtual machine is running. If more settings are modified, you may need to plan maintenance accordingly for any necessary virtual machine re-configurations.\n\n",
            "properties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system when guest_id is otherGuest or otherGuest64.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "User-provided description of the virtual machine.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting the boot sequence.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.\n"
                },
                "cdroms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom"
                    },
                    "description": "A specification for a CDROM device on this virtual machine.\n"
                },
                "changeVersion": {
                    "type": "string",
                    "description": "A unique identifier for a given version of the last configuration was applied.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                    "description": "A specification for cloning a virtual machine from template.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance counters on this virtual machine.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to cpu for a custom share level.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for cpu resources. Can be one of high, low, normal, or custom.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VM is to be created.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The ID of a datastore cluster to put the virtual machine in.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual\ndisks that are created without datastores.\n"
                },
                "defaultIpAddress": {
                    "type": "string",
                    "description": "The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on this virtual machine.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "When the boot type set in firmware is efi, this enables EFI secure boot.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging on this virtual machine.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata, or configuration data for OVF images.\n"
                },
                "extraConfigRebootRequired": {
                    "type": "boolean",
                    "description": "Allow the virtual machine to be rebooted when a change to `extra_config` occurs.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware interface to use on the virtual machine. Can be one of bios or efi.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The name of the folder to locate the virtual machine in.\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system.\n"
                },
                "guestIpAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The current list of IP addresses on this machine, including the value of `default_ip_address`. If VMware Tools is not running on the virtual machine, or if the virtul machine is powered off, this list will be empty.\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version for the virtual machine.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The ID of an optional host system to pin the virtual machine to.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.\n"
                },
                "ideControllerCount": {
                    "type": "integer"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to ignore while waiting for an IP\n"
                },
                "imported": {
                    "type": "boolean",
                    "description": "Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard\ndevices. Can be one of low, normal, medium, or high.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The size of the virtual machine's memory, in MB.\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to this virtual machine while it is running.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                },
                "memoryReservationLockedToMax": {
                    "type": "boolean",
                    "description": "If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine's memory\nsize;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature\nmay only be enabled if it is currently possible to reserve all of the virtual machine's memory.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to memory for a custom share level.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for memory resources. Can be one of high, low, normal, or custom.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for a vMotion operation to complete before failing.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "The managed object reference ID of the created virtual machine.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of this virtual machine.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this virtual machine.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus\nmust be evenly divisible by this value.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The number of virtual processors to assign to this virtual machine.\n"
                },
                "nvmeControllerCount": {
                    "type": "integer"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "A specification for deploying a virtual machine from ovf/ova template.\n"
                },
                "pciDeviceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PCI passthrough devices\n"
                },
                "powerState": {
                    "type": "string",
                    "description": "A computed value for the current power state of the virtual machine. One of `on`, `off`, or `suspended`.\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "rebootRequired": {
                    "type": "boolean"
                },
                "replaceTrigger": {
                    "type": "string",
                    "description": "Triggers replacement of resource whenever it changes.\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The ID of a resource pool to put the virtual machine in.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable the run of scripts after virtual machine power-on when VMware Tools is installed.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable the run of scripts after virtual machine resume when when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system reboot when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system standby when VMware Tools is installed.\n"
                },
                "sataControllerCount": {
                    "type": "integer"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.\n"
                },
                "scsiControllerCount": {
                    "type": "integer"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The ID of the storage policy to assign to the virtual machine home directory.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is\nsynchronized on startup and resume. Requires VMware Tools to be installed.\n"
                },
                "syncTimeWithHostPeriodically": {
                    "type": "boolean",
                    "description": "Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions\nsetting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "toolsUpgradePolicy": {
                    "type": "string",
                    "description": "Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual machine. Also exposed as the `id` of the resource.\n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.\n"
                },
                "vappTransports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.\n"
                },
                "vbsEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if Virtualization-based security is enabled for this virtual machine.\n"
                },
                "vmwareToolsStatus": {
                    "type": "string",
                    "description": "The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.\n"
                },
                "vmxPath": {
                    "type": "string",
                    "description": "The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.\n"
                },
                "vtpm": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVtpm:VirtualMachineVtpm",
                    "description": "A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.\n"
                },
                "vvtdEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD\nI/O Virtualization (AMD-Vi or IOMMU), is enabled.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for\na default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                }
            },
            "required": [
                "annotation",
                "changeVersion",
                "cpuShareCount",
                "datastoreId",
                "defaultIpAddress",
                "disks",
                "eptRviMode",
                "guestId",
                "guestIpAddresses",
                "hardwareVersion",
                "hostSystemId",
                "hvMode",
                "imported",
                "memoryShareCount",
                "moid",
                "name",
                "powerState",
                "rebootRequired",
                "resourcePoolId",
                "storagePolicyId",
                "uuid",
                "vappTransports",
                "vmwareToolsStatus",
                "vmxPath"
            ],
            "inputProperties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system when guest_id is otherGuest or otherGuest64.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "User-provided description of the virtual machine.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting the boot sequence.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.\n"
                },
                "cdroms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom"
                    },
                    "description": "A specification for a CDROM device on this virtual machine.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                    "description": "A specification for cloning a virtual machine from template.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance counters on this virtual machine.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to cpu for a custom share level.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for cpu resources. Can be one of high, low, normal, or custom.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VM is to be created.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The ID of a datastore cluster to put the virtual machine in.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual\ndisks that are created without datastores.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on this virtual machine.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "When the boot type set in firmware is efi, this enables EFI secure boot.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging on this virtual machine.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata, or configuration data for OVF images.\n"
                },
                "extraConfigRebootRequired": {
                    "type": "boolean",
                    "description": "Allow the virtual machine to be rebooted when a change to `extra_config` occurs.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware interface to use on the virtual machine. Can be one of bios or efi.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The name of the folder to locate the virtual machine in.\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system.\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version for the virtual machine.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The ID of an optional host system to pin the virtual machine to.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.\n"
                },
                "ideControllerCount": {
                    "type": "integer"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to ignore while waiting for an IP\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard\ndevices. Can be one of low, normal, medium, or high.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The size of the virtual machine's memory, in MB.\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to this virtual machine while it is running.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                },
                "memoryReservationLockedToMax": {
                    "type": "boolean",
                    "description": "If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine's memory\nsize;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature\nmay only be enabled if it is currently possible to reserve all of the virtual machine's memory.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to memory for a custom share level.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for memory resources. Can be one of high, low, normal, or custom.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for a vMotion operation to complete before failing.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of this virtual machine.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this virtual machine.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus\nmust be evenly divisible by this value.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The number of virtual processors to assign to this virtual machine.\n"
                },
                "nvmeControllerCount": {
                    "type": "integer"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "A specification for deploying a virtual machine from ovf/ova template.\n"
                },
                "pciDeviceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PCI passthrough devices\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "replaceTrigger": {
                    "type": "string",
                    "description": "Triggers replacement of resource whenever it changes.\n",
                    "willReplaceOnChanges": true
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The ID of a resource pool to put the virtual machine in.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable the run of scripts after virtual machine power-on when VMware Tools is installed.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable the run of scripts after virtual machine resume when when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system reboot when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system standby when VMware Tools is installed.\n"
                },
                "sataControllerCount": {
                    "type": "integer"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.\n"
                },
                "scsiControllerCount": {
                    "type": "integer"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The ID of the storage policy to assign to the virtual machine home directory.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is\nsynchronized on startup and resume. Requires VMware Tools to be installed.\n"
                },
                "syncTimeWithHostPeriodically": {
                    "type": "boolean",
                    "description": "Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions\nsetting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "toolsUpgradePolicy": {
                    "type": "string",
                    "description": "Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.\n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.\n"
                },
                "vbsEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if Virtualization-based security is enabled for this virtual machine.\n"
                },
                "vtpm": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVtpm:VirtualMachineVtpm",
                    "description": "A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.\n"
                },
                "vvtdEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD\nI/O Virtualization (AMD-Vi or IOMMU), is enabled.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for\na default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                }
            },
            "requiredInputs": [
                "resourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachine resources.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The guest name for the operating system when guest_id is otherGuest or otherGuest64.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "User-provided description of the virtual machine.\n"
                    },
                    "bootDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before starting the boot sequence.\n"
                    },
                    "bootRetryDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.\n"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean",
                        "description": "If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.\n"
                    },
                    "cdroms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom"
                        },
                        "description": "A specification for a CDROM device on this virtual machine.\n"
                    },
                    "changeVersion": {
                        "type": "string",
                        "description": "A unique identifier for a given version of the last configuration was applied.\n"
                    },
                    "clone": {
                        "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                        "description": "A specification for cloning a virtual machine from template.\n"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean",
                        "description": "Enable CPU performance counters on this virtual machine.\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                    },
                    "cpuShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to cpu for a custom share level.\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The allocation level for cpu resources. Can be one of high, low, normal, or custom.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter where the VM is to be created.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The ID of a datastore cluster to put the virtual machine in.\n"
                    },
                    "datastoreId": {
                        "type": "string",
                        "description": "The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual\ndisks that are created without datastores.\n"
                    },
                    "defaultIpAddress": {
                        "type": "string",
                        "description": "The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                        },
                        "description": "A specification for a virtual disk device on this virtual machine.\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean",
                        "description": "When the boot type set in firmware is efi, this enables EFI secure boot.\n"
                    },
                    "enableDiskUuid": {
                        "type": "boolean",
                        "description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.\n"
                    },
                    "enableLogging": {
                        "type": "boolean",
                        "description": "Enable logging on this virtual machine.\n"
                    },
                    "eptRviMode": {
                        "type": "string",
                        "description": "The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata, or configuration data for OVF images.\n"
                    },
                    "extraConfigRebootRequired": {
                        "type": "boolean",
                        "description": "Allow the virtual machine to be rebooted when a change to `extra_config` occurs.\n"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware interface to use on the virtual machine. Can be one of bios or efi.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The name of the folder to locate the virtual machine in.\n"
                    },
                    "forcePowerOff": {
                        "type": "boolean",
                        "description": "Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID for the operating system.\n"
                    },
                    "guestIpAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The current list of IP addresses on this machine, including the value of `default_ip_address`. If VMware Tools is not running on the virtual machine, or if the virtul machine is powered off, this list will be empty.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version for the virtual machine.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The ID of an optional host system to pin the virtual machine to.\n"
                    },
                    "hvMode": {
                        "type": "string",
                        "description": "The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.\n"
                    },
                    "ideControllerCount": {
                        "type": "integer"
                    },
                    "ignoredGuestIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP addresses and CIDR networks to ignore while waiting for an IP\n"
                    },
                    "imported": {
                        "type": "boolean",
                        "description": "Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.\n"
                    },
                    "latencySensitivity": {
                        "type": "string",
                        "description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard\ndevices. Can be one of low, normal, medium, or high.\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow memory to be added to this virtual machine while it is running.\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                    },
                    "memoryReservationLockedToMax": {
                        "type": "boolean",
                        "description": "If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine's memory\nsize;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature\nmay only be enabled if it is currently possible to reserve all of the virtual machine's memory.\n"
                    },
                    "memoryShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to memory for a custom share level.\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The allocation level for memory resources. Can be one of high, low, normal, or custom.\n"
                    },
                    "migrateWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for a vMotion operation to complete before failing.\n"
                    },
                    "moid": {
                        "type": "string",
                        "description": "The managed object reference ID of the created virtual machine.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of this virtual machine.\n"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean",
                        "description": "Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.\n"
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                        },
                        "description": "A specification for a virtual NIC on this virtual machine.\n"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus\nmust be evenly divisible by this value.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The number of virtual processors to assign to this virtual machine.\n"
                    },
                    "nvmeControllerCount": {
                        "type": "integer"
                    },
                    "ovfDeploy": {
                        "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                        "description": "A specification for deploying a virtual machine from ovf/ova template.\n"
                    },
                    "pciDeviceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of PCI passthrough devices\n"
                    },
                    "powerState": {
                        "type": "string",
                        "description": "A computed value for the current power state of the virtual machine. One of `on`, `off`, or `suspended`.\n"
                    },
                    "poweronTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                    },
                    "rebootRequired": {
                        "type": "boolean"
                    },
                    "replaceTrigger": {
                        "type": "string",
                        "description": "Triggers replacement of resource whenever it changes.\n",
                        "willReplaceOnChanges": true
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The ID of a resource pool to put the virtual machine in.\n"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean",
                        "description": "Enable the run of scripts after virtual machine power-on when VMware Tools is installed.\n"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean",
                        "description": "Enable the run of scripts after virtual machine resume when when VMware Tools is installed.\n"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean",
                        "description": "Enable the run of scripts before guest operating system reboot when VMware Tools is installed.\n"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean",
                        "description": "Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.\n"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean",
                        "description": "Enable the run of scripts before guest operating system standby when VMware Tools is installed.\n"
                    },
                    "sataControllerCount": {
                        "type": "integer"
                    },
                    "scsiBusSharing": {
                        "type": "string",
                        "description": "Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.\n"
                    },
                    "scsiControllerCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "type": "string",
                        "description": "The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.\n"
                    },
                    "shutdownWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.\n"
                    },
                    "storagePolicyId": {
                        "type": "string",
                        "description": "The ID of the storage policy to assign to the virtual machine home directory.\n"
                    },
                    "swapPlacementPolicy": {
                        "type": "string",
                        "description": "The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.\n"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean",
                        "description": "Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is\nsynchronized on startup and resume. Requires VMware Tools to be installed.\n"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean",
                        "description": "Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions\nsetting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "toolsUpgradePolicy": {
                        "type": "string",
                        "description": "Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "The UUID of the virtual machine. Also exposed as the `id` of the resource.\n"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                        "description": "vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.\n"
                    },
                    "vappTransports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.\n"
                    },
                    "vbsEnabled": {
                        "type": "boolean",
                        "description": "Flag to specify if Virtualization-based security is enabled for this virtual machine.\n"
                    },
                    "vmwareToolsStatus": {
                        "type": "string",
                        "description": "The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.\n"
                    },
                    "vmxPath": {
                        "type": "string",
                        "description": "The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.\n"
                    },
                    "vtpm": {
                        "$ref": "#/types/vsphere:index/VirtualMachineVtpm:VirtualMachineVtpm",
                        "description": "A specification for a virtual Trusted Platform Module (TPM) device on the virtual machine.\n"
                    },
                    "vvtdEnabled": {
                        "type": "boolean",
                        "description": "Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD\nI/O Virtualization (AMD-Vi or IOMMU), is enabled.\n"
                    },
                    "waitForGuestIpTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                    },
                    "waitForGuestNetRoutable": {
                        "type": "boolean",
                        "description": "Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for\na default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.\n"
                    },
                    "waitForGuestNetTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachineClass:VirtualMachineClass": {
            "description": "Provides a resource for configuring a Virtual Machine class.\n\n## Example Usage\n\n### S\n\n**Create a basic class**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst basicClass = new vsphere.VirtualMachineClass(\"basic_class\", {\n    name: \"basic-class\",\n    cpus: 4,\n    memory: 4096,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nbasic_class = vsphere.VirtualMachineClass(\"basic_class\",\n    name=\"basic-class\",\n    cpus=4,\n    memory=4096)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var basicClass = new VSphere.VirtualMachineClass(\"basic_class\", new()\n    {\n        Name = \"basic-class\",\n        Cpus = 4,\n        Memory = 4096,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachineClass(ctx, \"basic_class\", \u0026vsphere.VirtualMachineClassArgs{\n\t\t\tName:   pulumi.String(\"basic-class\"),\n\t\t\tCpus:   pulumi.Int(4),\n\t\t\tMemory: pulumi.Int(4096),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachineClass;\nimport com.pulumi.vsphere.VirtualMachineClassArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var basicClass = new VirtualMachineClass(\"basicClass\", VirtualMachineClassArgs.builder()\n            .name(\"basic-class\")\n            .cpus(4)\n            .memory(4096)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  basicClass:\n    type: vsphere:VirtualMachineClass\n    name: basic_class\n    properties:\n      name: basic-class\n      cpus: 4\n      memory: 4096\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n**Create a class with a vGPU**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vgpClass = new vsphere.VirtualMachineClass(\"vgp_class\", {\n    name: \"vgpu-class\",\n    cpus: 4,\n    memory: 4096,\n    memoryReservation: 100,\n    vgpuDevices: [\"vgpu1\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvgp_class = vsphere.VirtualMachineClass(\"vgp_class\",\n    name=\"vgpu-class\",\n    cpus=4,\n    memory=4096,\n    memory_reservation=100,\n    vgpu_devices=[\"vgpu1\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vgpClass = new VSphere.VirtualMachineClass(\"vgp_class\", new()\n    {\n        Name = \"vgpu-class\",\n        Cpus = 4,\n        Memory = 4096,\n        MemoryReservation = 100,\n        VgpuDevices = new[]\n        {\n            \"vgpu1\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachineClass(ctx, \"vgp_class\", \u0026vsphere.VirtualMachineClassArgs{\n\t\t\tName:              pulumi.String(\"vgpu-class\"),\n\t\t\tCpus:              pulumi.Int(4),\n\t\t\tMemory:            pulumi.Int(4096),\n\t\t\tMemoryReservation: pulumi.Int(100),\n\t\t\tVgpuDevices: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vgpu1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachineClass;\nimport com.pulumi.vsphere.VirtualMachineClassArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vgpClass = new VirtualMachineClass(\"vgpClass\", VirtualMachineClassArgs.builder()\n            .name(\"vgpu-class\")\n            .cpus(4)\n            .memory(4096)\n            .memoryReservation(100)\n            .vgpuDevices(\"vgpu1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vgpClass:\n    type: vsphere:VirtualMachineClass\n    name: vgp_class\n    properties:\n      name: vgpu-class\n      cpus: 4\n      memory: 4096\n      memoryReservation: 100\n      vgpuDevices:\n        - vgpu1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "cpuReservation": {
                    "type": "integer",
                    "description": "The percentage of the available CPU capacity which will be reserved.\n"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of CPUs.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of memory in MB.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The percentage of memory reservation.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the class.\n"
                },
                "vgpuDevices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identifiers of the vGPU devices for the class. If this is set memory reservation needs to be 100.\n"
                }
            },
            "required": [
                "cpus",
                "memory",
                "name"
            ],
            "inputProperties": {
                "cpuReservation": {
                    "type": "integer",
                    "description": "The percentage of the available CPU capacity which will be reserved.\n"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of CPUs.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of memory in MB.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The percentage of memory reservation.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the class.\n"
                },
                "vgpuDevices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identifiers of the vGPU devices for the class. If this is set memory reservation needs to be 100.\n"
                }
            },
            "requiredInputs": [
                "cpus",
                "memory"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachineClass resources.\n",
                "properties": {
                    "cpuReservation": {
                        "type": "integer",
                        "description": "The percentage of the available CPU capacity which will be reserved.\n"
                    },
                    "cpus": {
                        "type": "integer",
                        "description": "The number of CPUs.\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The amount of memory in MB.\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "The percentage of memory reservation.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name for the class.\n"
                    },
                    "vgpuDevices": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The identifiers of the vGPU devices for the class. If this is set memory reservation needs to be 100.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachineSnapshot:VirtualMachineSnapshot": {
            "description": "The `vsphere.VirtualMachineSnapshot` resource can be used to manage snapshots\nfor a virtual machine.\n\nFor more information on managing snapshots and how they work in VMware, see\n[here][ext-vm-snapshot-management].\n\n[ext-vm-snapshot-management]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-single-host-management-vmware-host-client-8-0/virtual-machine-management-with-the-vsphere-host-client-vSphereSingleHostManagementVMwareHostClient/managing-virtual-machines-in-the-vsphere-host-client-vSphereSingleHostManagementVMwareHostClient/using-snapshots-to-manage-virtual-machines-vSphereSingleHostManagementVMwareHostClient.html\n\n\u003e **NOTE:** A snapshot in VMware differs from traditional disk snapshots, and\ncan contain the actual running state of the virtual machine, data for all disks\nthat have not been set to be independent from the snapshot (including ones that\nhave been attached via the `attach`\nparameter to the `vsphere.VirtualMachine` `disk` block), and even the\nconfiguration of the virtual machine at the time of the snapshot. Virtual\nmachine, disk activity, and configuration changes post-snapshot are not\nincluded in the original state. Use this resource with care! Neither VMware nor\nHashiCorp recommends retaining snapshots for a extended period of time and does\nNOT recommend using them as as backup feature. For more information on the\nlimitation of virtual machine snapshots, see [here][ext-vm-snap-limitations].\n\n[ext-vm-snap-limitations]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-virtual-machine-administration-guide-8-0/managing-virtual-machinesvsphere-vm-admin/using-snapshots-to-manage-virtual-machinesvsphere-vm-admin/snapshot-file-names-and-descriptionvsphere-vm-admin.html\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst demo1 = new vsphere.VirtualMachineSnapshot(\"demo1\", {\n    virtualMachineUuid: \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n    snapshotName: \"Snapshot Name\",\n    description: \"This is Demo Snapshot\",\n    memory: true,\n    quiesce: true,\n    removeChildren: false,\n    consolidate: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndemo1 = vsphere.VirtualMachineSnapshot(\"demo1\",\n    virtual_machine_uuid=\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n    snapshot_name=\"Snapshot Name\",\n    description=\"This is Demo Snapshot\",\n    memory=True,\n    quiesce=True,\n    remove_children=False,\n    consolidate=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demo1 = new VSphere.VirtualMachineSnapshot(\"demo1\", new()\n    {\n        VirtualMachineUuid = \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n        SnapshotName = \"Snapshot Name\",\n        Description = \"This is Demo Snapshot\",\n        Memory = true,\n        Quiesce = true,\n        RemoveChildren = false,\n        Consolidate = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachineSnapshot(ctx, \"demo1\", \u0026vsphere.VirtualMachineSnapshotArgs{\n\t\t\tVirtualMachineUuid: pulumi.String(\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\"),\n\t\t\tSnapshotName:       pulumi.String(\"Snapshot Name\"),\n\t\t\tDescription:        pulumi.String(\"This is Demo Snapshot\"),\n\t\t\tMemory:             pulumi.Bool(true),\n\t\t\tQuiesce:            pulumi.Bool(true),\n\t\t\tRemoveChildren:     pulumi.Bool(false),\n\t\t\tConsolidate:        pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachineSnapshot;\nimport com.pulumi.vsphere.VirtualMachineSnapshotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demo1 = new VirtualMachineSnapshot(\"demo1\", VirtualMachineSnapshotArgs.builder()\n            .virtualMachineUuid(\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\")\n            .snapshotName(\"Snapshot Name\")\n            .description(\"This is Demo Snapshot\")\n            .memory(true)\n            .quiesce(true)\n            .removeChildren(false)\n            .consolidate(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demo1:\n    type: vsphere:VirtualMachineSnapshot\n    properties:\n      virtualMachineUuid: 9aac5551-a351-4158-8c5c-15a71e8ec5c9\n      snapshotName: Snapshot Name\n      description: This is Demo Snapshot\n      memory: 'true'\n      quiesce: 'true'\n      removeChildren: 'false'\n      consolidate: 'true'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n"
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n"
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n"
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n"
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n"
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n"
                }
            },
            "required": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "inputProperties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n",
                    "willReplaceOnChanges": true
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n",
                    "willReplaceOnChanges": true
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachineSnapshot resources.\n",
                "properties": {
                    "consolidate": {
                        "type": "boolean",
                        "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "memory": {
                        "type": "boolean",
                        "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "quiesce": {
                        "type": "boolean",
                        "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n",
                        "willReplaceOnChanges": true
                    },
                    "removeChildren": {
                        "type": "boolean",
                        "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotName": {
                        "type": "string",
                        "description": "The name of the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "virtualMachineUuid": {
                        "type": "string",
                        "description": "The virtual machine UUID.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vmStoragePolicy:VmStoragePolicy": {
            "description": "The `vsphere.VmStoragePolicy` resource can be used to create and manage storage\npolicies. Using this resource, tag based placement rules can be created to\nplace virtual machines on a datastore with matching tags. If storage requirements for the applications on the virtual machine change, you can modify the storage policy that was originally applied to the virtual machine.\n\n## Example Usage\n\nThe following example creates storage policies with `tag_rules` base on sets of environment, service level, and replication attributes.\n\nIn this example, tags are first applied to datastores.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst environment = vsphere.getTagCategory({\n    name: \"environment\",\n});\nconst serviceLevel = vsphere.getTagCategory({\n    name: \"service_level\",\n});\nconst replication = vsphere.getTagCategory({\n    name: \"replication\",\n});\nconst production = vsphere.getTag({\n    name: \"production\",\n    categoryId: \"data.vsphere_tag_category.environment.id\",\n});\nconst development = vsphere.getTag({\n    name: \"development\",\n    categoryId: \"data.vsphere_tag_category.environment.id\",\n});\nconst platinum = vsphere.getTag({\n    name: \"platinum\",\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n});\nconst gold = vsphere.getTag({\n    name: \"platinum\",\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n});\nconst silver = vsphere.getTag({\n    name: \"silver\",\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n});\nconst bronze = vsphere.getTag({\n    name: \"bronze\",\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n});\nconst replicated = vsphere.getTag({\n    name: \"replicated\",\n    categoryId: \"data.vsphere_tag_category.replication.id\",\n});\nconst nonReplicated = vsphere.getTag({\n    name: \"non_replicated\",\n    categoryId: \"data.vsphere_tag_category.replication.id\",\n});\nconst prodDatastore = new vsphere.VmfsDatastore(\"prod_datastore\", {tags: [\n    \"data.vsphere_tag.production.id\",\n    \"data.vsphere_tag.platinum.id\",\n    \"data.vsphere_tag.replicated.id\",\n]});\nconst devDatastore = new vsphere.NasDatastore(\"dev_datastore\", {tags: [\n    \"data.vsphere_tag.development.id\",\n    \"data.vsphere_tag.silver.id\",\n    \"data.vsphere_tag.non_replicated.id\",\n]});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nenvironment = vsphere.get_tag_category(name=\"environment\")\nservice_level = vsphere.get_tag_category(name=\"service_level\")\nreplication = vsphere.get_tag_category(name=\"replication\")\nproduction = vsphere.get_tag(name=\"production\",\n    category_id=\"data.vsphere_tag_category.environment.id\")\ndevelopment = vsphere.get_tag(name=\"development\",\n    category_id=\"data.vsphere_tag_category.environment.id\")\nplatinum = vsphere.get_tag(name=\"platinum\",\n    category_id=\"data.vsphere_tag_category.service_level.id\")\ngold = vsphere.get_tag(name=\"platinum\",\n    category_id=\"data.vsphere_tag_category.service_level.id\")\nsilver = vsphere.get_tag(name=\"silver\",\n    category_id=\"data.vsphere_tag_category.service_level.id\")\nbronze = vsphere.get_tag(name=\"bronze\",\n    category_id=\"data.vsphere_tag_category.service_level.id\")\nreplicated = vsphere.get_tag(name=\"replicated\",\n    category_id=\"data.vsphere_tag_category.replication.id\")\nnon_replicated = vsphere.get_tag(name=\"non_replicated\",\n    category_id=\"data.vsphere_tag_category.replication.id\")\nprod_datastore = vsphere.VmfsDatastore(\"prod_datastore\", tags=[\n    \"data.vsphere_tag.production.id\",\n    \"data.vsphere_tag.platinum.id\",\n    \"data.vsphere_tag.replicated.id\",\n])\ndev_datastore = vsphere.NasDatastore(\"dev_datastore\", tags=[\n    \"data.vsphere_tag.development.id\",\n    \"data.vsphere_tag.silver.id\",\n    \"data.vsphere_tag.non_replicated.id\",\n])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var environment = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"environment\",\n    });\n\n    var serviceLevel = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"service_level\",\n    });\n\n    var replication = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"replication\",\n    });\n\n    var production = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"production\",\n        CategoryId = \"data.vsphere_tag_category.environment.id\",\n    });\n\n    var development = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"development\",\n        CategoryId = \"data.vsphere_tag_category.environment.id\",\n    });\n\n    var platinum = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"platinum\",\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n    });\n\n    var gold = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"platinum\",\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n    });\n\n    var silver = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"silver\",\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n    });\n\n    var bronze = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"bronze\",\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n    });\n\n    var replicated = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"replicated\",\n        CategoryId = \"data.vsphere_tag_category.replication.id\",\n    });\n\n    var nonReplicated = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"non_replicated\",\n        CategoryId = \"data.vsphere_tag_category.replication.id\",\n    });\n\n    var prodDatastore = new VSphere.VmfsDatastore(\"prod_datastore\", new()\n    {\n        Tags = new[]\n        {\n            \"data.vsphere_tag.production.id\",\n            \"data.vsphere_tag.platinum.id\",\n            \"data.vsphere_tag.replicated.id\",\n        },\n    });\n\n    var devDatastore = new VSphere.NasDatastore(\"dev_datastore\", new()\n    {\n        Tags = new[]\n        {\n            \"data.vsphere_tag.development.id\",\n            \"data.vsphere_tag.silver.id\",\n            \"data.vsphere_tag.non_replicated.id\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"environment\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"service_level\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"replication\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"production\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.environment.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"development\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.environment.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"platinum\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"platinum\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"silver\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"bronze\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"replicated\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.replication.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"non_replicated\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.replication.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVmfsDatastore(ctx, \"prod_datastore\", \u0026vsphere.VmfsDatastoreArgs{\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"data.vsphere_tag.production.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.platinum.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.replicated.id\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewNasDatastore(ctx, \"dev_datastore\", \u0026vsphere.NasDatastoreArgs{\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"data.vsphere_tag.development.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.silver.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.non_replicated.id\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport com.pulumi.vsphere.inputs.GetTagArgs;\nimport com.pulumi.vsphere.VmfsDatastore;\nimport com.pulumi.vsphere.VmfsDatastoreArgs;\nimport com.pulumi.vsphere.NasDatastore;\nimport com.pulumi.vsphere.NasDatastoreArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var environment = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"environment\")\n            .build());\n\n        final var serviceLevel = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"service_level\")\n            .build());\n\n        final var replication = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"replication\")\n            .build());\n\n        final var production = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"production\")\n            .categoryId(\"data.vsphere_tag_category.environment.id\")\n            .build());\n\n        final var development = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"development\")\n            .categoryId(\"data.vsphere_tag_category.environment.id\")\n            .build());\n\n        final var platinum = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"platinum\")\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .build());\n\n        final var gold = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"platinum\")\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .build());\n\n        final var silver = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"silver\")\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .build());\n\n        final var bronze = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"bronze\")\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .build());\n\n        final var replicated = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"replicated\")\n            .categoryId(\"data.vsphere_tag_category.replication.id\")\n            .build());\n\n        final var nonReplicated = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"non_replicated\")\n            .categoryId(\"data.vsphere_tag_category.replication.id\")\n            .build());\n\n        var prodDatastore = new VmfsDatastore(\"prodDatastore\", VmfsDatastoreArgs.builder()\n            .tags(            \n                \"data.vsphere_tag.production.id\",\n                \"data.vsphere_tag.platinum.id\",\n                \"data.vsphere_tag.replicated.id\")\n            .build());\n\n        var devDatastore = new NasDatastore(\"devDatastore\", NasDatastoreArgs.builder()\n            .tags(            \n                \"data.vsphere_tag.development.id\",\n                \"data.vsphere_tag.silver.id\",\n                \"data.vsphere_tag.non_replicated.id\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodDatastore:\n    type: vsphere:VmfsDatastore\n    name: prod_datastore\n    properties:\n      tags: # ... other configuration ...\n        - data.vsphere_tag.production.id\n        - data.vsphere_tag.platinum.id\n        - data.vsphere_tag.replicated.id\n  devDatastore:\n    type: vsphere:NasDatastore\n    name: dev_datastore\n    properties:\n      tags: # ... other configuration ...\n        - data.vsphere_tag.development.id\n        - data.vsphere_tag.silver.id\n        - data.vsphere_tag.non_replicated.id\nvariables:\n  environment:\n    fn::invoke:\n      function: vsphere:getTagCategory\n      arguments:\n        name: environment\n  serviceLevel:\n    fn::invoke:\n      function: vsphere:getTagCategory\n      arguments:\n        name: service_level\n  replication:\n    fn::invoke:\n      function: vsphere:getTagCategory\n      arguments:\n        name: replication\n  production:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: production\n        categoryId: data.vsphere_tag_category.environment.id\n  development:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: development\n        categoryId: data.vsphere_tag_category.environment.id\n  platinum:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: platinum\n        categoryId: data.vsphere_tag_category.service_level.id\n  gold:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: platinum\n        categoryId: data.vsphere_tag_category.service_level.id\n  silver:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: silver\n        categoryId: data.vsphere_tag_category.service_level.id\n  bronze:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: bronze\n        categoryId: data.vsphere_tag_category.service_level.id\n  replicated:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: replicated\n        categoryId: data.vsphere_tag_category.replication.id\n  nonReplicated:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: non_replicated\n        categoryId: data.vsphere_tag_category.replication.id\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nNext, storage policies are created and `tag_rules` are applied.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodPlatinumReplicated = new vsphere.VmStoragePolicy(\"prod_platinum_replicated\", {\n    name: \"prod_platinum_replicated\",\n    description: \"prod_platinum_replicated\",\n    tagRules: [\n        {\n            tagCategory: environment.name,\n            tags: [production.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: serviceLevel.name,\n            tags: [platinum.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: replication.name,\n            tags: [replicated.name],\n            includeDatastoresWithTags: true,\n        },\n    ],\n});\nconst devSilverNonreplicated = new vsphere.VmStoragePolicy(\"dev_silver_nonreplicated\", {\n    name: \"dev_silver_nonreplicated\",\n    description: \"dev_silver_nonreplicated\",\n    tagRules: [\n        {\n            tagCategory: environment.name,\n            tags: [development.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: serviceLevel.name,\n            tags: [silver.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: replication.name,\n            tags: [nonReplicated.name],\n            includeDatastoresWithTags: true,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_platinum_replicated = vsphere.VmStoragePolicy(\"prod_platinum_replicated\",\n    name=\"prod_platinum_replicated\",\n    description=\"prod_platinum_replicated\",\n    tag_rules=[\n        {\n            \"tag_category\": environment[\"name\"],\n            \"tags\": [production[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n        {\n            \"tag_category\": service_level[\"name\"],\n            \"tags\": [platinum[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n        {\n            \"tag_category\": replication[\"name\"],\n            \"tags\": [replicated[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n    ])\ndev_silver_nonreplicated = vsphere.VmStoragePolicy(\"dev_silver_nonreplicated\",\n    name=\"dev_silver_nonreplicated\",\n    description=\"dev_silver_nonreplicated\",\n    tag_rules=[\n        {\n            \"tag_category\": environment[\"name\"],\n            \"tags\": [development[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n        {\n            \"tag_category\": service_level[\"name\"],\n            \"tags\": [silver[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n        {\n            \"tag_category\": replication[\"name\"],\n            \"tags\": [non_replicated[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodPlatinumReplicated = new VSphere.VmStoragePolicy(\"prod_platinum_replicated\", new()\n    {\n        Name = \"prod_platinum_replicated\",\n        Description = \"prod_platinum_replicated\",\n        TagRules = new[]\n        {\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = environment.Name,\n                Tags = new[]\n                {\n                    production.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = serviceLevel.Name,\n                Tags = new[]\n                {\n                    platinum.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = replication.Name,\n                Tags = new[]\n                {\n                    replicated.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n        },\n    });\n\n    var devSilverNonreplicated = new VSphere.VmStoragePolicy(\"dev_silver_nonreplicated\", new()\n    {\n        Name = \"dev_silver_nonreplicated\",\n        Description = \"dev_silver_nonreplicated\",\n        TagRules = new[]\n        {\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = environment.Name,\n                Tags = new[]\n                {\n                    development.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = serviceLevel.Name,\n                Tags = new[]\n                {\n                    silver.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = replication.Name,\n                Tags = new[]\n                {\n                    nonReplicated.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVmStoragePolicy(ctx, \"prod_platinum_replicated\", \u0026vsphere.VmStoragePolicyArgs{\n\t\t\tName:        pulumi.String(\"prod_platinum_replicated\"),\n\t\t\tDescription: pulumi.String(\"prod_platinum_replicated\"),\n\t\t\tTagRules: vsphere.VmStoragePolicyTagRuleArray{\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(environment.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tproduction.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(serviceLevel.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tplatinum.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(replication.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\treplicated.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVmStoragePolicy(ctx, \"dev_silver_nonreplicated\", \u0026vsphere.VmStoragePolicyArgs{\n\t\t\tName:        pulumi.String(\"dev_silver_nonreplicated\"),\n\t\t\tDescription: pulumi.String(\"dev_silver_nonreplicated\"),\n\t\t\tTagRules: vsphere.VmStoragePolicyTagRuleArray{\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(environment.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tdevelopment.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(serviceLevel.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tsilver.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(replication.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tnonReplicated.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VmStoragePolicy;\nimport com.pulumi.vsphere.VmStoragePolicyArgs;\nimport com.pulumi.vsphere.inputs.VmStoragePolicyTagRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var prodPlatinumReplicated = new VmStoragePolicy(\"prodPlatinumReplicated\", VmStoragePolicyArgs.builder()\n            .name(\"prod_platinum_replicated\")\n            .description(\"prod_platinum_replicated\")\n            .tagRules(            \n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(environment.name())\n                    .tags(production.name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(serviceLevel.name())\n                    .tags(platinum.name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(replication.name())\n                    .tags(replicated.name())\n                    .includeDatastoresWithTags(true)\n                    .build())\n            .build());\n\n        var devSilverNonreplicated = new VmStoragePolicy(\"devSilverNonreplicated\", VmStoragePolicyArgs.builder()\n            .name(\"dev_silver_nonreplicated\")\n            .description(\"dev_silver_nonreplicated\")\n            .tagRules(            \n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(environment.name())\n                    .tags(development.name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(serviceLevel.name())\n                    .tags(silver.name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(replication.name())\n                    .tags(nonReplicated.name())\n                    .includeDatastoresWithTags(true)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodPlatinumReplicated:\n    type: vsphere:VmStoragePolicy\n    name: prod_platinum_replicated\n    properties:\n      name: prod_platinum_replicated\n      description: prod_platinum_replicated\n      tagRules:\n        - tagCategory: ${environment.name}\n          tags:\n            - ${production.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${serviceLevel.name}\n          tags:\n            - ${platinum.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${replication.name}\n          tags:\n            - ${replicated.name}\n          includeDatastoresWithTags: true\n  devSilverNonreplicated:\n    type: vsphere:VmStoragePolicy\n    name: dev_silver_nonreplicated\n    properties:\n      name: dev_silver_nonreplicated\n      description: dev_silver_nonreplicated\n      tagRules:\n        - tagCategory: ${environment.name}\n          tags:\n            - ${development.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${serviceLevel.name}\n          tags:\n            - ${silver.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${replication.name}\n          tags:\n            - ${nonReplicated.name}\n          includeDatastoresWithTags: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nLastly, when creating a virtual machine resource, a storage policy can be specified to direct virtual machine placement to a datastore which matches the policy's `tags_rules`.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodPlatinumReplicated = vsphere.getPolicy({\n    name: \"prod_platinum_replicated\",\n});\nconst devSilverNonreplicated = vsphere.getPolicy({\n    name: \"dev_silver_nonreplicated\",\n});\nconst prodVm = new vsphere.VirtualMachine(\"prod_vm\", {storagePolicyId: storagePolicy.prodPlatinumReplicated.id});\nconst devVm = new vsphere.VirtualMachine(\"dev_vm\", {storagePolicyId: storagePolicy.devSilverNonreplicated.id});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_platinum_replicated = vsphere.get_policy(name=\"prod_platinum_replicated\")\ndev_silver_nonreplicated = vsphere.get_policy(name=\"dev_silver_nonreplicated\")\nprod_vm = vsphere.VirtualMachine(\"prod_vm\", storage_policy_id=storage_policy[\"prodPlatinumReplicated\"][\"id\"])\ndev_vm = vsphere.VirtualMachine(\"dev_vm\", storage_policy_id=storage_policy[\"devSilverNonreplicated\"][\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodPlatinumReplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"prod_platinum_replicated\",\n    });\n\n    var devSilverNonreplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"dev_silver_nonreplicated\",\n    });\n\n    var prodVm = new VSphere.VirtualMachine(\"prod_vm\", new()\n    {\n        StoragePolicyId = storagePolicy.ProdPlatinumReplicated.Id,\n    });\n\n    var devVm = new VSphere.VirtualMachine(\"dev_vm\", new()\n    {\n        StoragePolicyId = storagePolicy.DevSilverNonreplicated.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"prod_platinum_replicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"dev_silver_nonreplicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVirtualMachine(ctx, \"prod_vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tStoragePolicyId: pulumi.Any(storagePolicy.ProdPlatinumReplicated.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVirtualMachine(ctx, \"dev_vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tStoragePolicyId: pulumi.Any(storagePolicy.DevSilverNonreplicated.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetPolicyArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var prodPlatinumReplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"prod_platinum_replicated\")\n            .build());\n\n        final var devSilverNonreplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"dev_silver_nonreplicated\")\n            .build());\n\n        var prodVm = new VirtualMachine(\"prodVm\", VirtualMachineArgs.builder()\n            .storagePolicyId(storagePolicy.prodPlatinumReplicated().id())\n            .build());\n\n        var devVm = new VirtualMachine(\"devVm\", VirtualMachineArgs.builder()\n            .storagePolicyId(storagePolicy.devSilverNonreplicated().id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodVm:\n    type: vsphere:VirtualMachine\n    name: prod_vm\n    properties:\n      storagePolicyId: ${storagePolicy.prodPlatinumReplicated.id}\n  devVm:\n    type: vsphere:VirtualMachine\n    name: dev_vm\n    properties:\n      storagePolicyId: ${storagePolicy.devSilverNonreplicated.id}\nvariables:\n  prodPlatinumReplicated:\n    fn::invoke:\n      function: vsphere:getPolicy\n      arguments:\n        name: prod_platinum_replicated\n  devSilverNonreplicated:\n    fn::invoke:\n      function: vsphere:getPolicy\n      arguments:\n        name: dev_silver_nonreplicated\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the storage policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "tagRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                    },
                    "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                }
            },
            "required": [
                "name",
                "tagRules"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the storage policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "tagRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                    },
                    "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                }
            },
            "requiredInputs": [
                "tagRules"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmStoragePolicy resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the storage policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    },
                    "tagRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                        },
                        "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vmfsDatastore:VmfsDatastore": {
            "description": "The `vsphere.VmfsDatastore` resource can be used to create and manage VMFS\ndatastores on an ESXi host or a set of hosts. The resource supports using any\nSCSI device that can generally be used in a datastore, such as local disks, or\ndisks presented to a host or multiple hosts over Fibre Channel or iSCSI.\nDevices can be specified manually, or discovered using the\n[`vsphere.getVmfsDisks`][data-source-vmfs-disks] data source.\n\n[data-source-vmfs-disks]: /docs/providers/vsphere/d/vmfs_disks.html\n\n## Auto-Mounting of Datastores Within vCenter\n\nNote that the current behavior of this resource will auto-mount any created\ndatastores to any other host within vCenter that has access to the same disk.\n\nExample: You want to create a datastore with a iSCSI LUN that is visible on 3\nhosts in a single vSphere cluster (`esxi1`, `esxi2` and `esxi3`). When you\ncreate the datastore on `esxi1`, the datastore will be automatically mounted on\n`esxi2` and `esxi3`, without the need to configure the resource on either of\nthose two hosts.\n\nFuture versions of this resource may allow you to control the hosts that a\ndatastore is mounted to, but currently, this automatic behavior cannot be\nchanged, so keep this in mind when writing your configurations and deploying\nyour disks.\n\n## Increasing Datastore Size\n\nTo increase the size of a datastore, you must add additional disks to the\n`disks` attribute. Expanding the size of a datastore by increasing the size of\nan already provisioned disk is currently not supported (but may be in future\nversions of this resource).\n\n\u003e **NOTE:** You cannot decrease the size of a datastore. If the resource\ndetects disks removed from the configuration, the provider will give an error. \n\n[cmd-taint]: /docs/commands/taint.html\n\n## Example Usage\n\n### Addition of local disks on a single host\n\nThe following example uses the default datacenter and default host to add a\ndatastore with local disks to a single ESXi server.\n\n\u003e **NOTE:** There are some situations where datastore creation will not work\nwhen working through vCenter (usually when trying to create a datastore on a\nsingle host with local disks). If you experience trouble creating the datastore\nyou need through vCenter, break the datastore off into a different configuration\nand deploy it using the ESXi server as the provider endpoint, using a similar\nconfiguration to what is below.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n}));\nconst datastore = new vsphere.VmfsDatastore(\"datastore\", {\n    name: \"test\",\n    hostSystemId: esxiHost.id,\n    disks: [\n        \"mpx.vmhba1:C0:T1:L0\",\n        \"mpx.vmhba1:C0:T2:L0\",\n        \"mpx.vmhba1:C0:T2:L0\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter()\nhost = vsphere.get_host(datacenter_id=datacenter.id)\ndatastore = vsphere.VmfsDatastore(\"datastore\",\n    name=\"test\",\n    host_system_id=esxi_host[\"id\"],\n    disks=[\n        \"mpx.vmhba1:C0:T1:L0\",\n        \"mpx.vmhba1:C0:T2:L0\",\n        \"mpx.vmhba1:C0:T2:L0\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke();\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var datastore = new VSphere.VmfsDatastore(\"datastore\", new()\n    {\n        Name = \"test\",\n        HostSystemId = esxiHost.Id,\n        Disks = new[]\n        {\n            \"mpx.vmhba1:C0:T1:L0\",\n            \"mpx.vmhba1:C0:T2:L0\",\n            \"mpx.vmhba1:C0:T2:L0\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVmfsDatastore(ctx, \"datastore\", \u0026vsphere.VmfsDatastoreArgs{\n\t\t\tName:         pulumi.String(\"test\"),\n\t\t\tHostSystemId: pulumi.Any(esxiHost.Id),\n\t\t\tDisks: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"mpx.vmhba1:C0:T1:L0\"),\n\t\t\t\tpulumi.String(\"mpx.vmhba1:C0:T2:L0\"),\n\t\t\t\tpulumi.String(\"mpx.vmhba1:C0:T2:L0\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.VmfsDatastore;\nimport com.pulumi.vsphere.VmfsDatastoreArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .datacenterId(datacenter.id())\n            .build());\n\n        var datastore = new VmfsDatastore(\"datastore\", VmfsDatastoreArgs.builder()\n            .name(\"test\")\n            .hostSystemId(esxiHost.id())\n            .disks(            \n                \"mpx.vmhba1:C0:T1:L0\",\n                \"mpx.vmhba1:C0:T2:L0\",\n                \"mpx.vmhba1:C0:T2:L0\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  datastore:\n    type: vsphere:VmfsDatastore\n    properties:\n      name: test\n      hostSystemId: ${esxiHost.id}\n      disks:\n        - mpx.vmhba1:C0:T1:L0\n        - mpx.vmhba1:C0:T2:L0\n        - mpx.vmhba1:C0:T2:L0\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments: {}\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Auto-detection of disks via `vsphere.getVmfsDisks`\n\nThe following example makes use of the\n`vsphere.getVmfsDisks` data source to auto-detect\nexported iSCSI LUNS matching a certain NAA vendor ID (in this case, LUNs\nexported from a [NetApp][ext-netapp]). These discovered disks are then loaded\ninto `vsphere.VmfsDatastore`. The datastore is also placed in the\n`datastore-folder` folder afterwards.\n\n[ext-netapp]: https://kb.netapp.com/support/s/article/ka31A0000000rLRQAY/how-to-match-a-lun-s-naa-number-to-its-serial-number?language=en_US\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst available = host.then(host =\u003e vsphere.getVmfsDisks({\n    hostSystemId: host.id,\n    rescan: true,\n    filter: \"naa.60a98000\",\n}));\nconst datastore = new vsphere.VmfsDatastore(\"datastore\", {\n    name: \"test\",\n    hostSystemId: esxiHost.id,\n    folder: \"datastore-folder\",\n    disks: [available.then(available =\u003e available.disks)],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\navailable = vsphere.get_vmfs_disks(host_system_id=host.id,\n    rescan=True,\n    filter=\"naa.60a98000\")\ndatastore = vsphere.VmfsDatastore(\"datastore\",\n    name=\"test\",\n    host_system_id=esxi_host[\"id\"],\n    folder=\"datastore-folder\",\n    disks=[available.disks])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var available = VSphere.GetVmfsDisks.Invoke(new()\n    {\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        Rescan = true,\n        Filter = \"naa.60a98000\",\n    });\n\n    var datastore = new VSphere.VmfsDatastore(\"datastore\", new()\n    {\n        Name = \"test\",\n        HostSystemId = esxiHost.Id,\n        Folder = \"datastore-folder\",\n        Disks = new[]\n        {\n            available.Apply(getVmfsDisksResult =\u003e getVmfsDisksResult.Disks),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tavailable, err := vsphere.GetVmfsDisks(ctx, \u0026vsphere.GetVmfsDisksArgs{\n\t\t\tHostSystemId: host.Id,\n\t\t\tRescan:       pulumi.BoolRef(true),\n\t\t\tFilter:       pulumi.StringRef(\"naa.60a98000\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVmfsDatastore(ctx, \"datastore\", \u0026vsphere.VmfsDatastoreArgs{\n\t\t\tName:         pulumi.String(\"test\"),\n\t\t\tHostSystemId: pulumi.Any(esxiHost.Id),\n\t\t\tFolder:       pulumi.String(\"datastore-folder\"),\n\t\t\tDisks: pulumi.StringArray{\n\t\t\t\tinterface{}(available.Disks),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetVmfsDisksArgs;\nimport com.pulumi.vsphere.VmfsDatastore;\nimport com.pulumi.vsphere.VmfsDatastoreArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var available = VsphereFunctions.getVmfsDisks(GetVmfsDisksArgs.builder()\n            .hostSystemId(host.id())\n            .rescan(true)\n            .filter(\"naa.60a98000\")\n            .build());\n\n        var datastore = new VmfsDatastore(\"datastore\", VmfsDatastoreArgs.builder()\n            .name(\"test\")\n            .hostSystemId(esxiHost.id())\n            .folder(\"datastore-folder\")\n            .disks(available.disks())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  datastore:\n    type: vsphere:VmfsDatastore\n    properties:\n      name: test\n      hostSystemId: ${esxiHost.id}\n      folder: datastore-folder\n      disks:\n        - ${available.disks}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  available:\n    fn::invoke:\n      function: vsphere:getVmfsDisks\n      arguments:\n        hostSystemId: ${host.id}\n        rescan: true\n        filter: naa.60a98000\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing VMFS datastore can be imported into this resource\n\nvia its managed object ID, via the command below. You also need the host system\n\nID.\n\n```sh\n$ pulumi import vsphere:index/vmfsDatastore:VmfsDatastore datastore datastore-123:host-10\n```\n\nYou need a tool like [`govc`][ext-govc] that can display managed object IDs.\n\n[ext-govc]: https://github.com/vmware/govmomi/tree/master/govc\n\nIn the case of govc, you can locate a managed object ID from an inventory path\n\nby doing the following:\n\n$ govc ls -i /dc/datastore/terraform-test\n\nDatastore:datastore-123\n\nTo locate host IDs, it might be a good idea to supply the `-l` flag as well so\n\nthat you can line up the names with the IDs:\n\n$ govc ls -l -i /dc/host/cluster1\n\nResourcePool:resgroup-10 /dc/host/cluster1/Resources\n\nHostSystem:host-10 /dc/host/cluster1/esxi1\n\nHostSystem:host-11 /dc/host/cluster1/esxi2\n\nHostSystem:host-12 /dc/host/cluster1/esxi3\n\n",
            "properties": {
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "disks",
                "freeSpace",
                "hostSystemId",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                }
            },
            "requiredInputs": [
                "disks",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmfsDatastore resources.\n",
                "properties": {
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The disks to use with the datastore.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vnic:Vnic": {
            "description": "Provides a VMware vSphere vnic resource.\n\n## Example Usage\n\n### Create a vnic attached to a distributed virtual switch using the vmotion TCP/IP stack\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst vds = new vsphere.DistributedVirtualSwitch(\"vds\", {\n    name: \"vds-01\",\n    datacenterId: datacenter.then(datacenter =\u003e datacenter.id),\n    hosts: [{\n        hostSystemId: host.then(host =\u003e host.id),\n        devices: [\"vnic3\"],\n    }],\n});\nconst pg = new vsphere.DistributedPortGroup(\"pg\", {\n    name: \"pg-01\",\n    vlanId: 1234,\n    distributedVirtualSwitchUuid: vds.id,\n});\nconst vnic = new vsphere.Vnic(\"vnic\", {\n    host: host.then(host =\u003e host.id),\n    distributedSwitchPort: vds.id,\n    distributedPortGroup: pg.id,\n    ipv4: {\n        dhcp: true,\n    },\n    netstack: \"vmotion\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nvds = vsphere.DistributedVirtualSwitch(\"vds\",\n    name=\"vds-01\",\n    datacenter_id=datacenter.id,\n    hosts=[{\n        \"host_system_id\": host.id,\n        \"devices\": [\"vnic3\"],\n    }])\npg = vsphere.DistributedPortGroup(\"pg\",\n    name=\"pg-01\",\n    vlan_id=1234,\n    distributed_virtual_switch_uuid=vds.id)\nvnic = vsphere.Vnic(\"vnic\",\n    host=host.id,\n    distributed_switch_port=vds.id,\n    distributed_port_group=pg.id,\n    ipv4={\n        \"dhcp\": True,\n    },\n    netstack=\"vmotion\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vds = new VSphere.DistributedVirtualSwitch(\"vds\", new()\n    {\n        Name = \"vds-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n        Hosts = new[]\n        {\n            new VSphere.Inputs.DistributedVirtualSwitchHostArgs\n            {\n                HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n                Devices = new[]\n                {\n                    \"vnic3\",\n                },\n            },\n        },\n    });\n\n    var pg = new VSphere.DistributedPortGroup(\"pg\", new()\n    {\n        Name = \"pg-01\",\n        VlanId = 1234,\n        DistributedVirtualSwitchUuid = vds.Id,\n    });\n\n    var vnic = new VSphere.Vnic(\"vnic\", new()\n    {\n        Host = host.Apply(getHostResult =\u003e getHostResult.Id),\n        DistributedSwitchPort = vds.Id,\n        DistributedPortGroup = pg.Id,\n        Ipv4 = new VSphere.Inputs.VnicIpv4Args\n        {\n            Dhcp = true,\n        },\n        Netstack = \"vmotion\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvds, err := vsphere.NewDistributedVirtualSwitch(ctx, \"vds\", \u0026vsphere.DistributedVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"vds-01\"),\n\t\t\tDatacenterId: pulumi.String(datacenter.Id),\n\t\t\tHosts: vsphere.DistributedVirtualSwitchHostArray{\n\t\t\t\t\u0026vsphere.DistributedVirtualSwitchHostArgs{\n\t\t\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\t\t\tDevices: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"vnic3\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpg, err := vsphere.NewDistributedPortGroup(ctx, \"pg\", \u0026vsphere.DistributedPortGroupArgs{\n\t\t\tName:                         pulumi.String(\"pg-01\"),\n\t\t\tVlanId:                       pulumi.Int(1234),\n\t\t\tDistributedVirtualSwitchUuid: vds.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVnic(ctx, \"vnic\", \u0026vsphere.VnicArgs{\n\t\t\tHost:                  pulumi.String(host.Id),\n\t\t\tDistributedSwitchPort: vds.ID(),\n\t\t\tDistributedPortGroup:  pg.ID(),\n\t\t\tIpv4: \u0026vsphere.VnicIpv4Args{\n\t\t\t\tDhcp: pulumi.Bool(true),\n\t\t\t},\n\t\t\tNetstack: pulumi.String(\"vmotion\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.DistributedVirtualSwitch;\nimport com.pulumi.vsphere.DistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.inputs.DistributedVirtualSwitchHostArgs;\nimport com.pulumi.vsphere.DistributedPortGroup;\nimport com.pulumi.vsphere.DistributedPortGroupArgs;\nimport com.pulumi.vsphere.Vnic;\nimport com.pulumi.vsphere.VnicArgs;\nimport com.pulumi.vsphere.inputs.VnicIpv4Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var vds = new DistributedVirtualSwitch(\"vds\", DistributedVirtualSwitchArgs.builder()\n            .name(\"vds-01\")\n            .datacenterId(datacenter.id())\n            .hosts(DistributedVirtualSwitchHostArgs.builder()\n                .hostSystemId(host.id())\n                .devices(\"vnic3\")\n                .build())\n            .build());\n\n        var pg = new DistributedPortGroup(\"pg\", DistributedPortGroupArgs.builder()\n            .name(\"pg-01\")\n            .vlanId(1234)\n            .distributedVirtualSwitchUuid(vds.id())\n            .build());\n\n        var vnic = new Vnic(\"vnic\", VnicArgs.builder()\n            .host(host.id())\n            .distributedSwitchPort(vds.id())\n            .distributedPortGroup(pg.id())\n            .ipv4(VnicIpv4Args.builder()\n                .dhcp(true)\n                .build())\n            .netstack(\"vmotion\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vds:\n    type: vsphere:DistributedVirtualSwitch\n    properties:\n      name: vds-01\n      datacenterId: ${datacenter.id}\n      hosts:\n        - hostSystemId: ${host.id}\n          devices:\n            - vnic3\n  pg:\n    type: vsphere:DistributedPortGroup\n    properties:\n      name: pg-01\n      vlanId: 1234\n      distributedVirtualSwitchUuid: ${vds.id}\n  vnic:\n    type: vsphere:Vnic\n    properties:\n      host: ${host.id}\n      distributedSwitchPort: ${vds.id}\n      distributedPortGroup: ${pg.id}\n      ipv4:\n        dhcp: true\n      netstack: vmotion\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Create a vnic attached to a portgroup using the default TCP/IP stack\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst hvs = new vsphere.HostVirtualSwitch(\"hvs\", {\n    name: \"hvs-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic3\",\n        \"vmnic4\",\n    ],\n    activeNics: [\"vmnic3\"],\n    standbyNics: [\"vmnic4\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    name: \"pg-01\",\n    virtualSwitchName: hvs.name,\n    hostSystemId: host.then(host =\u003e host.id),\n});\nconst vnic = new vsphere.Vnic(\"vnic\", {\n    host: host.then(host =\u003e host.id),\n    portgroup: pg.name,\n    ipv4: {\n        dhcp: true,\n    },\n    services: [\n        \"vsan\",\n        \"management\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nhvs = vsphere.HostVirtualSwitch(\"hvs\",\n    name=\"hvs-01\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic3\",\n        \"vmnic4\",\n    ],\n    active_nics=[\"vmnic3\"],\n    standby_nics=[\"vmnic4\"])\npg = vsphere.HostPortGroup(\"pg\",\n    name=\"pg-01\",\n    virtual_switch_name=hvs.name,\n    host_system_id=host.id)\nvnic = vsphere.Vnic(\"vnic\",\n    host=host.id,\n    portgroup=pg.name,\n    ipv4={\n        \"dhcp\": True,\n    },\n    services=[\n        \"vsan\",\n        \"management\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hvs = new VSphere.HostVirtualSwitch(\"hvs\", new()\n    {\n        Name = \"hvs-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic3\",\n            \"vmnic4\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic3\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic4\",\n        },\n    });\n\n    var pg = new VSphere.HostPortGroup(\"pg\", new()\n    {\n        Name = \"pg-01\",\n        VirtualSwitchName = hvs.Name,\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n    });\n\n    var vnic = new VSphere.Vnic(\"vnic\", new()\n    {\n        Host = host.Apply(getHostResult =\u003e getHostResult.Id),\n        Portgroup = pg.Name,\n        Ipv4 = new VSphere.Inputs.VnicIpv4Args\n        {\n            Dhcp = true,\n        },\n        Services = new[]\n        {\n            \"vsan\",\n            \"management\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thvs, err := vsphere.NewHostVirtualSwitch(ctx, \"hvs\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"hvs-01\"),\n\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic3\"),\n\t\t\t\tpulumi.String(\"vmnic4\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic3\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpg, err := vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tName:              pulumi.String(\"pg-01\"),\n\t\t\tVirtualSwitchName: hvs.Name,\n\t\t\tHostSystemId:      pulumi.String(host.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVnic(ctx, \"vnic\", \u0026vsphere.VnicArgs{\n\t\t\tHost:      pulumi.String(host.Id),\n\t\t\tPortgroup: pg.Name,\n\t\t\tIpv4: \u0026vsphere.VnicIpv4Args{\n\t\t\t\tDhcp: pulumi.Bool(true),\n\t\t\t},\n\t\t\tServices: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vsan\"),\n\t\t\t\tpulumi.String(\"management\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport com.pulumi.vsphere.HostPortGroup;\nimport com.pulumi.vsphere.HostPortGroupArgs;\nimport com.pulumi.vsphere.Vnic;\nimport com.pulumi.vsphere.VnicArgs;\nimport com.pulumi.vsphere.inputs.VnicIpv4Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var hvs = new HostVirtualSwitch(\"hvs\", HostVirtualSwitchArgs.builder()\n            .name(\"hvs-01\")\n            .hostSystemId(host.id())\n            .networkAdapters(            \n                \"vmnic3\",\n                \"vmnic4\")\n            .activeNics(\"vmnic3\")\n            .standbyNics(\"vmnic4\")\n            .build());\n\n        var pg = new HostPortGroup(\"pg\", HostPortGroupArgs.builder()\n            .name(\"pg-01\")\n            .virtualSwitchName(hvs.name())\n            .hostSystemId(host.id())\n            .build());\n\n        var vnic = new Vnic(\"vnic\", VnicArgs.builder()\n            .host(host.id())\n            .portgroup(pg.name())\n            .ipv4(VnicIpv4Args.builder()\n                .dhcp(true)\n                .build())\n            .services(            \n                \"vsan\",\n                \"management\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hvs:\n    type: vsphere:HostVirtualSwitch\n    properties:\n      name: hvs-01\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic3\n        - vmnic4\n      activeNics:\n        - vmnic3\n      standbyNics:\n        - vmnic4\n  pg:\n    type: vsphere:HostPortGroup\n    properties:\n      name: pg-01\n      virtualSwitchName: ${hvs.name}\n      hostSystemId: ${host.id}\n  vnic:\n    type: vsphere:Vnic\n    properties:\n      host: ${host.id}\n      portgroup: ${pg.name}\n      ipv4:\n        dhcp: true\n      services:\n        - vsan\n        - management\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAn existing vNic can be imported into this resource\n\nvia supplying the vNic's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```sh\n$ pulumi import vsphere:index/vnic:Vnic vnic host-123_vmk2\n```\n\nThe above would import the vnic `vmk2` from host with ID `host-123`.\n\n",
            "properties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to.\n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the vdswitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n"
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See IPv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See IPv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are `defaultTcpipStack``, 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default:`defaultTcpipStack`)\n"
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Enabled services setting for this interface. Currently support values are `vmotion`, `management`, and `vsan`.\n"
                }
            },
            "required": [
                "host",
                "mac",
                "mtu"
            ],
            "inputProperties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to.\n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the vdswitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n",
                    "willReplaceOnChanges": true
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See IPv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See IPv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are `defaultTcpipStack``, 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default:`defaultTcpipStack`)\n",
                    "willReplaceOnChanges": true
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Enabled services setting for this interface. Currently support values are `vmotion`, `management`, and `vsan`.\n"
                }
            },
            "requiredInputs": [
                "host"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vnic resources.\n",
                "properties": {
                    "distributedPortGroup": {
                        "type": "string",
                        "description": "Key of the distributed portgroup the nic will connect to.\n"
                    },
                    "distributedSwitchPort": {
                        "type": "string",
                        "description": "UUID of the vdswitch the nic will be attached to. Do not set if you set portgroup.\n"
                    },
                    "host": {
                        "type": "string",
                        "description": "ESX host the interface belongs to\n",
                        "willReplaceOnChanges": true
                    },
                    "ipv4": {
                        "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                        "description": "IPv4 settings. Either this or `ipv6` needs to be set. See IPv4 options below.\n"
                    },
                    "ipv6": {
                        "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                        "description": "IPv6 settings. Either this or `ipv6` needs to be set. See IPv6 options below.\n"
                    },
                    "mac": {
                        "type": "string",
                        "description": "MAC address of the interface.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "MTU of the interface.\n"
                    },
                    "netstack": {
                        "type": "string",
                        "description": "TCP/IP stack setting for this interface. Possible values are `defaultTcpipStack``, 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default:`defaultTcpipStack`)\n",
                        "willReplaceOnChanges": true
                    },
                    "portgroup": {
                        "type": "string",
                        "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                    },
                    "services": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Enabled services setting for this interface. Currently support values are `vmotion`, `management`, and `vsan`.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "pulumi:providers:vsphere/terraformConfig": {
            "description": "This function returns a Terraform config object with terraform-namecased keys,to be used with the Terraform Module Provider.",
            "inputs": {
                "properties": {
                    "__self__": {
                        "type": "ref",
                        "$ref": "#/resources/pulumi:providers:vsphere"
                    }
                },
                "type": "pulumi:providers:vsphere/terraformConfig",
                "required": [
                    "__self__"
                ]
            },
            "outputs": {
                "properties": {
                    "result": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    }
                },
                "required": [
                    "result"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getComputeCluster:getComputeCluster": {
            "description": "The `vsphere.ComputeCluster` data source can be used to discover the ID of a\ncluster in vSphere. This is useful to fetch the ID of a cluster that you want\nto use for virtual machine placement via the `vsphere.VirtualMachine` resource, allowing to specify the cluster's root resource pool directly versus\nusing the alias available through the `vsphere.ResourcePool`\ndata source.\n\n\u003e You may also wish to see the `vsphere.ComputeCluster`\n resource for more information about clusters and how to managed the resource\n in this provider.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst computeCluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncompute_cluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  computeCluster:\n    fn::invoke:\n      function: vsphere:getComputeCluster\n      arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the cluster is located in.  This can be omitted if the\nsearch path used in `name` is an absolute path. For default datacenters,\nuse the `id` attribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "description": "The managed object reference ID of\nthe root resource pool for the cluster.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "resourcePoolId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getComputeClusterHostGroup:getComputeClusterHostGroup": {
            "description": "The `vsphere.ComputeClusterHostGroup` data source can be used to discover\nthe IDs ESXi hosts in a host group and return host group attributes to other\nresources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst hostGroup = cluster.then(cluster =\u003e vsphere.getComputeClusterHostGroup({\n    name: \"hostgroup-01\",\n    computeClusterId: cluster.id,\n}));\nconst hostRule = new vsphere.ComputeClusterVmHostRule(\"host_rule\", {\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    name: \"pulumi-host-rule1\",\n    vmGroupName: \"vmgroup-01\",\n    affinityHostGroupName: hostGroup.then(hostGroup =\u003e hostGroup.name),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nhost_group = vsphere.get_compute_cluster_host_group(name=\"hostgroup-01\",\n    compute_cluster_id=cluster.id)\nhost_rule = vsphere.ComputeClusterVmHostRule(\"host_rule\",\n    compute_cluster_id=cluster.id,\n    name=\"pulumi-host-rule1\",\n    vm_group_name=\"vmgroup-01\",\n    affinity_host_group_name=host_group.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hostGroup = VSphere.GetComputeClusterHostGroup.Invoke(new()\n    {\n        Name = \"hostgroup-01\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n    });\n\n    var hostRule = new VSphere.ComputeClusterVmHostRule(\"host_rule\", new()\n    {\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        Name = \"pulumi-host-rule1\",\n        VmGroupName = \"vmgroup-01\",\n        AffinityHostGroupName = hostGroup.Apply(getComputeClusterHostGroupResult =\u003e getComputeClusterHostGroupResult.Name),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostGroup, err := vsphere.LookupComputeClusterHostGroup(ctx, \u0026vsphere.LookupComputeClusterHostGroupArgs{\n\t\t\tName:             \"hostgroup-01\",\n\t\t\tComputeClusterId: cluster.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewComputeClusterVmHostRule(ctx, \"host_rule\", \u0026vsphere.ComputeClusterVmHostRuleArgs{\n\t\t\tComputeClusterId:      pulumi.String(cluster.Id),\n\t\t\tName:                  pulumi.String(\"pulumi-host-rule1\"),\n\t\t\tVmGroupName:           pulumi.String(\"vmgroup-01\"),\n\t\t\tAffinityHostGroupName: pulumi.String(hostGroup.Name),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterHostGroupArgs;\nimport com.pulumi.vsphere.ComputeClusterVmHostRule;\nimport com.pulumi.vsphere.ComputeClusterVmHostRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var hostGroup = VsphereFunctions.getComputeClusterHostGroup(GetComputeClusterHostGroupArgs.builder()\n            .name(\"hostgroup-01\")\n            .computeClusterId(cluster.id())\n            .build());\n\n        var hostRule = new ComputeClusterVmHostRule(\"hostRule\", ComputeClusterVmHostRuleArgs.builder()\n            .computeClusterId(cluster.id())\n            .name(\"pulumi-host-rule1\")\n            .vmGroupName(\"vmgroup-01\")\n            .affinityHostGroupName(hostGroup.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hostRule:\n    type: vsphere:ComputeClusterVmHostRule\n    name: host_rule\n    properties:\n      computeClusterId: ${cluster.id}\n      name: pulumi-host-rule1\n      vmGroupName: vmgroup-01\n      affinityHostGroupName: ${hostGroup.name}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  cluster:\n    fn::invoke:\n      function: vsphere:getComputeCluster\n      arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n  hostGroup:\n    fn::invoke:\n      function: vsphere:getComputeClusterHostGroup\n      arguments:\n        name: hostgroup-01\n        computeClusterId: ${cluster.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getComputeClusterHostGroup.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The\n[managed object reference ID][docs-about-morefs] of the compute cluster for\nthe host group.\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "computeClusterId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getComputeClusterHostGroup.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string"
                    },
                    "hostSystemIds": {
                        "description": "The [managed object reference ID][docs-about-morefs] of\nthe ESXi hosts in the host group.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "computeClusterId",
                    "hostSystemIds",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getContentLibrary:getContentLibrary": {
            "description": "The `vsphere.ContentLibrary` data source can be used to discover the ID of a\ncontent library.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nhost connections.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst contentLibrary = vsphere.getContentLibrary({\n    name: \"Content Library\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncontent_library = vsphere.get_content_library(name=\"Content Library\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var contentLibrary = VSphere.GetContentLibrary.Invoke(new()\n    {\n        Name = \"Content Library\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupContentLibrary(ctx, \u0026vsphere.LookupContentLibraryArgs{\n\t\t\tName: \"Content Library\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetContentLibraryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var contentLibrary = VsphereFunctions.getContentLibrary(GetContentLibraryArgs.builder()\n            .name(\"Content Library\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  contentLibrary:\n    fn::invoke:\n      function: vsphere:getContentLibrary\n      arguments:\n        name: Content Library\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibrary.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the content library.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibrary.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getContentLibraryItem:getContentLibraryItem": {
            "description": "The `vsphere.ContentLibraryItem` data source can be used to discover the ID\nof a content library item.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nhost connections.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibraryItem.\n",
                "properties": {
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the content library in which the item\nexists.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the content library item.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "The type for the content library item. One of `ovf`,\n`vm-template`, or `iso`\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "libraryId",
                    "name",
                    "type"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibraryItem.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "libraryId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "libraryId",
                    "name",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getCustomAttribute:getCustomAttribute": {
            "description": "The `vsphere.CustomAttribute` data source can be used to reference custom\nattributes that are not managed by this provider. Its attributes are exactly the\nsame as the `vsphere.CustomAttribute` resource,\nand, like importing, the data source takes a name argument for the search. The\n`id` and other attributes are then populated with the data found by the search.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand require vCenter Server.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst attribute = vsphere.getCustomAttribute({\n    name: \"test-attribute\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nattribute = vsphere.get_custom_attribute(name=\"test-attribute\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attribute = VSphere.GetCustomAttribute.Invoke(new()\n    {\n        Name = \"test-attribute\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupCustomAttribute(ctx, \u0026vsphere.LookupCustomAttributeArgs{\n\t\t\tName: \"test-attribute\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetCustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var attribute = VsphereFunctions.getCustomAttribute(GetCustomAttributeArgs.builder()\n            .name(\"test-attribute\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  attribute:\n    fn::invoke:\n      function: vsphere:getCustomAttribute\n      arguments:\n        name: test-attribute\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomAttribute.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomAttribute.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "managedObjectType": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "managedObjectType",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDatacenter:getDatacenter": {
            "description": "The `vsphere.Datacenter` data source can be used to discover the ID of a\nvSphere datacenter object. This can then be used with resources or data sources\nthat require a datacenter, such as the `vsphere.Host`\ndata source.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatacenter.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This can be a name or path.\nCan be omitted if there is only one datacenter in the inventory.\n\n\u003e **NOTE:** When used with an ESXi host, this data source _always_ returns the\nhost's \"default\" datacenter, which is a special datacenter name unrelated to the\ndatacenters that exist in the vSphere inventory when managed by a vCenter Server\ninstance. Hence, the `name` attribute is completely ignored.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatacenter.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "virtualMachines": {
                        "description": "List of all virtual machines included in the vSphere datacenter object.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "virtualMachines",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDatastore:getDatastore": {
            "description": "The `vsphere.getDatastore` data source can be used to discover the ID of a\nvSphere datastore object. This can then be used with resources or data sources\nthat require a datastore. For example, to create virtual machines in using the\n`vsphere.VirtualMachine` resource.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  datastore:\n    fn::invoke:\n      function: vsphere:getDatastore\n      arguments:\n        name: datastore-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the datastore is located in. This can be omitted if the\nsearch path used in `name` is an absolute path. For default datacenters, use\nthe `id` attribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. This can be a name or path.\n"
                    },
                    "stats": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The disk space usage statistics for the specific datastore. The\ntotal datastore capacity is represented as `capacity` and the free remaining\ndisk is represented as `free`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "stats": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The disk space usage statistics for the specific datastore. The\ntotal datastore capacity is represented as `capacity` and the free remaining\ndisk is represented as `free`.\n",
                        "type": "object"
                    }
                },
                "required": [
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDatastoreCluster:getDatastoreCluster": {
            "description": "The `vsphere.DatastoreCluster` data source can be used to discover the ID of a\nvSphere datastore cluster object. This can then be used with resources or data sources\nthat require a datastore. For example, to assign datastores using the\n`vsphere.NasDatastore` or `vsphere.VmfsDatastore` resources, or to create virtual machines in using the `vsphere.VirtualMachine` resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastoreCluster = datacenter.then(datacenter =\u003e vsphere.getDatastoreCluster({\n    name: \"datastore-cluster-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore_cluster = vsphere.get_datastore_cluster(name=\"datastore-cluster-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastoreCluster = VSphere.GetDatastoreCluster.Invoke(new()\n    {\n        Name = \"datastore-cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupDatastoreCluster(ctx, \u0026vsphere.LookupDatastoreClusterArgs{\n\t\t\tName:         \"datastore-cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastoreCluster = VsphereFunctions.getDatastoreCluster(GetDatastoreClusterArgs.builder()\n            .name(\"datastore-cluster-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  datastoreCluster:\n    fn::invoke:\n      function: vsphere:getDatastoreCluster\n      arguments:\n        name: datastore-cluster-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the datastore cluster is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the id attribute from an empty\n`vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the datastore cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "datastores": {
                        "description": "(Optional) The names of the datastores included in the specific \ncluster.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "datastores",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDatastoreStats:getDatastoreStats": {
            "description": "The `vsphere.getDatastoreStats` data source can be used to retrieve the usage\nstats of all vSphere datastore objects in a datacenter. This can then be used as\na standalone data source to get information required as input to other data\nsources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastoreStats = datacenter.then(datacenter =\u003e vsphere.getDatastoreStats({\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore_stats = vsphere.get_datastore_stats(datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastoreStats = VSphere.GetDatastoreStats.Invoke(new()\n    {\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetDatastoreStats(ctx, \u0026vsphere.GetDatastoreStatsArgs{\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreStatsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastoreStats = VsphereFunctions.getDatastoreStats(GetDatastoreStatsArgs.builder()\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  datastoreStats:\n    fn::invoke:\n      function: vsphere:getDatastoreStats\n      arguments:\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nA useful example of this data source would be to determine the datastore with\nthe most free space. For example, in addition to the above:\n\nCreate an `outputs.tf` like that:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const maxFreeSpaceName = theirMaxFreeSpaceName;\nexport const maxFreeSpace = theirMaxFreeSpace;\n```\n```python\nimport pulumi\n\npulumi.export(\"maxFreeSpaceName\", their_max_free_space_name)\npulumi.export(\"maxFreeSpace\", their_max_free_space)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"maxFreeSpaceName\"] = theirMaxFreeSpaceName,\n        [\"maxFreeSpace\"] = theirMaxFreeSpace,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"maxFreeSpaceName\", theirMaxFreeSpaceName)\n\t\tctx.Export(\"maxFreeSpace\", theirMaxFreeSpace)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"maxFreeSpaceName\", theirMaxFreeSpaceName);\n        ctx.export(\"maxFreeSpace\", theirMaxFreeSpace);\n    }\n}\n```\n```yaml\noutputs:\n  maxFreeSpaceName: ${theirMaxFreeSpaceName}\n  maxFreeSpace: ${theirMaxFreeSpace}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nand a `locals.tf` like that:\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastoreStats.\n",
                "properties": {
                    "capacity": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A mapping of the capacity for all datastore in the datacenter,\nwhere the name of the datastore is used as key and the capacity as value.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The\n[managed object reference ID][docs-about-morefs] of the datacenter the\ndatastores are located in. For default datacenters, use the `id` attribute\nfrom an empty `vsphere.Datacenter` data source.\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n"
                    },
                    "freeSpace": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A mapping of the free space for each datastore in the\ndatacenter, where the name of the datastore is used as key and the free space\nas value.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastoreStats.\n",
                "properties": {
                    "capacity": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A mapping of the capacity for all datastore in the datacenter,\nwhere the name of the datastore is used as key and the capacity as value.\n",
                        "type": "object"
                    },
                    "datacenterId": {
                        "description": "The [managed object reference ID][docs-about-morefs] of the\ndatacenter the datastores are located in.\n",
                        "type": "string"
                    },
                    "freeSpace": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A mapping of the free space for each datastore in the\ndatacenter, where the name of the datastore is used as key and the free space\nas value.\n",
                        "type": "object"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "datacenterId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDistributedVirtualSwitch:getDistributedVirtualSwitch": {
            "description": "The `vsphere.DistributedVirtualSwitch` data source can be used to discover\nthe ID and uplink data of a of a vSphere distributed switch (VDS). This\ncan then be used with resources or data sources that require a VDS, such as the\n`vsphere.DistributedPortGroup` resource, for which\nan example is shown below.\n\n\u003e **NOTE:** This data source requires vCenter Server and is not available on\ndirect ESXi host connections.\n\n## Example Usage\n\nThe following example locates a distributed switch named `vds-01`, in the\ndatacenter `dc-01`. It then uses this distributed switch to set up a\n`vsphere.DistributedPortGroup` resource that uses the first uplink as a\nprimary uplink and the second uplink as a secondary.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst vds = datacenter.then(datacenter =\u003e vsphere.getDistributedVirtualSwitch({\n    name: \"vds-01\",\n    datacenterId: datacenter.id,\n}));\nconst dvpg = new vsphere.DistributedPortGroup(\"dvpg\", {\n    name: \"dvpg-01\",\n    distributedVirtualSwitchUuid: vds.then(vds =\u003e vds.id),\n    activeUplinks: [vds.then(vds =\u003e vds.uplinks?.[0])],\n    standbyUplinks: [vds.then(vds =\u003e vds.uplinks?.[1])],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nvds = vsphere.get_distributed_virtual_switch(name=\"vds-01\",\n    datacenter_id=datacenter.id)\ndvpg = vsphere.DistributedPortGroup(\"dvpg\",\n    name=\"dvpg-01\",\n    distributed_virtual_switch_uuid=vds.id,\n    active_uplinks=[vds.uplinks[0]],\n    standby_uplinks=[vds.uplinks[1]])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var vds = VSphere.GetDistributedVirtualSwitch.Invoke(new()\n    {\n        Name = \"vds-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var dvpg = new VSphere.DistributedPortGroup(\"dvpg\", new()\n    {\n        Name = \"dvpg-01\",\n        DistributedVirtualSwitchUuid = vds.Apply(getDistributedVirtualSwitchResult =\u003e getDistributedVirtualSwitchResult.Id),\n        ActiveUplinks = new[]\n        {\n            vds.Apply(getDistributedVirtualSwitchResult =\u003e getDistributedVirtualSwitchResult.Uplinks[0]),\n        },\n        StandbyUplinks = new[]\n        {\n            vds.Apply(getDistributedVirtualSwitchResult =\u003e getDistributedVirtualSwitchResult.Uplinks[1]),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvds, err := vsphere.LookupDistributedVirtualSwitch(ctx, \u0026vsphere.LookupDistributedVirtualSwitchArgs{\n\t\t\tName:         \"vds-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewDistributedPortGroup(ctx, \"dvpg\", \u0026vsphere.DistributedPortGroupArgs{\n\t\t\tName:                         pulumi.String(\"dvpg-01\"),\n\t\t\tDistributedVirtualSwitchUuid: pulumi.String(vds.Id),\n\t\t\tActiveUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(vds.Uplinks[0]),\n\t\t\t},\n\t\t\tStandbyUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(vds.Uplinks[1]),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.DistributedPortGroup;\nimport com.pulumi.vsphere.DistributedPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var vds = VsphereFunctions.getDistributedVirtualSwitch(GetDistributedVirtualSwitchArgs.builder()\n            .name(\"vds-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        var dvpg = new DistributedPortGroup(\"dvpg\", DistributedPortGroupArgs.builder()\n            .name(\"dvpg-01\")\n            .distributedVirtualSwitchUuid(vds.id())\n            .activeUplinks(vds.uplinks()[0])\n            .standbyUplinks(vds.uplinks()[1])\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dvpg:\n    type: vsphere:DistributedPortGroup\n    properties:\n      name: dvpg-01\n      distributedVirtualSwitchUuid: ${vds.id}\n      activeUplinks:\n        - ${vds.uplinks[0]}\n      standbyUplinks:\n        - ${vds.uplinks[1]}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  vds:\n    fn::invoke:\n      function: vsphere:getDistributedVirtualSwitch\n      arguments:\n        name: vds-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the VDS is located in. This can be omitted if the search\npath used in `name` is an absolute path. For default datacenters, use the `id`\nattribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VDS. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "uplinks": {
                        "description": "The list of the uplinks on this vSphere distributed switch, as per the\n`uplinks` argument to the\n`vsphere.DistributedVirtualSwitch`\nresource.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "name",
                    "uplinks",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDynamic:getDynamic": {
            "description": "[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n\nThe `vsphere.getDynamic` data source can be used to get the\n[managed object reference ID][docs-about-morefs] of any tagged managed object in\nvCenter Server by providing a list of tag IDs and an optional regular expression\nto filter objects by name.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = vsphere.getTagCategory({\n    name: \"SomeCategory\",\n});\nconst tag1 = vsphere.getTag({\n    name: \"FirstTag\",\n    categoryId: cat.id,\n});\nconst tag2 = vsphere.getTag({\n    name: \"SecondTag\",\n    categoryId: cat.id,\n});\nconst dyn = Promise.all([tag1, tag1]).then(([tag1, tag11]) =\u003e vsphere.getDynamic({\n    filters: [\n        tag1.id,\n        tag11.id,\n    ],\n    nameRegex: \"ubuntu\",\n    type: \"Datacenter\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"SomeCategory\")\ntag1 = vsphere.get_tag(name=\"FirstTag\",\n    category_id=cat[\"id\"])\ntag2 = vsphere.get_tag(name=\"SecondTag\",\n    category_id=cat[\"id\"])\ndyn = vsphere.get_dynamic(filters=[\n        tag1.id,\n        tag1.id,\n    ],\n    name_regex=\"ubuntu\",\n    type=\"Datacenter\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"SomeCategory\",\n    });\n\n    var tag1 = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"FirstTag\",\n        CategoryId = cat.Id,\n    });\n\n    var tag2 = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"SecondTag\",\n        CategoryId = cat.Id,\n    });\n\n    var dyn = VSphere.GetDynamic.Invoke(new()\n    {\n        Filters = new[]\n        {\n            tag1.Apply(getTagResult =\u003e getTagResult.Id),\n            tag1.Apply(getTagResult =\u003e getTagResult.Id),\n        },\n        NameRegex = \"ubuntu\",\n        Type = \"Datacenter\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\nfunc main() {\npulumi.Run(func(ctx *pulumi.Context) error {\n_, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\nName: \"SomeCategory\",\n}, nil);\nif err != nil {\nreturn err\n}\ntag1, err := vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\nName: \"FirstTag\",\nCategoryId: cat.Id,\n}, nil);\nif err != nil {\nreturn err\n}\n_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\nName: \"SecondTag\",\nCategoryId: cat.Id,\n}, nil);\nif err != nil {\nreturn err\n}\n_, err = vsphere.GetDynamic(ctx, \u0026vsphere.GetDynamicArgs{\nFilters: interface{}{\ntag1.Id,\ntag1.Id,\n},\nNameRegex: pulumi.StringRef(\"ubuntu\"),\nType: pulumi.StringRef(\"Datacenter\"),\n}, nil);\nif err != nil {\nreturn err\n}\nreturn nil\n})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport com.pulumi.vsphere.inputs.GetTagArgs;\nimport com.pulumi.vsphere.inputs.GetDynamicArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var category = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"SomeCategory\")\n            .build());\n\n        final var tag1 = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"FirstTag\")\n            .categoryId(cat.id())\n            .build());\n\n        final var tag2 = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"SecondTag\")\n            .categoryId(cat.id())\n            .build());\n\n        final var dyn = VsphereFunctions.getDynamic(GetDynamicArgs.builder()\n            .filters(            \n                tag1.id(),\n                tag1.id())\n            .nameRegex(\"ubuntu\")\n            .type(\"Datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  category:\n    fn::invoke:\n      function: vsphere:getTagCategory\n      arguments:\n        name: SomeCategory\n  tag1:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: FirstTag\n        categoryId: ${cat.id}\n  tag2:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: SecondTag\n        categoryId: ${cat.id}\n  dyn:\n    fn::invoke:\n      function: vsphere:getDynamic\n      arguments:\n        filters:\n          - ${tag1.id}\n          - ${tag1.id}\n        nameRegex: ubuntu\n        type: Datacenter\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDynamic.\n",
                "properties": {
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs that must be present on an object to\nbe a match.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match the\nobject's name.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The managed object type the returned object must match.\nThe managed object types can be found in the managed object type section\n[here](https://developer.broadcom.com/xapis/vsphere-web-services-api/latest/).\n"
                    }
                },
                "type": "object",
                "required": [
                    "filters"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDynamic.\n",
                "properties": {
                    "filters": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "nameRegex": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "filters",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getFolder:getFolder": {
            "description": "The `vsphere.Folder` data source can be used to get the general attributes of a\nvSphere inventory folder. The data source supports creating folders of the 5\nmajor types - datacenter folders, host and cluster folders, virtual machine\nfolders, storage folders, and network folders.\n\nPaths are absolute and must include the datacenter.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst folder = vsphere.getFolder({\n    path: \"/dc-01/datastore-01/folder-01\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nfolder = vsphere.get_folder(path=\"/dc-01/datastore-01/folder-01\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var folder = VSphere.GetFolder.Invoke(new()\n    {\n        Path = \"/dc-01/datastore-01/folder-01\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupFolder(ctx, \u0026vsphere.LookupFolderArgs{\n\t\t\tPath: \"/dc-01/datastore-01/folder-01\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetFolderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var folder = VsphereFunctions.getFolder(GetFolderArgs.builder()\n            .path(\"/dc-01/datastore-01/folder-01\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  folder:\n    fn::invoke:\n      function: vsphere:getFolder\n      arguments:\n        path: /dc-01/datastore-01/folder-01\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFolder.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The absolute path of the folder. For example, given a\ndefault datacenter of `default-dc`, a folder of type `vm`, and a folder name\nof `test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`. The valid folder types to be used in\nthe path are: `vm`, `host`, `datacenter`, `datastore`, or `network`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFolder.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    }
                },
                "required": [
                    "path",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getGuestOsCustomization:getGuestOsCustomization": {
            "description": "The `vsphere.GuestOsCustomization` data source can be used to discover the\ndetails about a customization specification for a guest operating system.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      templateUuid: ${template.id}\n      customizationSpec:\n        - id: ${windows.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  template:\n    fn::invoke:\n      function: vsphere:getVirtualMachine\n      arguments:\n        name: windows-template\n        datacenterId: ${datacenter.id}\n  windows:\n    fn::invoke:\n      function: vsphere:getGuestOsCustomization\n      arguments:\n        name: windows\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGuestOsCustomization.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the customization specification is the unique\nidentifier per vCenter Server instance. ## Attribute Reference\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGuestOsCustomization.\n",
                "properties": {
                    "changeVersion": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lastUpdateTime": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "specs": {
                        "items": {
                            "$ref": "#/types/vsphere:index/getGuestOsCustomizationSpec:getGuestOsCustomizationSpec"
                        },
                        "type": "array"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "changeVersion",
                    "description",
                    "lastUpdateTime",
                    "name",
                    "specs",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHost:getHost": {
            "description": "The `vsphere.Host` data source can be used to discover the ID of an ESXi host.\nThis can then be used with resources or data sources that require an ESX\nhost's managed object reference ID.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof a vSphere datacenter object.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ESXI host. This can be a name or path.\nCan be omitted if there is only one host in your inventory.\n\n\u003e **NOTE:** When used against an ESXi host directly, this data source _always_\nreturns the ESXi host's object ID, regardless of what is entered into `name`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "description": "The managed object ID of the ESXi\nhost's root resource pool.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "datacenterId",
                    "resourcePoolId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHostBaseImages:getHostBaseImages": {
            "description": "The `vsphere.getHostBaseImages` data source can be used to get the list of ESXi\nbase images available for cluster software management.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst baseImages = vsphere.getHostBaseImages({});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nbase_images = vsphere.get_host_base_images()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var baseImages = VSphere.GetHostBaseImages.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetHostBaseImages(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var baseImages = VsphereFunctions.getHostBaseImages(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n    }\n}\n```\n```yaml\nvariables:\n  baseImages:\n    fn::invoke:\n      function: vsphere:getHostBaseImages\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getHostBaseImages.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "versions": {
                        "description": "The ESXi version identifier for the image\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "versions",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHostPciDevice:getHostPciDevice": {
            "description": "The `vsphere.getHostPciDevice` data source can be used to discover the device ID\nof a vSphere host's PCI device. This can then be used with\n`vsphere.VirtualMachine`'s `pci_device_id`.\n\n## Example Usage\n\n### With Vendor ID And Class ID\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst dev = host.then(host =\u003e vsphere.getHostPciDevice({\n    hostId: host.id,\n    classId: \"123\",\n    vendorId: \"456\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\ndev = vsphere.get_host_pci_device(host_id=host.id,\n    class_id=\"123\",\n    vendor_id=\"456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var dev = VSphere.GetHostPciDevice.Invoke(new()\n    {\n        HostId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        ClassId = \"123\",\n        VendorId = \"456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostPciDevice(ctx, \u0026vsphere.GetHostPciDeviceArgs{\n\t\t\tHostId:   host.Id,\n\t\t\tClassId:  pulumi.StringRef(\"123\"),\n\t\t\tVendorId: pulumi.StringRef(\"456\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetHostPciDeviceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var dev = VsphereFunctions.getHostPciDevice(GetHostPciDeviceArgs.builder()\n            .hostId(host.id())\n            .classId(\"123\")\n            .vendorId(\"456\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  dev:\n    fn::invoke:\n      function: vsphere:getHostPciDevice\n      arguments:\n        hostId: ${host.id}\n        classId: 123\n        vendorId: 456\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### With Name Regular Expression\n\n \u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst dev = host.then(host =\u003e vsphere.getHostPciDevice({\n    hostId: host.id,\n    nameRegex: \"MMC\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\ndev = vsphere.get_host_pci_device(host_id=host.id,\n    name_regex=\"MMC\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var dev = VSphere.GetHostPciDevice.Invoke(new()\n    {\n        HostId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NameRegex = \"MMC\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostPciDevice(ctx, \u0026vsphere.GetHostPciDeviceArgs{\n\t\t\tHostId:    host.Id,\n\t\t\tNameRegex: pulumi.StringRef(\"MMC\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetHostPciDeviceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var dev = VsphereFunctions.getHostPciDevice(GetHostPciDeviceArgs.builder()\n            .hostId(host.id())\n            .nameRegex(\"MMC\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  dev:\n    fn::invoke:\n      function: vsphere:getHostPciDevice\n      arguments:\n        hostId: ${host.id}\n        nameRegex: MMC\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHostPciDevice.\n",
                "properties": {
                    "classId": {
                        "type": "string",
                        "description": "The hexadecimal PCI device class ID\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n\n\u003e **NOTE:** `name_regex`, `vendor_id`, and `class_id` can all be used together.\n"
                    },
                    "hostId": {
                        "type": "string",
                        "description": "The [managed object reference ID][docs-about-morefs] of\na host.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match the\nhost PCI device name.\n"
                    },
                    "vendorId": {
                        "type": "string",
                        "description": "The hexadecimal PCI device vendor ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostPciDevice.\n",
                "properties": {
                    "classId": {
                        "type": "string"
                    },
                    "hostId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the PCI device.\n",
                        "type": "string"
                    },
                    "nameRegex": {
                        "type": "string"
                    },
                    "vendorId": {
                        "type": "string"
                    }
                },
                "required": [
                    "hostId",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHostThumbprint:getHostThumbprint": {
            "description": "The `vsphere_thumbprint` data source can be used to discover the host thumbprint\nof an ESXi host. This can be used when adding the `vsphere.Host` resource to a\ncluster or a vCenter Server instance.\n\n* If the ESXi host is using a certificate chain, the first one returned will be\nused to generate the thumbprint.\n\n* If the ESXi host has a certificate issued by a certificate authority, ensure\nthat the the certificate authority is trusted on the system running the plan.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst thumbprint = vsphere.getHostThumbprint({\n    address: \"esxi-01.example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nthumbprint = vsphere.get_host_thumbprint(address=\"esxi-01.example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var thumbprint = VSphere.GetHostThumbprint.Invoke(new()\n    {\n        Address = \"esxi-01.example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetHostThumbprint(ctx, \u0026vsphere.GetHostThumbprintArgs{\n\t\t\tAddress: \"esxi-01.example.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetHostThumbprintArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var thumbprint = VsphereFunctions.getHostThumbprint(GetHostThumbprintArgs.builder()\n            .address(\"esxi-01.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  thumbprint:\n    fn::invoke:\n      function: vsphere:getHostThumbprint\n      arguments:\n        address: esxi-01.example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHostThumbprint.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The address of the ESXi host to retrieve the thumbprint\nfrom.\n"
                    },
                    "insecure": {
                        "type": "boolean",
                        "description": "Disables SSL certificate verification. Default: `false`\n"
                    },
                    "port": {
                        "type": "string",
                        "description": "The port to use connecting to the ESXi host. Default: 443\n"
                    }
                },
                "type": "object",
                "required": [
                    "address"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostThumbprint.\n",
                "properties": {
                    "address": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "insecure": {
                        "type": "boolean"
                    },
                    "port": {
                        "type": "string"
                    }
                },
                "required": [
                    "address",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHostVgpuProfile:getHostVgpuProfile": {
            "description": "The `vsphere.getHostVgpuProfile` data source can be used to discover the\navailable vGPU profiles of a vSphere host.\n\n## Example Usage\n\n### To Return All VGPU Profiles\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst vgpuProfile = host.then(host =\u003e vsphere.getHostVgpuProfile({\n    hostId: host.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nvgpu_profile = vsphere.get_host_vgpu_profile(host_id=host.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vgpuProfile = VSphere.GetHostVgpuProfile.Invoke(new()\n    {\n        HostId = host.Apply(getHostResult =\u003e getHostResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostVgpuProfile(ctx, \u0026vsphere.GetHostVgpuProfileArgs{\n\t\t\tHostId: host.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetHostVgpuProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var vgpuProfile = VsphereFunctions.getHostVgpuProfile(GetHostVgpuProfileArgs.builder()\n            .hostId(host.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  vgpuProfile:\n    fn::invoke:\n      function: vsphere:getHostVgpuProfile\n      arguments:\n        hostId: ${host.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### With VGPU Profile Name_regex\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst vgpuProfile = host.then(host =\u003e vsphere.getHostVgpuProfile({\n    hostId: host.id,\n    nameRegex: \"a100\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nvgpu_profile = vsphere.get_host_vgpu_profile(host_id=host.id,\n    name_regex=\"a100\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vgpuProfile = VSphere.GetHostVgpuProfile.Invoke(new()\n    {\n        HostId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NameRegex = \"a100\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostVgpuProfile(ctx, \u0026vsphere.GetHostVgpuProfileArgs{\n\t\t\tHostId:    host.Id,\n\t\t\tNameRegex: pulumi.StringRef(\"a100\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetHostVgpuProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var vgpuProfile = VsphereFunctions.getHostVgpuProfile(GetHostVgpuProfileArgs.builder()\n            .hostId(host.id())\n            .nameRegex(\"a100\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  vgpuProfile:\n    fn::invoke:\n      function: vsphere:getHostVgpuProfile\n      arguments:\n        hostId: ${host.id}\n        nameRegex: a100\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHostVgpuProfile.\n",
                "properties": {
                    "hostId": {
                        "type": "string",
                        "description": "The [managed object reference ID][docs-about-morefs] of\na host.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match the\nhost vGPU profile name.\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostVgpuProfile.\n",
                "properties": {
                    "hostId": {
                        "description": "The [managed objectID][docs-about-morefs] of the ESXi host.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "nameRegex": {
                        "description": "(Optional) A regular expression that will be used to match the\nhost vGPU profile name.\n",
                        "type": "string"
                    },
                    "vgpuProfiles": {
                        "description": "The list of available vGPU profiles on the ESXi host.\nThis may be and empty array if no vGPU profile are identified.\n",
                        "items": {
                            "$ref": "#/types/vsphere:index/getHostVgpuProfileVgpuProfile:getHostVgpuProfileVgpuProfile"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "hostId",
                    "vgpuProfiles",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getLicense:getLicense": {
            "description": "The `vsphere.License` data source can be used to get the general attributes of\na license keys from a vCenter Server instance.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst license = vsphere.getLicense({\n    licenseKey: \"00000-00000-00000-00000-00000\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlicense = vsphere.get_license(license_key=\"00000-00000-00000-00000-00000\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var license = VSphere.GetLicense.Invoke(new()\n    {\n        LicenseKey = \"00000-00000-00000-00000-00000\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupLicense(ctx, \u0026vsphere.LookupLicenseArgs{\n\t\t\tLicenseKey: \"00000-00000-00000-00000-00000\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetLicenseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var license = VsphereFunctions.getLicense(GetLicenseArgs.builder()\n            .licenseKey(\"00000-00000-00000-00000-00000\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  license:\n    fn::invoke:\n      function: vsphere:getLicense\n      arguments:\n        licenseKey: 00000-00000-00000-00000-00000\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLicense.\n",
                "properties": {
                    "licenseKey": {
                        "type": "string",
                        "description": "The license key.\n"
                    }
                },
                "type": "object",
                "required": [
                    "licenseKey"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLicense.\n",
                "properties": {
                    "editionKey": {
                        "description": "The product edition of the license key.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "labels": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of key/value pairs attached as labels (tags) to the license\nkey.\n",
                        "type": "object"
                    },
                    "licenseKey": {
                        "type": "string"
                    },
                    "name": {
                        "description": "The display name for the license.\n",
                        "type": "string"
                    },
                    "total": {
                        "description": "Total number of units (example: CPUs) contained in the license.\n",
                        "type": "integer"
                    },
                    "used": {
                        "description": "The number of units (example: CPUs) assigned to this license.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "editionKey",
                    "id",
                    "labels",
                    "licenseKey",
                    "name",
                    "total",
                    "used"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getNetwork:getNetwork": {
            "description": "The `vsphere.getNetwork` data source can be used to discover the ID of a network in\nvSphere. This can be any network that can be used as the backing for a network\ninterface for `vsphere.VirtualMachine` or any other vSphere resource that\nrequires a network. This includes standard (host-based) port groups, distributed\nport groups, or opaque networks such as those managed by NSX.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"VM Network\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nnetwork = vsphere.get_network(name=\"VM Network\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"VM Network\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"VM Network\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"VM Network\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  network:\n    fn::invoke:\n      function: vsphere:getNetwork\n      arguments:\n        name: VM Network\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Additional Examples\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst myPortGroup = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    datacenterId: datacenter.id,\n    name: \"VM Network\",\n    filters: [{\n        networkType: \"Network\",\n    }],\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nmy_port_group = vsphere.get_network(datacenter_id=datacenter.id,\n    name=\"VM Network\",\n    filters=[{\n        \"network_type\": \"Network\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var myPortGroup = VSphere.GetNetwork.Invoke(new()\n    {\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n        Name = \"VM Network\",\n        Filters = new[]\n        {\n            new VSphere.Inputs.GetNetworkFilterInputArgs\n            {\n                NetworkType = \"Network\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t\tName:         \"VM Network\",\n\t\t\tFilters: []vsphere.GetNetworkFilter{\n\t\t\t\t{\n\t\t\t\t\tNetworkType: pulumi.StringRef(\"Network\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var myPortGroup = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .datacenterId(datacenter.id())\n            .name(\"VM Network\")\n            .filters(GetNetworkFilterArgs.builder()\n                .networkType(\"Network\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  myPortGroup:\n    fn::invoke:\n      function: vsphere:getNetwork\n      arguments:\n        datacenterId: ${datacenter.id}\n        name: VM Network\n        filters:\n          - networkType: Network\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the network is located in. This can be omitted if the\nsearch path used in `name` is an absolute path. For default datacenters,\nuse the `id` attribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "For distributed port group type\nnetwork objects, the ID of the distributed virtual switch for which the port\ngroup belongs. It is useful to differentiate port groups with same name using\nthe distributed virtual switch ID.\n"
                    },
                    "filters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/getNetworkFilter:getNetworkFilter"
                        },
                        "description": "Apply a filter for the discovered network.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the network. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string"
                    },
                    "filters": {
                        "items": {
                            "$ref": "#/types/vsphere:index/getNetworkFilter:getNetworkFilter"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "description": "The managed object type for the discovered network. This will be one\nof `DistributedVirtualPortgroup` for distributed port groups, `Network` for\nstandard (host-based) port groups, or `OpaqueNetwork` for networks managed\nexternally, such as those managed by NSX.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getOvfVmTemplate:getOvfVmTemplate": {
            "description": "The `vsphere.getOvfVmTemplate` data source can be used to submit an OVF to\nvSphere and extract its hardware settings in a form that can be then used as\ninputs for a `vsphere.VirtualMachine` resource.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOvfVmTemplate.\n",
                "properties": {
                    "allowUnverifiedSslCert": {
                        "type": "boolean",
                        "description": "Allow unverified SSL certificates\nwhen deploying OVF/OVA from a URL.\n"
                    },
                    "datastoreId": {
                        "type": "string",
                        "description": "The ID of the virtual machine's datastore. The\nvirtual machine configuration is placed here, along with any virtual disks\nthat are created without datastores.\n"
                    },
                    "deploymentOption": {
                        "type": "string",
                        "description": "The key of the chosen deployment option. If\nempty, the default option is chosen.\n",
                        "willReplaceOnChanges": true
                    },
                    "diskProvisioning": {
                        "type": "string",
                        "description": "The disk provisioning type. If set, all the\ndisks in the deployed OVA/OVF will have the same specified disk type. Can be\none of `thin`, `flat`, `thick` or `sameAsSource`.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableHiddenProperties": {
                        "type": "boolean",
                        "description": "Allow properties with\n`ovf:userConfigurable=false` to be set.\n",
                        "willReplaceOnChanges": true
                    },
                    "folder": {
                        "type": "string",
                        "description": "The name of the folder in which to place the virtual\nmachine.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The ID of the ESXi host system to deploy the\nvirtual machine.\n"
                    },
                    "ipAllocationPolicy": {
                        "type": "string",
                        "description": "The IP allocation policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipProtocol": {
                        "type": "string",
                        "description": "The IP protocol.\n",
                        "willReplaceOnChanges": true
                    },
                    "localOvfPath": {
                        "type": "string",
                        "description": "The absolute path to the OVF/OVA file on the\nlocal system. When deploying from an OVF, ensure all necessary files such as\nthe `.vmdk` files are present in the same directory as the OVF.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the virtual machine to create.\n"
                    },
                    "ovfNetworkMap": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The mapping of name of network identifiers\nfrom the OVF descriptor to network UUID in the environment.\n",
                        "willReplaceOnChanges": true
                    },
                    "remoteOvfUrl": {
                        "type": "string",
                        "description": "URL of the remote OVF/OVA file to be deployed.\n\n\u003e **NOTE:** Either `local_ovf_path` or `remote_ovf_url` is required, both can\nnot be empty.\n",
                        "willReplaceOnChanges": true
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The ID of a resource pool in which to place\nthe virtual machine.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostSystemId",
                    "name",
                    "resourcePoolId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOvfVmTemplate.\n",
                "properties": {
                    "allowUnverifiedSslCert": {
                        "type": "boolean"
                    },
                    "alternateGuestName": {
                        "description": "An alternate guest operating system name.\n",
                        "type": "string"
                    },
                    "annotation": {
                        "description": "A description of the virtual machine.\n",
                        "type": "string"
                    },
                    "cpuHotAddEnabled": {
                        "description": "Allow CPUs to be added to the virtual machine while\npowered on.\n",
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "description": "Allow CPUs to be removed from the virtual machine\nwhile powered on.\n",
                        "type": "boolean"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "datastoreId": {
                        "type": "string"
                    },
                    "deploymentOption": {
                        "type": "string"
                    },
                    "diskProvisioning": {
                        "type": "string"
                    },
                    "enableHiddenProperties": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "description": "The firmware to use on the virtual machine.\n",
                        "type": "string"
                    },
                    "folder": {
                        "type": "string"
                    },
                    "guestId": {
                        "description": "The ID for the guest operating system\n",
                        "type": "string"
                    },
                    "hostSystemId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ideControllerCount": {
                        "type": "integer"
                    },
                    "ipAllocationPolicy": {
                        "type": "string"
                    },
                    "ipProtocol": {
                        "type": "string"
                    },
                    "localOvfPath": {
                        "type": "string"
                    },
                    "memory": {
                        "description": "The size of the virtual machine memory, in MB.\n",
                        "type": "integer"
                    },
                    "memoryHotAddEnabled": {
                        "description": "Allow memory to be added to the virtual machine\nwhile powered on.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nestedHvEnabled": {
                        "description": "Enable nested hardware virtualization on the virtual\nmachine, facilitating nested virtualization in the guest.\n",
                        "type": "boolean"
                    },
                    "numCoresPerSocket": {
                        "description": "The number of cores per virtual CPU in the virtual\nmachine.\n",
                        "type": "integer"
                    },
                    "numCpus": {
                        "description": "The number of virtual CPUs to assign to the virtual machine.\n",
                        "type": "integer"
                    },
                    "ovfNetworkMap": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "remoteOvfUrl": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string"
                    },
                    "sataControllerCount": {
                        "type": "integer"
                    },
                    "scsiControllerCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "description": "The swap file placement policy for the virtual\nmachine.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "alternateGuestName",
                    "annotation",
                    "cpuHotAddEnabled",
                    "cpuHotRemoveEnabled",
                    "cpuPerformanceCountersEnabled",
                    "firmware",
                    "guestId",
                    "hostSystemId",
                    "ideControllerCount",
                    "memory",
                    "memoryHotAddEnabled",
                    "name",
                    "nestedHvEnabled",
                    "numCoresPerSocket",
                    "numCpus",
                    "resourcePoolId",
                    "sataControllerCount",
                    "scsiControllerCount",
                    "scsiType",
                    "swapPlacementPolicy",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getPolicy:getPolicy": {
            "description": "The `vsphere.getPolicy` data source can be used to discover the UUID of a\nstorage policy. This can then be used with other resources or data sources that\nuse a storage policy.\n\n\u003e **NOTE:** Storage policies are not supported on direct ESXi hosts and\nrequires vCenter Server.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodPlatinumReplicated = vsphere.getPolicy({\n    name: \"prod_platinum_replicated\",\n});\nconst devSilverNonreplicated = vsphere.getPolicy({\n    name: \"dev_silver_nonreplicated\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_platinum_replicated = vsphere.get_policy(name=\"prod_platinum_replicated\")\ndev_silver_nonreplicated = vsphere.get_policy(name=\"dev_silver_nonreplicated\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodPlatinumReplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"prod_platinum_replicated\",\n    });\n\n    var devSilverNonreplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"dev_silver_nonreplicated\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"prod_platinum_replicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"dev_silver_nonreplicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var prodPlatinumReplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"prod_platinum_replicated\")\n            .build());\n\n        final var devSilverNonreplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"dev_silver_nonreplicated\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  prodPlatinumReplicated:\n    fn::invoke:\n      function: vsphere:getPolicy\n      arguments:\n        name: prod_platinum_replicated\n  devSilverNonreplicated:\n    fn::invoke:\n      function: vsphere:getPolicy\n      arguments:\n        name: dev_silver_nonreplicated\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPolicy.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getResourcePool:getResourcePool": {
            "description": "The `vsphere.ResourcePool` data source can be used to discover the ID of a\nresource pool in vSphere. This is useful to return the ID of a resource pool\nthat you want to use to create virtual machines in using the\n`vsphere.VirtualMachine` resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst pool = datacenter.then(datacenter =\u003e vsphere.getResourcePool({\n    name: \"resource-pool-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\npool = vsphere.get_resource_pool(name=\"resource-pool-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var pool = VSphere.GetResourcePool.Invoke(new()\n    {\n        Name = \"resource-pool-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupResourcePool(ctx, \u0026vsphere.LookupResourcePoolArgs{\n\t\t\tName:         pulumi.StringRef(\"resource-pool-01\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var pool = VsphereFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"resource-pool-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  pool:\n    fn::invoke:\n      function: vsphere:getResourcePool\n      arguments:\n        name: resource-pool-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Specifying the Root Resource Pool for a Standalone ESXi Host\n\n\u003e **NOTE:** Returning the root resource pool for a cluster can be done\ndirectly via the `vsphere.ComputeCluster`\ndata source.\n\nAll compute resources in vSphere have a resource pool, even if one has not been\nexplicitly created. This resource pool is referred to as the _root resource\npool_ and can be looked up by specifying the path.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst pool = vsphere.getResourcePool({\n    name: \"esxi-01.example.com/Resources\",\n    datacenterId: datacenter.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\npool = vsphere.get_resource_pool(name=\"esxi-01.example.com/Resources\",\n    datacenter_id=datacenter[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pool = VSphere.GetResourcePool.Invoke(new()\n    {\n        Name = \"esxi-01.example.com/Resources\",\n        DatacenterId = datacenter.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupResourcePool(ctx, \u0026vsphere.LookupResourcePoolArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com/Resources\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var pool = VsphereFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"esxi-01.example.com/Resources\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  pool:\n    fn::invoke:\n      function: vsphere:getResourcePool\n      arguments:\n        name: esxi-01.example.com/Resources\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nFor more information on the root resource pool, see\n[Managing Resource Pools][vmware-docs-resource-pools] in the vSphere\ndocumentation.\n\n[vmware-docs-resource-pools]: https://techdocs.broadcom.com/us/en/vmware-cis/vsphere/vsphere/8-0/vsphere-resource-management-8-0/managing-resource-pools.html\n",
            "inputs": {
                "description": "A collection of arguments for invoking getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter in which the resource pool is located. This can be omitted\nif the search path used in `name` is an absolute path. For default\ndatacenters, use the id attribute from an empty `vsphere.Datacenter` data\nsource.\n\n\u003e **Note:** When using ESXi without a vCenter Server instance, you do not\nneed to specify either attribute to use this data source. An empty declaration\nwill load the ESXi host's root resource pool.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource pool. This can be a name or\npath. This is required when using vCenter.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getRole:getRole": {
            "description": "The `vsphere.Role` data source can be used to discover the `id` and privileges\nassociated with a role given its name or display label.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst terraformRole = vsphere.getRole({\n    label: \"Terraform to vSphere Integration Role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nterraform_role = vsphere.get_role(label=\"Terraform to vSphere Integration Role\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var terraformRole = VSphere.GetRole.Invoke(new()\n    {\n        Label = \"Terraform to vSphere Integration Role\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupRole(ctx, \u0026vsphere.LookupRoleArgs{\n\t\t\tLabel: \"Terraform to vSphere Integration Role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var terraformRole = VsphereFunctions.getRole(GetRoleArgs.builder()\n            .label(\"Terraform to vSphere Integration Role\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  terraformRole:\n    fn::invoke:\n      function: vsphere:getRole\n      arguments:\n        label: Terraform to vSphere Integration Role\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the role.\n"
                    },
                    "label": {
                        "type": "string",
                        "description": "The label of the role.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges associated with the role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "label"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "description": {
                        "description": "The description of the role.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "label": {
                        "description": "The display label of the role.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rolePrivileges": {
                        "description": "The privileges associated with the role.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "label",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getTag:getTag": {
            "description": "The `vsphere.Tag` data source can be used to reference tags that are not\nmanaged by this provider. Its attributes are exactly the same as the `vsphere.Tag`\nresource, and, like importing, the data source takes a name and\ncategory to search on. The `id` and other attributes are then populated with\nthe data found by the search.\n\n\u003e **NOTE:** Tagging is not supported on direct ESXi hosts connections and\nrequires vCenter Server.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = vsphere.getTagCategory({\n    name: \"example-category\",\n});\nconst tag = category.then(category =\u003e vsphere.getTag({\n    name: \"example-tag\",\n    categoryId: category.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"example-category\")\ntag = vsphere.get_tag(name=\"example-tag\",\n    category_id=category.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"example-category\",\n    });\n\n    var tag = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"example-tag\",\n        CategoryId = category.Apply(getTagCategoryResult =\u003e getTagCategoryResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcategory, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"example-category\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"example-tag\",\n\t\t\tCategoryId: category.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport com.pulumi.vsphere.inputs.GetTagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var category = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"example-category\")\n            .build());\n\n        final var tag = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"example-tag\")\n            .categoryId(category.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  category:\n    fn::invoke:\n      function: vsphere:getTagCategory\n      arguments:\n        name: example-category\n  tag:\n    fn::invoke:\n      function: vsphere:getTag\n      arguments:\n        name: example-tag\n        categoryId: ${category.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The ID of the tag category in which the tag is\nlocated.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the tag.\n"
                    }
                },
                "type": "object",
                "required": [
                    "categoryId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "categoryId",
                    "description",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getTagCategory:getTagCategory": {
            "description": "The `vsphere.TagCategory` data source can be used to reference tag categories\nthat are not managed by this provider. Its attributes are the same as the\n`vsphere.TagCategory` resource, and, like importing,\nthe data source uses a name and category as search criteria. The `id` and other\nattributes are populated with the data found by the search.\n\n\u003e **NOTE:** Tagging is not supported on direct ESXi hosts connections and\nrequires vCenter Server.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = vsphere.getTagCategory({\n    name: \"example-category\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"example-category\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"example-category\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"example-category\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var category = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"example-category\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  category:\n    fn::invoke:\n      function: vsphere:getTagCategory\n      arguments:\n        name: example-category\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTagCategory.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the tag category.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTagCategory.\n",
                "properties": {
                    "associableTypes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "cardinality": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "associableTypes",
                    "cardinality",
                    "description",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getVappContainer:getVappContainer": {
            "description": "The `vsphere.VappContainer` data source can be used to discover the ID of a\nvApp container in vSphere. This is useful to return the ID of a vApp container\nthat you want to use to create virtual machines in using the\n`vsphere.VirtualMachine` resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst pool = datacenter.then(datacenter =\u003e vsphere.getVappContainer({\n    name: \"vapp-container-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\npool = vsphere.get_vapp_container(name=\"vapp-container-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var pool = VSphere.GetVappContainer.Invoke(new()\n    {\n        Name = \"vapp-container-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVappContainer(ctx, \u0026vsphere.LookupVappContainerArgs{\n\t\t\tName:         \"vapp-container-01\",\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetVappContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var pool = VsphereFunctions.getVappContainer(GetVappContainerArgs.builder()\n            .name(\"vapp-container-01\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  pool:\n    fn::invoke:\n      function: vsphere:getVappContainer\n      arguments:\n        name: vapp-container-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter in which the vApp container is located.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container. This can be a name or\npath.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "datacenterId",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getVirtualMachine:getVirtualMachine": {
            "description": "The `vsphere.VirtualMachine` data source can be used to find the UUID of an\nexisting virtual machine or template. The most common purpose is for finding\nthe UUID of a template to be used as the source for cloning to a new\n`vsphere.VirtualMachine` resource. It also\nreads the guest ID so that can be supplied as well.\n\n## Example Usage\n\nIn the following example, a virtual machine template is returned by its unique\nname within the `vsphere.Datacenter`.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst template = datacenter.then(datacenter =\u003e vsphere.getVirtualMachine({\n    name: \"ubuntu-server-template\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ntemplate = vsphere.get_virtual_machine(name=\"ubuntu-server-template\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var template = VSphere.GetVirtualMachine.Invoke(new()\n    {\n        Name = \"ubuntu-server-template\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026vsphere.LookupVirtualMachineArgs{\n\t\t\tName:         pulumi.StringRef(\"ubuntu-server-template\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetVirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var template = VsphereFunctions.getVirtualMachine(GetVirtualMachineArgs.builder()\n            .name(\"ubuntu-server-template\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  template:\n    fn::invoke:\n      function: vsphere:getVirtualMachine\n      arguments:\n        name: ubuntu-server-template\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nIn the following example, each virtual machine template is returned by its\nunique full path within the `vsphere.Datacenter`.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst productionTemplate = datacenter.then(datacenter =\u003e vsphere.getVirtualMachine({\n    name: \"production/templates/ubuntu-server-template\",\n    datacenterId: datacenter.id,\n}));\nconst developmentTemplate = datacenter.then(datacenter =\u003e vsphere.getVirtualMachine({\n    name: \"development/templates/ubuntu-server-template\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nproduction_template = vsphere.get_virtual_machine(name=\"production/templates/ubuntu-server-template\",\n    datacenter_id=datacenter.id)\ndevelopment_template = vsphere.get_virtual_machine(name=\"development/templates/ubuntu-server-template\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var productionTemplate = VSphere.GetVirtualMachine.Invoke(new()\n    {\n        Name = \"production/templates/ubuntu-server-template\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var developmentTemplate = VSphere.GetVirtualMachine.Invoke(new()\n    {\n        Name = \"development/templates/ubuntu-server-template\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026vsphere.LookupVirtualMachineArgs{\n\t\t\tName:         pulumi.StringRef(\"production/templates/ubuntu-server-template\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026vsphere.LookupVirtualMachineArgs{\n\t\t\tName:         pulumi.StringRef(\"development/templates/ubuntu-server-template\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetVirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var productionTemplate = VsphereFunctions.getVirtualMachine(GetVirtualMachineArgs.builder()\n            .name(\"production/templates/ubuntu-server-template\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var developmentTemplate = VsphereFunctions.getVirtualMachine(GetVirtualMachineArgs.builder()\n            .name(\"development/templates/ubuntu-server-template\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  productionTemplate:\n    fn::invoke:\n      function: vsphere:getVirtualMachine\n      arguments:\n        name: production/templates/ubuntu-server-template\n        datacenterId: ${datacenter.id}\n  developmentTemplate:\n    fn::invoke:\n      function: vsphere:getVirtualMachine\n      arguments:\n        name: development/templates/ubuntu-server-template\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVirtualMachine.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The alternate guest name of the virtual machine when\n`guest_id` is a non-specific operating system, like `otherGuest` or\n`otherGuest64`.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "The user-provided description of this virtual machine.\n"
                    },
                    "bootDelay": {
                        "type": "integer"
                    },
                    "bootRetryDelay": {
                        "type": "integer"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "type": "integer"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "cpuReservation": {
                        "type": "integer"
                    },
                    "cpuShareCount": {
                        "type": "integer"
                    },
                    "cpuShareLevel": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the virtual machine is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the `id` attribute from an empty\n`vsphere.Datacenter` data source.\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean"
                    },
                    "enableDiskUuid": {
                        "type": "boolean"
                    },
                    "enableLogging": {
                        "type": "boolean"
                    },
                    "eptRviMode": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "extraConfigRebootRequired": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware type for this virtual machine. Can be `bios` or\n`efi`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The name of the virtual machine folder where the virtual machine is located. The `name` argument is limited to 80 characters. If the `name` argument includes the full path to the virtual machine and exceeds the 80 characters limit, the `folder` folder argument can be used.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID of the virtual machine or template.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version number on this virtual machine.\n"
                    },
                    "hvMode": {
                        "type": "string"
                    },
                    "ideControllerScanCount": {
                        "type": "integer"
                    },
                    "latencySensitivity": {
                        "type": "string"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "type": "integer"
                    },
                    "memoryReservation": {
                        "type": "integer"
                    },
                    "memoryReservationLockedToMax": {
                        "type": "boolean"
                    },
                    "memoryShareCount": {
                        "type": "integer"
                    },
                    "memoryShareLevel": {
                        "type": "string"
                    },
                    "moid": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual machine. This can be a name or\nthe full path relative to the datacenter. This is required if a UUID lookup\nis not performed.\n"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per socket for this virtual\nmachine.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The total number of virtual processor cores assigned to this\nvirtual machine.\n"
                    },
                    "nvmeControllerScanCount": {
                        "type": "integer",
                        "description": "The number of NVMe controllers to\nscan for disk attributes and controller types on. Default: `1`.\n\n\u003e **NOTE:** For best results, ensure that all the disks on any templates you\nuse with this data source reside on the primary controller, and leave this\nvalue at the default. See the `vsphere.VirtualMachine`\nresource documentation for the significance of this setting, specifically the\nadditional requirements and notes for cloning section.\n"
                    },
                    "replaceTrigger": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean"
                    },
                    "sataControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer",
                        "description": "The number of SCSI controllers to\nscan for disk attributes and controller types on. Default: `1`.\n"
                    },
                    "storagePolicyId": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean"
                    },
                    "toolsUpgradePolicy": {
                        "type": "string"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "Specify this field for a UUID lookup, `name` and `datacenter_id`\nare not required if this is specified.\n"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp"
                    },
                    "vbsEnabled": {
                        "type": "boolean"
                    },
                    "vvtdEnabled": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getVirtualMachine.\n",
                "properties": {
                    "alternateGuestName": {
                        "description": "The alternate guest name of the virtual machine when\n`guest_id` is a non-specific operating system, like `otherGuest` or\n`otherGuest64`.\n",
                        "type": "string"
                    },
                    "annotation": {
                        "description": "The user-provided description of this virtual machine.\n",
                        "type": "string"
                    },
                    "bootDelay": {
                        "type": "integer"
                    },
                    "bootRetryDelay": {
                        "type": "integer"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean"
                    },
                    "changeVersion": {
                        "type": "string"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "type": "integer"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "cpuReservation": {
                        "type": "integer"
                    },
                    "cpuShareCount": {
                        "type": "integer"
                    },
                    "cpuShareLevel": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "defaultIpAddress": {
                        "description": "Whenever possible, this is the first IPv4 address that\nis reachable through the default gateway configured on the machine, then the\nfirst reachable IPv6 address, and then the first general discovered address if\nneither exist. If VMware Tools is not running on the virtual machine, or if\nthe VM is powered off, this value will be blank.\n",
                        "type": "string"
                    },
                    "disks": {
                        "description": "Information about each of the disks on this virtual machine or\ntemplate. These are sorted by bus and unit number so that they can be applied\nto a `vsphere.VirtualMachine` resource in the order the resource expects\nwhile cloning. This is useful for discovering certain disk settings while\nperforming a linked clone, as all settings that are output by this data source\nmust be the same on the destination virtual machine as the source. Only the\nfirst number of controllers defined by `scsi_controller_scan_count` are\nscanned for disks. The sub-attributes are:\n",
                        "items": {
                            "$ref": "#/types/vsphere:index/getVirtualMachineDisk:getVirtualMachineDisk"
                        },
                        "type": "array"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean"
                    },
                    "enableDiskUuid": {
                        "type": "boolean"
                    },
                    "enableLogging": {
                        "type": "boolean"
                    },
                    "eptRviMode": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "extraConfigRebootRequired": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "description": "The firmware type for this virtual machine. Can be `bios` or\n`efi`.\n",
                        "type": "string"
                    },
                    "folder": {
                        "type": "string"
                    },
                    "guestId": {
                        "description": "The guest ID of the virtual machine or template.\n",
                        "type": "string"
                    },
                    "guestIpAddresses": {
                        "description": "A list of IP addresses as reported by VMware Tools.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "hardwareVersion": {
                        "description": "The hardware version number on this virtual machine.\n",
                        "type": "integer"
                    },
                    "hvMode": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ideControllerScanCount": {
                        "type": "integer"
                    },
                    "instanceUuid": {
                        "description": "The instance UUID of the virtual machine or template.\n",
                        "type": "string"
                    },
                    "latencySensitivity": {
                        "type": "string"
                    },
                    "memory": {
                        "description": "The size of the virtual machine's memory, in MB.\n",
                        "type": "integer"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "type": "integer"
                    },
                    "memoryReservation": {
                        "type": "integer"
                    },
                    "memoryReservationLockedToMax": {
                        "type": "boolean"
                    },
                    "memoryShareCount": {
                        "type": "integer"
                    },
                    "memoryShareLevel": {
                        "type": "string"
                    },
                    "moid": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean"
                    },
                    "networkInterfaceTypes": {
                        "description": "The network interface types for each network\ninterface found on the virtual machine, in device bus order. Will be one of\n`e1000`, `e1000e`, `pcnet32`, `sriov`, `vmxnet2`, `vmxnet3vrdma`, or\n`vmxnet3`.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "networkInterfaces": {
                        "description": "Information about each of the network interfaces on\nthis virtual machine or template. These are sorted by device bus order so that\nthey can be applied to a `vsphere.VirtualMachine` resource in the order the\nresource expects while cloning. This is useful for discovering certain network\ninterface settings while performing a linked clone, as all settings that are\noutput by this data source must be the same on the destination virtual machine\nas the source. The sub-attributes are:\n",
                        "items": {
                            "$ref": "#/types/vsphere:index/getVirtualMachineNetworkInterface:getVirtualMachineNetworkInterface"
                        },
                        "type": "array"
                    },
                    "numCoresPerSocket": {
                        "description": "The number of cores per socket for this virtual\nmachine.\n",
                        "type": "integer"
                    },
                    "numCpus": {
                        "description": "The total number of virtual processor cores assigned to this\nvirtual machine.\n",
                        "type": "integer"
                    },
                    "nvmeControllerScanCount": {
                        "type": "integer"
                    },
                    "replaceTrigger": {
                        "type": "string"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean"
                    },
                    "sataControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiBusSharing": {
                        "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Only the first number of\ncontrollers defined by `scsi_controller_scan_count` are scanned.\n",
                        "type": "string"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "description": "The common type of all SCSI controllers on this virtual machine.\nWill be one of `lsilogic` (LSI Logic Parallel), `lsilogic-sas` (LSI Logic\nSAS), `pvscsi` (VMware Paravirtual), `buslogic` (BusLogic), or `mixed` when\nthere are multiple controller types. Only the first number of controllers\ndefined by `scsi_controller_scan_count` are scanned.\n",
                        "type": "string"
                    },
                    "storagePolicyId": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean"
                    },
                    "toolsUpgradePolicy": {
                        "type": "string"
                    },
                    "uuid": {
                        "type": "string"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp"
                    },
                    "vappTransports": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "vbsEnabled": {
                        "type": "boolean"
                    },
                    "vtpm": {
                        "description": "Indicates whether a virtual Trusted Platform Module (TPM) device is present on the virtual machine.\n",
                        "type": "boolean"
                    },
                    "vvtdEnabled": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "annotation",
                    "changeVersion",
                    "cpuShareCount",
                    "defaultIpAddress",
                    "disks",
                    "eptRviMode",
                    "guestId",
                    "guestIpAddresses",
                    "hardwareVersion",
                    "hvMode",
                    "instanceUuid",
                    "memoryShareCount",
                    "moid",
                    "networkInterfaceTypes",
                    "networkInterfaces",
                    "scsiBusSharing",
                    "scsiType",
                    "storagePolicyId",
                    "uuid",
                    "vappTransports",
                    "vtpm",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getVmfsDisks:getVmfsDisks": {
            "description": "The `vsphere.getVmfsDisks` data source can be used to discover the storage\ndevices available on an ESXi host. This data source can be combined with the\n`vsphere.VmfsDatastore` resource to create VMFS\ndatastores based off a set of discovered disks.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst vmfsDisks = host.then(host =\u003e vsphere.getVmfsDisks({\n    hostSystemId: host.id,\n    rescan: true,\n    filter: \"mpx.vmhba1:C0:T[12]:L0\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nvmfs_disks = vsphere.get_vmfs_disks(host_system_id=host.id,\n    rescan=True,\n    filter=\"mpx.vmhba1:C0:T[12]:L0\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vmfsDisks = VSphere.GetVmfsDisks.Invoke(new()\n    {\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        Rescan = true,\n        Filter = \"mpx.vmhba1:C0:T[12]:L0\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetVmfsDisks(ctx, \u0026vsphere.GetVmfsDisksArgs{\n\t\t\tHostSystemId: host.Id,\n\t\t\tRescan:       pulumi.BoolRef(true),\n\t\t\tFilter:       pulumi.StringRef(\"mpx.vmhba1:C0:T[12]:L0\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetVmfsDisksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.id())\n            .build());\n\n        final var vmfsDisks = VsphereFunctions.getVmfsDisks(GetVmfsDisksArgs.builder()\n            .hostSystemId(host.id())\n            .rescan(true)\n            .filter(\"mpx.vmhba1:C0:T[12]:L0\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      function: vsphere:getDatacenter\n      arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      function: vsphere:getHost\n      arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  vmfsDisks:\n    fn::invoke:\n      function: vsphere:getVmfsDisks\n      arguments:\n        hostSystemId: ${host.id}\n        rescan: true\n        filter: mpx.vmhba1:C0:T[12]:L0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVmfsDisks.\n",
                "properties": {
                    "filter": {
                        "type": "string",
                        "description": "A regular expression to filter the disks against. Only\ndisks with canonical names that match will be included.\n\n\u003e **NOTE:** Using a `filter` is recommended if there is any chance the host\nwill have any specific storage devices added to it that may affect the order of\nthe output `disks` attribute below, which is lexicographically sorted.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to look for disks on.\n"
                    },
                    "rescan": {
                        "type": "boolean",
                        "description": "Whether or not to rescan storage adapters before\nsearching for disks. This may lengthen the time it takes to perform the\nsearch. Default: `false`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostSystemId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVmfsDisks.\n",
                "properties": {
                    "disks": {
                        "description": "A lexicographically sorted list of devices discovered by the\noperation, matching the supplied `filter`, if provided.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "hostSystemId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "rescan": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "disks",
                    "hostSystemId",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}