{
    "name": "vsphere",
    "description": "A Pulumi package for creating vsphere resources",
    "keywords": [
        "pulumi",
        "vsphere"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vsphere` Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere).",
    "repository": "https://github.com/pulumi/pulumi-vsphere",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "defaults": [
            "password",
            "user"
        ]
    },
    "types": {
        "vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup": {
            "properties": {
                "cache": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:index/ContentLibraryPublication:ContentLibraryPublication": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "Method to log into remote Content Library. Must be `NONE` or `BASIC`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to log in with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publishUrl": {
                    "type": "string",
                    "description": "URL to remotely access the published Content Library.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "published": {
                    "type": "boolean",
                    "description": "Bool determining if Content Library is published.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "User name to log in with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "password",
                        "publishUrl",
                        "username"
                    ]
                }
            }
        },
        "vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "Method to log into remote Content Library. Must be `NONE` or `BASIC`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "automaticSync": {
                    "type": "boolean",
                    "description": "Enable automatic synchronization with the external content library.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "onDemand": {
                    "type": "boolean",
                    "description": "Download all library content immediately.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "password": {
                    "type": "string",
                    "description": "Password to log in with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "subscriptionUrl": {
                    "type": "string",
                    "description": "URL of remote Content Library.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "User name to log in with.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "password",
                        "username"
                    ]
                }
            }
        },
        "vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minVlan": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost": {
            "properties": {
                "devices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of NIC devices to map to uplinks on the DVS,\nadded in order they are specified.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The host system ID of the host to add to the\nDVS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "devices",
                "hostSystemId"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping": {
            "properties": {
                "primaryVlanId": {
                    "type": "integer",
                    "description": "The primary VLAN ID. The VLAN IDs of 0 and\n4095 are reserved and cannot be used in this property.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pvlanType": {
                    "type": "string",
                    "description": "The private VLAN type. Valid values are\npromiscuous, community and isolated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID. The VLAN IDs of 0\nand 4095 are reserved and cannot be used in this property.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "primaryVlanId",
                "pvlanType",
                "secondaryVlanId"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minVlan": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission": {
            "properties": {
                "isGroup": {
                    "type": "boolean",
                    "description": "Whether user_or_group field refers to a user or a group. True for a group and false for a user.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "propagate": {
                    "type": "boolean",
                    "description": "Whether or not this permission propagates down the hierarchy to sub-entities.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleId": {
                    "type": "string",
                    "description": "The role id of the role to be given to the user on the specified entity.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userOrGroup": {
                    "type": "string",
                    "description": "The user/group getting the permission.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "isGroup",
                "propagate",
                "roleId",
                "userOrGroup"
            ]
        },
        "vsphere:index/HostPortGroupPort:HostPortGroupPort": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "macAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "macAddresses",
                        "type"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom": {
            "properties": {
                "clientDevice": {
                    "type": "boolean",
                    "description": "Indicates whether the device should be backed by\nremote client device. Conflicts with `datastore_id` and `path`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "An address internal to this provider that helps locate the\ndevice when `key` is unavailable. This follows a convention of\n`CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device\nunit 1 on SCSI bus 0.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the ISO file. Required for using a datastore\nISO. Conflicts with `client_device`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceAddress",
                        "key"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineClone:VirtualMachineClone": {
            "properties": {
                "customize": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "linkedClone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ovfStorageMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "templateUuid": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "templateUuid"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize": {
            "properties": {
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dnsSuffixLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv4Gateway": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6Gateway": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "linuxOptions": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this\nvirtual machine. See network interface options\nbelow.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "windowsOptions": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "windowsSysprepText": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions": {
            "properties": {
                "domain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hwClockUtc": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeZone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "domain",
                "hostName"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface": {
            "properties": {
                "dnsDomain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv4Address": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv4Netmask": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6Address": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6Netmask": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoLogon": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoLogonCount": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computerName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "domainAdminPassword": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "domainAdminUser": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fullName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "joinDomain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizationName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "runOnceCommandLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeZone": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "workgroup": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "computerName"
            ]
        },
        "vsphere:index/VirtualMachineDisk:VirtualMachineDisk": {
            "properties": {
                "attach": {
                    "type": "boolean",
                    "description": "Attach an external disk instead of creating a new one.\nImplies and conflicts with `keep_on_remove`. If set, you cannot set `size`,\n`eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "controllerType": {
                    "type": "string",
                    "description": "The type of storage controller to attach the\ndisk to. Can be `scsi`, `sata`, or `ide`. You must have the appropriate\nnumber of controllers enabled for the selected type. Default `scsi`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "An address internal to this provider that helps locate the\ndevice when `key` is unavailable. This follows a convention of\n`CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device\nunit 1 on SCSI bus 0.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskMode": {
                    "type": "string",
                    "description": "The mode of this this virtual disk for purposes of\nwrites and snapshotting. Can be one of `append`, `independent_nonpersistent`,\n`independent_persistent`, `nonpersistent`, `persistent`, or `undoable`.\nDefault: `persistent`. For an explanation of options, click\n[here][vmware-docs-disk-mode].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskSharing": {
                    "type": "string",
                    "description": "The sharing mode of this virtual disk. Can be one\nof `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "If set to `true`, the disk space is zeroed out\non VM creation. This will delay the creation of the disk or virtual machine.\nCannot be set to `true` when `thin_provisioned` is `true`.  See the section\non picking a disk type.  Default: `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ioLimit": {
                    "type": "integer",
                    "description": "The upper limit of IOPS that this disk can use. The\ndefault is no limit.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ioReservation": {
                    "type": "integer",
                    "description": "The I/O reservation (guarantee) that this disk\nhas, in IOPS.  The default is no reservation.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ioShareCount": {
                    "type": "integer",
                    "description": "The share count for this disk when the share\nlevel is `custom`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ioShareLevel": {
                    "type": "string",
                    "description": "The share allocation level for this disk. Can\nbe one of `low`, `normal`, `high`, or `custom`. Default: `normal`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keepOnRemove": {
                    "type": "boolean",
                    "description": "Keep this disk when removing the device or\ndestroying the virtual machine. Default: `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "label": {
                    "type": "string",
                    "description": "A label for the disk. Forces a new disk if changed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the ISO file. Required for using a datastore\nISO. Conflicts with `client_device`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GB.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The UUID of the storage policy to assign to this disk.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "If `true`, this disk is thin provisioned,\nwith space for the file being allocated on an as-needed basis. Cannot be set\nto `true` when `eagerly_scrub` is `true`. See the section on picking a disk\ntype. Default: `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The disk number on the storage bus. The maximum\nvalue for this setting is the value of the controller count times the\ncontroller capacity (15 for SCSI, 30 for SATA, and 2 for IDE).\nThe default is `0`, for which one disk must be set to. Duplicate unit numbers\nare not allowed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual disk's VMDK file. This is used to track the\nvirtual disk on the virtual machine.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "writeThrough": {
                    "type": "boolean",
                    "description": "If `true`, writes for this disk are sent\ndirectly to the filesystem immediately instead of being buffered. Default:\n`false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "label"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "datastoreId",
                        "deviceAddress",
                        "key",
                        "label",
                        "path",
                        "storagePolicyId",
                        "uuid"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The network interface type. Can be one of\n`e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthLimit": {
                    "type": "integer",
                    "description": "The upper bandwidth limit of this network\ninterface, in Mbits/sec. The default is no limit.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthReservation": {
                    "type": "integer",
                    "description": "The bandwidth reservation of this\nnetwork interface, in Mbits/sec. The default is no reservation.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthShareCount": {
                    "type": "integer",
                    "description": "The share count for this network\ninterface when the share level is `custom`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthShareLevel": {
                    "type": "string",
                    "description": "The bandwidth share allocation level for\nthis interface. Can be one of `low`, `normal`, `high`, or `custom`. Default:\n`normal`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "An address internal to this provider that helps locate the\ndevice when `key` is unavailable. This follows a convention of\n`CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device\nunit 1 on SCSI bus 0.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of this network interface. Can\nonly be manually set if `use_static_mac` is true, otherwise this is a\ncomputed value that gives the current MAC address of this interface.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "networkId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the network to connect this interface to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ovfMapping": {
                    "type": "string",
                    "description": "Specifies which OVF NIC the `network_interface`\nshould be associated with. Only applies at creation and only when deploying\nfrom an OVF source.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useStaticMac": {
                    "type": "boolean",
                    "description": "If true, the `mac_address` field is treated as\na static MAC address and set accordingly. Setting this to `true` requires\n`mac_address` to be set. Default: `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "networkId"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bandwidthShareCount",
                        "deviceAddress",
                        "key",
                        "macAddress",
                        "networkId"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy": {
            "properties": {
                "allowUnverifiedSslCert": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deploymentOption": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskProvisioning": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enableHiddenProperties": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipAllocationPolicy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipProtocol": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "localOvfPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "remoteOvfUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineVapp:VirtualMachineVapp": {
            "properties": {
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule": {
            "properties": {
                "includeDatastoresWithTags": {
                    "type": "boolean",
                    "description": "Whether to include datastores with the given tags or exclude. Default \nvalue is true i.e. include datastores with the given tags.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tagCategory": {
                    "type": "string",
                    "description": "Name of the tag category.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Name of tags to select from the given category.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "tagCategory",
                "tags"
            ]
        },
        "vsphere:index/VnicIpv4:VnicIpv4": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP or autoconfig is not set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ip": {
                    "type": "string",
                    "description": "Address of the interface, if DHCP is not set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "netmask": {
                    "type": "string",
                    "description": "Netmask of the interface, if DHCP is not set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:index/VnicIpv6:VnicIpv6": {
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IPv6 addresses\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoconfig": {
                    "type": "boolean",
                    "description": "Use IPv6 Autoconfiguration (RFC2462).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP or autoconfig is not set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:index/getVirtualMachineDisk:getVirtualMachineDisk": {
            "properties": {
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been eager zeroed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "label": {
                    "type": "string",
                    "description": "The label for the disk.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GIB.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been thin provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The disk number on the storage bus.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "eagerlyScrub",
                "label",
                "size",
                "thinProvisioned",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getVirtualMachineNetworkInterface:getVirtualMachineNetworkInterface": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The network interface types for each network interface found \non the virtual machine, in device bus order. Will be one of `e1000`, `e1000e` or\n`vmxnet3`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthLimit": {
                    "type": "integer",
                    "description": "The upper bandwidth limit of this network interface, \nin Mbits/sec.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthReservation": {
                    "type": "integer",
                    "description": "The bandwidth reservation of this network interface, \nin Mbits/sec.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthShareCount": {
                    "type": "integer",
                    "description": "The share count for this network interface when the \nshare level is custom.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthShareLevel": {
                    "type": "string",
                    "description": "The bandwidth share allocation level for this interface. \nCan be one of `low`, `normal`, `high`, or `custom`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of this network interface.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "networkId": {
                    "type": "string",
                    "description": "The managed object reference ID of the network this interface is \nconnected to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "adapterType",
                "bandwidthShareCount",
                "macAddress",
                "networkId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp": {
            "properties": {
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the vsphere package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n"
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n"
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n"
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n"
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n"
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n"
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n"
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n"
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "required": [
            "password",
            "user"
        ],
        "inputProperties": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "requiredInputs": [
            "password",
            "user"
        ]
    },
    "resources": {
        "vsphere:index/computeCluster:ComputeCluster": {
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations in this cluster. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS in this cluster.\nRequires `drs_enabled` to be `true` in order to be effective.\nDefault: `false`.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating the\nthreshold of load within the cluster that influences host power operations.\nThis affects both power on and power off operations - a lower setting will\ntolerate more of a surplus/deficit than a higher setting. Default: `3`.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all\nvirtual machines in this cluster. Can be one of `manual`,\n`partiallyAutomated`, or `fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When `true`, enables DRS to use data\nfrom [vRealize Operations Manager][ref-vsphere-vro] to make proactive DRS\nrecommendations. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "Allow individual DRS overrides to be\nset for virtual machines in the cluster. Default: `true`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster. Default: `false`.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating\nthe threshold of imbalance tolerated between hosts. A lower setting will\ntolerate more imbalance while a higher setting will tolerate less. Default:\n`3`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "When destroying the resource, setting this to\n`true` will auto-remove any hosts that are currently a member of the cluster,\nas if they were removed by taking their entry out of `host_system_ids` (see\nbelow). This is an advanced\noption and should only be used for testing. Default: `false`.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines the\nmanaged object IDs of hosts to use as dedicated failover\nhosts. These hosts are kept as available as possible - admission control will\nblock access to the host, and DRS will ignore the host when making\nrecommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number\nof failed hosts that admission control tolerates when making decisions on\nwhether to permit virtual machine operations. The maximum is one less than\nthe number of hosts in the cluster. Default: `1`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of\nresource reduction that a cluster of virtual machines can tolerate in case of\na failover. A value of 0 produces warnings only, whereas a value of 100\ndisables the setting. Default: `100` (disabled).\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control\npolicy to use with vSphere HA. Can be one of `resourcePercentage`,\n`slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "Automatically determine available resource percentages by subtracting the\naverage number of host resources represented by the\n`ha_admission_control_host_failure_tolerance`\nsetting from the total amount of resources in the cluster. Disable to supply\nuser-defined values. Default: `true`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of CPU resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of memory resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined CPU slot size, in MHz. Default: `32`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined memory slot size, in MB. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "Controls\nwhether or not you wish to supply explicit values to CPU and memory slot\nsizes. The default is `false`, which tells vSphere to gather a automatic\naverage based on all powered-on virtual machines currently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non virtual machines if an APD status on an affected datastore clears in the\nmiddle of an APD event. Can be one of `none` or `reset`. Default: `none`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected loss to all paths to a\nrelevant datastore. Can be one of `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Default: `3`\nminutes. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `disabled`, `warning`, or\n`restartAggressive`. Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster. Default:\n`false`.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for\npreferred datastores to use for HA heartbeating. This setting is only useful\nwhen `ha_heartbeat_datastore_policy` is set\nto either `userSelectedDs` or `allFeasibleDsWithUserPreference`.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA\nheartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or\n`allFeasibleDsWithUserPreference`. Default:\n`allFeasibleDsWithUserPreference`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual\nmachines when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:\n`none`.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether\nvSphere HA remediates virtual machines on host failure. Can be one of `enabled`\nor `disabled`. Default: `enabled`.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component\nprotection for virtual machines in this cluster. Can be one of `enabled` or\n`disabled`. Default: `enabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to\ndetermine whether or not virtual machines in a certain restart priority class\nare online, allowing HA to move on to restarting virtual machines on the next\npriority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or\n`appHbStatusGreen`. The default is `none`, which means that a virtual machine\nis considered ready immediately after a host is found to start it on.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from a virtual machine\nis not received within this configured interval, the virtual machine is\nmarked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to a virtual machine when responding to a failure event. Default: `3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on a virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay in seconds\nafter ready condition is met. A VM is considered ready at this point.\nDefault: `0` (no delay). \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority\nfor affected virtual machines when vSphere detects a host failure. Can be one\nof `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds,\nthat vSphere HA will wait for virtual machines in one priority to be ready\nbefore proceeding with the next priority. Default: `600` (10 minutes).\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout for each host maintenance mode\noperation when removing hosts from a cluster. The value is specified in\nseconds. Default: `3600` (1 hour).\n"
                },
                "hostManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `host` resource rather than the\n`compute_cluster` resource. Conflicts with: `host_system_ids`.\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e v1.18.3\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The [managed object IDs][docs-about-morefs] of\nthe hosts to put in the cluster. Conflicts with: `host_managed`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "Determines how the host\nquarantine, maintenance mode, or virtual machine migration recommendations\nmade by proactive HA are to be handled. Can be one of `Automated` or\n`Manual`. Default: `Manual`. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables Proactive HA. Default: `false`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation\nfor moderately degraded hosts. Can be one of `MaintenanceMode` or\n`QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when\n`proactive_ha_severe_remediation` is set\nto `QuarantineMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update\nproviders configured for this cluster.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for\nseverely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.\nNote that this cannot be set to `QuarantineMode` when\n`proactive_ha_moderate_remediation` is\nset to `MaintenanceMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID of the cluster's root resource pool.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "vsanDiskGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                    },
                    "description": "A list of disk UUIDs to add to the vSAN cluster.\n"
                },
                "vsanEnabled": {
                    "type": "boolean",
                    "description": "Whether the VSAN service is enabled for the cluster.\n"
                }
            },
            "required": [
                "datacenterId",
                "name",
                "resourcePoolId",
                "vsanDiskGroups",
                "vsanEnabled"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations in this cluster. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS in this cluster.\nRequires `drs_enabled` to be `true` in order to be effective.\nDefault: `false`.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating the\nthreshold of load within the cluster that influences host power operations.\nThis affects both power on and power off operations - a lower setting will\ntolerate more of a surplus/deficit than a higher setting. Default: `3`.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all\nvirtual machines in this cluster. Can be one of `manual`,\n`partiallyAutomated`, or `fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When `true`, enables DRS to use data\nfrom [vRealize Operations Manager][ref-vsphere-vro] to make proactive DRS\nrecommendations. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "Allow individual DRS overrides to be\nset for virtual machines in the cluster. Default: `true`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster. Default: `false`.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating\nthe threshold of imbalance tolerated between hosts. A lower setting will\ntolerate more imbalance while a higher setting will tolerate less. Default:\n`3`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "When destroying the resource, setting this to\n`true` will auto-remove any hosts that are currently a member of the cluster,\nas if they were removed by taking their entry out of `host_system_ids` (see\nbelow). This is an advanced\noption and should only be used for testing. Default: `false`.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines the\nmanaged object IDs of hosts to use as dedicated failover\nhosts. These hosts are kept as available as possible - admission control will\nblock access to the host, and DRS will ignore the host when making\nrecommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number\nof failed hosts that admission control tolerates when making decisions on\nwhether to permit virtual machine operations. The maximum is one less than\nthe number of hosts in the cluster. Default: `1`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of\nresource reduction that a cluster of virtual machines can tolerate in case of\na failover. A value of 0 produces warnings only, whereas a value of 100\ndisables the setting. Default: `100` (disabled).\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control\npolicy to use with vSphere HA. Can be one of `resourcePercentage`,\n`slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "Automatically determine available resource percentages by subtracting the\naverage number of host resources represented by the\n`ha_admission_control_host_failure_tolerance`\nsetting from the total amount of resources in the cluster. Disable to supply\nuser-defined values. Default: `true`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of CPU resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of memory resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined CPU slot size, in MHz. Default: `32`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined memory slot size, in MB. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "Controls\nwhether or not you wish to supply explicit values to CPU and memory slot\nsizes. The default is `false`, which tells vSphere to gather a automatic\naverage based on all powered-on virtual machines currently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non virtual machines if an APD status on an affected datastore clears in the\nmiddle of an APD event. Can be one of `none` or `reset`. Default: `none`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected loss to all paths to a\nrelevant datastore. Can be one of `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Default: `3`\nminutes. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `disabled`, `warning`, or\n`restartAggressive`. Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster. Default:\n`false`.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for\npreferred datastores to use for HA heartbeating. This setting is only useful\nwhen `ha_heartbeat_datastore_policy` is set\nto either `userSelectedDs` or `allFeasibleDsWithUserPreference`.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA\nheartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or\n`allFeasibleDsWithUserPreference`. Default:\n`allFeasibleDsWithUserPreference`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual\nmachines when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:\n`none`.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether\nvSphere HA remediates virtual machines on host failure. Can be one of `enabled`\nor `disabled`. Default: `enabled`.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component\nprotection for virtual machines in this cluster. Can be one of `enabled` or\n`disabled`. Default: `enabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to\ndetermine whether or not virtual machines in a certain restart priority class\nare online, allowing HA to move on to restarting virtual machines on the next\npriority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or\n`appHbStatusGreen`. The default is `none`, which means that a virtual machine\nis considered ready immediately after a host is found to start it on.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from a virtual machine\nis not received within this configured interval, the virtual machine is\nmarked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to a virtual machine when responding to a failure event. Default: `3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on a virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay in seconds\nafter ready condition is met. A VM is considered ready at this point.\nDefault: `0` (no delay). \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority\nfor affected virtual machines when vSphere detects a host failure. Can be one\nof `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds,\nthat vSphere HA will wait for virtual machines in one priority to be ready\nbefore proceeding with the next priority. Default: `600` (10 minutes).\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout for each host maintenance mode\noperation when removing hosts from a cluster. The value is specified in\nseconds. Default: `3600` (1 hour).\n"
                },
                "hostManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `host` resource rather than the\n`compute_cluster` resource. Conflicts with: `host_system_ids`.\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e v1.18.3\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The [managed object IDs][docs-about-morefs] of\nthe hosts to put in the cluster. Conflicts with: `host_managed`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "Determines how the host\nquarantine, maintenance mode, or virtual machine migration recommendations\nmade by proactive HA are to be handled. Can be one of `Automated` or\n`Manual`. Default: `Manual`. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables Proactive HA. Default: `false`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation\nfor moderately degraded hosts. Can be one of `MaintenanceMode` or\n`QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when\n`proactive_ha_severe_remediation` is set\nto `QuarantineMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update\nproviders configured for this cluster.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for\nseverely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.\nNote that this cannot be set to `QuarantineMode` when\n`proactive_ha_moderate_remediation` is\nset to `MaintenanceMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "vsanDiskGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                    },
                    "description": "A list of disk UUIDs to add to the vSAN cluster.\n"
                },
                "vsanEnabled": {
                    "type": "boolean",
                    "description": "Whether the VSAN service is enabled for the cluster.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n"
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power\noperations in this cluster. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for DRS in this cluster.\nRequires `drs_enabled` to be `true` in order to be effective.\nDefault: `false`.\n"
                    },
                    "dpmThreshold": {
                        "type": "integer",
                        "description": "A value between `1` and `5` indicating the\nthreshold of load within the cluster that influences host power operations.\nThis affects both power on and power off operations - a lower setting will\ntolerate more of a surplus/deficit than a higher setting. Default: `3`.\n"
                    },
                    "drsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key/value map that specifies advanced\noptions for DRS and DPM.\n"
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "The default automation level for all\nvirtual machines in this cluster. Can be one of `manual`,\n`partiallyAutomated`, or `fullyAutomated`. Default: `manual`.\n"
                    },
                    "drsEnablePredictiveDrs": {
                        "type": "boolean",
                        "description": "When `true`, enables DRS to use data\nfrom [vRealize Operations Manager][ref-vsphere-vro] to make proactive DRS\nrecommendations. \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "drsEnableVmOverrides": {
                        "type": "boolean",
                        "description": "Allow individual DRS overrides to be\nset for virtual machines in the cluster. Default: `true`.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Enable DRS for this cluster. Default: `false`.\n"
                    },
                    "drsMigrationThreshold": {
                        "type": "integer",
                        "description": "A value between `1` and `5` indicating\nthe threshold of imbalance tolerated between hosts. A lower setting will\ntolerate more imbalance while a higher setting will tolerate less. Default:\n`3`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                    },
                    "forceEvacuateOnDestroy": {
                        "type": "boolean",
                        "description": "When destroying the resource, setting this to\n`true` will auto-remove any hosts that are currently a member of the cluster,\nas if they were removed by taking their entry out of `host_system_ids` (see\nbelow). This is an advanced\noption and should only be used for testing. Default: `false`.\n"
                    },
                    "haAdmissionControlFailoverHostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines the\nmanaged object IDs of hosts to use as dedicated failover\nhosts. These hosts are kept as available as possible - admission control will\nblock access to the host, and DRS will ignore the host when making\nrecommendations.\n"
                    },
                    "haAdmissionControlHostFailureTolerance": {
                        "type": "integer",
                        "description": "The maximum number\nof failed hosts that admission control tolerates when making decisions on\nwhether to permit virtual machine operations. The maximum is one less than\nthe number of hosts in the cluster. Default: `1`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haAdmissionControlPerformanceTolerance": {
                        "type": "integer",
                        "description": "The percentage of\nresource reduction that a cluster of virtual machines can tolerate in case of\na failover. A value of 0 produces warnings only, whereas a value of 100\ndisables the setting. Default: `100` (disabled).\n"
                    },
                    "haAdmissionControlPolicy": {
                        "type": "string",
                        "description": "The type of admission control\npolicy to use with vSphere HA. Can be one of `resourcePercentage`,\n`slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.\n"
                    },
                    "haAdmissionControlResourcePercentageAutoCompute": {
                        "type": "boolean",
                        "description": "Automatically determine available resource percentages by subtracting the\naverage number of host resources represented by the\n`ha_admission_control_host_failure_tolerance`\nsetting from the total amount of resources in the cluster. Disable to supply\nuser-defined values. Default: `true`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haAdmissionControlResourcePercentageCpu": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined percentage of CPU resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                    },
                    "haAdmissionControlResourcePercentageMemory": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined percentage of memory resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitCpu": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined CPU slot size, in MHz. Default: `32`.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitMemory": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined memory slot size, in MB. Default: `100`.\n"
                    },
                    "haAdmissionControlSlotPolicyUseExplicitSize": {
                        "type": "boolean",
                        "description": "Controls\nwhether or not you wish to supply explicit values to CPU and memory slot\nsizes. The default is `false`, which tells vSphere to gather a automatic\naverage based on all powered-on virtual machines currently in the cluster.\n"
                    },
                    "haAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key/value map that specifies advanced\noptions for vSphere HA.\n"
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "Controls the action to take\non virtual machines if an APD status on an affected datastore clears in the\nmiddle of an APD event. Can be one of `none` or `reset`. Default: `none`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "Controls the action to take on\nvirtual machines when the cluster has detected loss to all paths to a\nrelevant datastore. Can be one of `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Default: `3`\nminutes. \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "Controls the action to take on\nvirtual machines when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `disabled`, `warning`, or\n`restartAggressive`. Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haEnabled": {
                        "type": "boolean",
                        "description": "Enable vSphere HA for this cluster. Default:\n`false`.\n"
                    },
                    "haHeartbeatDatastoreIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of managed object IDs for\npreferred datastores to use for HA heartbeating. This setting is only useful\nwhen `ha_heartbeat_datastore_policy` is set\nto either `userSelectedDs` or `allFeasibleDsWithUserPreference`.\n"
                    },
                    "haHeartbeatDatastorePolicy": {
                        "type": "string",
                        "description": "The selection policy for HA\nheartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or\n`allFeasibleDsWithUserPreference`. Default:\n`allFeasibleDsWithUserPreference`.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on virtual\nmachines when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:\n`none`.\n"
                    },
                    "haHostMonitoring": {
                        "type": "string",
                        "description": "Global setting that controls whether\nvSphere HA remediates virtual machines on host failure. Can be one of `enabled`\nor `disabled`. Default: `enabled`.\n"
                    },
                    "haVmComponentProtection": {
                        "type": "string",
                        "description": "Controls vSphere VM component\nprotection for virtual machines in this cluster. Can be one of `enabled` or\n`disabled`. Default: `enabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haVmDependencyRestartCondition": {
                        "type": "string",
                        "description": "The condition used to\ndetermine whether or not virtual machines in a certain restart priority class\nare online, allowing HA to move on to restarting virtual machines on the next\npriority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or\n`appHbStatusGreen`. The default is `none`, which means that a virtual machine\nis considered ready immediately after a host is found to start it on.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "If a heartbeat from a virtual machine\nis not received within this configured interval, the virtual machine is\nmarked as failed. The value is in seconds. Default: `30`.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will\nperform to a virtual machine when responding to a failure event. Default: `3`\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after\npowering on a virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                    },
                    "haVmRestartAdditionalDelay": {
                        "type": "integer",
                        "description": "Additional delay in seconds\nafter ready condition is met. A VM is considered ready at this point.\nDefault: `0` (no delay). \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The default restart priority\nfor affected virtual machines when vSphere detects a host failure. Can be one\nof `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds,\nthat vSphere HA will wait for virtual machines in one priority to be ready\nbefore proceeding with the next priority. Default: `600` (10 minutes).\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "hostClusterExitTimeout": {
                        "type": "integer",
                        "description": "The timeout for each host maintenance mode\noperation when removing hosts from a cluster. The value is specified in\nseconds. Default: `3600` (1 hour).\n"
                    },
                    "hostManaged": {
                        "type": "boolean",
                        "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `host` resource rather than the\n`compute_cluster` resource. Conflicts with: `host_system_ids`.\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e v1.18.3\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The [managed object IDs][docs-about-morefs] of\nthe hosts to put in the cluster. Conflicts with: `host_managed`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the cluster.\n"
                    },
                    "proactiveHaAutomationLevel": {
                        "type": "string",
                        "description": "Determines how the host\nquarantine, maintenance mode, or virtual machine migration recommendations\nmade by proactive HA are to be handled. Can be one of `Automated` or\n`Manual`. Default: `Manual`. \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaEnabled": {
                        "type": "boolean",
                        "description": "Enables Proactive HA. Default: `false`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaModerateRemediation": {
                        "type": "string",
                        "description": "The configured remediation\nfor moderately degraded hosts. Can be one of `MaintenanceMode` or\n`QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when\n`proactive_ha_severe_remediation` is set\nto `QuarantineMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaProviderIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of IDs for health update\nproviders configured for this cluster.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaSevereRemediation": {
                        "type": "string",
                        "description": "The configured remediation for\nseverely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.\nNote that this cannot be set to `QuarantineMode` when\n`proactive_ha_moderate_remediation` is\nset to `MaintenanceMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID of the cluster's root resource pool.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "vsanDiskGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                        },
                        "description": "A list of disk UUIDs to add to the vSAN cluster.\n"
                    },
                    "vsanEnabled": {
                        "type": "boolean",
                        "description": "Whether the VSAN service is enabled for the cluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterHostGroup:ComputeClusterHostGroup": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterHostGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to put in the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAffinityRule:ComputeClusterVmAffinityRule": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAntiAffinityRule:ComputeClusterVmAntiAffinityRule": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmDependencyRule:ComputeClusterVmDependencyRule": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "required": [
                "computeClusterId",
                "dependencyVmGroupName",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "dependencyVmGroupName",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmDependencyRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "dependencyVmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmGroup:ComputeClusterVmGroup": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines in this\ngroup.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmHostRule:ComputeClusterVmHostRule": {
            "properties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmHostRule resources.\n",
                "properties": {
                    "affinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                    },
                    "antiAffinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                    },
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the virtual machine group to use\nwith this rule.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibrary:ContentLibrary": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description of the Content Library.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Content Library.\n"
                },
                "publication": {
                    "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                    "description": "Options to publish a local Content Library.\n"
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID on which to store Content Library\nitems.\n"
                },
                "subscription": {
                    "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                    "description": "Options to publish a local Content Library.\n"
                }
            },
            "required": [
                "name",
                "publication",
                "storageBackings"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description of the Content Library.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Content Library.\n"
                },
                "publication": {
                    "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                    "description": "Options to publish a local Content Library.\n"
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID on which to store Content Library\nitems.\n"
                },
                "subscription": {
                    "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                    "description": "Options to publish a local Content Library.\n"
                }
            },
            "requiredInputs": [
                "storageBackings"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibrary resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description of the Content Library.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Content Library.\n"
                    },
                    "publication": {
                        "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                        "description": "Options to publish a local Content Library.\n"
                    },
                    "storageBackings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object reference ID on which to store Content Library\nitems.\n"
                    },
                    "subscription": {
                        "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                        "description": "Options to publish a local Content Library.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibraryItem:ContentLibraryItem": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description for the item.\n"
                },
                "fileUrl": {
                    "type": "string",
                    "description": "File to import into the Content Library item. OVFs and\nOVAs will be parsed and associated files will also be imported.\n"
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the Content Library the item should be created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the Content Library.\n"
                },
                "sourceUuid": {
                    "type": "string",
                    "description": "Virtual machine UUID to clone to Content Library.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\n"
                }
            },
            "required": [
                "libraryId",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description for the item.\n"
                },
                "fileUrl": {
                    "type": "string",
                    "description": "File to import into the Content Library item. OVFs and\nOVAs will be parsed and associated files will also be imported.\n"
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the Content Library the item should be created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the Content Library.\n"
                },
                "sourceUuid": {
                    "type": "string",
                    "description": "Virtual machine UUID to clone to Content Library.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\n"
                }
            },
            "requiredInputs": [
                "libraryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibraryItem resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description for the item.\n"
                    },
                    "fileUrl": {
                        "type": "string",
                        "description": "File to import into the Content Library item. OVFs and\nOVAs will be parsed and associated files will also be imported.\n"
                    },
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the Content Library the item should be created in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the item to be created in the Content Library.\n"
                    },
                    "sourceUuid": {
                        "type": "string",
                        "description": "Virtual machine UUID to clone to Content Library.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of content library item.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/customAttribute:CustomAttribute": {
            "properties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, click here. Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, click here. Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomAttribute resources.\n",
                "properties": {
                    "managedObjectType": {
                        "type": "string",
                        "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, click here. Forces a new\nresource if changed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datacenter:Datacenter": {
            "description": "Provides a VMware vSphere datacenter resource. This can be used as the primary\ncontainer of inventory objects such as hosts and virtual machines.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Create datacenter on the root folder\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodDatacenter = new vsphere.Datacenter(\"prod_datacenter\", {});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_datacenter = vsphere.Datacenter(\"prodDatacenter\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var prodDatacenter = new VSphere.Datacenter(\"prodDatacenter\", new VSphere.DatacenterArgs\n        {\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDatacenter(ctx, \"prodDatacenter\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Create datacenter on a subfolder\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst researchDatacenter = new vsphere.Datacenter(\"research_datacenter\", {\n    folder: \"/research/\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nresearch_datacenter = vsphere.Datacenter(\"researchDatacenter\", folder=\"/research/\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var researchDatacenter = new VSphere.Datacenter(\"researchDatacenter\", new VSphere.DatacenterArgs\n        {\n            Folder = \"/research/\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDatacenter(ctx, \"researchDatacenter\", \u0026vsphere.DatacenterArgs{\n\t\t\tFolder: pulumi.String(\"/research/\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value \nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "Managed object ID of this datacenter.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "moid",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value \nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Datacenter resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to value \nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n"
                    },
                    "moid": {
                        "type": "string",
                        "description": "Managed object ID of this datacenter.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreCluster:DatastoreCluster": {
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map of advanced Storage DRS\nsettings that are not exposed via the provider or the vSphere client.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The global automation level for all\nvirtual machines in this datastore cluster. Default: `manual`.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When `true`, all disks in a\nsingle virtual machine will be kept on the same datastore. Default: `true`.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The free space threshold to use.\nWhen set to `utilization`, `drs_space_utilization_threshold` is used, and\nwhen set to `freeSpace`, `drs_free_space_threshold` is used. Default:\n`utilization`.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of difference between space utilization in datastores before storage\nDRS makes decisions to balance the space. Default: `5` percent.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in\nmilliseconds, that storage DRS uses to make recommendations to move disks\nfrom this datastore. Default: `15` seconds.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for\nthis datastore cluster. Default: `true`.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load\nin datastores in the cluster before storage DRS makes recommendations to\nbalance the load. Default: `5` percent.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable\nIOPS of all virtual machines on the datastore before storage DRS makes\nrecommendations to move VMs off of a datastore. Note that this setting should\nonly be set if `sdrs_io_reservable_percent_threshold` cannot make an accurate\nestimate of the capacity of the datastores in your cluster, and should be set\nto roughly 50-60% of the worst case peak performance of the backing LUNs.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of actual estimated performance of the datastore (in IOPS) that\nstorage DRS uses to make recommendations to move VMs off of a datastore when\nthe total reservable IOPS exceeds the threshold. Default: `60` percent.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS\nthreshold setting to use, `sdrs_io_reservable_percent_threshold` in the event\nof `automatic`, or `sdrs_io_reservable_iops_threshold` in the event of\n`manual`. Default: `automatic`.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in\nminutes. Default: `480` minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "datacenterId",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map of advanced Storage DRS\nsettings that are not exposed via the provider or the vSphere client.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The global automation level for all\nvirtual machines in this datastore cluster. Default: `manual`.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When `true`, all disks in a\nsingle virtual machine will be kept on the same datastore. Default: `true`.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The free space threshold to use.\nWhen set to `utilization`, `drs_space_utilization_threshold` is used, and\nwhen set to `freeSpace`, `drs_free_space_threshold` is used. Default:\n`utilization`.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of difference between space utilization in datastores before storage\nDRS makes decisions to balance the space. Default: `5` percent.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in\nmilliseconds, that storage DRS uses to make recommendations to move disks\nfrom this datastore. Default: `15` seconds.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for\nthis datastore cluster. Default: `true`.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load\nin datastores in the cluster before storage DRS makes recommendations to\nbalance the load. Default: `5` percent.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable\nIOPS of all virtual machines on the datastore before storage DRS makes\nrecommendations to move VMs off of a datastore. Note that this setting should\nonly be set if `sdrs_io_reservable_percent_threshold` cannot make an accurate\nestimate of the capacity of the datastores in your cluster, and should be set\nto roughly 50-60% of the worst case peak performance of the backing LUNs.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of actual estimated performance of the datastore (in IOPS) that\nstorage DRS uses to make recommendations to move VMs off of a datastore when\nthe total reservable IOPS exceeds the threshold. Default: `60` percent.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS\nthreshold setting to use, `sdrs_io_reservable_percent_threshold` in the event\nof `automatic`, or `sdrs_io_reservable_iops_threshold` in the event of\n`manual`. Default: `automatic`.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in\nminutes. Default: `480` minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore cluster.\n"
                    },
                    "sdrsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key/value map of advanced Storage DRS\nsettings that are not exposed via the provider or the vSphere client.\n"
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "The global automation level for all\nvirtual machines in this datastore cluster. Default: `manual`.\n"
                    },
                    "sdrsDefaultIntraVmAffinity": {
                        "type": "boolean",
                        "description": "When `true`, all disks in a\nsingle virtual machine will be kept on the same datastore. Default: `true`.\n"
                    },
                    "sdrsEnabled": {
                        "type": "boolean",
                        "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                    },
                    "sdrsFreeSpaceThreshold": {
                        "type": "integer",
                        "description": "The free space threshold to use.\nWhen set to `utilization`, `drs_space_utilization_threshold` is used, and\nwhen set to `freeSpace`, `drs_free_space_threshold` is used. Default:\n`utilization`.\n"
                    },
                    "sdrsFreeSpaceThresholdMode": {
                        "type": "string",
                        "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                    },
                    "sdrsFreeSpaceUtilizationDifference": {
                        "type": "integer",
                        "description": "The threshold, in\npercent, of difference between space utilization in datastores before storage\nDRS makes decisions to balance the space. Default: `5` percent.\n"
                    },
                    "sdrsIoBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting I/O load imbalances.\n"
                    },
                    "sdrsIoLatencyThreshold": {
                        "type": "integer",
                        "description": "The I/O latency threshold, in\nmilliseconds, that storage DRS uses to make recommendations to move disks\nfrom this datastore. Default: `15` seconds.\n"
                    },
                    "sdrsIoLoadBalanceEnabled": {
                        "type": "boolean",
                        "description": "Enable I/O load balancing for\nthis datastore cluster. Default: `true`.\n"
                    },
                    "sdrsIoLoadImbalanceThreshold": {
                        "type": "integer",
                        "description": "The difference between load\nin datastores in the cluster before storage DRS makes recommendations to\nbalance the load. Default: `5` percent.\n"
                    },
                    "sdrsIoReservableIopsThreshold": {
                        "type": "integer",
                        "description": "The threshold of reservable\nIOPS of all virtual machines on the datastore before storage DRS makes\nrecommendations to move VMs off of a datastore. Note that this setting should\nonly be set if `sdrs_io_reservable_percent_threshold` cannot make an accurate\nestimate of the capacity of the datastores in your cluster, and should be set\nto roughly 50-60% of the worst case peak performance of the backing LUNs.\n"
                    },
                    "sdrsIoReservablePercentThreshold": {
                        "type": "integer",
                        "description": "The threshold, in\npercent, of actual estimated performance of the datastore (in IOPS) that\nstorage DRS uses to make recommendations to move VMs off of a datastore when\nthe total reservable IOPS exceeds the threshold. Default: `60` percent.\n"
                    },
                    "sdrsIoReservableThresholdMode": {
                        "type": "string",
                        "description": "The reservable IOPS\nthreshold setting to use, `sdrs_io_reservable_percent_threshold` in the event\nof `automatic`, or `sdrs_io_reservable_iops_threshold` in the event of\n`manual`. Default: `automatic`.\n"
                    },
                    "sdrsLoadBalanceInterval": {
                        "type": "integer",
                        "description": "The storage DRS poll interval, in\nminutes. Default: `480` minutes.\n"
                    },
                    "sdrsPolicyEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting storage and VM policy violations.\n"
                    },
                    "sdrsRuleEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting affinity rule violations.\n"
                    },
                    "sdrsSpaceBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting disk space imbalances.\n"
                    },
                    "sdrsSpaceUtilizationThreshold": {
                        "type": "integer",
                        "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                    },
                    "sdrsVmEvacuationAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when generating recommendations for datastore evacuation.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreClusterVmAntiAffinityRule:DatastoreClusterVmAntiAffinityRule": {
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n"
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedPortGroup:DistributedPortGroup": {
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the port shutdown\npolicy to be overridden on an individual port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "Version string of the configuration that this spec is trying to change.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the DVS to add the\nport group to. Forces a new resource if changed.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The generated UUID of the portgroup.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a port in this port group to be\nmoved to another port group while it is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the Netflow\npolicy on this port group to be overridden on an individual\nport.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network\nresource pool set on this port group to be overridden on an individual port.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset a port's settings to the\nsettings defined on this port group policy when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the security policy\nsettings defined in this port group policy to be\noverridden on an individual port.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the traffic shaping\noptions on this port group policy to be overridden\non an individual port.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any traffic filters on\nthis port group to be overridden on an individual port.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the uplink teaming\noptions on this port group to be overridden on an\nindividual port.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the VLAN settings\non this port group to be overridden on an individual port.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "directpathGen2Allowed",
                "distributedVirtualSwitchUuid",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "key",
                "lacpEnabled",
                "lacpMode",
                "name",
                "netflowEnabled",
                "notifySwitches",
                "numberOfPorts",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "vlanId",
                "vlanRanges"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the port shutdown\npolicy to be overridden on an individual port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the DVS to add the\nport group to. Forces a new resource if changed.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a port in this port group to be\nmoved to another port group while it is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the Netflow\npolicy on this port group to be overridden on an individual\nport.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network\nresource pool set on this port group to be overridden on an individual port.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset a port's settings to the\nsettings defined on this port group policy when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the security policy\nsettings defined in this port group policy to be\noverridden on an individual port.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the traffic shaping\noptions on this port group policy to be overridden\non an individual port.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any traffic filters on\nthis port group to be overridden on an individual port.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the uplink teaming\noptions on this port group to be overridden on an\nindividual port.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the VLAN settings\non this port group to be overridden on an individual port.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "requiredInputs": [
                "distributedVirtualSwitchUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedPortGroup resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "autoExpand": {
                        "type": "boolean",
                        "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Indicates whether to block all ports by default.\n"
                    },
                    "blockOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the port shutdown\npolicy to be overridden on an individual port.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing on the ports this policy applies to.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "Version string of the configuration that this spec is trying to change.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description for the port group.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "The ID of the DVS to add the\nport group to. Forces a new resource if changed.\n"
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The generated UUID of the portgroup.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable LACP on all uplink ports.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                    },
                    "livePortMovingAllowed": {
                        "type": "boolean",
                        "description": "Allow a port in this port group to be\nmoved to another port group while it is connected.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether to enable netflow on all ports.\n"
                    },
                    "netflowOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the Netflow\npolicy on this port group to be overridden on an individual\nport.\n"
                    },
                    "networkResourcePoolKey": {
                        "type": "string",
                        "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                    },
                    "networkResourcePoolOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the network\nresource pool set on this port group to be overridden on an individual port.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                    },
                    "portConfigResetAtDisconnect": {
                        "type": "boolean",
                        "description": "Reset a port's settings to the\nsettings defined on this port group policy when the port disconnects.\n"
                    },
                    "portNameFormat": {
                        "type": "string",
                        "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "The secondary VLAN ID for this port.\n"
                    },
                    "securityPolicyOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the security policy\nsettings defined in this port group policy to be\noverridden on an individual port.\n"
                    },
                    "shapingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the traffic shaping\noptions on this port group policy to be overridden\non an individual port.\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                    },
                    "trafficFilterOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow any traffic filters on\nthis port group to be overridden on an individual port.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                    },
                    "uplinkTeamingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the uplink teaming\noptions on this port group to be overridden on an\nindividual port.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the VLAN settings\non this port group to be overridden on an individual port.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                        },
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch": {
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of active uplinks to be used in load\nbalancing. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not a virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port.\n"
                },
                "backupnfcMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                },
                "backupnfcShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Shuts down all ports in the port groups that\nthis policy applies to, effectively blocking all network access to connected\nvirtual devices.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enables beacon probing as an additional measure\nto detect NIC failure.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "The version string of the configuration that this spec is trying to change.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the DVS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nDVS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual switch.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the distributed\nvirtual switch will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the DVS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 for the ports\nfor which this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits\nper second if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is enabled\non the port for egress traffic.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts\nin bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will re-activate failed\nuplinks higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder to create the DVS in. Forces a new resource\nif changed.\n"
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "Use the `host` block to declare a host specification. The\noptions are:\n"
                },
                "ignoreOtherPvlanMappings": {
                    "type": "boolean",
                    "description": "Whether to ignore existing PVLAN\nmappings not managed by this resource. Defaults to false.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in\nbits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is\nenabled on the port for ingress traffic.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during\nbursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments found\nbelow.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the switch. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Enables LACP for the ports that this policy\napplies to.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The LACP mode. Can be one of `active` or `passive`.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the switch. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the distributed virtual switch.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nactive flows are forced to be exported to the collector. Allowed range is\n`60` to `3600`. Default: `60`.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the Netflow\ncollector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed\nSwitch Version 6.0 or later. Must be set before Netflow can be enabled.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "Port for the Netflow collector. This\nmust be set before Netflow can be enabled.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Enables Netflow on all ports that this policy\napplies to.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nidle flows are forced to be exported to the collector. Allowed range is `10`\nto `600`. Default: `15`.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to\ntraffic that has both source and destination served by the same host.\nDefault: `false`.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation domain ID for\nthe Netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to\nthe number of packets analyzed. The default is `0`, which indicates that the\nswitch should analyze all packets. The maximum value is `1000`, which\nindicates an analysis rate of 0.001%.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable\nnetwork I/O control. Default: `false`.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The version of network I/O\ncontrol to use. Can be one of `version2` or `version3`. Default: `version2`.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will notify the\nbroadcast network of an uplink failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "Used to define a secondary VLAN\nID when using private VLANs.\n"
                },
                "pvlanMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                    },
                    "description": "Use the `pvlan_mapping` block to declare a\nprivate VLAN mapping. The options are:\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of standby uplinks to be used in\nfailover. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The uplink teaming policy. Can be one of\n`loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "Forward all traffic transmitted by ports for which\nthis policy applies to its DVS uplinks.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of strings that uniquely identifies the names\nof the uplinks on the DVS across hosts. The number of items in this list\ncontrols the number of uplinks that exist on the DVS, in addition to the\nnames.  See here for an example on how to\nuse this option.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "- The version of the DVS to create. The default is to\ncreate the DVS at the latest version supported by the version of vSphere\nbeing used. A DVS can be upgraded to another version, but cannot be\ndowngraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "Used to denote VLAN trunking. Use the `min_vlan`\nand `max_vlan` sub-arguments to define the tagged VLAN range. Multiple\n`vlan_range` definitions are allowed, but they must not overlap. Example\nbelow:\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "backupnfcMaximumMbit",
                "backupnfcReservationMbit",
                "backupnfcShareCount",
                "backupnfcShareLevel",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "datacenterId",
                "directpathGen2Allowed",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "faulttoleranceMaximumMbit",
                "faulttoleranceReservationMbit",
                "faulttoleranceShareCount",
                "faulttoleranceShareLevel",
                "hbrMaximumMbit",
                "hbrReservationMbit",
                "hbrShareCount",
                "hbrShareLevel",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "iscsiMaximumMbit",
                "iscsiReservationMbit",
                "iscsiShareCount",
                "iscsiShareLevel",
                "lacpApiVersion",
                "lacpEnabled",
                "lacpMode",
                "managementMaximumMbit",
                "managementReservationMbit",
                "managementShareCount",
                "managementShareLevel",
                "maxMtu",
                "multicastFilteringMode",
                "name",
                "netflowEnabled",
                "networkResourceControlVersion",
                "nfsMaximumMbit",
                "nfsReservationMbit",
                "nfsShareCount",
                "nfsShareLevel",
                "notifySwitches",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "uplinks",
                "vdpMaximumMbit",
                "vdpReservationMbit",
                "vdpShareCount",
                "vdpShareLevel",
                "version",
                "virtualmachineMaximumMbit",
                "virtualmachineReservationMbit",
                "virtualmachineShareCount",
                "virtualmachineShareLevel",
                "vlanId",
                "vlanRanges",
                "vmotionMaximumMbit",
                "vmotionReservationMbit",
                "vmotionShareCount",
                "vmotionShareLevel",
                "vsanMaximumMbit",
                "vsanReservationMbit",
                "vsanShareCount",
                "vsanShareLevel"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of active uplinks to be used in load\nbalancing. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not a virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port.\n"
                },
                "backupnfcMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                },
                "backupnfcShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Shuts down all ports in the port groups that\nthis policy applies to, effectively blocking all network access to connected\nvirtual devices.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enables beacon probing as an additional measure\nto detect NIC failure.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the DVS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nDVS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual switch.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the distributed\nvirtual switch will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the DVS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 for the ports\nfor which this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits\nper second if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is enabled\non the port for egress traffic.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts\nin bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will re-activate failed\nuplinks higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder to create the DVS in. Forces a new resource\nif changed.\n"
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "Use the `host` block to declare a host specification. The\noptions are:\n"
                },
                "ignoreOtherPvlanMappings": {
                    "type": "boolean",
                    "description": "Whether to ignore existing PVLAN\nmappings not managed by this resource. Defaults to false.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in\nbits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is\nenabled on the port for ingress traffic.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during\nbursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments found\nbelow.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the switch. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Enables LACP for the ports that this policy\napplies to.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The LACP mode. Can be one of `active` or `passive`.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the switch. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the distributed virtual switch.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nactive flows are forced to be exported to the collector. Allowed range is\n`60` to `3600`. Default: `60`.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the Netflow\ncollector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed\nSwitch Version 6.0 or later. Must be set before Netflow can be enabled.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "Port for the Netflow collector. This\nmust be set before Netflow can be enabled.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Enables Netflow on all ports that this policy\napplies to.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nidle flows are forced to be exported to the collector. Allowed range is `10`\nto `600`. Default: `15`.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to\ntraffic that has both source and destination served by the same host.\nDefault: `false`.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation domain ID for\nthe Netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to\nthe number of packets analyzed. The default is `0`, which indicates that the\nswitch should analyze all packets. The maximum value is `1000`, which\nindicates an analysis rate of 0.001%.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable\nnetwork I/O control. Default: `false`.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The version of network I/O\ncontrol to use. Can be one of `version2` or `version3`. Default: `version2`.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will notify the\nbroadcast network of an uplink failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "Used to define a secondary VLAN\nID when using private VLANs.\n"
                },
                "pvlanMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                    },
                    "description": "Use the `pvlan_mapping` block to declare a\nprivate VLAN mapping. The options are:\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of standby uplinks to be used in\nfailover. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The uplink teaming policy. Can be one of\n`loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "Forward all traffic transmitted by ports for which\nthis policy applies to its DVS uplinks.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of strings that uniquely identifies the names\nof the uplinks on the DVS across hosts. The number of items in this list\ncontrols the number of uplinks that exist on the DVS, in addition to the\nnames.  See here for an example on how to\nuse this option.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "- The version of the DVS to create. The default is to\ncreate the DVS at the latest version supported by the version of vSphere\nbeing used. A DVS can be upgraded to another version, but cannot be\ndowngraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "Used to denote VLAN trunking. Use the `min_vlan`\nand `max_vlan` sub-arguments to define the tagged VLAN range. Multiple\n`vlan_range` definitions are allowed, but they must not overlap. Example\nbelow:\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedVirtualSwitch resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of active uplinks to be used in load\nbalancing. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not a virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "backupnfcMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                    },
                    "backupnfcReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                    },
                    "backupnfcShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                    },
                    "backupnfcShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Shuts down all ports in the port groups that\nthis policy applies to, effectively blocking all network access to connected\nvirtual devices.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enables beacon probing as an additional measure\nto detect NIC failure.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "The version string of the configuration that this spec is trying to change.\n"
                    },
                    "contactDetail": {
                        "type": "string",
                        "description": "The detailed contact information for the person\nwho is responsible for the DVS.\n"
                    },
                    "contactName": {
                        "type": "string",
                        "description": "The name of the person who is responsible for the\nDVS.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual switch.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter where the distributed\nvirtual switch will be created. Forces a new resource if changed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A detailed description for the DVS.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 for the ports\nfor which this policy applies to.\n"
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits\nper second if egress traffic shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in\nbytes if egress traffic shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "`true` if the traffic shaper is enabled\non the port for egress traffic.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts\nin bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If `true`, the teaming policy will re-activate failed\nuplinks higher in precedence when they come back up.\n"
                    },
                    "faulttoleranceMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                    },
                    "faulttoleranceShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder to create the DVS in. Forces a new resource\nif changed.\n"
                    },
                    "hbrMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                    },
                    "hbrShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                        },
                        "description": "Use the `host` block to declare a host specification. The\noptions are:\n"
                    },
                    "ignoreOtherPvlanMappings": {
                        "type": "boolean",
                        "description": "Whether to ignore existing PVLAN\nmappings not managed by this resource. Defaults to false.\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in\nbits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in\nbytes if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "`true` if the traffic shaper is\nenabled on the port for ingress traffic.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during\nbursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ipv4Address": {
                        "type": "string",
                        "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments found\nbelow.\n"
                    },
                    "iscsiMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                    },
                    "iscsiShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "lacpApiVersion": {
                        "type": "string",
                        "description": "The Link Aggregation Control Protocol group\nversion to use with the switch. Possible values are `singleLag` and\n`multipleLag`.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Enables LACP for the ports that this policy\napplies to.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The LACP mode. Can be one of `active` or `passive`.\n"
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                    },
                    "managementMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                    },
                    "managementShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "maxMtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the virtual\nswitch.\n"
                    },
                    "multicastFilteringMode": {
                        "type": "string",
                        "description": "The multicast filtering mode to use\nwith the switch. Can be one of `legacyFiltering` or `snooping`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the distributed virtual switch.\n"
                    },
                    "netflowActiveFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which\nactive flows are forced to be exported to the collector. Allowed range is\n`60` to `3600`. Default: `60`.\n"
                    },
                    "netflowCollectorIpAddress": {
                        "type": "string",
                        "description": "IP address for the Netflow\ncollector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed\nSwitch Version 6.0 or later. Must be set before Netflow can be enabled.\n"
                    },
                    "netflowCollectorPort": {
                        "type": "integer",
                        "description": "Port for the Netflow collector. This\nmust be set before Netflow can be enabled.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Enables Netflow on all ports that this policy\napplies to.\n"
                    },
                    "netflowIdleFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which\nidle flows are forced to be exported to the collector. Allowed range is `10`\nto `600`. Default: `15`.\n"
                    },
                    "netflowInternalFlowsOnly": {
                        "type": "boolean",
                        "description": "Whether to limit analysis to\ntraffic that has both source and destination served by the same host.\nDefault: `false`.\n"
                    },
                    "netflowObservationDomainId": {
                        "type": "integer",
                        "description": "The observation domain ID for\nthe Netflow collector.\n"
                    },
                    "netflowSamplingRate": {
                        "type": "integer",
                        "description": "The ratio of total number of packets to\nthe number of packets analyzed. The default is `0`, which indicates that the\nswitch should analyze all packets. The maximum value is `1000`, which\nindicates an analysis rate of 0.001%.\n"
                    },
                    "networkResourceControlEnabled": {
                        "type": "boolean",
                        "description": "Set to `true` to enable\nnetwork I/O control. Default: `false`.\n"
                    },
                    "networkResourceControlVersion": {
                        "type": "string",
                        "description": "The version of network I/O\ncontrol to use. Can be one of `version2` or `version3`. Default: `version2`.\n"
                    },
                    "nfsMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                    },
                    "nfsShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If `true`, the teaming policy will notify the\nbroadcast network of an uplink failover, triggering cache updates.\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "Used to define a secondary VLAN\nID when using private VLANs.\n"
                    },
                    "pvlanMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                        },
                        "description": "Use the `pvlan_mapping` block to declare a\nprivate VLAN mapping. The options are:\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of standby uplinks to be used in\nfailover. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The uplink teaming policy. Can be one of\n`loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "Forward all traffic transmitted by ports for which\nthis policy applies to its DVS uplinks.\n"
                    },
                    "uplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of strings that uniquely identifies the names\nof the uplinks on the DVS across hosts. The number of items in this list\ncontrols the number of uplinks that exist on the DVS, in addition to the\nnames.  See here for an example on how to\nuse this option.\n"
                    },
                    "vdpMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                    },
                    "vdpShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "- The version of the DVS to create. The default is to\ncreate the DVS at the latest version supported by the version of vSphere\nbeing used. A DVS can be upgraded to another version, but cannot be\ndowngraded.\n"
                    },
                    "virtualmachineMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                    },
                    "virtualmachineShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                        },
                        "description": "Used to denote VLAN trunking. Use the `min_vlan`\nand `max_vlan` sub-arguments to define the tagged VLAN range. Multiple\n`vlan_range` definitions are allowed, but they must not overlap. Example\nbelow:\n"
                    },
                    "vmotionMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                    },
                    "vmotionShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vsanMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                    },
                    "vsanShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/dpmHostOverride:DpmHostOverride": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n"
                }
            },
            "required": [
                "computeClusterId",
                "hostSystemId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DpmHostOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for this host. Default:\n`false`.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of the host.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/drsVmOverride:DrsVmOverride": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DrsVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/entityPermissions:EntityPermissions": {
            "properties": {
                "entityId": {
                    "type": "string",
                    "description": "The managed object id (uuid for some entities) on which permissions are to be created.\n"
                },
                "entityType": {
                    "type": "string",
                    "description": "The managed object type, types can be found in the managed object type section \n[here](https://code.vmware.com/apis/968/vsphere).\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                    },
                    "description": "The permissions to be given on this entity. Keep the permissions sorted\nalphabetically on `user_or_group` for a better user experience.\n"
                }
            },
            "required": [
                "entityId",
                "entityType",
                "permissions"
            ],
            "inputProperties": {
                "entityId": {
                    "type": "string",
                    "description": "The managed object id (uuid for some entities) on which permissions are to be created.\n"
                },
                "entityType": {
                    "type": "string",
                    "description": "The managed object type, types can be found in the managed object type section \n[here](https://code.vmware.com/apis/968/vsphere).\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                    },
                    "description": "The permissions to be given on this entity. Keep the permissions sorted\nalphabetically on `user_or_group` for a better user experience.\n"
                }
            },
            "requiredInputs": [
                "entityId",
                "entityType",
                "permissions"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityPermissions resources.\n",
                "properties": {
                    "entityId": {
                        "type": "string",
                        "description": "The managed object id (uuid for some entities) on which permissions are to be created.\n"
                    },
                    "entityType": {
                        "type": "string",
                        "description": "The managed object type, types can be found in the managed object type section \n[here](https://code.vmware.com/apis/968/vsphere).\n"
                    },
                    "permissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                        },
                        "description": "The permissions to be given on this entity. Keep the permissions sorted\nalphabetically on `user_or_group` for a better user experience.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/file:File": {
            "description": "The `vsphere.File` resource can be used to upload files (such as virtual disk\nfiles) from the host machine that this provider is running on to a target\ndatastore.  The resource can also be used to copy files between datastores, or\nfrom one location to another on the same datastore.\n\nUpdates to destination parameters such as `datacenter`, `datastore`, or\n`destination_file` will move the managed file a new destination based on the\nvalues of the new settings.  If any source parameter is changed, such as\n`source_datastore`, `source_datacenter` or `source_file`), the resource will be\nre-created. Depending on if destination parameters are being changed as well,\nthis may result in the destination file either being overwritten or deleted at\nthe old location.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Uploading a file\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuDiskUpload = new vsphere.File(\"ubuntu_disk_upload\", {\n    datacenter: \"my_datacenter\",\n    datastore: \"local\",\n    destinationFile: \"/my_path/disks/custom_ubuntu.vmdk\",\n    sourceFile: \"/home/ubuntu/my_disks/custom_ubuntu.vmdk\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_disk_upload = vsphere.File(\"ubuntuDiskUpload\",\n    datacenter=\"my_datacenter\",\n    datastore=\"local\",\n    destination_file=\"/my_path/disks/custom_ubuntu.vmdk\",\n    source_file=\"/home/ubuntu/my_disks/custom_ubuntu.vmdk\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ubuntuDiskUpload = new VSphere.File(\"ubuntuDiskUpload\", new VSphere.FileArgs\n        {\n            Datacenter = \"my_datacenter\",\n            Datastore = \"local\",\n            DestinationFile = \"/my_path/disks/custom_ubuntu.vmdk\",\n            SourceFile = \"/home/ubuntu/my_disks/custom_ubuntu.vmdk\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewFile(ctx, \"ubuntuDiskUpload\", \u0026vsphere.FileArgs{\n\t\t\tDatacenter:      pulumi.String(\"my_datacenter\"),\n\t\t\tDatastore:       pulumi.String(\"local\"),\n\t\t\tDestinationFile: pulumi.String(\"/my_path/disks/custom_ubuntu.vmdk\"),\n\t\t\tSourceFile:      pulumi.String(\"/home/ubuntu/my_disks/custom_ubuntu.vmdk\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Copying a file\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuDiskCopy = new vsphere.File(\"ubuntu_disk_copy\", {\n    datacenter: \"my_datacenter\",\n    datastore: \"local\",\n    destinationFile: \"/my_path/custom_ubuntu_id.vmdk\",\n    sourceDatacenter: \"my_datacenter\",\n    sourceDatastore: \"local\",\n    sourceFile: \"/my_path/disks/custom_ubuntu.vmdk\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_disk_copy = vsphere.File(\"ubuntuDiskCopy\",\n    datacenter=\"my_datacenter\",\n    datastore=\"local\",\n    destination_file=\"/my_path/custom_ubuntu_id.vmdk\",\n    source_datacenter=\"my_datacenter\",\n    source_datastore=\"local\",\n    source_file=\"/my_path/disks/custom_ubuntu.vmdk\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ubuntuDiskCopy = new VSphere.File(\"ubuntuDiskCopy\", new VSphere.FileArgs\n        {\n            Datacenter = \"my_datacenter\",\n            Datastore = \"local\",\n            DestinationFile = \"/my_path/custom_ubuntu_id.vmdk\",\n            SourceDatacenter = \"my_datacenter\",\n            SourceDatastore = \"local\",\n            SourceFile = \"/my_path/disks/custom_ubuntu.vmdk\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewFile(ctx, \"ubuntuDiskCopy\", \u0026vsphere.FileArgs{\n\t\t\tDatacenter:       pulumi.String(\"my_datacenter\"),\n\t\t\tDatastore:        pulumi.String(\"local\"),\n\t\t\tDestinationFile:  pulumi.String(\"/my_path/custom_ubuntu_id.vmdk\"),\n\t\t\tSourceDatacenter: pulumi.String(\"my_datacenter\"),\n\t\t\tSourceDatastore:  pulumi.String(\"local\"),\n\t\t\tSourceFile:       pulumi.String(\"/my_path/disks/custom_ubuntu.vmdk\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter if any missing for copy operation.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter in which the file will be\nuploaded to.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to upload the\nfile to.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter in which the file\nwill be copied from. Forces a new resource if changed.\n"
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore in which file will\nbe copied from. Forces a new resource if changed.\n"
                },
                "sourceFile": {
                    "type": "string",
                    "description": "The path to the file being uploaded from the\nhost to vSphere or copied within vSphere. Forces a new resource if\nchanged.\n"
                }
            },
            "required": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "inputProperties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter if any missing for copy operation.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter in which the file will be\nuploaded to.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to upload the\nfile to.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter in which the file\nwill be copied from. Forces a new resource if changed.\n"
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore in which file will\nbe copied from. Forces a new resource if changed.\n"
                },
                "sourceFile": {
                    "type": "string",
                    "description": "The path to the file being uploaded from the\nhost to vSphere or copied within vSphere. Forces a new resource if\nchanged.\n"
                }
            },
            "requiredInputs": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering File resources.\n",
                "properties": {
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Create directories in `destination_file`\npath parameter if any missing for copy operation.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of a datacenter in which the file will be\nuploaded to.\n"
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore in which to upload the\nfile to.\n"
                    },
                    "destinationFile": {
                        "type": "string",
                        "description": "The path to where the file should be uploaded\nor copied to on vSphere.\n"
                    },
                    "sourceDatacenter": {
                        "type": "string",
                        "description": "The name of a datacenter in which the file\nwill be copied from. Forces a new resource if changed.\n"
                    },
                    "sourceDatastore": {
                        "type": "string",
                        "description": "The name of the datastore in which file will\nbe copied from. Forces a new resource if changed.\n"
                    },
                    "sourceFile": {
                        "type": "string",
                        "description": "The path to the file being uploaded from the\nhost to vSphere or copied within vSphere. Forces a new resource if\nchanged.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/folder:Folder": {
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "path",
                "type"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "path",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Folder resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/haVmOverride:HaVmOverride": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non this virtual machine if an APD status on an affected datastore clears in\nthe middle of an APD event. Can be one of `useClusterDefault`, `none` or\n`reset`.  Default: `useClusterDefault`.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of `clusterDefault`, `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `clusterDefault`.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Use `-1` to use\nthe cluster default. Default: `-1`.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `clusterDefault`, `disabled`, `warning`, or\n`restartAggressive`. Default: `clusterDefault`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual\nmachine when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `clusterIsolationResponse`, `none`, `powerOff`, or\n`shutdown`. Default: `clusterIsolationResponse`.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual\nmachine is not received within this configured interval, the virtual machine\nis marked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to this virtual machine when responding to a failure event. Default:\n`3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on this virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or\nnot the cluster's default settings or the VM override settings specified in\nthis resource are used for virtual machine monitoring. The default is `true`\n(use cluster defaults) - set to `false` to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for the virtual\nmachine when vSphere detects a host failure. Can be one of\n`clusterRestartPriority`, `lowest`, `low`, `medium`, `high`, or `highest`.\nDefault: `clusterRestartPriority`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that\nvSphere HA will wait for this virtual machine to be ready. Use `-1` to\nspecify the cluster default.  Default: `-1`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non this virtual machine if an APD status on an affected datastore clears in\nthe middle of an APD event. Can be one of `useClusterDefault`, `none` or\n`reset`.  Default: `useClusterDefault`.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of `clusterDefault`, `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `clusterDefault`.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Use `-1` to use\nthe cluster default. Default: `-1`.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `clusterDefault`, `disabled`, `warning`, or\n`restartAggressive`. Default: `clusterDefault`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual\nmachine when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `clusterIsolationResponse`, `none`, `powerOff`, or\n`shutdown`. Default: `clusterIsolationResponse`.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual\nmachine is not received within this configured interval, the virtual machine\nis marked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to this virtual machine when responding to a failure event. Default:\n`3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on this virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or\nnot the cluster's default settings or the VM override settings specified in\nthis resource are used for virtual machine monitoring. The default is `true`\n(use cluster defaults) - set to `false` to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for the virtual\nmachine when vSphere detects a host failure. Can be one of\n`clusterRestartPriority`, `lowest`, `low`, `medium`, `high`, or `highest`.\nDefault: `clusterRestartPriority`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that\nvSphere HA will wait for this virtual machine to be ready. Use `-1` to\nspecify the cluster default.  Default: `-1`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HaVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "Controls the action to take\non this virtual machine if an APD status on an affected datastore clears in\nthe middle of an APD event. Can be one of `useClusterDefault`, `none` or\n`reset`.  Default: `useClusterDefault`.\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this\nvirtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of `clusterDefault`, `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `clusterDefault`.\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Use `-1` to use\nthe cluster default. Default: `-1`.\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this\nvirtual machine when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `clusterDefault`, `disabled`, `warning`, or\n`restartAggressive`. Default: `clusterDefault`.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on this virtual\nmachine when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `clusterIsolationResponse`, `none`, `powerOff`, or\n`shutdown`. Default: `clusterIsolationResponse`.\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "If a heartbeat from this virtual\nmachine is not received within this configured interval, the virtual machine\nis marked as failed. The value is in seconds. Default: `30`.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will\nperform to this virtual machine when responding to a failure event. Default:\n`3`\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after\npowering on this virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                    },
                    "haVmMonitoringUseClusterDefaults": {
                        "type": "boolean",
                        "description": "Determines whether or\nnot the cluster's default settings or the VM override settings specified in\nthis resource are used for virtual machine monitoring. The default is `true`\n(use cluster defaults) - set to `false` to have overrides take effect.\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The restart priority for the virtual\nmachine when vSphere detects a host failure. Can be one of\n`clusterRestartPriority`, `lowest`, `low`, `medium`, `high`, or `highest`.\nDefault: `clusterRestartPriority`.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds, that\nvSphere HA will wait for this virtual machine to be ready. Use `-1` to\nspecify the cluster default.  Default: `-1`.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/host:Host": {
            "description": "Provides a VMware vSphere host resource. This represents an ESXi host that\ncan be used either as part of a Compute Cluster or Standalone.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Create a standalone host\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = vsphere.getDatacenter({\n    name: \"my-datacenter\",\n});\nconst h1 = new vsphere.Host(\"h1\", {\n    hostname: \"10.10.10.1\",\n    username: \"root\",\n    password: \"password\",\n    license: \"00000-00000-00000-00000i-00000\",\n    datacenter: dc.then(dc =\u003e dc.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"my-datacenter\")\nh1 = vsphere.Host(\"h1\",\n    hostname=\"10.10.10.1\",\n    username=\"root\",\n    password=\"password\",\n    license=\"00000-00000-00000-00000i-00000\",\n    datacenter=dc.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"my-datacenter\",\n        }));\n        var h1 = new VSphere.Host(\"h1\", new VSphere.HostArgs\n        {\n            Hostname = \"10.10.10.1\",\n            Username = \"root\",\n            Password = \"password\",\n            License = \"00000-00000-00000-00000i-00000\",\n            Datacenter = dc.Apply(dc =\u003e dc.Id),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdc, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"my-datacenter\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHost(ctx, \"h1\", \u0026vsphere.HostArgs{\n\t\t\tHostname:   pulumi.String(\"10.10.10.1\"),\n\t\t\tUsername:   pulumi.String(\"root\"),\n\t\t\tPassword:   pulumi.String(\"password\"),\n\t\t\tLicense:    pulumi.String(\"00000-00000-00000-00000i-00000\"),\n\t\t\tDatacenter: pulumi.String(dc.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Create host in a compute cluster\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = vsphere.getDatacenter({\n    name: \"TfDatacenter\",\n});\nconst c1 = dc.then(dc =\u003e vsphere.getComputeCluster({\n    name: \"DC0_C0\",\n    datacenterId: dc.id,\n}));\nconst h1 = new vsphere.Host(\"h1\", {\n    hostname: \"10.10.10.1\",\n    username: \"root\",\n    password: \"password\",\n    license: \"00000-00000-00000-00000i-00000\",\n    cluster: c1.then(c1 =\u003e c1.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"TfDatacenter\")\nc1 = vsphere.get_compute_cluster(name=\"DC0_C0\",\n    datacenter_id=dc.id)\nh1 = vsphere.Host(\"h1\",\n    hostname=\"10.10.10.1\",\n    username=\"root\",\n    password=\"password\",\n    license=\"00000-00000-00000-00000i-00000\",\n    cluster=c1.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"TfDatacenter\",\n        }));\n        var c1 = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            Name = \"DC0_C0\",\n            DatacenterId = dc.Id,\n        })));\n        var h1 = new VSphere.Host(\"h1\", new VSphere.HostArgs\n        {\n            Hostname = \"10.10.10.1\",\n            Username = \"root\",\n            Password = \"password\",\n            License = \"00000-00000-00000-00000i-00000\",\n            Cluster = c1.Apply(c1 =\u003e c1.Id),\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdc, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"TfDatacenter\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc1, err := vsphere.LookupComputeCluster(ctx, \u0026GetComputeClusterArgs{\n\t\t\tName:         \"DC0_C0\",\n\t\t\tDatacenterId: pulumi.StringRef(dc.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHost(ctx, \"h1\", \u0026vsphere.HostArgs{\n\t\t\tHostname: pulumi.String(\"10.10.10.1\"),\n\t\t\tUsername: pulumi.String(\"root\"),\n\t\t\tPassword: pulumi.String(\"password\"),\n\t\t\tLicense:  pulumi.String(\"00000-00000-00000-00000i-00000\"),\n\t\t\tCluster:  pulumi.String(c1.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Importing \n\nAn existing host can be [imported][docs-import] into this resource\nvia supplying the host's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n\nThe above would import the host with ID `host-123`.\n",
            "properties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster`.\n"
                },
                "clusterManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconected.\nDefault is `false`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to true then it will force the host to be added, even\nif the host is already connected to a different vSphere instance. Default is `false`\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host. Default is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the the\nCA that signed the host's certificate should be trusted. If the CA is not trusted\nand no thumbprint is set then the operation will fail.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "required": [
                "hostname",
                "password",
                "username"
            ],
            "inputProperties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster`.\n"
                },
                "clusterManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconected.\nDefault is `false`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to true then it will force the host to be added, even\nif the host is already connected to a different vSphere instance. Default is `false`\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host. Default is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the the\nCA that signed the host's certificate should be trusted. If the CA is not trusted\nand no thumbprint is set then the operation will fail.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "requiredInputs": [
                "hostname",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Host resources.\n",
                "properties": {
                    "cluster": {
                        "type": "string",
                        "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster`.\n"
                    },
                    "clusterManaged": {
                        "type": "boolean",
                        "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                    },
                    "connected": {
                        "type": "boolean",
                        "description": "If set to false then the host will be disconected.\nDefault is `false`.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                    },
                    "force": {
                        "type": "boolean",
                        "description": "If set to true then it will force the host to be added, even\nif the host is already connected to a different vSphere instance. Default is `false`\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "FQDN or IP address of the host to be added.\n"
                    },
                    "license": {
                        "type": "string",
                        "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                    },
                    "lockdown": {
                        "type": "string",
                        "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                    },
                    "maintenance": {
                        "type": "boolean",
                        "description": "Set the management state of the host. Default is `false`.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password that will be used by vSphere to authenticate\nto the host.\n"
                    },
                    "thumbprint": {
                        "type": "string",
                        "description": "Host's certificate SHA-1 thumbprint. If not set the the\nCA that signed the host's certificate should be trusted. If the CA is not trusted\nand no thumbprint is set then the operation will fail.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostPortGroup:HostPortGroup": {
            "description": "The `vsphere.HostPortGroup` resource can be used to manage vSphere standard\nport groups on an ESXi host. These port groups are connected to standard\nvirtual switches, which can be managed by the\n`vsphere.HostVirtualSwitch` resource.\n\nFor an overview on vSphere networking concepts, see [this page][ref-vsphere-net-concepts].\n\n[ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Create a virtual switch and bind a port group to it\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst esxiHost = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n    name: \"esxi1\",\n}));\nconst switchHostVirtualSwitch = new vsphere.HostVirtualSwitch(\"switch\", {\n    activeNics: [\"vmnic0\"],\n    hostSystemId: esxiHost.id,\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    hostSystemId: esxiHost.id,\n    virtualSwitchName: switchHostVirtualSwitch.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nesxi_host = vsphere.get_host(datacenter_id=datacenter.id,\n    name=\"esxi1\")\nswitch = vsphere.HostVirtualSwitch(\"switch\",\n    active_nics=[\"vmnic0\"],\n    host_system_id=esxi_host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    host_system_id=esxi_host.id,\n    virtual_switch_name=switch.name)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var esxiHost = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"esxi1\",\n        })));\n        var @switch = new VSphere.HostVirtualSwitch(\"switch\", new VSphere.HostVirtualSwitchArgs\n        {\n            ActiveNics = \n            {\n                \"vmnic0\",\n            },\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n            NetworkAdapters = \n            {\n                \"vmnic0\",\n                \"vmnic1\",\n            },\n            StandbyNics = \n            {\n                \"vmnic1\",\n            },\n        });\n        var pg = new VSphere.HostPortGroup(\"pg\", new VSphere.HostPortGroupArgs\n        {\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n            VirtualSwitchName = @switch.Name,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tesxiHost, err := vsphere.LookupHost(ctx, \u0026GetHostArgs{\n\t\t\tDatacenterId: datacenter.Id,\n\t\t\tName:         pulumi.StringRef(\"esxi1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostVirtualSwitch(ctx, \"switch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tHostSystemId: pulumi.String(esxiHost.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tHostSystemId:      pulumi.String(esxiHost.Id),\n\t\t\tVirtualSwitchName: _switch.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Create a port group with VLAN set and some overrides\n\nThis example sets the trunk mode VLAN (`4095`, which passes through all tags)\nand sets\n`allow_promiscuous`\nto ensure that all traffic is seen on the port. The latter setting overrides\nthe implicit default of `false` set on the virtual switch.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst esxiHost = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n    name: \"esxi1\",\n}));\nconst switchHostVirtualSwitch = new vsphere.HostVirtualSwitch(\"switch\", {\n    activeNics: [\"vmnic0\"],\n    hostSystemId: esxiHost.id,\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    allowPromiscuous: true,\n    hostSystemId: esxiHost.id,\n    virtualSwitchName: switchHostVirtualSwitch.name,\n    vlanId: 4095,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nesxi_host = vsphere.get_host(datacenter_id=datacenter.id,\n    name=\"esxi1\")\nswitch = vsphere.HostVirtualSwitch(\"switch\",\n    active_nics=[\"vmnic0\"],\n    host_system_id=esxi_host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    allow_promiscuous=True,\n    host_system_id=esxi_host.id,\n    virtual_switch_name=switch.name,\n    vlan_id=4095)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var esxiHost = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"esxi1\",\n        })));\n        var @switch = new VSphere.HostVirtualSwitch(\"switch\", new VSphere.HostVirtualSwitchArgs\n        {\n            ActiveNics = \n            {\n                \"vmnic0\",\n            },\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n            NetworkAdapters = \n            {\n                \"vmnic0\",\n                \"vmnic1\",\n            },\n            StandbyNics = \n            {\n                \"vmnic1\",\n            },\n        });\n        var pg = new VSphere.HostPortGroup(\"pg\", new VSphere.HostPortGroupArgs\n        {\n            AllowPromiscuous = true,\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n            VirtualSwitchName = @switch.Name,\n            VlanId = 4095,\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tesxiHost, err := vsphere.LookupHost(ctx, \u0026GetHostArgs{\n\t\t\tDatacenterId: datacenter.Id,\n\t\t\tName:         pulumi.StringRef(\"esxi1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostVirtualSwitch(ctx, \"switch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tHostSystemId: pulumi.String(esxiHost.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tAllowPromiscuous:  pulumi.Bool(true),\n\t\t\tHostSystemId:      pulumi.String(esxiHost.Id),\n\t\t\tVirtualSwitchName: _switch.Name,\n\t\t\tVlanId:            pulumi.Int(4095),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Importing \n\nAn existing host port group can be [imported][docs-import] into this resource\nusing the host port group's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n\nThe above would import the `Management` host port group from host with ID `host-123`.\n",
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "computedPolicy": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/HostPortGroupPort:HostPortGroupPort"
                    },
                    "description": "A list of ports that currently exist and are used on this port group.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "required": [
                "computedPolicy",
                "hostSystemId",
                "key",
                "name",
                "ports",
                "virtualSwitchName"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "requiredInputs": [
                "hostSystemId",
                "virtualSwitchName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostPortGroup resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active network adapters used for load balancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                    },
                    "computedPolicy": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The key for this port group as returned from the vSphere API.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.  Forces a new resource if\nchanged.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "ports": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/HostPortGroupPort:HostPortGroupPort"
                        },
                        "description": "A list of ports that currently exist and are used on this port group.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Enable traffic shaping on this virtual switch or port group.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby network adapters used for failover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                    },
                    "virtualSwitchName": {
                        "type": "string",
                        "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostVirtualSwitch:HostVirtualSwitch": {
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of active network adapters used for load\nbalancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own. Default: `true`.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed. Default: `true`.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port. Default:\n`false`.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "The interval, in seconds, that a NIC beacon\npacket is sent out. This can be used with `check_beacon` to\noffer link failure capability beyond link status only. Default: `1`.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing - this requires that the\n`beacon_interval` option has been set in the bridge\noptions. If this is set to `false`, only link status is used to check for\nfailed NICs.  Default: `false`.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will re-activate\nfailed interfaces higher in precedence when they come back up.  Default:\n`true`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic. Default: `listen`.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type.  Valid\ntypes are `cpd` and `lldp`. Default: `cdp`.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n"
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The network interfaces to bind to the bridge.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will\nnotify the broadcast network of a NIC failover, triggering cache updates.\nDefault: `true`.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per\nsecond if traffic shaping is enabled. Default: `0`\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if\nshaping is enabled. Default: `0`\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the traffic shaper for\nports managed by this virtual switch. Default: `false`.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in\nbits per second if traffic shaping is enabled. Default: `0`\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of standby network adapters used for\nfailover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one\nof `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`. Default: `loadbalance_srcid`.\n"
                }
            },
            "required": [
                "activeNics",
                "hostSystemId",
                "name",
                "networkAdapters",
                "standbyNics"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of active network adapters used for load\nbalancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own. Default: `true`.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed. Default: `true`.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port. Default:\n`false`.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "The interval, in seconds, that a NIC beacon\npacket is sent out. This can be used with `check_beacon` to\noffer link failure capability beyond link status only. Default: `1`.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing - this requires that the\n`beacon_interval` option has been set in the bridge\noptions. If this is set to `false`, only link status is used to check for\nfailed NICs.  Default: `false`.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will re-activate\nfailed interfaces higher in precedence when they come back up.  Default:\n`true`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic. Default: `listen`.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type.  Valid\ntypes are `cpd` and `lldp`. Default: `cdp`.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n"
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The network interfaces to bind to the bridge.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will\nnotify the broadcast network of a NIC failover, triggering cache updates.\nDefault: `true`.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per\nsecond if traffic shaping is enabled. Default: `0`\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if\nshaping is enabled. Default: `0`\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the traffic shaper for\nports managed by this virtual switch. Default: `false`.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in\nbits per second if traffic shaping is enabled. Default: `0`\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of standby network adapters used for\nfailover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one\nof `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`. Default: `loadbalance_srcid`.\n"
                }
            },
            "requiredInputs": [
                "activeNics",
                "hostSystemId",
                "networkAdapters",
                "standbyNics"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostVirtualSwitch resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of active network adapters used for load\nbalancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own. Default: `true`.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed. Default: `true`.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port. Default:\n`false`.\n"
                    },
                    "beaconInterval": {
                        "type": "integer",
                        "description": "The interval, in seconds, that a NIC beacon\npacket is sent out. This can be used with `check_beacon` to\noffer link failure capability beyond link status only. Default: `1`.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing - this requires that the\n`beacon_interval` option has been set in the bridge\noptions. If this is set to `false`, only link status is used to check for\nfailed NICs.  Default: `false`.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If set to `true`, the teaming policy will re-activate\nfailed interfaces higher in precedence when they come back up.  Default:\n`true`.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n"
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to `advertise` or `listen`\nfor link discovery traffic. Default: `listen`.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type.  Valid\ntypes are `cpd` and `lldp`. Default: `cdp`.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n"
                    },
                    "networkAdapters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The network interfaces to bind to the bridge.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If set to `true`, the teaming policy will\nnotify the broadcast network of a NIC failover, triggering cache updates.\nDefault: `true`.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per\nsecond if traffic shaping is enabled. Default: `0`\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if\nshaping is enabled. Default: `0`\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Set to `true` to enable the traffic shaper for\nports managed by this virtual switch. Default: `false`.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in\nbits per second if traffic shaping is enabled. Default: `0`\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of standby network adapters used for\nfailover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one\nof `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`. Default: `loadbalance_srcid`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/license:License": {
            "description": "Provides a VMware vSphere license resource. This can be used to add and remove license keys.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst licenseKey = new vsphere.License(\"licenseKey\", {\n    labels: {\n        VpxClientLicenseLabel: \"Hello World\",\n        Workflow: \"Hello World\",\n    },\n    licenseKey: \"452CQ-2EK54-K8742-00000-00000\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlicense_key = vsphere.License(\"licenseKey\",\n    labels={\n        \"VpxClientLicenseLabel\": \"Hello World\",\n        \"Workflow\": \"Hello World\",\n    },\n    license_key=\"452CQ-2EK54-K8742-00000-00000\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var licenseKey = new VSphere.License(\"licenseKey\", new VSphere.LicenseArgs\n        {\n            Labels = \n            {\n                { \"VpxClientLicenseLabel\", \"Hello World\" },\n                { \"Workflow\", \"Hello World\" },\n            },\n            LicenseKey = \"452CQ-2EK54-K8742-00000-00000\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewLicense(ctx, \"licenseKey\", \u0026vsphere.LicenseArgs{\n\t\t\tLabels: pulumi.StringMap{\n\t\t\t\t\"VpxClientLicenseLabel\": pulumi.String(\"Hello World\"),\n\t\t\t\t\"Workflow\":              pulumi.String(\"Hello World\"),\n\t\t\t},\n\t\t\tLicenseKey: pulumi.String(\"452CQ-2EK54-K8742-00000-00000\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "editionKey": {
                    "type": "string",
                    "description": "The product edition of the license key.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name for the license.\n"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of units (example: CPUs) contained in the license.\n"
                },
                "used": {
                    "type": "integer",
                    "description": "The number of units (example: CPUs) assigned to this license.\n"
                }
            },
            "required": [
                "editionKey",
                "licenseKey",
                "name",
                "total",
                "used"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n"
                }
            },
            "requiredInputs": [
                "licenseKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering License resources.\n",
                "properties": {
                    "editionKey": {
                        "type": "string",
                        "description": "The product edition of the license key.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                    },
                    "licenseKey": {
                        "type": "string",
                        "description": "The license key to add.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name for the license.\n"
                    },
                    "total": {
                        "type": "integer",
                        "description": "Total number of units (example: CPUs) contained in the license.\n"
                    },
                    "used": {
                        "type": "integer",
                        "description": "The number of units (example: CPUs) assigned to this license.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/nasDatastore:NasDatastore": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n"
                },
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "protocolEndpoint": {
                    "type": "boolean",
                    "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nserver or servers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n"
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n"
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "freeSpace",
                "hostSystemIds",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "protocolEndpoint",
                "remoteHosts",
                "remotePath",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nserver or servers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n"
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n"
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n"
                }
            },
            "requiredInputs": [
                "hostSystemIds",
                "remoteHosts",
                "remotePath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NasDatastore resources.\n",
                "properties": {
                    "accessMode": {
                        "type": "string",
                        "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n"
                    },
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "protocolEndpoint": {
                        "type": "boolean",
                        "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                    },
                    "remoteHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The hostnames or IP addresses of the remote\nserver or servers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n"
                    },
                    "remotePath": {
                        "type": "string",
                        "description": "The remote path of the mount point. Forces a new\nresource if changed.\n"
                    },
                    "securityType": {
                        "type": "string",
                        "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n"
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/resourcePool:ResourcePool": {
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourcePool resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource pool.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/role:Role": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "The display label of the role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "rolePrivileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to be associated with this role.\n"
                }
            },
            "required": [
                "label",
                "name"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "rolePrivileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to be associated with this role.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "label": {
                        "type": "string",
                        "description": "The display label of the role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges to be associated with this role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/storageDrsVmOverride:StorageDrsVmOverride": {
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageDrsVmOverride resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n"
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                    },
                    "sdrsEnabled": {
                        "type": "string",
                        "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                    },
                    "sdrsIntraVmAffinity": {
                        "type": "string",
                        "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tag:Tag": {
            "properties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "required": [
                "categoryId",
                "name"
            ],
            "inputProperties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "requiredInputs": [
                "categoryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tag resources.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the tag.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tagCategory:TagCategory": {
            "properties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "required": [
                "associableTypes",
                "cardinality",
                "name"
            ],
            "inputProperties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "requiredInputs": [
                "associableTypes",
                "cardinality"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagCategory resources.\n",
                "properties": {
                    "associableTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                    },
                    "cardinality": {
                        "type": "string",
                        "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the category.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappContainer:VappContainer": {
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappContainer resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container.\n"
                    },
                    "parentFolderId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappEntity:VappEntity": {
            "properties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n"
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "required": [
                "containerId",
                "targetId"
            ],
            "inputProperties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n"
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "requiredInputs": [
                "containerId",
                "targetId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappEntity resources.\n",
                "properties": {
                    "containerId": {
                        "type": "string",
                        "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "startAction": {
                        "type": "string",
                        "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                    },
                    "startDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                    },
                    "startOrder": {
                        "type": "integer",
                        "description": "Order to start and stop target in vApp. Default: 1\n"
                    },
                    "stopAction": {
                        "type": "string",
                        "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                    },
                    "stopDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "targetId": {
                        "type": "string",
                        "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n"
                    },
                    "waitForGuest": {
                        "type": "boolean",
                        "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualDisk:VirtualDisk": {
            "description": "The `vsphere.VirtualDisk` resource can be used to create virtual disks outside\nof any given `vsphere.VirtualMachine`\nresource. These disks can be attached to a virtual machine by creating a disk\nblock with the `attach` parameter.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst myDisk = new vsphere.VirtualDisk(\"myDisk\", {\n    datacenter: \"Datacenter\",\n    datastore: \"local\",\n    size: 2,\n    type: \"thin\",\n    vmdkPath: \"myDisk.vmdk\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nmy_disk = vsphere.VirtualDisk(\"myDisk\",\n    datacenter=\"Datacenter\",\n    datastore=\"local\",\n    size=2,\n    type=\"thin\",\n    vmdk_path=\"myDisk.vmdk\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var myDisk = new VSphere.VirtualDisk(\"myDisk\", new VSphere.VirtualDiskArgs\n        {\n            Datacenter = \"Datacenter\",\n            Datastore = \"local\",\n            Size = 2,\n            Type = \"thin\",\n            VmdkPath = \"myDisk.vmdk\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualDisk(ctx, \"myDisk\", \u0026vsphere.VirtualDiskArgs{\n\t\t\tDatacenter: pulumi.String(\"Datacenter\"),\n\t\t\tDatastore:  pulumi.String(\"local\"),\n\t\t\tSize:       pulumi.Int(2),\n\t\t\tType:       pulumi.String(\"thin\"),\n\t\t\tVmdkPath:   pulumi.String(\"myDisk.vmdk\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead"
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when when ESXi or if there is only one datacenter in\nyour infrastructure.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB).\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n"
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n"
                }
            },
            "required": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "inputProperties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead"
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when when ESXi or if there is only one datacenter in\nyour infrastructure.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB).\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n"
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n"
                }
            },
            "requiredInputs": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualDisk resources.\n",
                "properties": {
                    "adapterType": {
                        "type": "string",
                        "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n",
                        "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead"
                    },
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when when ESXi or if there is only one datacenter in\nyour infrastructure.\n"
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore in which to create the\ndisk.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "Size of the disk (in GB).\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n"
                    },
                    "vmdkPath": {
                        "type": "string",
                        "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachine:VirtualMachine": {
            "properties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system\nwhen `guest_id` is `other` or `other-64`.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "A user-provided description of the virtual machine.\nThe default is no annotation.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting\nthe boot sequence. The default is no delay.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before\nretrying the boot sequence. This only valid if `boot_retry_enabled` is true.\nDefault: `10000` (10 seconds).\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a virtual machine that\nfails to boot will try again after the delay defined in `boot_retry_delay`.\nDefault: `false`.\n"
                },
                "cdrom": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom",
                    "description": "A specification for a CDROM device on this virtual\nmachine. See CDROM options below.\n"
                },
                "changeVersion": {
                    "type": "string",
                    "description": "A unique identifier for a given version of the last\nconfiguration applied, such the timestamp of the last update to the\nconfiguration.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                    "description": "When specified, the VM will be created as a clone of a\nspecified template. Optional customization options can be submitted as well.\nSee creating a virtual machine from a\ntemplate for more details.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual\nmachine while it is running.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be removed to this\nvirtual machine while it is running.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of CPU (in MHz) that this virtual\nmachine can consume, regardless of available resources. The default is no\nlimit.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance\ncounters on this virtual machine. Default: `false`.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of CPU (in MHz) that this virtual\nmachine is guaranteed. The default is no reservation.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The number of CPU shares allocated to the\nvirtual machine when the `cpu_share_level` is `custom`.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for CPU resources. Can be\none of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual machine.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter id. Required only when deploying\nan ovf template.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster ID to use. This setting\napplies to entire virtual machine and implies that you wish to use Storage\nDRS with this virtual machine. See the section on virtual machine\nmigration for details on changing this value.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n"
                },
                "defaultIpAddress": {
                    "type": "string",
                    "description": "The IP address selected by the provider to be used with\nany provisioners configured on this resource.\nWhenever possible, this is the first IPv4 address that is reachable through\nthe default gateway configured on the machine, then the first reachable IPv6\naddress, and then the first general discovered address if neither exist. If\nVMware tools is not running on the virtual machine, or if the VM is powered\noff, this value will be blank.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on this virtual\nmachine. See disk options below.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "When the `firmware` type is set to is\n`efi`, this enables EFI secure boot. Default: `false`.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to\nthe virtual machine, allowing access to them in the guest. Default: `false`.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging of virtual machine events to a\nlog file stored in the virtual machine directory. Default: `false`.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization)\nsetting for this virtual machine. Can be one of `automatic`, `on`, or `off`.\nDefault: `automatic`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for this virtual\nmachine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware interface to use on the virtual machine.\nCan be one of `bios` or `EFI`. Default: `bios`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The path to the folder to put this virtual machine in,\nrelative to the datacenter that the resource pool is in.\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "If a guest shutdown failed or timed out while\nupdating or destroying (see\n`shutdown_wait_timeout`), force the power-off of\nthe virtual machine. Default: `true`.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system type. For a\nfull list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.\n"
                },
                "guestIpAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The current list of IP addresses on this machine,\nincluding the value of `default_ip_address`. If VMware tools is not running\non the virtual machine, or if the VM is powered off, this list will be empty.\n* `moid`: The managed object reference ID of the created\nvirtual machine.\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version number. Valid range\nis from 4 to 15. The hardware version cannot be downgraded. See [virtual\nmachine hardware compatibility][virtual-machine-hardware-compatibility] for\nmore details.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "An optional managed object reference\nID of a host to put this virtual machine on. See the\nsection on virtual machine migration for\ndetails on changing this value. If a `host_system_id` is not supplied,\nvSphere will select a host in the resource pool to place the virtual machine,\naccording to any defaults or DRS policies in place.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The (non-nested) hardware virtualization setting for\nthis virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:\n`hvAuto`.\n"
                },
                "ideControllerCount": {
                    "type": "integer",
                    "description": "The number of IDE controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to\nignore while waiting for an available IP address using either of the waiters.\nAny IP addresses in this list will be ignored if they show up so that the\nwaiter will continue to wait for a real IP address. Default: [].\n"
                },
                "imported": {
                    "type": "boolean",
                    "description": "This is flagged if the virtual machine has been imported, or the\nstate has been migrated from a previous version of the resource. It\ninfluences the behavior of the first post-import apply operation. See the\nsection on importing below.\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the\nvirtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that\nrequire frequent access to mouse or keyboard devices. Can be one of `low`,\n`normal`, `medium`, or `high`.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The size of the virtual machine's memory, in MB.\nDefault: `1024` (1 GB).\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to this\nvirtual machine while it is running.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) that this\nvirtual machine can consume, regardless of available resources. The default\nis no limit.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) that this\nvirtual machine is guaranteed. The default is no reservation.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The number of memory shares allocated to\nthe virtual machine when the `memory_share_level` is `custom`.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for memory resources.\nCan be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait\nfor a virtual machine migration to complete before failing. Default: 10\nminutes. Also see the section on virtual machine\nmigration.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "The machine object ID from VMWare\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual machine.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on\nthis virtual machine, facilitating nested virtualization in the guest.\nDefault: `false`.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this\nvirtual machine. See network interface options\nbelow.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores per socket in this\nvirtual machine. The number of vCPUs on the virtual machine will be\n`num_cpus` divided by `num_cores_per_socket`. If specified, the value\nsupplied to `num_cpus` must be evenly divisible by this value. Default: `1`.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The total number of virtual processor cores to assign\nto this virtual machine. Default: `1`.\n"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "When specified, the VM will be deployed from the\nprovided ovf/ova template. See creating a virtual machine from a\novf/ova template for more details.\n"
                },
                "pciDeviceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of host PCI device IDs to create PCI\npassthroughs for.\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "rebootRequired": {
                    "type": "boolean",
                    "description": "Value internal to the provider used to determine if a\nconfiguration set change requires a reboot. This value is only useful during\nan update process and gets reset on refresh.\n"
                },
                "replaceTrigger": {
                    "type": "string",
                    "description": "Triggers replacement of resource whenever it changes.\n`replace_trigger = sha256(format(\"%s-%s\",data.template_file.cloud_init_metadata.rendered,data.template_file.cloud_init_userdata.rendered))`\nwill fingerprint the changes in cloud_init metadata and userdata templates. This will enable a replacement\nof the resource whenever the dependant template renders a new configuration. (Forces a replacement)\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the resource pool to put this virtual machine in.\nSee the section on virtual machine migration\nfor details on changing this value.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable the execution of\npost-power-on scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable the execution of\npost-resume scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable the execution of\npre-reboot scripts when VMware tools is installed. Default: `false`.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable the execution\nof pre-shutdown scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable the execution of\npre-standby scripts when VMware tools is installed. Default: `true`.\n"
                },
                "sataControllerCount": {
                    "type": "integer",
                    "description": "The number of SATA controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Default: `noSharing`.\n"
                },
                "scsiControllerCount": {
                    "type": "integer",
                    "description": "The number of SCSI controllers that\nthis provider manages on this virtual machine. This directly affects the amount\nof disks you can add to the virtual machine and the maximum disk unit number.\nNote that lowering this value does not remove controllers. Default: `1`.\n"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The type of SCSI bus this virtual machine will have.\nCan be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or\npvscsi (VMware Paravirtual). Defualt: `pvscsi`.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait\nfor a graceful guest shutdown when making necessary updates to the virtual\nmachine. If `force_power_off` is set to true, the VM will be force powered-off\nafter this timeout, otherwise an error is returned. Default: 3 minutes.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The UUID of the storage policy to assign to this disk.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for this\nvirtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.\nDefault: `inherit`.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable guest clock synchronization with the host.\nOn vSphere 7 U1 and above, with only this setting the clock is synchronized on\nstartup and resume so consider also setting `sync_time_with_host_periodically`.\nRequires VMware tools to be installed. Default: `false`.\n"
                },
                "syncTimeWithHostPeriodically": {
                    "type": "boolean",
                    "description": "Enable periodic clock\nsynchronization with the host. Supported only on vSphere 7 U1 and above.\nOn older versions setting `sync_time_with_host` is enough for periodic\nsynchronization. Requires VMware tools to be installed. Default: `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual disk's VMDK file. This is used to track the\nvirtual disk on the virtual machine.\n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "Optional vApp configuration. The only sub-key available\nis `properties`, which is a key/value map of properties for virtual machines\nimported from OVF or OVA files. See Using vApp properties to supply OVF/OVA\nconfiguration for\nmore details.\n"
                },
                "vappTransports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Computed value which is only valid for cloned virtual\nmachines. A list of vApp transport methods supported by the source virtual\nmachine or template.\n"
                },
                "vbsEnabled": {
                    "type": "boolean",
                    "description": "Enable Virtualization Based Security. Requires\n`firmware` to be `efi`, and `vvtd_enabled`, `nested_hv_enabled` and\n`efi_secure_boot_enabled` must all have a value of `true`. Supported on\nvSphere 6.7 and higher. Default: `false`.\n"
                },
                "vmwareToolsStatus": {
                    "type": "string",
                    "description": "The state of VMware tools in the guest. This will\ndetermine the proper course of action for some device operations.\n"
                },
                "vmxPath": {
                    "type": "string",
                    "description": "The path of the virtual machine's configuration file in the VM's\ndatastore.\n"
                },
                "vvtdEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if Intel Virtualization Technology \nfor Directed I/O is enabled for this virtual machine (_I/O MMU_ in the\nvSphere Client). Supported on vSphere 6.7 and higher. Default: `false`.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to\nwait for an available guest IP address on this virtual machine. This should\nonly be used if your version of VMware Tools does not allow the\n`wait_for_guest_net_timeout` waiter to be\nused. A value less than 1 disables the waiter. Default: 0.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest\nnetwork waiter waits for a routable address. When `false`, the waiter does\nnot wait for a default gateway, nor are IP addresses checked against any\ndiscovered default gateways as part of its success criteria. This property is\nignored if the `wait_for_guest_ip_timeout`\nwaiter is used. Default: `true`.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to\nwait for an available IP address on this virtual machine's NICs. Older\nversions of VMware Tools do not populate this property. In those cases, this\nwaiter can be disabled and the\n`wait_for_guest_ip_timeout` waiter can be used\ninstead. A value less than 1 disables the waiter. Default: 5 minutes.\n"
                }
            },
            "required": [
                "changeVersion",
                "cpuShareCount",
                "datastoreId",
                "defaultIpAddress",
                "disks",
                "guestId",
                "guestIpAddresses",
                "hardwareVersion",
                "hostSystemId",
                "imported",
                "memoryShareCount",
                "moid",
                "name",
                "rebootRequired",
                "resourcePoolId",
                "storagePolicyId",
                "uuid",
                "vappTransports",
                "vmwareToolsStatus",
                "vmxPath"
            ],
            "inputProperties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system\nwhen `guest_id` is `other` or `other-64`.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "A user-provided description of the virtual machine.\nThe default is no annotation.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting\nthe boot sequence. The default is no delay.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before\nretrying the boot sequence. This only valid if `boot_retry_enabled` is true.\nDefault: `10000` (10 seconds).\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a virtual machine that\nfails to boot will try again after the delay defined in `boot_retry_delay`.\nDefault: `false`.\n"
                },
                "cdrom": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom",
                    "description": "A specification for a CDROM device on this virtual\nmachine. See CDROM options below.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                    "description": "When specified, the VM will be created as a clone of a\nspecified template. Optional customization options can be submitted as well.\nSee creating a virtual machine from a\ntemplate for more details.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual\nmachine while it is running.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be removed to this\nvirtual machine while it is running.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of CPU (in MHz) that this virtual\nmachine can consume, regardless of available resources. The default is no\nlimit.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance\ncounters on this virtual machine. Default: `false`.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of CPU (in MHz) that this virtual\nmachine is guaranteed. The default is no reservation.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The number of CPU shares allocated to the\nvirtual machine when the `cpu_share_level` is `custom`.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for CPU resources. Can be\none of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual machine.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter id. Required only when deploying\nan ovf template.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster ID to use. This setting\napplies to entire virtual machine and implies that you wish to use Storage\nDRS with this virtual machine. See the section on virtual machine\nmigration for details on changing this value.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on this virtual\nmachine. See disk options below.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "When the `firmware` type is set to is\n`efi`, this enables EFI secure boot. Default: `false`.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to\nthe virtual machine, allowing access to them in the guest. Default: `false`.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging of virtual machine events to a\nlog file stored in the virtual machine directory. Default: `false`.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization)\nsetting for this virtual machine. Can be one of `automatic`, `on`, or `off`.\nDefault: `automatic`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for this virtual\nmachine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware interface to use on the virtual machine.\nCan be one of `bios` or `EFI`. Default: `bios`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The path to the folder to put this virtual machine in,\nrelative to the datacenter that the resource pool is in.\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "If a guest shutdown failed or timed out while\nupdating or destroying (see\n`shutdown_wait_timeout`), force the power-off of\nthe virtual machine. Default: `true`.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system type. For a\nfull list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version number. Valid range\nis from 4 to 15. The hardware version cannot be downgraded. See [virtual\nmachine hardware compatibility][virtual-machine-hardware-compatibility] for\nmore details.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "An optional managed object reference\nID of a host to put this virtual machine on. See the\nsection on virtual machine migration for\ndetails on changing this value. If a `host_system_id` is not supplied,\nvSphere will select a host in the resource pool to place the virtual machine,\naccording to any defaults or DRS policies in place.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The (non-nested) hardware virtualization setting for\nthis virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:\n`hvAuto`.\n"
                },
                "ideControllerCount": {
                    "type": "integer",
                    "description": "The number of IDE controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to\nignore while waiting for an available IP address using either of the waiters.\nAny IP addresses in this list will be ignored if they show up so that the\nwaiter will continue to wait for a real IP address. Default: [].\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the\nvirtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that\nrequire frequent access to mouse or keyboard devices. Can be one of `low`,\n`normal`, `medium`, or `high`.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The size of the virtual machine's memory, in MB.\nDefault: `1024` (1 GB).\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to this\nvirtual machine while it is running.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) that this\nvirtual machine can consume, regardless of available resources. The default\nis no limit.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) that this\nvirtual machine is guaranteed. The default is no reservation.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The number of memory shares allocated to\nthe virtual machine when the `memory_share_level` is `custom`.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for memory resources.\nCan be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait\nfor a virtual machine migration to complete before failing. Default: 10\nminutes. Also see the section on virtual machine\nmigration.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual machine.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on\nthis virtual machine, facilitating nested virtualization in the guest.\nDefault: `false`.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this\nvirtual machine. See network interface options\nbelow.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores per socket in this\nvirtual machine. The number of vCPUs on the virtual machine will be\n`num_cpus` divided by `num_cores_per_socket`. If specified, the value\nsupplied to `num_cpus` must be evenly divisible by this value. Default: `1`.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The total number of virtual processor cores to assign\nto this virtual machine. Default: `1`.\n"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "When specified, the VM will be deployed from the\nprovided ovf/ova template. See creating a virtual machine from a\novf/ova template for more details.\n"
                },
                "pciDeviceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of host PCI device IDs to create PCI\npassthroughs for.\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "replaceTrigger": {
                    "type": "string",
                    "description": "Triggers replacement of resource whenever it changes.\n`replace_trigger = sha256(format(\"%s-%s\",data.template_file.cloud_init_metadata.rendered,data.template_file.cloud_init_userdata.rendered))`\nwill fingerprint the changes in cloud_init metadata and userdata templates. This will enable a replacement\nof the resource whenever the dependant template renders a new configuration. (Forces a replacement)\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the resource pool to put this virtual machine in.\nSee the section on virtual machine migration\nfor details on changing this value.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable the execution of\npost-power-on scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable the execution of\npost-resume scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable the execution of\npre-reboot scripts when VMware tools is installed. Default: `false`.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable the execution\nof pre-shutdown scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable the execution of\npre-standby scripts when VMware tools is installed. Default: `true`.\n"
                },
                "sataControllerCount": {
                    "type": "integer",
                    "description": "The number of SATA controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Default: `noSharing`.\n"
                },
                "scsiControllerCount": {
                    "type": "integer",
                    "description": "The number of SCSI controllers that\nthis provider manages on this virtual machine. This directly affects the amount\nof disks you can add to the virtual machine and the maximum disk unit number.\nNote that lowering this value does not remove controllers. Default: `1`.\n"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The type of SCSI bus this virtual machine will have.\nCan be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or\npvscsi (VMware Paravirtual). Defualt: `pvscsi`.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait\nfor a graceful guest shutdown when making necessary updates to the virtual\nmachine. If `force_power_off` is set to true, the VM will be force powered-off\nafter this timeout, otherwise an error is returned. Default: 3 minutes.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The UUID of the storage policy to assign to this disk.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for this\nvirtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.\nDefault: `inherit`.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable guest clock synchronization with the host.\nOn vSphere 7 U1 and above, with only this setting the clock is synchronized on\nstartup and resume so consider also setting `sync_time_with_host_periodically`.\nRequires VMware tools to be installed. Default: `false`.\n"
                },
                "syncTimeWithHostPeriodically": {
                    "type": "boolean",
                    "description": "Enable periodic clock\nsynchronization with the host. Supported only on vSphere 7 U1 and above.\nOn older versions setting `sync_time_with_host` is enough for periodic\nsynchronization. Requires VMware tools to be installed. Default: `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "Optional vApp configuration. The only sub-key available\nis `properties`, which is a key/value map of properties for virtual machines\nimported from OVF or OVA files. See Using vApp properties to supply OVF/OVA\nconfiguration for\nmore details.\n"
                },
                "vbsEnabled": {
                    "type": "boolean",
                    "description": "Enable Virtualization Based Security. Requires\n`firmware` to be `efi`, and `vvtd_enabled`, `nested_hv_enabled` and\n`efi_secure_boot_enabled` must all have a value of `true`. Supported on\nvSphere 6.7 and higher. Default: `false`.\n"
                },
                "vvtdEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if Intel Virtualization Technology \nfor Directed I/O is enabled for this virtual machine (_I/O MMU_ in the\nvSphere Client). Supported on vSphere 6.7 and higher. Default: `false`.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to\nwait for an available guest IP address on this virtual machine. This should\nonly be used if your version of VMware Tools does not allow the\n`wait_for_guest_net_timeout` waiter to be\nused. A value less than 1 disables the waiter. Default: 0.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest\nnetwork waiter waits for a routable address. When `false`, the waiter does\nnot wait for a default gateway, nor are IP addresses checked against any\ndiscovered default gateways as part of its success criteria. This property is\nignored if the `wait_for_guest_ip_timeout`\nwaiter is used. Default: `true`.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to\nwait for an available IP address on this virtual machine's NICs. Older\nversions of VMware Tools do not populate this property. In those cases, this\nwaiter can be disabled and the\n`wait_for_guest_ip_timeout` waiter can be used\ninstead. A value less than 1 disables the waiter. Default: 5 minutes.\n"
                }
            },
            "requiredInputs": [
                "resourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachine resources.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The guest name for the operating system\nwhen `guest_id` is `other` or `other-64`.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "A user-provided description of the virtual machine.\nThe default is no annotation.\n"
                    },
                    "bootDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before starting\nthe boot sequence. The default is no delay.\n"
                    },
                    "bootRetryDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before\nretrying the boot sequence. This only valid if `boot_retry_enabled` is true.\nDefault: `10000` (10 seconds).\n"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean",
                        "description": "If set to true, a virtual machine that\nfails to boot will try again after the delay defined in `boot_retry_delay`.\nDefault: `false`.\n"
                    },
                    "cdrom": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom",
                        "description": "A specification for a CDROM device on this virtual\nmachine. See CDROM options below.\n"
                    },
                    "changeVersion": {
                        "type": "string",
                        "description": "A unique identifier for a given version of the last\nconfiguration applied, such the timestamp of the last update to the\nconfiguration.\n"
                    },
                    "clone": {
                        "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                        "description": "When specified, the VM will be created as a clone of a\nspecified template. Optional customization options can be submitted as well.\nSee creating a virtual machine from a\ntemplate for more details.\n"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to this virtual\nmachine while it is running.\n"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be removed to this\nvirtual machine while it is running.\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The maximum amount of CPU (in MHz) that this virtual\nmachine can consume, regardless of available resources. The default is no\nlimit.\n"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean",
                        "description": "Enable CPU performance\ncounters on this virtual machine. Default: `false`.\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "The amount of CPU (in MHz) that this virtual\nmachine is guaranteed. The default is no reservation.\n"
                    },
                    "cpuShareCount": {
                        "type": "integer",
                        "description": "The number of CPU shares allocated to the\nvirtual machine when the `cpu_share_level` is `custom`.\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The allocation level for CPU resources. Can be\none of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual machine.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The datacenter id. Required only when deploying\nan ovf template.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster ID to use. This setting\napplies to entire virtual machine and implies that you wish to use Storage\nDRS with this virtual machine. See the section on virtual machine\nmigration for details on changing this value.\n"
                    },
                    "datastoreId": {
                        "type": "string",
                        "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n"
                    },
                    "defaultIpAddress": {
                        "type": "string",
                        "description": "The IP address selected by the provider to be used with\nany provisioners configured on this resource.\nWhenever possible, this is the first IPv4 address that is reachable through\nthe default gateway configured on the machine, then the first reachable IPv6\naddress, and then the first general discovered address if neither exist. If\nVMware tools is not running on the virtual machine, or if the VM is powered\noff, this value will be blank.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                        },
                        "description": "A specification for a virtual disk device on this virtual\nmachine. See disk options below.\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean",
                        "description": "When the `firmware` type is set to is\n`efi`, this enables EFI secure boot. Default: `false`.\n"
                    },
                    "enableDiskUuid": {
                        "type": "boolean",
                        "description": "Expose the UUIDs of attached virtual disks to\nthe virtual machine, allowing access to them in the guest. Default: `false`.\n"
                    },
                    "enableLogging": {
                        "type": "boolean",
                        "description": "Enable logging of virtual machine events to a\nlog file stored in the virtual machine directory. Default: `false`.\n"
                    },
                    "eptRviMode": {
                        "type": "string",
                        "description": "The EPT/RVI (hardware memory virtualization)\nsetting for this virtual machine. Can be one of `automatic`, `on`, or `off`.\nDefault: `automatic`.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Extra configuration data for this virtual\nmachine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata.\n"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware interface to use on the virtual machine.\nCan be one of `bios` or `EFI`. Default: `bios`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The path to the folder to put this virtual machine in,\nrelative to the datacenter that the resource pool is in.\n"
                    },
                    "forcePowerOff": {
                        "type": "boolean",
                        "description": "If a guest shutdown failed or timed out while\nupdating or destroying (see\n`shutdown_wait_timeout`), force the power-off of\nthe virtual machine. Default: `true`.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID for the operating system type. For a\nfull list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.\n"
                    },
                    "guestIpAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The current list of IP addresses on this machine,\nincluding the value of `default_ip_address`. If VMware tools is not running\non the virtual machine, or if the VM is powered off, this list will be empty.\n* `moid`: The managed object reference ID of the created\nvirtual machine.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version number. Valid range\nis from 4 to 15. The hardware version cannot be downgraded. See [virtual\nmachine hardware compatibility][virtual-machine-hardware-compatibility] for\nmore details.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "An optional managed object reference\nID of a host to put this virtual machine on. See the\nsection on virtual machine migration for\ndetails on changing this value. If a `host_system_id` is not supplied,\nvSphere will select a host in the resource pool to place the virtual machine,\naccording to any defaults or DRS policies in place.\n"
                    },
                    "hvMode": {
                        "type": "string",
                        "description": "The (non-nested) hardware virtualization setting for\nthis virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:\n`hvAuto`.\n"
                    },
                    "ideControllerCount": {
                        "type": "integer",
                        "description": "The number of IDE controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                    },
                    "ignoredGuestIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP addresses and CIDR networks to\nignore while waiting for an available IP address using either of the waiters.\nAny IP addresses in this list will be ignored if they show up so that the\nwaiter will continue to wait for a real IP address. Default: [].\n"
                    },
                    "imported": {
                        "type": "boolean",
                        "description": "This is flagged if the virtual machine has been imported, or the\nstate has been migrated from a previous version of the resource. It\ninfluences the behavior of the first post-import apply operation. See the\nsection on importing below.\n"
                    },
                    "latencySensitivity": {
                        "type": "string",
                        "description": "Controls the scheduling delay of the\nvirtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that\nrequire frequent access to mouse or keyboard devices. Can be one of `low`,\n`normal`, `medium`, or `high`.\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\nDefault: `1024` (1 GB).\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow memory to be added to this\nvirtual machine while it is running.\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The maximum amount of memory (in MB) that this\nvirtual machine can consume, regardless of available resources. The default\nis no limit.\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "The amount of memory (in MB) that this\nvirtual machine is guaranteed. The default is no reservation.\n"
                    },
                    "memoryShareCount": {
                        "type": "integer",
                        "description": "The number of memory shares allocated to\nthe virtual machine when the `memory_share_level` is `custom`.\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The allocation level for memory resources.\nCan be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                    },
                    "migrateWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait\nfor a virtual machine migration to complete before failing. Default: 10\nminutes. Also see the section on virtual machine\nmigration.\n"
                    },
                    "moid": {
                        "type": "string",
                        "description": "The machine object ID from VMWare\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual machine.\n"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean",
                        "description": "Enable nested hardware virtualization on\nthis virtual machine, facilitating nested virtualization in the guest.\nDefault: `false`.\n"
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                        },
                        "description": "A specification for a virtual NIC on this\nvirtual machine. See network interface options\nbelow.\n"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per socket in this\nvirtual machine. The number of vCPUs on the virtual machine will be\n`num_cpus` divided by `num_cores_per_socket`. If specified, the value\nsupplied to `num_cpus` must be evenly divisible by this value. Default: `1`.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The total number of virtual processor cores to assign\nto this virtual machine. Default: `1`.\n"
                    },
                    "ovfDeploy": {
                        "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                        "description": "When specified, the VM will be deployed from the\nprovided ovf/ova template. See creating a virtual machine from a\novf/ova template for more details.\n"
                    },
                    "pciDeviceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of host PCI device IDs to create PCI\npassthroughs for.\n"
                    },
                    "poweronTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                    },
                    "rebootRequired": {
                        "type": "boolean",
                        "description": "Value internal to the provider used to determine if a\nconfiguration set change requires a reboot. This value is only useful during\nan update process and gets reset on refresh.\n"
                    },
                    "replaceTrigger": {
                        "type": "string",
                        "description": "Triggers replacement of resource whenever it changes.\n`replace_trigger = sha256(format(\"%s-%s\",data.template_file.cloud_init_metadata.rendered,data.template_file.cloud_init_userdata.rendered))`\nwill fingerprint the changes in cloud_init metadata and userdata templates. This will enable a replacement\nof the resource whenever the dependant template renders a new configuration. (Forces a replacement)\n"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the resource pool to put this virtual machine in.\nSee the section on virtual machine migration\nfor details on changing this value.\n"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean",
                        "description": "Enable the execution of\npost-power-on scripts when VMware tools is installed. Default: `true`.\n"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean",
                        "description": "Enable the execution of\npost-resume scripts when VMware tools is installed. Default: `true`.\n"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean",
                        "description": "Enable the execution of\npre-reboot scripts when VMware tools is installed. Default: `false`.\n"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean",
                        "description": "Enable the execution\nof pre-shutdown scripts when VMware tools is installed. Default: `true`.\n"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean",
                        "description": "Enable the execution of\npre-standby scripts when VMware tools is installed. Default: `true`.\n"
                    },
                    "sataControllerCount": {
                        "type": "integer",
                        "description": "The number of SATA controllers that Terraform manages on this virtual machine. This directly affects the amount of disks\nyou can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove\ncontrollers.\n"
                    },
                    "scsiBusSharing": {
                        "type": "string",
                        "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Default: `noSharing`.\n"
                    },
                    "scsiControllerCount": {
                        "type": "integer",
                        "description": "The number of SCSI controllers that\nthis provider manages on this virtual machine. This directly affects the amount\nof disks you can add to the virtual machine and the maximum disk unit number.\nNote that lowering this value does not remove controllers. Default: `1`.\n"
                    },
                    "scsiType": {
                        "type": "string",
                        "description": "The type of SCSI bus this virtual machine will have.\nCan be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or\npvscsi (VMware Paravirtual). Defualt: `pvscsi`.\n"
                    },
                    "shutdownWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait\nfor a graceful guest shutdown when making necessary updates to the virtual\nmachine. If `force_power_off` is set to true, the VM will be force powered-off\nafter this timeout, otherwise an error is returned. Default: 3 minutes.\n"
                    },
                    "storagePolicyId": {
                        "type": "string",
                        "description": "The UUID of the storage policy to assign to this disk.\n"
                    },
                    "swapPlacementPolicy": {
                        "type": "string",
                        "description": "The swap file placement policy for this\nvirtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.\nDefault: `inherit`.\n"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean",
                        "description": "Enable guest clock synchronization with the host.\nOn vSphere 7 U1 and above, with only this setting the clock is synchronized on\nstartup and resume so consider also setting `sync_time_with_host_periodically`.\nRequires VMware tools to be installed. Default: `false`.\n"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean",
                        "description": "Enable periodic clock\nsynchronization with the host. Supported only on vSphere 7 U1 and above.\nOn older versions setting `sync_time_with_host` is enough for periodic\nsynchronization. Requires VMware tools to be installed. Default: `false`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "The UUID of the virtual disk's VMDK file. This is used to track the\nvirtual disk on the virtual machine.\n"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                        "description": "Optional vApp configuration. The only sub-key available\nis `properties`, which is a key/value map of properties for virtual machines\nimported from OVF or OVA files. See Using vApp properties to supply OVF/OVA\nconfiguration for\nmore details.\n"
                    },
                    "vappTransports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Computed value which is only valid for cloned virtual\nmachines. A list of vApp transport methods supported by the source virtual\nmachine or template.\n"
                    },
                    "vbsEnabled": {
                        "type": "boolean",
                        "description": "Enable Virtualization Based Security. Requires\n`firmware` to be `efi`, and `vvtd_enabled`, `nested_hv_enabled` and\n`efi_secure_boot_enabled` must all have a value of `true`. Supported on\nvSphere 6.7 and higher. Default: `false`.\n"
                    },
                    "vmwareToolsStatus": {
                        "type": "string",
                        "description": "The state of VMware tools in the guest. This will\ndetermine the proper course of action for some device operations.\n"
                    },
                    "vmxPath": {
                        "type": "string",
                        "description": "The path of the virtual machine's configuration file in the VM's\ndatastore.\n"
                    },
                    "vvtdEnabled": {
                        "type": "boolean",
                        "description": "Flag to specify if Intel Virtualization Technology \nfor Directed I/O is enabled for this virtual machine (_I/O MMU_ in the\nvSphere Client). Supported on vSphere 6.7 and higher. Default: `false`.\n"
                    },
                    "waitForGuestIpTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to\nwait for an available guest IP address on this virtual machine. This should\nonly be used if your version of VMware Tools does not allow the\n`wait_for_guest_net_timeout` waiter to be\nused. A value less than 1 disables the waiter. Default: 0.\n"
                    },
                    "waitForGuestNetRoutable": {
                        "type": "boolean",
                        "description": "Controls whether or not the guest\nnetwork waiter waits for a routable address. When `false`, the waiter does\nnot wait for a default gateway, nor are IP addresses checked against any\ndiscovered default gateways as part of its success criteria. This property is\nignored if the `wait_for_guest_ip_timeout`\nwaiter is used. Default: `true`.\n"
                    },
                    "waitForGuestNetTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to\nwait for an available IP address on this virtual machine's NICs. Older\nversions of VMware Tools do not populate this property. In those cases, this\nwaiter can be disabled and the\n`wait_for_guest_ip_timeout` waiter can be used\ninstead. A value less than 1 disables the waiter. Default: 5 minutes.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachineSnapshot:VirtualMachineSnapshot": {
            "description": "The `vsphere.VirtualMachineSnapshot` resource can be used to manage snapshots\nfor a virtual machine.\n\nFor more information on managing snapshots and how they work in VMware, see\n[here][ext-vm-snapshot-management].\n\n[ext-vm-snapshot-management]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-CA948C69-7F58-4519-AEB1-739545EA94E5.html\n\n\u003e **NOTE:** A snapshot in VMware differs from traditional disk snapshots, and\ncan contain the actual running state of the virtual machine, data for all disks\nthat have not been set to be independent from the snapshot (including ones that\nhave been attached via the `attach`\nparameter to the `vsphere.VirtualMachine` `disk` block), and even the\nconfiguration of the virtual machine at the time of the snapshot. Virtual\nmachine, disk activity, and configuration changes post-snapshot are not\nincluded in the original state. Use this resource with care! Neither VMware nor\nHashiCorp recommends retaining snapshots for a extended period of time and does\nNOT recommend using them as as backup feature. For more information on the\nlimitation of virtual machine snapshots, see [here][ext-vm-snap-limitations].\n\n[ext-vm-snap-limitations]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-53F65726-A23B-4CF0-A7D5-48E584B88613.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst demo1 = new vsphere.VirtualMachineSnapshot(\"demo1\", {\n    consolidate: true,\n    description: \"This is Demo Snapshot\",\n    memory: true,\n    quiesce: true,\n    removeChildren: false,\n    snapshotName: \"Snapshot Name\",\n    virtualMachineUuid: \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndemo1 = vsphere.VirtualMachineSnapshot(\"demo1\",\n    consolidate=True,\n    description=\"This is Demo Snapshot\",\n    memory=True,\n    quiesce=True,\n    remove_children=False,\n    snapshot_name=\"Snapshot Name\",\n    virtual_machine_uuid=\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demo1 = new VSphere.VirtualMachineSnapshot(\"demo1\", new VSphere.VirtualMachineSnapshotArgs\n        {\n            Consolidate = true,\n            Description = \"This is Demo Snapshot\",\n            Memory = true,\n            Quiesce = true,\n            RemoveChildren = false,\n            SnapshotName = \"Snapshot Name\",\n            VirtualMachineUuid = \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachineSnapshot(ctx, \"demo1\", \u0026vsphere.VirtualMachineSnapshotArgs{\n\t\t\tConsolidate:        pulumi.Bool(true),\n\t\t\tDescription:        pulumi.String(\"This is Demo Snapshot\"),\n\t\t\tMemory:             pulumi.Bool(true),\n\t\t\tQuiesce:            pulumi.Bool(true),\n\t\t\tRemoveChildren:     pulumi.Bool(false),\n\t\t\tSnapshotName:       pulumi.String(\"Snapshot Name\"),\n\t\t\tVirtualMachineUuid: pulumi.String(\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n"
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n"
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n"
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n"
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n"
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n"
                }
            },
            "required": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "inputProperties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n"
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n"
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n"
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n"
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n"
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n"
                }
            },
            "requiredInputs": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachineSnapshot resources.\n",
                "properties": {
                    "consolidate": {
                        "type": "boolean",
                        "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the snapshot.\n"
                    },
                    "memory": {
                        "type": "boolean",
                        "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n"
                    },
                    "quiesce": {
                        "type": "boolean",
                        "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n"
                    },
                    "removeChildren": {
                        "type": "boolean",
                        "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n"
                    },
                    "snapshotName": {
                        "type": "string",
                        "description": "The name of the snapshot.\n"
                    },
                    "virtualMachineUuid": {
                        "type": "string",
                        "description": "The virtual machine UUID.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vmStoragePolicy:VmStoragePolicy": {
            "description": "The `vsphere.VmStoragePolicy` resource can be used to create and manage storage \npolicies. Using this storage policy, tag based placement rules can be created to \nplace a VM on a particular tagged datastore.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example creates a storage policy with tag_rule having cat1 as tag_category and \ntag1, tag2 as the tags. While creating a VM, this policy can be referenced to place \nthe VM in any of the compatible datastore tagged with these tags.\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = vsphere.getDatacenter({\n    name: \"DC\",\n});\nconst tagCategory = vsphere.getTagCategory({\n    name: \"cat1\",\n});\nconst tag1 = tagCategory.then(tagCategory =\u003e vsphere.getTag({\n    name: \"tag1\",\n    categoryId: tagCategory.id,\n}));\nconst tag2 = tagCategory.then(tagCategory =\u003e vsphere.getTag({\n    name: \"tag2\",\n    categoryId: tagCategory.id,\n}));\nconst policyTagBasedPlacement = new vsphere.VmStoragePolicy(\"policyTagBasedPlacement\", {\n    description: \"description\",\n    tagRules: [{\n        tagCategory: tagCategory.then(tagCategory =\u003e tagCategory.name),\n        tags: [\n            tag1.then(tag1 =\u003e tag1.name),\n            tag2.then(tag2 =\u003e tag2.name),\n        ],\n        includeDatastoresWithTags: true,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"DC\")\ntag_category = vsphere.get_tag_category(name=\"cat1\")\ntag1 = vsphere.get_tag(name=\"tag1\",\n    category_id=tag_category.id)\ntag2 = vsphere.get_tag(name=\"tag2\",\n    category_id=tag_category.id)\npolicy_tag_based_placement = vsphere.VmStoragePolicy(\"policyTagBasedPlacement\",\n    description=\"description\",\n    tag_rules=[vsphere.VmStoragePolicyTagRuleArgs(\n        tag_category=tag_category.name,\n        tags=[\n            tag1.name,\n            tag2.name,\n        ],\n        include_datastores_with_tags=True,\n    )])\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"DC\",\n        }));\n        var tagCategory = Output.Create(VSphere.GetTagCategory.InvokeAsync(new VSphere.GetTagCategoryArgs\n        {\n            Name = \"cat1\",\n        }));\n        var tag1 = tagCategory.Apply(tagCategory =\u003e Output.Create(VSphere.GetTag.InvokeAsync(new VSphere.GetTagArgs\n        {\n            Name = \"tag1\",\n            CategoryId = tagCategory.Id,\n        })));\n        var tag2 = tagCategory.Apply(tagCategory =\u003e Output.Create(VSphere.GetTag.InvokeAsync(new VSphere.GetTagArgs\n        {\n            Name = \"tag2\",\n            CategoryId = tagCategory.Id,\n        })));\n        var policyTagBasedPlacement = new VSphere.VmStoragePolicy(\"policyTagBasedPlacement\", new VSphere.VmStoragePolicyArgs\n        {\n            Description = \"description\",\n            TagRules = \n            {\n                new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n                {\n                    TagCategory = tagCategory.Apply(tagCategory =\u003e tagCategory.Name),\n                    Tags = \n                    {\n                        tag1.Apply(tag1 =\u003e tag1.Name),\n                        tag2.Apply(tag2 =\u003e tag2.Name),\n                    },\n                    IncludeDatastoresWithTags = true,\n                },\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"DC\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttagCategory, err := vsphere.LookupTagCategory(ctx, \u0026GetTagCategoryArgs{\n\t\t\tName: \"cat1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttag1, err := vsphere.LookupTag(ctx, \u0026GetTagArgs{\n\t\t\tName:       \"tag1\",\n\t\t\tCategoryId: tagCategory.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttag2, err := vsphere.LookupTag(ctx, \u0026GetTagArgs{\n\t\t\tName:       \"tag2\",\n\t\t\tCategoryId: tagCategory.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVmStoragePolicy(ctx, \"policyTagBasedPlacement\", \u0026vsphere.VmStoragePolicyArgs{\n\t\t\tDescription: pulumi.String(\"description\"),\n\t\t\tTagRules: VmStoragePolicyTagRuleArray{\n\t\t\t\t\u0026VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.String(tagCategory.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(tag1.Name),\n\t\t\t\t\t\tpulumi.String(tag2.Name),\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the storage policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "tagRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                    },
                    "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                }
            },
            "required": [
                "name",
                "tagRules"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the storage policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "tagRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                    },
                    "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                }
            },
            "requiredInputs": [
                "tagRules"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmStoragePolicy resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the storage policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    },
                    "tagRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                        },
                        "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vmfsDatastore:VmfsDatastore": {
            "properties": {
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "disks",
                "freeSpace",
                "hostSystemId",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "disks",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmfsDatastore resources.\n",
                "properties": {
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The disks to use with the datastore.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n"
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vnic:Vnic": {
            "description": "Provides a VMware vSphere vnic resource.\n\n{{% examples %}}\n## Example Usage\n\n### S\n{{% example %}}\n### Create a vnic attached to a distributed virtual switch using the vmotion TCP/IP stack\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = vsphere.getDatacenter({\n    name: \"mydc\",\n});\nconst h1 = dc.then(dc =\u003e vsphere.getHost({\n    name: \"esxi1.host.test\",\n    datacenterId: dc.id,\n}));\nconst d1 = new vsphere.DistributedVirtualSwitch(\"d1\", {\n    datacenterId: dc.then(dc =\u003e dc.id),\n    hosts: [{\n        hostSystemId: h1.then(h1 =\u003e h1.id),\n        devices: [\"vnic3\"],\n    }],\n});\nconst p1 = new vsphere.DistributedPortGroup(\"p1\", {\n    vlanId: 1234,\n    distributedVirtualSwitchUuid: d1.id,\n});\nconst v1 = new vsphere.Vnic(\"v1\", {\n    host: h1.then(h1 =\u003e h1.id),\n    distributedSwitchPort: d1.id,\n    distributedPortGroup: p1.id,\n    ipv4: {\n        dhcp: true,\n    },\n    netstack: \"vmotion\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"mydc\")\nh1 = vsphere.get_host(name=\"esxi1.host.test\",\n    datacenter_id=dc.id)\nd1 = vsphere.DistributedVirtualSwitch(\"d1\",\n    datacenter_id=dc.id,\n    hosts=[vsphere.DistributedVirtualSwitchHostArgs(\n        host_system_id=h1.id,\n        devices=[\"vnic3\"],\n    )])\np1 = vsphere.DistributedPortGroup(\"p1\",\n    vlan_id=1234,\n    distributed_virtual_switch_uuid=d1.id)\nv1 = vsphere.Vnic(\"v1\",\n    host=h1.id,\n    distributed_switch_port=d1.id,\n    distributed_port_group=p1.id,\n    ipv4=vsphere.VnicIpv4Args(\n        dhcp=True,\n    ),\n    netstack=\"vmotion\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"mydc\",\n        }));\n        var h1 = dc.Apply(dc =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            Name = \"esxi1.host.test\",\n            DatacenterId = dc.Id,\n        })));\n        var d1 = new VSphere.DistributedVirtualSwitch(\"d1\", new VSphere.DistributedVirtualSwitchArgs\n        {\n            DatacenterId = dc.Apply(dc =\u003e dc.Id),\n            Hosts = \n            {\n                new VSphere.Inputs.DistributedVirtualSwitchHostArgs\n                {\n                    HostSystemId = h1.Apply(h1 =\u003e h1.Id),\n                    Devices = \n                    {\n                        \"vnic3\",\n                    },\n                },\n            },\n        });\n        var p1 = new VSphere.DistributedPortGroup(\"p1\", new VSphere.DistributedPortGroupArgs\n        {\n            VlanId = 1234,\n            DistributedVirtualSwitchUuid = d1.Id,\n        });\n        var v1 = new VSphere.Vnic(\"v1\", new VSphere.VnicArgs\n        {\n            Host = h1.Apply(h1 =\u003e h1.Id),\n            DistributedSwitchPort = d1.Id,\n            DistributedPortGroup = p1.Id,\n            Ipv4 = new VSphere.Inputs.VnicIpv4Args\n            {\n                Dhcp = true,\n            },\n            Netstack = \"vmotion\",\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdc, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"mydc\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\th1, err := vsphere.LookupHost(ctx, \u0026GetHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi1.host.test\"),\n\t\t\tDatacenterId: dc.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\td1, err := vsphere.NewDistributedVirtualSwitch(ctx, \"d1\", \u0026vsphere.DistributedVirtualSwitchArgs{\n\t\t\tDatacenterId: pulumi.String(dc.Id),\n\t\t\tHosts: DistributedVirtualSwitchHostArray{\n\t\t\t\t\u0026DistributedVirtualSwitchHostArgs{\n\t\t\t\t\tHostSystemId: pulumi.String(h1.Id),\n\t\t\t\t\tDevices: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"vnic3\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp1, err := vsphere.NewDistributedPortGroup(ctx, \"p1\", \u0026vsphere.DistributedPortGroupArgs{\n\t\t\tVlanId:                       pulumi.Int(1234),\n\t\t\tDistributedVirtualSwitchUuid: d1.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVnic(ctx, \"v1\", \u0026vsphere.VnicArgs{\n\t\t\tHost:                  pulumi.String(h1.Id),\n\t\t\tDistributedSwitchPort: d1.ID(),\n\t\t\tDistributedPortGroup:  p1.ID(),\n\t\t\tIpv4: \u0026VnicIpv4Args{\n\t\t\t\tDhcp: pulumi.Bool(true),\n\t\t\t},\n\t\t\tNetstack: pulumi.String(\"vmotion\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Create a vnic attached to a portgroup using the default TCP/IP stack\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = vsphere.getDatacenter({\n    name: \"mydc\",\n});\nconst h1 = dc.then(dc =\u003e vsphere.getHost({\n    name: \"esxi1.host.test\",\n    datacenterId: dc.id,\n}));\nconst hvs1 = new vsphere.HostVirtualSwitch(\"hvs1\", {\n    hostSystemId: h1.then(h1 =\u003e h1.id),\n    networkAdapters: [\n        \"vmnic3\",\n        \"vmnic4\",\n    ],\n    activeNics: [\"vmnic3\"],\n    standbyNics: [\"vmnic4\"],\n});\nconst p1 = new vsphere.HostPortGroup(\"p1\", {\n    virtualSwitchName: hvs1.name,\n    hostSystemId: h1.then(h1 =\u003e h1.id),\n});\nconst v1 = new vsphere.Vnic(\"v1\", {\n    host: h1.then(h1 =\u003e h1.id),\n    portgroup: p1.name,\n    ipv4: {\n        dhcp: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"mydc\")\nh1 = vsphere.get_host(name=\"esxi1.host.test\",\n    datacenter_id=dc.id)\nhvs1 = vsphere.HostVirtualSwitch(\"hvs1\",\n    host_system_id=h1.id,\n    network_adapters=[\n        \"vmnic3\",\n        \"vmnic4\",\n    ],\n    active_nics=[\"vmnic3\"],\n    standby_nics=[\"vmnic4\"])\np1 = vsphere.HostPortGroup(\"p1\",\n    virtual_switch_name=hvs1.name,\n    host_system_id=h1.id)\nv1 = vsphere.Vnic(\"v1\",\n    host=h1.id,\n    portgroup=p1.name,\n    ipv4=vsphere.VnicIpv4Args(\n        dhcp=True,\n    ))\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"mydc\",\n        }));\n        var h1 = dc.Apply(dc =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            Name = \"esxi1.host.test\",\n            DatacenterId = dc.Id,\n        })));\n        var hvs1 = new VSphere.HostVirtualSwitch(\"hvs1\", new VSphere.HostVirtualSwitchArgs\n        {\n            HostSystemId = h1.Apply(h1 =\u003e h1.Id),\n            NetworkAdapters = \n            {\n                \"vmnic3\",\n                \"vmnic4\",\n            },\n            ActiveNics = \n            {\n                \"vmnic3\",\n            },\n            StandbyNics = \n            {\n                \"vmnic4\",\n            },\n        });\n        var p1 = new VSphere.HostPortGroup(\"p1\", new VSphere.HostPortGroupArgs\n        {\n            VirtualSwitchName = hvs1.Name,\n            HostSystemId = h1.Apply(h1 =\u003e h1.Id),\n        });\n        var v1 = new VSphere.Vnic(\"v1\", new VSphere.VnicArgs\n        {\n            Host = h1.Apply(h1 =\u003e h1.Id),\n            Portgroup = p1.Name,\n            Ipv4 = new VSphere.Inputs.VnicIpv4Args\n            {\n                Dhcp = true,\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdc, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"mydc\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\th1, err := vsphere.LookupHost(ctx, \u0026GetHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi1.host.test\"),\n\t\t\tDatacenterId: dc.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thvs1, err := vsphere.NewHostVirtualSwitch(ctx, \"hvs1\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tHostSystemId: pulumi.String(h1.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic3\"),\n\t\t\t\tpulumi.String(\"vmnic4\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic3\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tp1, err := vsphere.NewHostPortGroup(ctx, \"p1\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tVirtualSwitchName: hvs1.Name,\n\t\t\tHostSystemId:      pulumi.String(h1.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVnic(ctx, \"v1\", \u0026vsphere.VnicArgs{\n\t\t\tHost:      pulumi.String(h1.Id),\n\t\t\tPortgroup: p1.Name,\n\t\t\tIpv4: \u0026VnicIpv4Args{\n\t\t\t\tDhcp: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}\n## Importing \n\nAn existing vNic can be [imported][docs-import] into this resource\nvia supplying the vNic's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\treturn nil\n\t})\n}\n```\n\nThe above would import the vnic `vmk2` from host with ID `host-123`.\n",
            "properties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to.\n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n"
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See  ipv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See  ipv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default: `defaultTcpipStack`)\n"
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                }
            },
            "required": [
                "host",
                "mac",
                "mtu"
            ],
            "inputProperties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to.\n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n"
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See  ipv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See  ipv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default: `defaultTcpipStack`)\n"
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                }
            },
            "requiredInputs": [
                "host"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vnic resources.\n",
                "properties": {
                    "distributedPortGroup": {
                        "type": "string",
                        "description": "Key of the distributed portgroup the nic will connect to.\n"
                    },
                    "distributedSwitchPort": {
                        "type": "string",
                        "description": "UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.\n"
                    },
                    "host": {
                        "type": "string",
                        "description": "ESX host the interface belongs to\n"
                    },
                    "ipv4": {
                        "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                        "description": "IPv4 settings. Either this or `ipv6` needs to be set. See  ipv4 options below.\n"
                    },
                    "ipv6": {
                        "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                        "description": "IPv6 settings. Either this or `ipv6` needs to be set. See  ipv6 options below.\n"
                    },
                    "mac": {
                        "type": "string",
                        "description": "MAC address of the interface.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "MTU of the interface.\n"
                    },
                    "netstack": {
                        "type": "string",
                        "description": "TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default: `defaultTcpipStack`)\n"
                    },
                    "portgroup": {
                        "type": "string",
                        "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "vsphere:index/getComputeCluster:getComputeCluster": {
            "description": "The `vsphere.ComputeCluster` data source can be used to discover the ID of a\ncluster in vSphere. This is useful to fetch the ID of a cluster that you want\nto use for virtual machine placement via the\n`vsphere.VirtualMachine` resource, allowing\nyou to specify the cluster's root resource pool directly versus using the alias\navailable through the `vsphere.ResourcePool`\ndata source.\n\n\u003e You may also wish to see the\n`vsphere.ComputeCluster` resource for further\ndetails about clusters or how to work with them.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst computeCluster = vsphere_datacenter_dc.id.apply(id =\u003e vsphere.getComputeCluster({\n    datacenterId: id,\n    name: \"compute-cluster1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ncompute_cluster = vsphere.get_compute_cluster(datacenter_id=data[\"vsphere_datacenter\"][\"dc\"][\"id\"],\n    name=\"compute-cluster1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var computeCluster = Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = data.Vsphere_datacenter.Dc.Id,\n            Name = \"compute-cluster1\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupComputeCluster(ctx, \u0026GetComputeClusterArgs{\n\t\t\tDatacenterId: pulumi.StringRef(data.Vsphere_datacenter.Dc.Id),\n\t\t\tName:         \"compute-cluster1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the cluster is located in.  This can\nbe omitted if the search path used in `name` is an absolute path.  For\ndefault datacenters, use the id attribute from an empty `vsphere.Datacenter`\ndata source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "resourcePoolId",
                    "id"
                ]
            }
        },
        "vsphere:index/getContentLibrary:getContentLibrary": {
            "description": "The `vsphere.ContentLibrary` data source can be used to discover the ID of a Content Library.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst library = pulumi.output(vsphere.getContentLibrary({\n    name: \"Content Library Test\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlibrary = vsphere.get_content_library(name=\"Content Library Test\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var library = Output.Create(VSphere.GetContentLibrary.InvokeAsync(new VSphere.GetContentLibraryArgs\n        {\n            Name = \"Content Library Test\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupContentLibrary(ctx, \u0026GetContentLibraryArgs{\n\t\t\tName: \"Content Library Test\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibrary.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the Content Library.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibrary.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getContentLibraryItem:getContentLibraryItem": {
            "description": "The `vsphere.ContentLibraryItem` data source can be used to discover the ID of a Content Library item.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst library = vsphere.getContentLibrary({\n    name: \"Content Library Test\",\n});\nconst item = library.then(library =\u003e vsphere.getContentLibraryItem({\n    name: \"Ubuntu Bionic 18.04\",\n    libraryId: library.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlibrary = vsphere.get_content_library(name=\"Content Library Test\")\nitem = vsphere.get_content_library_item(name=\"Ubuntu Bionic 18.04\",\n    library_id=library.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var library = Output.Create(VSphere.GetContentLibrary.InvokeAsync(new VSphere.GetContentLibraryArgs\n        {\n            Name = \"Content Library Test\",\n        }));\n        var item = library.Apply(library =\u003e Output.Create(VSphere.GetContentLibraryItem.InvokeAsync(new VSphere.GetContentLibraryItemArgs\n        {\n            Name = \"Ubuntu Bionic 18.04\",\n            LibraryId = library.Id,\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tlibrary, err := vsphere.LookupContentLibrary(ctx, \u0026GetContentLibraryArgs{\n\t\t\tName: \"Content Library Test\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupContentLibraryItem(ctx, \u0026GetContentLibraryItemArgs{\n\t\t\tName:      \"Ubuntu Bionic 18.04\",\n\t\t\tLibraryId: library.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibraryItem.\n",
                "properties": {
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the Content Library the item exists in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Content Library.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The Content Library type. Can be ovf, iso, or vm-template.\n"
                    }
                },
                "type": "object",
                "required": [
                    "libraryId",
                    "name",
                    "type"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibraryItem.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "libraryId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The Content Library type. Can be ovf, iso, or vm-template.\n"
                    }
                },
                "type": "object",
                "required": [
                    "libraryId",
                    "name",
                    "type",
                    "id"
                ]
            }
        },
        "vsphere:index/getCustomAttribute:getCustomAttribute": {
            "description": "The `vsphere.CustomAttribute` data source can be used to reference custom \nattributes that are not managed by this provider. Its attributes are exactly the \nsame as the `vsphere.CustomAttribute` resource, \nand, like importing, the data source takes a name to search on. The `id` and \nother attributes are then populated with the data found by the search.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections \nand require vCenter.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst attribute = pulumi.output(vsphere.getCustomAttribute({\n    name: \"test-attribute\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nattribute = vsphere.get_custom_attribute(name=\"test-attribute\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var attribute = Output.Create(VSphere.GetCustomAttribute.InvokeAsync(new VSphere.GetCustomAttributeArgs\n        {\n            Name = \"test-attribute\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupCustomAttribute(ctx, \u0026GetCustomAttributeArgs{\n\t\t\tName: \"test-attribute\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomAttribute.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomAttribute.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "managedObjectType": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "managedObjectType",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getDatacenter:getDatacenter": {
            "description": "The `vsphere.Datacenter` data source can be used to discover the ID of a\nvSphere datacenter. This can then be used with resources or data sources that\nrequire a datacenter, such as the `vsphere.Host`\ndata source.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatacenter.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This can be a name or path.\nCan be omitted if there is only one datacenter in your inventory.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatacenter.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            }
        },
        "vsphere:index/getDatastore:getDatastore": {
            "description": "The `vsphere.getDatastore` data source can be used to discover the ID of a\ndatastore in vSphere. This is useful to fetch the ID of a datastore that you\nwant to use to create virtual machines in using the\n`vsphere.VirtualMachine` resource. \n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst datastore = datacenter.apply(datacenter =\u003e vsphere.getDatastore({\n    datacenterId: datacenter.id,\n    name: \"datastore1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ndatastore = vsphere.get_datastore(datacenter_id=datacenter.id,\n    name=\"datastore1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastore = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"datastore1\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetDatastore(ctx, \u0026GetDatastoreArgs{\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t\tName:         \"datastore1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the datastore is located in. This\ncan be omitted if the search path used in `name` is an absolute path. For\ndefault datacenters, use the id attribute from an empty `vsphere.Datacenter`\ndata source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getDatastoreCluster:getDatastoreCluster": {
            "description": "The `vsphere.DatastoreCluster` data source can be used to discover the ID of a\ndatastore cluster in vSphere. This is useful to fetch the ID of a datastore\ncluster that you want to use to assign datastores to using the\n`vsphere.NasDatastore` or\n`vsphere.VmfsDatastore` resources, or create\nvirtual machines in using the\n`vsphere.VirtualMachine` resource. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst datastoreCluster = vsphere_datacenter_dc.id.apply(id =\u003e vsphere.getDatastoreCluster({\n    datacenterId: id,\n    name: \"datastore-cluster1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ndatastore_cluster = vsphere.get_datastore_cluster(datacenter_id=data[\"vsphere_datacenter\"][\"dc\"][\"id\"],\n    name=\"datastore-cluster1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastoreCluster = Output.Create(VSphere.GetDatastoreCluster.InvokeAsync(new VSphere.GetDatastoreClusterArgs\n        {\n            DatacenterId = data.Vsphere_datacenter.Dc.Id,\n            Name = \"datastore-cluster1\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupDatastoreCluster(ctx, \u0026GetDatastoreClusterArgs{\n\t\t\tDatacenterId: pulumi.StringRef(data.Vsphere_datacenter.Dc.Id),\n\t\t\tName:         \"datastore-cluster1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the datastore cluster is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the id attribute from an empty\n`vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the datastore cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getDistributedVirtualSwitch:getDistributedVirtualSwitch": {
            "description": "The `vsphere.DistributedVirtualSwitch` data source can be used to discover\nthe ID and uplink data of a of a vSphere distributed virtual switch (DVS). This\ncan then be used with resources or data sources that require a DVS, such as the\n`vsphere.DistributedPortGroup` resource, for which\nan example is shown below.\n\n\n\u003e **NOTE:** This data source requires vCenter and is not available on direct\nESXi connections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe following example locates a DVS that is named `test-dvs`, in the\ndatacenter `dc1`. It then uses this DVS to set up a\n`vsphere.DistributedPortGroup` resource that uses the first uplink as a\nprimary uplink and the second uplink as a secondary.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst dvs = datacenter.apply(datacenter =\u003e vsphere.getDistributedVirtualSwitch({\n    datacenterId: datacenter.id,\n    name: \"test-dvs\",\n}));\nconst pg = new vsphere.DistributedPortGroup(\"pg\", {\n    activeUplinks: [dvs.apply(dvs =\u003e dvs.uplinks[0])],\n    distributedVirtualSwitchUuid: dvs.id,\n    standbyUplinks: [dvs.apply(dvs =\u003e dvs.uplinks[1])],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ndvs = vsphere.get_distributed_virtual_switch(datacenter_id=datacenter.id,\n    name=\"test-dvs\")\npg = vsphere.DistributedPortGroup(\"pg\",\n    active_uplinks=[dvs.uplinks[0]],\n    distributed_virtual_switch_uuid=dvs.id,\n    standby_uplinks=[dvs.uplinks[1]])\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var dvs = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetDistributedVirtualSwitch.InvokeAsync(new VSphere.GetDistributedVirtualSwitchArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"test-dvs\",\n        })));\n        var pg = new VSphere.DistributedPortGroup(\"pg\", new VSphere.DistributedPortGroupArgs\n        {\n            ActiveUplinks = \n            {\n                dvs.Apply(dvs =\u003e dvs.Uplinks?[0]),\n            },\n            DistributedVirtualSwitchUuid = dvs.Apply(dvs =\u003e dvs.Id),\n            StandbyUplinks = \n            {\n                dvs.Apply(dvs =\u003e dvs.Uplinks?[1]),\n            },\n        });\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdvs, err := vsphere.LookupDistributedVirtualSwitch(ctx, \u0026GetDistributedVirtualSwitchArgs{\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t\tName:         \"test-dvs\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewDistributedPortGroup(ctx, \"pg\", \u0026vsphere.DistributedPortGroupArgs{\n\t\t\tActiveUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(dvs.Uplinks[0]),\n\t\t\t},\n\t\t\tDistributedVirtualSwitchUuid: pulumi.String(dvs.Id),\n\t\t\tStandbyUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(dvs.Uplinks[1]),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the DVS is located in. This can be\nomitted if the search path used in `name` is an absolute path. For default\ndatacenters, use the id attribute from an empty `vsphere.Datacenter` data\nsource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the distributed virtual switch. This can be a\nname or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "uplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "uplinks",
                    "id"
                ]
            }
        },
        "vsphere:index/getDynamic:getDynamic": {
            "description": "[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n\nThe `vsphere.getDynamic` data source can be used to get the [managed object \n  reference ID][docs-about-morefs] of any tagged managed object in vCenter\n  by providing a list of tag IDs and an optional regular expression to filter\n  objects by name.\n   \n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst cat = vsphere.getTagCategory({\n    name: \"SomeCategory\",\n});\nconst tag1 = cat.then(cat =\u003e vsphere.getTag({\n    name: \"FirstTag\",\n    categoryId: cat.id,\n}));\nconst tag2 = cat.then(cat =\u003e vsphere.getTag({\n    name: \"SecondTag\",\n    categoryId: cat.id,\n}));\nconst dyn = Promise.all([tag1, tag1]).then(([tag1, tag11]) =\u003e vsphere.getDynamic({\n    filters: [\n        tag1.id,\n        tag11.id,\n    ],\n    nameRegex: \"ubuntu\",\n    type: \"Datacenter\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncat = vsphere.get_tag_category(name=\"SomeCategory\")\ntag1 = vsphere.get_tag(name=\"FirstTag\",\n    category_id=cat.id)\ntag2 = vsphere.get_tag(name=\"SecondTag\",\n    category_id=cat.id)\ndyn = vsphere.get_dynamic(filters=[\n        tag1.id,\n        tag1.id,\n    ],\n    name_regex=\"ubuntu\",\n    type=\"Datacenter\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var cat = Output.Create(VSphere.GetTagCategory.InvokeAsync(new VSphere.GetTagCategoryArgs\n        {\n            Name = \"SomeCategory\",\n        }));\n        var tag1 = cat.Apply(cat =\u003e Output.Create(VSphere.GetTag.InvokeAsync(new VSphere.GetTagArgs\n        {\n            Name = \"FirstTag\",\n            CategoryId = cat.Id,\n        })));\n        var tag2 = cat.Apply(cat =\u003e Output.Create(VSphere.GetTag.InvokeAsync(new VSphere.GetTagArgs\n        {\n            Name = \"SecondTag\",\n            CategoryId = cat.Id,\n        })));\n        var dyn = Output.Tuple(tag1, tag1).Apply(values =\u003e\n        {\n            var tag1 = values.Item1;\n            var tag11 = values.Item2;\n            return Output.Create(VSphere.GetDynamic.InvokeAsync(new VSphere.GetDynamicArgs\n            {\n                Filters = \n                {\n                    tag1.Id,\n                    tag11.Id,\n                },\n                NameRegex = \"ubuntu\",\n                Type = \"Datacenter\",\n            }));\n        });\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDynamic.\n",
                "properties": {
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs that must be present on an object to\nbe a match.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match\nthe object's name.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The managed object type the returned object must match.\nFor a full list, click [here](https://code.vmware.com/apis/196/vsphere).\n"
                    }
                },
                "type": "object",
                "required": [
                    "filters"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDynamic.\n",
                "properties": {
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "nameRegex": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "filters",
                    "id"
                ]
            }
        },
        "vsphere:index/getFolder:getFolder": {
            "description": "The `vsphere.Folder` data source can be used to get the general attributes of a\nvSphere inventory folder. Paths are absolute and include must include the\ndatacenter.  \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst folder = pulumi.output(vsphere.getFolder({\n    path: \"/dc1/datastore/folder1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nfolder = vsphere.get_folder(path=\"/dc1/datastore/folder1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var folder = Output.Create(VSphere.GetFolder.InvokeAsync(new VSphere.GetFolderArgs\n        {\n            Path = \"/dc1/datastore/folder1\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupFolder(ctx, \u0026GetFolderArgs{\n\t\t\tPath: \"/dc1/datastore/folder1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFolder.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The absolute path of the folder. For example, given a\ndefault datacenter of `default-dc`, a folder of type `vm`, and a folder name\nof `test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`. The valid folder types to be used in\nthe path are: `vm`, `host`, `datacenter`, `datastore`, or `network`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFolder.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "id"
                ]
            }
        },
        "vsphere:index/getHost:getHost": {
            "description": "The `vsphere.Host` data source can be used to discover the ID of a vSphere\nhost. This can then be used with resources or data sources that require a host\nmanaged object reference ID.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst host = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n    name: \"esxi1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nhost = vsphere.get_host(datacenter_id=datacenter.id,\n    name=\"esxi1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var host = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"esxi1\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupHost(ctx, \u0026GetHostArgs{\n\t\t\tDatacenterId: datacenter.Id,\n\t\t\tName:         pulumi.StringRef(\"esxi1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of a datacenter.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host. This can be a name or path. Can be\nomitted if there is only one host in your inventory.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID of the host's\nroot resource pool.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "resourcePoolId",
                    "id"
                ]
            }
        },
        "vsphere:index/getHostPciDevice:getHostPciDevice": {
            "description": "The `vsphere.getHostPciDevice` data source can be used to discover the DeviceID\nof a vSphere host's PCI device. This can then be used with \n`vsphere.VirtualMachine`'s `pci_device_id`.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### With Vendor ID And Class ID\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc1\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi1\",\n    datacenterId: datacenter.id,\n}));\nconst dev = host.then(host =\u003e vsphere.getHostPciDevice({\n    hostId: host.id,\n    classId: 123,\n    vendorId: 456,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nhost = vsphere.get_host(name=\"esxi1\",\n    datacenter_id=datacenter.id)\ndev = vsphere.get_host_pci_device(host_id=host.id,\n    class_id=\"123\",\n    vendor_id=\"456\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var host = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            Name = \"esxi1\",\n            DatacenterId = datacenter.Id,\n        })));\n        var dev = host.Apply(host =\u003e Output.Create(VSphere.GetHostPciDevice.InvokeAsync(new VSphere.GetHostPciDeviceArgs\n        {\n            HostId = host.Id,\n            ClassId = \"123\",\n            VendorId = \"456\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026GetHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi1\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostPciDevice(ctx, \u0026GetHostPciDeviceArgs{\n\t\t\tHostId:   host.Id,\n\t\t\tClassId:  pulumi.StringRef(\"123\"),\n\t\t\tVendorId: pulumi.StringRef(\"456\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n### With Name Regular Expression\n \n ```hcl\n data \"vsphere_datacenter\" \"datacenter\" {\n   name = \"dc1\"\n }\n \n data \"vsphere_host\" \"host\" {\n   name          = \"esxi1\"\n   datacenter_id = data.vsphere_datacenter.datacenter.id\n }\n \n data \"vsphere_host_pci_device\" \"dev\" {\n   host_id    = data.vsphere_host.host.id\n   name_regex = \"MMC\"\n }\n ```\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getHostPciDevice.\n",
                "properties": {
                    "classId": {
                        "type": "string",
                        "description": "The hexadecimal PCI device class ID\n"
                    },
                    "hostId": {
                        "type": "string",
                        "description": "The [managed object reference\nID][docs-about-morefs] of a host.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match\nthe host PCI device name.\n"
                    },
                    "vendorId": {
                        "type": "string",
                        "description": "The hexadecimal PCI device vendor ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostPciDevice.\n",
                "properties": {
                    "classId": {
                        "type": "string"
                    },
                    "hostId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the PCI device.\n"
                    },
                    "nameRegex": {
                        "type": "string"
                    },
                    "vendorId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "hostId",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getHostThumbprint:getHostThumbprint": {
            "description": "The `vsphere_thumbprint` data source can be used to discover the host\nthumbprint of an ESXi host. This can be used when adding the `vsphere.Host`\nresource. If the host is using a certificate chain, the first one returned\nwill be used to generate the thumbprint.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst thumbprint = pulumi.output(vsphere.getHostThumbprint({\n    address: \"esxi.example.internal\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nthumbprint = vsphere.get_host_thumbprint(address=\"esxi.example.internal\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var thumbprint = Output.Create(VSphere.GetHostThumbprint.InvokeAsync(new VSphere.GetHostThumbprintArgs\n        {\n            Address = \"esxi.example.internal\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetHostThumbprint(ctx, \u0026GetHostThumbprintArgs{\n\t\t\tAddress: \"esxi.example.internal\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getHostThumbprint.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The address of the ESXi host to retrieve the\nthumbprint from.\n"
                    },
                    "insecure": {
                        "type": "boolean",
                        "description": "Boolean that can be set to true to disable SSL \ncertificate verification. Default: false\n"
                    },
                    "port": {
                        "type": "string",
                        "description": "The port to use connecting to the ESXi host. Default: 443\n"
                    }
                },
                "type": "object",
                "required": [
                    "address"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostThumbprint.\n",
                "properties": {
                    "address": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "insecure": {
                        "type": "boolean"
                    },
                    "port": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "address",
                    "id"
                ]
            }
        },
        "vsphere:index/getNetwork:getNetwork": {
            "description": "The `vsphere.getNetwork` data source can be used to discover the ID of a network\nin vSphere. This can be any network that can be used as the backing for a\nnetwork interface for `vsphere.VirtualMachine` or any other vSphere resource\nthat requires a network. This includes standard (host-based) port groups, DVS\nport groups, or opaque networks such as those managed by NSX.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst net = datacenter.apply(datacenter =\u003e vsphere.getNetwork({\n    datacenterId: datacenter.id,\n    name: \"test-net\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nnet = vsphere.get_network(datacenter_id=datacenter.id,\n    name=\"test-net\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var net = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"test-net\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetNetwork(ctx, \u0026GetNetworkArgs{\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t\tName:         \"test-net\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the network is located in. This can\nbe omitted if the search path used in `name` is an absolute path. For default\ndatacenters, use the id attribute from an empty `vsphere.Datacenter` data\nsource.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "For distributed port group type \nnetwork objects, the ID of the distributed virtual switch the given port group\nbelongs to. It is useful to differentiate port groups with same name using the\nDistributed virtual switch ID.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the network. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "type",
                    "id"
                ]
            }
        },
        "vsphere:index/getOvfVmTemplate:getOvfVmTemplate": {
            "description": "The `vsphere.getOvfVmTemplate` data source can be used to submit an OVF to vSphere and extract its hardware\nsettings in a form that can be then used as inputs for a `vsphere.VirtualMachine` resource.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ovf = vsphere.getOvfVmTemplate({\n    name: \"testOVF\",\n    resourcePoolId: vsphere_resource_pool.rp.id,\n    datastoreId: data.vsphere_datastore.ds.id,\n    hostSystemId: data.vsphere_host.hs.id,\n    remoteOvfUrl: \"https://download3.vmware.com/software/vmw-tools/nested-esxi/Nested_ESXi7.0_Appliance_Template_v1.ova\",\n    ovfNetworkMap: {\n        \"Network 1\": data.vsphere_network.net.id,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\novf = vsphere.get_ovf_vm_template(name=\"testOVF\",\n    resource_pool_id=vsphere_resource_pool[\"rp\"][\"id\"],\n    datastore_id=data[\"vsphere_datastore\"][\"ds\"][\"id\"],\n    host_system_id=data[\"vsphere_host\"][\"hs\"][\"id\"],\n    remote_ovf_url=\"https://download3.vmware.com/software/vmw-tools/nested-esxi/Nested_ESXi7.0_Appliance_Template_v1.ova\",\n    ovf_network_map={\n        \"Network 1\": data[\"vsphere_network\"][\"net\"][\"id\"],\n    })\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ovf = Output.Create(VSphere.GetOvfVmTemplate.InvokeAsync(new VSphere.GetOvfVmTemplateArgs\n        {\n            Name = \"testOVF\",\n            ResourcePoolId = vsphere_resource_pool.Rp.Id,\n            DatastoreId = data.Vsphere_datastore.Ds.Id,\n            HostSystemId = data.Vsphere_host.Hs.Id,\n            RemoteOvfUrl = \"https://download3.vmware.com/software/vmw-tools/nested-esxi/Nested_ESXi7.0_Appliance_Template_v1.ova\",\n            OvfNetworkMap = \n            {\n                { \"Network 1\", data.Vsphere_network.Net.Id },\n            },\n        }));\n    }\n\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getOvfVmTemplate.\n",
                "properties": {
                    "allowUnverifiedSslCert": {
                        "type": "boolean",
                        "description": "Allow unverified ssl certificates while deploying ovf/ova from url.\n"
                    },
                    "datastoreId": {
                        "type": "string",
                        "description": "The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.\n"
                    },
                    "deploymentOption": {
                        "type": "string",
                        "description": "The key of the chosen deployment option. If empty, the default option is chosen.\n"
                    },
                    "diskProvisioning": {
                        "type": "string",
                        "description": "The disk provisioning. If set, all the disks in the deployed OVF will have\nthe same specified disk type (accepted values {thin, flat, thick, sameAsSource}).\n"
                    },
                    "enableHiddenProperties": {
                        "type": "boolean"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The name of the folder to locate the virtual machine in.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The ID of an optional host system to pin the virtual machine to.\n"
                    },
                    "ipAllocationPolicy": {
                        "type": "string",
                        "description": "The IP allocation policy.\n"
                    },
                    "ipProtocol": {
                        "type": "string",
                        "description": "The IP protocol.\n"
                    },
                    "localOvfPath": {
                        "type": "string",
                        "description": "The absolute path to the ovf/ova file in the local system. While deploying from ovf,\nmake sure the other necessary files like the .vmdk files are also in the same directory as the given ovf file.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the virtual machine to create.\n"
                    },
                    "ovfNetworkMap": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The mapping of name of network identifiers from the ovf descriptor to network UUID in the\nVI infrastructure.\n"
                    },
                    "remoteOvfUrl": {
                        "type": "string",
                        "description": "URL to the remote ovf/ova file to be deployed.\n"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The ID of a resource pool to put the virtual machine in.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostSystemId",
                    "name",
                    "resourcePoolId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOvfVmTemplate.\n",
                "properties": {
                    "allowUnverifiedSslCert": {
                        "type": "boolean"
                    },
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The guest name for the operating system .\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "User-provided description of the virtual machine.\n"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "datastoreId": {
                        "type": "string"
                    },
                    "deploymentOption": {
                        "type": "string"
                    },
                    "diskProvisioning": {
                        "type": "string"
                    },
                    "enableHiddenProperties": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware interface to use on the virtual machine.\n"
                    },
                    "folder": {
                        "type": "string"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID for the operating system\n"
                    },
                    "hostSystemId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ideControllerCount": {
                        "type": "integer"
                    },
                    "ipAllocationPolicy": {
                        "type": "string"
                    },
                    "ipProtocol": {
                        "type": "string"
                    },
                    "localOvfPath": {
                        "type": "string"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow memory to be added to this virtual machine while it is running.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean",
                        "description": "Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.\n"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores to distribute amongst the CPUs in this virtual machine.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The number of virtual processors to assign to this virtual machine.\n"
                    },
                    "ovfNetworkMap": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "remoteOvfUrl": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string"
                    },
                    "sataControllerCount": {
                        "type": "integer"
                    },
                    "scsiControllerCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string",
                        "description": "The swap file placement policy for this virtual machine.\n"
                    }
                },
                "type": "object",
                "required": [
                    "alternateGuestName",
                    "annotation",
                    "cpuHotAddEnabled",
                    "cpuHotRemoveEnabled",
                    "cpuPerformanceCountersEnabled",
                    "firmware",
                    "guestId",
                    "hostSystemId",
                    "ideControllerCount",
                    "memory",
                    "memoryHotAddEnabled",
                    "name",
                    "nestedHvEnabled",
                    "numCoresPerSocket",
                    "numCpus",
                    "resourcePoolId",
                    "sataControllerCount",
                    "scsiControllerCount",
                    "scsiType",
                    "swapPlacementPolicy",
                    "id"
                ]
            }
        },
        "vsphere:index/getPolicy:getPolicy": {
            "description": "The `vsphere.getPolicy` data source can be used to discover the UUID of a\nvSphere storage policy. This can then be used with resources or data sources that\nrequire a storage policy.\n\n\u003e **NOTE:** Storage policy support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst policy = pulumi.output(vsphere.getPolicy({\n    name: \"policy1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\npolicy = vsphere.get_policy(name=\"policy1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var policy = Output.Create(VSphere.GetPolicy.InvokeAsync(new VSphere.GetPolicyArgs\n        {\n            Name = \"policy1\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetPolicy(ctx, \u0026GetPolicyArgs{\n\t\t\tName: \"policy1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPolicy.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getResourcePool:getResourcePool": {
            "description": "The `vsphere.ResourcePool` data source can be used to discover the ID of a\nresource pool in vSphere. This is useful to fetch the ID of a resource pool\nthat you want to use to create virtual machines in using the\n`vsphere.VirtualMachine` resource. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst pool = datacenter.apply(datacenter =\u003e vsphere.getResourcePool({\n    datacenterId: datacenter.id,\n    name: \"resource-pool-1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\npool = vsphere.get_resource_pool(datacenter_id=datacenter.id,\n    name=\"resource-pool-1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var pool = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetResourcePool.InvokeAsync(new VSphere.GetResourcePoolArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"resource-pool-1\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupResourcePool(ctx, \u0026GetResourcePoolArgs{\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t\tName:         pulumi.StringRef(\"resource-pool-1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% example %}}\n### Specifying the root resource pool for a standalone host\n\n\u003e **NOTE:** Fetching the root resource pool for a cluster can now be done\ndirectly via the `vsphere.ComputeCluster`\ndata source.\n\nAll compute resources in vSphere (clusters, standalone hosts, and standalone\nESXi) have a resource pool, even if one has not been explicitly created. This\nresource pool is referred to as the _root resource pool_ and can be looked up\nby specifying the path as per the example below:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst pool = vsphere_datacenter_dc.id.apply(id =\u003e vsphere.getResourcePool({\n    datacenterId: id,\n    name: \"esxi1/Resources\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\npool = vsphere.get_resource_pool(datacenter_id=data[\"vsphere_datacenter\"][\"dc\"][\"id\"],\n    name=\"esxi1/Resources\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pool = Output.Create(VSphere.GetResourcePool.InvokeAsync(new VSphere.GetResourcePoolArgs\n        {\n            DatacenterId = data.Vsphere_datacenter.Dc.Id,\n            Name = \"esxi1/Resources\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupResourcePool(ctx, \u0026GetResourcePoolArgs{\n\t\t\tDatacenterId: pulumi.StringRef(data.Vsphere_datacenter.Dc.Id),\n\t\t\tName:         pulumi.StringRef(\"esxi1/Resources\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n\nFor more information on the root resource pool, see [Managing Resource\nPools][vmware-docs-resource-pools] in the vSphere documentation.\n\n[vmware-docs-resource-pools]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-60077B40-66FF-4625-934A-641703ED7601.html\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the resource pool is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the id attribute from an empty\n`vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource pool. This can be a name or\npath. This is required when using vCenter.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            }
        },
        "vsphere:index/getRole:getRole": {
            "description": "The `vsphere.Role` data source can be used to discover the id and privileges associated\nwith a role given its name or display label in vsphere UI.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst role1 = pulumi.output(vsphere.getRole({\n    label: \"Virtual machine user (sample)\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nrole1 = vsphere.get_role(label=\"Virtual machine user (sample)\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var role1 = Output.Create(VSphere.GetRole.InvokeAsync(new VSphere.GetRoleArgs\n        {\n            Label = \"Virtual machine user (sample)\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupRole(ctx, \u0026GetRoleArgs{\n\t\t\tLabel: \"Virtual machine user (sample)\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the role.\n"
                    },
                    "label": {
                        "type": "string",
                        "description": "The label of the role.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges associated with the role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "label"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the role.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "label": {
                        "type": "string",
                        "description": "The display label of the role.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges associated with the role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "label",
                    "id"
                ]
            }
        },
        "vsphere:index/getTag:getTag": {
            "description": "The `vsphere.Tag` data source can be used to reference tags that are not\nmanaged by this provider. Its attributes are exactly the same as the `vsphere.Tag`\nresource, and, like importing, the data source takes a name and\ncategory to search on. The `id` and other attributes are then populated with\nthe data found by the search.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = pulumi.output(vsphere.getTagCategory({\n    name: \"test-category\",\n}));\nconst tag = category.apply(category =\u003e vsphere.getTag({\n    categoryId: category.id,\n    name: \"test-tag\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"test-category\")\ntag = vsphere.get_tag(category_id=category.id,\n    name=\"test-tag\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var category = Output.Create(VSphere.GetTagCategory.InvokeAsync(new VSphere.GetTagCategoryArgs\n        {\n            Name = \"test-category\",\n        }));\n        var tag = category.Apply(category =\u003e Output.Create(VSphere.GetTag.InvokeAsync(new VSphere.GetTagArgs\n        {\n            CategoryId = category.Id,\n            Name = \"test-tag\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcategory, err := vsphere.LookupTagCategory(ctx, \u0026GetTagCategoryArgs{\n\t\t\tName: \"test-category\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026GetTagArgs{\n\t\t\tCategoryId: category.Id,\n\t\t\tName:       \"test-tag\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The ID of the tag category the tag is located in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the tag.\n"
                    }
                },
                "type": "object",
                "required": [
                    "categoryId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "categoryId",
                    "description",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getTagCategory:getTagCategory": {
            "description": "The `vsphere.TagCategory` data source can be used to reference tag categories\nthat are not managed by this provider. Its attributes are exactly the same as the\n`vsphere.TagCategory` resource, and, like importing,\nthe data source takes a name to search on. The `id` and other attributes are\nthen populated with the data found by the search.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = pulumi.output(vsphere.getTagCategory({\n    name: \"test-category\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"test-category\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var category = Output.Create(VSphere.GetTagCategory.InvokeAsync(new VSphere.GetTagCategoryArgs\n        {\n            Name = \"test-category\",\n        }));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupTagCategory(ctx, \u0026GetTagCategoryArgs{\n\t\t\tName: \"test-category\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getTagCategory.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the tag category.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTagCategory.\n",
                "properties": {
                    "associableTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "cardinality": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "associableTypes",
                    "cardinality",
                    "description",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getVappContainer:getVappContainer": {
            "description": "The `vsphere.VappContainer` data source can be used to discover the ID of a\nvApp container in vSphere. This is useful to fetch the ID of a vApp container\nthat you want to use to create virtual machines in using the\n`vsphere.VirtualMachine` resource. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst pool = datacenter.apply(datacenter =\u003e vsphere.getVappContainer({\n    datacenterId: datacenter.id,\n    name: \"vapp-container-1\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\npool = vsphere.get_vapp_container(datacenter_id=datacenter.id,\n    name=\"vapp-container-1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var pool = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetVappContainer.InvokeAsync(new VSphere.GetVappContainerArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"vapp-container-1\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVappContainer(ctx, \u0026GetVappContainerArgs{\n\t\t\tDatacenterId: datacenter.Id,\n\t\t\tName:         \"vapp-container-1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the vApp container is located in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container. This can be a name or\npath.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getVirtualMachine:getVirtualMachine": {
            "description": "The `vsphere.VirtualMachine` data source can be used to find the UUID of an\nexisting virtual machine or template. Its most relevant purpose is for finding\nthe UUID of a template to be used as the source for cloning into a new\n`vsphere.VirtualMachine` resource. It also\nreads the guest ID so that can be supplied as well.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst template = datacenter.apply(datacenter =\u003e vsphere.getVirtualMachine({\n    datacenterId: datacenter.id,\n    name: \"test-vm-template\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ntemplate = vsphere.get_virtual_machine(datacenter_id=datacenter.id,\n    name=\"test-vm-template\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var template = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetVirtualMachine.InvokeAsync(new VSphere.GetVirtualMachineArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"test-vm-template\",\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026GetVirtualMachineArgs{\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t\tName:         \"test-vm-template\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getVirtualMachine.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The alternate guest name of the virtual machine when\nguest_id is a non-specific operating system, like `otherGuest`.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "The user-provided description of this virtual machine.\n"
                    },
                    "bootDelay": {
                        "type": "integer"
                    },
                    "bootRetryDelay": {
                        "type": "integer"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "type": "integer"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "cpuReservation": {
                        "type": "integer"
                    },
                    "cpuShareCount": {
                        "type": "integer"
                    },
                    "cpuShareLevel": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the virtual machine is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the `id` attribute from an empty\n`vsphere.Datacenter` data source.\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean"
                    },
                    "enableDiskUuid": {
                        "type": "boolean"
                    },
                    "enableLogging": {
                        "type": "boolean"
                    },
                    "eptRviMode": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware type for this virtual machine. Can be `bios` or `efi`.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID of the virtual machine or template.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version number on this virtual machine.\n"
                    },
                    "hvMode": {
                        "type": "string"
                    },
                    "ideControllerScanCount": {
                        "type": "integer"
                    },
                    "latencySensitivity": {
                        "type": "string"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "type": "integer"
                    },
                    "memoryReservation": {
                        "type": "integer"
                    },
                    "memoryShareCount": {
                        "type": "integer"
                    },
                    "memoryShareLevel": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual machine. This can be a name or\npath.\n"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per socket for this virtual machine.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The total number of virtual processor cores assigned to this\nvirtual machine.\n"
                    },
                    "replaceTrigger": {
                        "type": "string"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean"
                    },
                    "sataControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer",
                        "description": "The number of SCSI controllers to\nscan for disk attributes and controller types on. Default: `1`.\n"
                    },
                    "storagePolicyId": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp"
                    },
                    "vbsEnabled": {
                        "type": "boolean"
                    },
                    "vvtdEnabled": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVirtualMachine.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The alternate guest name of the virtual machine when\nguest_id is a non-specific operating system, like `otherGuest`.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "The user-provided description of this virtual machine.\n"
                    },
                    "bootDelay": {
                        "type": "integer"
                    },
                    "bootRetryDelay": {
                        "type": "integer"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean"
                    },
                    "changeVersion": {
                        "type": "string"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "type": "integer"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "cpuReservation": {
                        "type": "integer"
                    },
                    "cpuShareCount": {
                        "type": "integer"
                    },
                    "cpuShareLevel": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/getVirtualMachineDisk:getVirtualMachineDisk"
                        },
                        "description": "Information about each of the disks on this virtual machine or\ntemplate. These are sorted by bus and unit number so that they can be applied\nto a `vsphere.VirtualMachine` resource in the order the resource expects\nwhile cloning. This is useful for discovering certain disk settings while\nperforming a linked clone, as all settings that are output by this data\nsource must be the same on the destination virtual machine as the source.\nOnly the first number of controllers defined by `scsi_controller_scan_count`\nare scanned for disks. The sub-attributes are:\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean"
                    },
                    "enableDiskUuid": {
                        "type": "boolean"
                    },
                    "enableLogging": {
                        "type": "boolean"
                    },
                    "eptRviMode": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware type for this virtual machine. Can be `bios` or `efi`.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID of the virtual machine or template.\n"
                    },
                    "guestIpAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IP addresses as reported by VMWare tools.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version number on this virtual machine.\n"
                    },
                    "hvMode": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ideControllerScanCount": {
                        "type": "integer"
                    },
                    "latencySensitivity": {
                        "type": "string"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "type": "integer"
                    },
                    "memoryReservation": {
                        "type": "integer"
                    },
                    "memoryShareCount": {
                        "type": "integer"
                    },
                    "memoryShareLevel": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean"
                    },
                    "networkInterfaceTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The network interface types for each network\ninterface found on the virtual machine, in device bus order. Will be one of\n`e1000`, `e1000e`, `pcnet32`, `sriov`, `vmxnet2`, or `vmxnet3`.\n"
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/getVirtualMachineNetworkInterface:getVirtualMachineNetworkInterface"
                        },
                        "description": "Information about each of the network interfaces on this \nvirtual machine or template. These are sorted by device bus order so that they\ncan be applied to a `vsphere.VirtualMachine` resource in the order the resource\nexpects while cloning. This is useful for discovering certain network interface\nsettings while performing a linked clone, as all settings that are output by this\ndata source must be the same on the destination virtual machine as the source.\nThe sub-attributes are:\n"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per socket for this virtual machine.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The total number of virtual processor cores assigned to this\nvirtual machine.\n"
                    },
                    "replaceTrigger": {
                        "type": "string"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean"
                    },
                    "sataControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiBusSharing": {
                        "type": "string",
                        "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Only the first number of\ncontrollers defined by `scsi_controller_scan_count` are scanned.\n"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "type": "string",
                        "description": "The common type of all SCSI controllers on this virtual machine.\nWill be one of `lsilogic` (LSI Logic Parallel), `lsilogic-sas` (LSI Logic\nSAS), `pvscsi` (VMware Paravirtual), `buslogic` (BusLogic), or `mixed` when\nthere are multiple controller types. Only the first number of controllers\ndefined by `scsi_controller_scan_count` are scanned.\n"
                    },
                    "storagePolicyId": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean"
                    },
                    "uuid": {
                        "type": "string"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp"
                    },
                    "vappTransports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "vbsEnabled": {
                        "type": "boolean"
                    },
                    "vvtdEnabled": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "changeVersion",
                    "cpuShareCount",
                    "disks",
                    "guestId",
                    "guestIpAddresses",
                    "hardwareVersion",
                    "memoryShareCount",
                    "name",
                    "networkInterfaceTypes",
                    "networkInterfaces",
                    "scsiBusSharing",
                    "scsiType",
                    "storagePolicyId",
                    "uuid",
                    "vappTransports",
                    "id"
                ]
            }
        },
        "vsphere:index/getVmfsDisks:getVmfsDisks": {
            "description": "The `vsphere.getVmfsDisks` data source can be used to discover the storage\ndevices available on an ESXi host. This data source can be combined with the\n`vsphere.VmfsDatastore` resource to create VMFS\ndatastores based off a set of discovered disks.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}));\nconst host = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n    name: \"esxi1\",\n}));\nconst available = host.apply(host =\u003e vsphere.getVmfsDisks({\n    filter: \"mpx.vmhba1:C0:T[12]:L0\",\n    hostSystemId: host.id,\n    rescan: true,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nhost = vsphere.get_host(datacenter_id=datacenter.id,\n    name=\"esxi1\")\navailable = vsphere.get_vmfs_disks(filter=\"mpx.vmhba1:C0:T[12]:L0\",\n    host_system_id=host.id,\n    rescan=True)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var host = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"esxi1\",\n        })));\n        var available = host.Apply(host =\u003e Output.Create(VSphere.GetVmfsDisks.InvokeAsync(new VSphere.GetVmfsDisksArgs\n        {\n            Filter = \"mpx.vmhba1:C0:T[12]:L0\",\n            HostSystemId = host.Id,\n            Rescan = true,\n        })));\n    }\n\n}\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026GetDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026GetHostArgs{\n\t\t\tDatacenterId: datacenter.Id,\n\t\t\tName:         pulumi.StringRef(\"esxi1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetVmfsDisks(ctx, \u0026GetVmfsDisksArgs{\n\t\t\tFilter:       pulumi.StringRef(\"mpx.vmhba1:C0:T[12]:L0\"),\n\t\t\tHostSystemId: host.Id,\n\t\t\tRescan:       pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getVmfsDisks.\n",
                "properties": {
                    "filter": {
                        "type": "string",
                        "description": "A regular expression to filter the disks against. Only\ndisks with canonical names that match will be included.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to look for disks on.\n"
                    },
                    "rescan": {
                        "type": "boolean",
                        "description": "Whether or not to rescan storage adapters before\nsearching for disks. This may lengthen the time it takes to perform the\nsearch. Default: `false`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostSystemId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVmfsDisks.\n",
                "properties": {
                    "disks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A lexicographically sorted list of devices discovered by the\noperation, matching the supplied `filter`, if provided.\n"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "hostSystemId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rescan": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "disks",
                    "hostSystemId",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": {
                "vsphere": "VSphere"
            },
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0",
                "builtin-modules": "3.0.0",
                "read-package-tree": "^5.2.1",
                "resolve": "^1.8.1"
            },
            "devDependencies": {
                "@types/node": "^10.9.2"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating vsphere resources",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-vsphere` repo](https://github.com/pulumi/pulumi-vsphere/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`hashicorp/terraform-provider-vsphere` repo](https://github.com/hashicorp/terraform-provider-vsphere/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi/pulumi-vsphere` repo](https://github.com/pulumi/pulumi-vsphere/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`hashicorp/terraform-provider-vsphere` repo](https://github.com/hashicorp/terraform-provider-vsphere/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    }
}