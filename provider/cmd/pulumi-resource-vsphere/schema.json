{
    "name": "vsphere",
    "description": "A Pulumi package for creating vsphere resources",
    "keywords": [
        "pulumi",
        "vsphere"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vsphere` Terraform Provider](https://github.com/terraform-providers/terraform-provider-vsphere).",
    "repository": "https://github.com/pulumi/pulumi-vsphere",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "config": {
        "variables": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PASSWORD"
                    ]
                }
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_USER"
                    ]
                }
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_SERVER"
                    ]
                }
            }
        },
        "defaults": [
            "password",
            "user"
        ]
    },
    "types": {
        "vsphere:/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minVlan": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost": {
            "properties": {
                "devices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of NIC devices to map to uplinks on the DVS,\nadded in order they are specified.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The host system ID of the host to add to the\nDVS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "devices",
                "hostSystemId"
            ]
        },
        "vsphere:/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minVlan": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:/HostPortGroupPorts:HostPortGroupPorts": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "macAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:/VirtualMachineCdrom:VirtualMachineCdrom": {
            "properties": {
                "clientDevice": {
                    "type": "boolean",
                    "description": "Indicates whether the device should be backed by\nremote client device. Conflicts with `datastore_id` and `path`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "An address internal to this provider that helps locate the\ndevice when `key` is unavailable. This follows a convention of\n`CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device\nunit 1 on SCSI bus 0.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the ISO file. Required for using a datastore\nISO. Conflicts with `client_device`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:/VirtualMachineClone:VirtualMachineClone": {
            "properties": {
                "customize": {
                    "$ref": "#/types/vsphere:/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "linkedClone": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ovfStorageMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "templateUuid": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "templateUuid"
            ]
        },
        "vsphere:/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize": {
            "properties": {
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dnsSuffixLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv4Gateway": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6Gateway": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "linuxOptions": {
                    "$ref": "#/types/vsphere:/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this\nvirtual machine. See network interface options\nbelow.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeout": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "windowsOptions": {
                    "$ref": "#/types/vsphere:/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "windowsSysprepText": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions": {
            "properties": {
                "domain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hwClockUtc": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeZone": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "domain",
                "hostName"
            ]
        },
        "vsphere:/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface": {
            "properties": {
                "dnsDomain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv4Address": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv4Netmask": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6Address": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipv6Netmask": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoLogon": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoLogonCount": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computerName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "domainAdminPassword": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "domainAdminUser": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fullName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "joinDomain": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "organizationName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "productKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "runOnceCommandLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timeZone": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "workgroup": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "computerName"
            ]
        },
        "vsphere:/VirtualMachineDisk:VirtualMachineDisk": {
            "properties": {
                "attach": {
                    "type": "boolean",
                    "description": "Attach an external disk instead of creating a new one.\nImplies and conflicts with `keep_on_remove`. If set, you cannot set `size`,\n`eagerly_scrub`, or `thin_provisioned`. Must set `path` if used.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "An address internal to this provider that helps locate the\ndevice when `key` is unavailable. This follows a convention of\n`CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device\nunit 1 on SCSI bus 0.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskMode": {
                    "type": "string",
                    "description": "The mode of this this virtual disk for purposes of\nwrites and snapshotting. Can be one of `append`, `independent_nonpersistent`,\n`independent_persistent`, `nonpersistent`, `persistent`, or `undoable`.\nDefault: `persistent`. For an explanation of options, click\n[here][vmware-docs-disk-mode].\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskSharing": {
                    "type": "string",
                    "description": "The sharing mode of this virtual disk. Can be one\nof `sharingMultiWriter` or `sharingNone`. Default: `sharingNone`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "If set to `true`, the disk space is zeroed out\non VM creation. This will delay the creation of the disk or virtual machine.\nCannot be set to `true` when `thin_provisioned` is `true`.  See the section\non picking a disk type.  Default: `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ioLimit": {
                    "type": "integer",
                    "description": "The upper limit of IOPS that this disk can use. The\ndefault is no limit.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ioReservation": {
                    "type": "integer",
                    "description": "The I/O reservation (guarantee) that this disk\nhas, in IOPS.  The default is no reservation.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ioShareCount": {
                    "type": "integer",
                    "description": "The share count for this disk when the share\nlevel is `custom`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ioShareLevel": {
                    "type": "string",
                    "description": "The share allocation level for this disk. Can\nbe one of `low`, `normal`, `high`, or `custom`. Default: `normal`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keepOnRemove": {
                    "type": "boolean",
                    "description": "Keep this disk when removing the device or\ndestroying the virtual machine. Default: `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "label": {
                    "type": "string",
                    "description": "A label for the disk. Forces a new disk if changed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "An alias for both `label` and `path`, the latter when\nusing `attach`. Required if not using `label`.\n",
                    "deprecationMessage": "\nThe name attribute for virtual disks will be removed in favor of \"label\" in\nfuture releases. To transition existing disks, rename the \"name\" attribute to\n\"label\". When doing so, ensure the value of the attribute stays the same.\n\nNote that \"label\" does not control the name of a VMDK and does not need to bear\nthe name of one on new disks or virtual machines. For more information, see the\ndocumentation for the label attribute at: \n\nhttps://www.terraform.io/docs/providers/vsphere/r/virtual_machine.html#label\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "description": "The path to the ISO file. Required for using a datastore\nISO. Conflicts with `client_device`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GB.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The UUID of the storage policy to assign to this disk.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "If `true`, this disk is thin provisioned,\nwith space for the file being allocated on an as-needed basis. Cannot be set\nto `true` when `eagerly_scrub` is `true`. See the section on picking a disk\ntype. Default: `true`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The disk number on the SCSI bus. The maximum value\nfor this setting is the value of\n`scsi_controller_count` times 15, minus 1 (so `14`,\n`29`, `44`, and `59`, for 1-4 controllers respectively). The default is `0`,\nfor which one disk must be set to. Duplicate unit numbers are not allowed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual disk's VMDK file. This is used to track the\nvirtual disk on the virtual machine.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "writeThrough": {
                    "type": "boolean",
                    "description": "If `true`, writes for this disk are sent\ndirectly to the filesystem immediately instead of being buffered. Default:\n`false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The network interface type. Can be one of\n`e1000`, `e1000e`, or `vmxnet3`. Default: `vmxnet3`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthLimit": {
                    "type": "integer",
                    "description": "The upper bandwidth limit of this network\ninterface, in Mbits/sec. The default is no limit.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthReservation": {
                    "type": "integer",
                    "description": "The bandwidth reservation of this\nnetwork interface, in Mbits/sec. The default is no reservation.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthShareCount": {
                    "type": "integer",
                    "description": "The share count for this network\ninterface when the share level is `custom`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bandwidthShareLevel": {
                    "type": "string",
                    "description": "The bandwidth share allocation level for\nthis interface. Can be one of `low`, `normal`, `high`, or `custom`. Default:\n`normal`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "An address internal to this provider that helps locate the\ndevice when `key` is unavailable. This follows a convention of\n`CONTROLLER_TYPE:BUS_NUMBER:UNIT_NUMBER`. Example: `scsi:0:1` means device\nunit 1 on SCSI bus 0.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of this network interface. Can\nonly be manually set if `use_static_mac` is true, otherwise this is a\ncomputed value that gives the current MAC address of this interface.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "networkId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the network to connect this interface to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ovfMapping": {
                    "type": "string",
                    "description": "Specifies which OVF NIC the `network_interface`\nshould be associated with. Only applies at creation and only when deploying\nfrom an OVF source.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "useStaticMac": {
                    "type": "boolean",
                    "description": "If true, the `mac_address` field is treated as\na static MAC address and set accordingly. Setting this to `true` requires\n`mac_address` to be set. Default: `false`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "networkId"
            ]
        },
        "vsphere:/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy": {
            "properties": {
                "diskProvisioning": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipAllocationPolicy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipProtocol": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "localOvfPath": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "remoteOvfUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:/VirtualMachineVapp:VirtualMachineVapp": {
            "properties": {
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:/VnicIpv4:VnicIpv4": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP or autoconfig is not set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ip": {
                    "type": "string",
                    "description": "Address of the interface, if DHCP is not set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "netmask": {
                    "type": "string",
                    "description": "Netmask of the interface, if DHCP is not set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:/VnicIpv6:VnicIpv6": {
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IPv6 addresses\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoconfig": {
                    "type": "boolean",
                    "description": "Use IPv6 Autoconfiguration (RFC2462).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP or autoconfig is not set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "vsphere:/getVirtualMachineDisk:getVirtualMachineDisk": {
            "properties": {
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been eager zeroed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GIB.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been thin provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "eagerlyScrub",
                "size",
                "thinProvisioned"
            ]
        }
    },
    "provider": {
        "description": "The provider type for the vsphere package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "inputProperties": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PASSWORD"
                    ]
                }
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_USER"
                    ]
                }
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_SERVER"
                    ]
                }
            }
        }
    },
    "resources": {
        "vsphere:index/computeCluster:ComputeCluster": {
            "description": "\u003e **A note on the naming of this resource:** VMware refers to clusters of\nhosts in the UI and documentation as _clusters_, _HA clusters_, or _DRS\nclusters_. All of these refer to the same kind of resource (with the latter two\nreferring to specific features of clustering). We use\n`vsphere..ComputeCluster` to differentiate host clusters from _datastore\nclusters_, which are clusters of datastores that can be used to distribute load\nand ensure fault tolerance via distribution of virtual machines. Datastore\nclusters can also be managed through the provider, via the\n`vsphere..DatastoreCluster` resource.\n\nThe `vsphere..ComputeCluster` resource can be used to create and manage\nclusters of hosts allowing for resource control of compute resources, load\nbalancing through DRS, and high availability through vSphere HA.\n\nFor more information on vSphere clusters and DRS, see [this\npage][ref-vsphere-drs-clusters]. For more information on vSphere HA, see [this\npage][ref-vsphere-ha-clusters].\n\n[ref-vsphere-drs-clusters]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-8ACF3502-5314-469F-8CC9-4A9BD5925BC2.html\n[ref-vsphere-ha-clusters]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.avail.doc/GUID-5432CA24-14F1-44E3-87FB-61D937831CF6.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n{{% /examples %}}\n## vSphere Version Requirements\n\nA large number of settings in the `vsphere..ComputeCluster` resource require a\nspecific version of vSphere to function. Rather than include warnings at every\nsetting or section, these settings are documented below.  Note that this list\nis for cluster-specific attributes only, and does not include the\n`tags` parameter, which requires vSphere 6.0 or higher across all\nresources that can be tagged.\n\nAll settings are footnoted by an asterisk (`*`) in their specific section in\nthe documentation, which takes you here.\n\n### Settings that require vSphere version 6.0 or higher\n\nThese settings require vSphere 6.0 or higher:\n\n* `ha_datastore_apd_recovery_action`\n* `ha_datastore_apd_response`\n* `ha_datastore_apd_response_delay`\n* `ha_datastore_pdl_response`\n* `ha_vm_component_protection`\n\n### Settings that require vSphere version 6.5 or higher\n\nThese settings require vSphere 6.5 or higher:\n\n* `drs_enable_predictive_drs`\n* `ha_admission_control_host_failure_tolerance`\n  (When `ha_admission_control_policy` is set to\n  `resourcePercentage` or `slotPolicy`. Permitted in all versions under\n  `failoverHosts`)\n* `ha_admission_control_resource_percentage_auto_compute`\n* `ha_vm_restart_timeout`\n* `ha_vm_dependency_restart_condition`\n* `ha_vm_restart_additional_delay`\n* `proactive_ha_automation_level`\n* `proactive_ha_enabled`\n* `proactive_ha_moderate_remediation`\n* `proactive_ha_provider_ids`\n* `proactive_ha_severe_remediation`\n",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations in this cluster. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS in this cluster.\nRequires `drs_enabled` to be `true` in order to be effective.\nDefault: `false`.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating the\nthreshold of load within the cluster that influences host power operations.\nThis affects both power on and power off operations - a lower setting will\ntolerate more of a surplus/deficit than a higher setting. Default: `3`.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all\nvirtual machines in this cluster. Can be one of `manual`,\n`partiallyAutomated`, or `fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When `true`, enables DRS to use data\nfrom [vRealize Operations Manager][ref-vsphere-vro] to make proactive DRS\nrecommendations. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "Allow individual DRS overrides to be\nset for virtual machines in the cluster. Default: `true`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster. Default: `false`.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating\nthe threshold of imbalance tolerated between hosts. A lower setting will\ntolerate more imbalance while a higher setting will tolerate less. Default:\n`3`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "When destroying the resource, setting this to\n`true` will auto-remove any hosts that are currently a member of the cluster,\nas if they were removed by taking their entry out of `host_system_ids` (see\nbelow). This is an advanced\noption and should only be used for testing. Default: `false`.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines the\nmanaged object IDs of hosts to use as dedicated failover\nhosts. These hosts are kept as available as possible - admission control will\nblock access to the host, and DRS will ignore the host when making\nrecommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number\nof failed hosts that admission control tolerates when making decisions on\nwhether to permit virtual machine operations. The maximum is one less than\nthe number of hosts in the cluster. Default: `1`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of\nresource reduction that a cluster of virtual machines can tolerate in case of\na failover. A value of 0 produces warnings only, whereas a value of 100\ndisables the setting. Default: `100` (disabled).\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control\npolicy to use with vSphere HA. Can be one of `resourcePercentage`,\n`slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "\nAutomatically determine available resource percentages by subtracting the\naverage number of host resources represented by the\n`ha_admission_control_host_failure_tolerance`\nsetting from the total amount of resources in the cluster. Disable to supply\nuser-defined values. Default: `true`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of CPU resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of memory resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined CPU slot size, in MHz. Default: `32`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined memory slot size, in MB. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "Controls\nwhether or not you wish to supply explicit values to CPU and memory slot\nsizes. The default is `false`, which tells vSphere to gather a automatic\naverage based on all powered-on virtual machines currently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non virtual machines if an APD status on an affected datastore clears in the\nmiddle of an APD event. Can be one of `none` or `reset`. Default: `none`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected loss to all paths to a\nrelevant datastore. Can be one of `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Default: `3`\nminutes. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `disabled`, `warning`, or\n`restartAggressive`. Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster. Default:\n`false`.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for\npreferred datastores to use for HA heartbeating. This setting is only useful\nwhen `ha_heartbeat_datastore_policy` is set\nto either `userSelectedDs` or `allFeasibleDsWithUserPreference`.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA\nheartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or\n`allFeasibleDsWithUserPreference`. Default:\n`allFeasibleDsWithUserPreference`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual\nmachines when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:\n`none`.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether\nvSphere HA remediates virtual machines on host failure. Can be one of `enabled`\nor `disabled`. Default: `enabled`.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component\nprotection for virtual machines in this cluster. Can be one of `enabled` or\n`disabled`. Default: `enabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to\ndetermine whether or not virtual machines in a certain restart priority class\nare online, allowing HA to move on to restarting virtual machines on the next\npriority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or\n`appHbStatusGreen`. The default is `none`, which means that a virtual machine\nis considered ready immediately after a host is found to start it on.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from a virtual machine\nis not received within this configured interval, the virtual machine is\nmarked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to a virtual machine when responding to a failure event. Default: `3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on a virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay in seconds\nafter ready condition is met. A VM is considered ready at this point.\nDefault: `0` (no delay). \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority\nfor affected virtual machines when vSphere detects a host failure. Can be one\nof `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds,\nthat vSphere HA will wait for virtual machines in one priority to be ready\nbefore proceeding with the next priority. Default: `600` (10 minutes).\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout for each host maintenance mode\noperation when removing hosts from a cluster. The value is specified in\nseconds. Default: `3600` (1 hour).\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "Determines how the host\nquarantine, maintenance mode, or virtual machine migration recommendations\nmade by proactive HA are to be handled. Can be one of `Automated` or\n`Manual`. Default: `Manual`. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables Proactive HA. Default: `false`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation\nfor moderately degraded hosts. Can be one of `MaintenanceMode` or\n`QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when\n`proactive_ha_severe_remediation` is set\nto `QuarantineMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update\nproviders configured for this cluster.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for\nseverely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.\nNote that this cannot be set to `QuarantineMode` when\n`proactive_ha_moderate_remediation` is\nset to `MaintenanceMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID of the cluster's root resource pool.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "datacenterId",
                "name",
                "resourcePoolId"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations in this cluster. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS in this cluster.\nRequires `drs_enabled` to be `true` in order to be effective.\nDefault: `false`.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating the\nthreshold of load within the cluster that influences host power operations.\nThis affects both power on and power off operations - a lower setting will\ntolerate more of a surplus/deficit than a higher setting. Default: `3`.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all\nvirtual machines in this cluster. Can be one of `manual`,\n`partiallyAutomated`, or `fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When `true`, enables DRS to use data\nfrom [vRealize Operations Manager][ref-vsphere-vro] to make proactive DRS\nrecommendations. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "Allow individual DRS overrides to be\nset for virtual machines in the cluster. Default: `true`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster. Default: `false`.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between `1` and `5` indicating\nthe threshold of imbalance tolerated between hosts. A lower setting will\ntolerate more imbalance while a higher setting will tolerate less. Default:\n`3`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "When destroying the resource, setting this to\n`true` will auto-remove any hosts that are currently a member of the cluster,\nas if they were removed by taking their entry out of `host_system_ids` (see\nbelow). This is an advanced\noption and should only be used for testing. Default: `false`.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines the\nmanaged object IDs of hosts to use as dedicated failover\nhosts. These hosts are kept as available as possible - admission control will\nblock access to the host, and DRS will ignore the host when making\nrecommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number\nof failed hosts that admission control tolerates when making decisions on\nwhether to permit virtual machine operations. The maximum is one less than\nthe number of hosts in the cluster. Default: `1`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of\nresource reduction that a cluster of virtual machines can tolerate in case of\na failover. A value of 0 produces warnings only, whereas a value of 100\ndisables the setting. Default: `100` (disabled).\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control\npolicy to use with vSphere HA. Can be one of `resourcePercentage`,\n`slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "\nAutomatically determine available resource percentages by subtracting the\naverage number of host resources represented by the\n`ha_admission_control_host_failure_tolerance`\nsetting from the total amount of resources in the cluster. Disable to supply\nuser-defined values. Default: `true`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of CPU resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined percentage of memory resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined CPU slot size, in MHz. Default: `32`.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "Controls the\nuser-defined memory slot size, in MB. Default: `100`.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "Controls\nwhether or not you wish to supply explicit values to CPU and memory slot\nsizes. The default is `false`, which tells vSphere to gather a automatic\naverage based on all powered-on virtual machines currently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map that specifies advanced\noptions for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non virtual machines if an APD status on an affected datastore clears in the\nmiddle of an APD event. Can be one of `none` or `reset`. Default: `none`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected loss to all paths to a\nrelevant datastore. Can be one of `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Default: `3`\nminutes. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on\nvirtual machines when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `disabled`, `warning`, or\n`restartAggressive`. Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster. Default:\n`false`.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for\npreferred datastores to use for HA heartbeating. This setting is only useful\nwhen `ha_heartbeat_datastore_policy` is set\nto either `userSelectedDs` or `allFeasibleDsWithUserPreference`.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA\nheartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or\n`allFeasibleDsWithUserPreference`. Default:\n`allFeasibleDsWithUserPreference`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual\nmachines when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:\n`none`.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether\nvSphere HA remediates virtual machines on host failure. Can be one of `enabled`\nor `disabled`. Default: `enabled`.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component\nprotection for virtual machines in this cluster. Can be one of `enabled` or\n`disabled`. Default: `enabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to\ndetermine whether or not virtual machines in a certain restart priority class\nare online, allowing HA to move on to restarting virtual machines on the next\npriority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or\n`appHbStatusGreen`. The default is `none`, which means that a virtual machine\nis considered ready immediately after a host is found to start it on.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from a virtual machine\nis not received within this configured interval, the virtual machine is\nmarked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to a virtual machine when responding to a failure event. Default: `3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on a virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay in seconds\nafter ready condition is met. A VM is considered ready at this point.\nDefault: `0` (no delay). \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority\nfor affected virtual machines when vSphere detects a host failure. Can be one\nof `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds,\nthat vSphere HA will wait for virtual machines in one priority to be ready\nbefore proceeding with the next priority. Default: `600` (10 minutes).\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout for each host maintenance mode\noperation when removing hosts from a cluster. The value is specified in\nseconds. Default: `3600` (1 hour).\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "Determines how the host\nquarantine, maintenance mode, or virtual machine migration recommendations\nmade by proactive HA are to be handled. Can be one of `Automated` or\n`Manual`. Default: `Manual`. \u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables Proactive HA. Default: `false`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation\nfor moderately degraded hosts. Can be one of `MaintenanceMode` or\n`QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when\n`proactive_ha_severe_remediation` is set\nto `QuarantineMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update\nproviders configured for this cluster.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for\nseverely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.\nNote that this cannot be set to `QuarantineMode` when\n`proactive_ha_moderate_remediation` is\nset to `MaintenanceMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n"
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power\noperations in this cluster. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for DRS in this cluster.\nRequires `drs_enabled` to be `true` in order to be effective.\nDefault: `false`.\n"
                    },
                    "dpmThreshold": {
                        "type": "integer",
                        "description": "A value between `1` and `5` indicating the\nthreshold of load within the cluster that influences host power operations.\nThis affects both power on and power off operations - a lower setting will\ntolerate more of a surplus/deficit than a higher setting. Default: `3`.\n"
                    },
                    "drsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key/value map that specifies advanced\noptions for DRS and DPM.\n"
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "The default automation level for all\nvirtual machines in this cluster. Can be one of `manual`,\n`partiallyAutomated`, or `fullyAutomated`. Default: `manual`.\n"
                    },
                    "drsEnablePredictiveDrs": {
                        "type": "boolean",
                        "description": "When `true`, enables DRS to use data\nfrom [vRealize Operations Manager][ref-vsphere-vro] to make proactive DRS\nrecommendations. \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "drsEnableVmOverrides": {
                        "type": "boolean",
                        "description": "Allow individual DRS overrides to be\nset for virtual machines in the cluster. Default: `true`.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Enable DRS for this cluster. Default: `false`.\n"
                    },
                    "drsMigrationThreshold": {
                        "type": "integer",
                        "description": "A value between `1` and `5` indicating\nthe threshold of imbalance tolerated between hosts. A lower setting will\ntolerate more imbalance while a higher setting will tolerate less. Default:\n`3`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                    },
                    "forceEvacuateOnDestroy": {
                        "type": "boolean",
                        "description": "When destroying the resource, setting this to\n`true` will auto-remove any hosts that are currently a member of the cluster,\nas if they were removed by taking their entry out of `host_system_ids` (see\nbelow). This is an advanced\noption and should only be used for testing. Default: `false`.\n"
                    },
                    "haAdmissionControlFailoverHostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Defines the\nmanaged object IDs of hosts to use as dedicated failover\nhosts. These hosts are kept as available as possible - admission control will\nblock access to the host, and DRS will ignore the host when making\nrecommendations.\n"
                    },
                    "haAdmissionControlHostFailureTolerance": {
                        "type": "integer",
                        "description": "The maximum number\nof failed hosts that admission control tolerates when making decisions on\nwhether to permit virtual machine operations. The maximum is one less than\nthe number of hosts in the cluster. Default: `1`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haAdmissionControlPerformanceTolerance": {
                        "type": "integer",
                        "description": "The percentage of\nresource reduction that a cluster of virtual machines can tolerate in case of\na failover. A value of 0 produces warnings only, whereas a value of 100\ndisables the setting. Default: `100` (disabled).\n"
                    },
                    "haAdmissionControlPolicy": {
                        "type": "string",
                        "description": "The type of admission control\npolicy to use with vSphere HA. Can be one of `resourcePercentage`,\n`slotPolicy`, `failoverHosts`, or `disabled`. Default: `resourcePercentage`.\n"
                    },
                    "haAdmissionControlResourcePercentageAutoCompute": {
                        "type": "boolean",
                        "description": "\nAutomatically determine available resource percentages by subtracting the\naverage number of host resources represented by the\n`ha_admission_control_host_failure_tolerance`\nsetting from the total amount of resources in the cluster. Disable to supply\nuser-defined values. Default: `true`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haAdmissionControlResourcePercentageCpu": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined percentage of CPU resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                    },
                    "haAdmissionControlResourcePercentageMemory": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined percentage of memory resources in the cluster to reserve for\nfailover. Default: `100`.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitCpu": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined CPU slot size, in MHz. Default: `32`.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitMemory": {
                        "type": "integer",
                        "description": "Controls the\nuser-defined memory slot size, in MB. Default: `100`.\n"
                    },
                    "haAdmissionControlSlotPolicyUseExplicitSize": {
                        "type": "boolean",
                        "description": "Controls\nwhether or not you wish to supply explicit values to CPU and memory slot\nsizes. The default is `false`, which tells vSphere to gather a automatic\naverage based on all powered-on virtual machines currently in the cluster.\n"
                    },
                    "haAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key/value map that specifies advanced\noptions for vSphere HA.\n"
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "Controls the action to take\non virtual machines if an APD status on an affected datastore clears in the\nmiddle of an APD event. Can be one of `none` or `reset`. Default: `none`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "Controls the action to take on\nvirtual machines when the cluster has detected loss to all paths to a\nrelevant datastore. Can be one of `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Default: `3`\nminutes. \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "Controls the action to take on\nvirtual machines when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `disabled`, `warning`, or\n`restartAggressive`. Default: `disabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haEnabled": {
                        "type": "boolean",
                        "description": "Enable vSphere HA for this cluster. Default:\n`false`.\n"
                    },
                    "haHeartbeatDatastoreIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of managed object IDs for\npreferred datastores to use for HA heartbeating. This setting is only useful\nwhen `ha_heartbeat_datastore_policy` is set\nto either `userSelectedDs` or `allFeasibleDsWithUserPreference`.\n"
                    },
                    "haHeartbeatDatastorePolicy": {
                        "type": "string",
                        "description": "The selection policy for HA\nheartbeat datastores. Can be one of `allFeasibleDs`, `userSelectedDs`, or\n`allFeasibleDsWithUserPreference`. Default:\n`allFeasibleDsWithUserPreference`.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on virtual\nmachines when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `none`, `powerOff`, or `shutdown`. Default:\n`none`.\n"
                    },
                    "haHostMonitoring": {
                        "type": "string",
                        "description": "Global setting that controls whether\nvSphere HA remediates virtual machines on host failure. Can be one of `enabled`\nor `disabled`. Default: `enabled`.\n"
                    },
                    "haVmComponentProtection": {
                        "type": "string",
                        "description": "Controls vSphere VM component\nprotection for virtual machines in this cluster. Can be one of `enabled` or\n`disabled`. Default: `enabled`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haVmDependencyRestartCondition": {
                        "type": "string",
                        "description": "The condition used to\ndetermine whether or not virtual machines in a certain restart priority class\nare online, allowing HA to move on to restarting virtual machines on the next\npriority. Can be one of `none`, `poweredOn`, `guestHbStatusGreen`, or\n`appHbStatusGreen`. The default is `none`, which means that a virtual machine\nis considered ready immediately after a host is found to start it on.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "If a heartbeat from a virtual machine\nis not received within this configured interval, the virtual machine is\nmarked as failed. The value is in seconds. Default: `30`.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will\nperform to a virtual machine when responding to a failure event. Default: `3`\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after\npowering on a virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                    },
                    "haVmRestartAdditionalDelay": {
                        "type": "integer",
                        "description": "Additional delay in seconds\nafter ready condition is met. A VM is considered ready at this point.\nDefault: `0` (no delay). \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The default restart priority\nfor affected virtual machines when vSphere detects a host failure. Can be one\nof `lowest`, `low`, `medium`, `high`, or `highest`. Default: `medium`.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds,\nthat vSphere HA will wait for virtual machines in one priority to be ready\nbefore proceeding with the next priority. Default: `600` (10 minutes).\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "hostClusterExitTimeout": {
                        "type": "integer",
                        "description": "The timeout for each host maintenance mode\noperation when removing hosts from a cluster. The value is specified in\nseconds. Default: `3600` (1 hour).\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to put in the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the cluster.\n"
                    },
                    "proactiveHaAutomationLevel": {
                        "type": "string",
                        "description": "Determines how the host\nquarantine, maintenance mode, or virtual machine migration recommendations\nmade by proactive HA are to be handled. Can be one of `Automated` or\n`Manual`. Default: `Manual`. \u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaEnabled": {
                        "type": "boolean",
                        "description": "Enables Proactive HA. Default: `false`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaModerateRemediation": {
                        "type": "string",
                        "description": "The configured remediation\nfor moderately degraded hosts. Can be one of `MaintenanceMode` or\n`QuarantineMode`. Note that this cannot be set to `MaintenanceMode` when\n`proactive_ha_severe_remediation` is set\nto `QuarantineMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaProviderIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of IDs for health update\nproviders configured for this cluster.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "proactiveHaSevereRemediation": {
                        "type": "string",
                        "description": "The configured remediation for\nseverely degraded hosts. Can be one of `MaintenanceMode` or `QuarantineMode`.\nNote that this cannot be set to `QuarantineMode` when\n`proactive_ha_moderate_remediation` is\nset to `MaintenanceMode`. Default: `QuarantineMode`.\n\u003csup\u003e\\*\u003c/sup\u003e\n"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID of the cluster's root resource pool.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterHostGroup:ComputeClusterHostGroup": {
            "description": "The `vsphere..ComputeClusterHostGroup` resource can be used to manage groups\nof hosts in a cluster, either created by the\n`vsphere..ComputeCluster` resource or looked up\nby the `vsphere..ComputeCluster` data source.\n\n\nThis resource mainly serves as an input to the\n`vsphere..ComputeClusterVmHostRule`\nresource - see the documentation for that resource for further details on how\nto use host groups.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterHostGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to put in the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAffinityRule:ComputeClusterVmAffinityRule": {
            "description": "The `vsphere..ComputeClusterVmAffinityRule` resource can be used to manage\nVM affinity rules in a cluster, either created by the\n`vsphere..ComputeCluster` resource or looked up\nby the `vsphere..ComputeCluster` data source.\n\nThis rule can be used to tell a set to virtual machines to run together on a\nsingle host within a cluster. When configured, DRS will make a best effort to\nensure that the virtual machines run on the same host, or prevent any operation\nthat would keep that from happening, depending on the value of the\n`mandatory` flag.\n\n\u003e Keep in mind that this rule can only be used to tell VMs to run together on\na _non-specific_ host - it can't be used to pin VMs to a host. For that, see\nthe\n`vsphere..ComputeClusterVmHostRule`\nresource.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below creates two virtual machines in a cluster using the\n`vsphere..VirtualMachine` resource, creating the\nvirtual machines in the cluster looked up by the\n`vsphere..ComputeCluster` data source. It\nthen creates an affinity rule for these two virtual machines, ensuring they\nwill run on the same host whenever possible.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastore = dc.apply(dc =\u003e vsphere.getDatastore({\n    datacenterId: dc.id,\n    name: \"datastore1\",\n}, { async: true }));\nconst cluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: \"cluster1\",\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"network1\",\n}, { async: true }));\nconst vm: vsphere.VirtualMachine[] = [];\nfor (let i = 0; i \u003c 2; i++) {\n    vm.push(new vsphere.VirtualMachine(`vm-${i}`, {\n        datastoreId: datastore.id,\n        disks: [{\n            label: \"disk0\",\n            size: 20,\n        }],\n        guestId: \"other3xLinux64Guest\",\n        memory: 2048,\n        networkInterfaces: [{\n            networkId: network.id,\n        }],\n        numCpus: 2,\n        resourcePoolId: cluster.resourcePoolId,\n    }));\n}\nconst clusterVmAffinityRule = new vsphere.ComputeClusterVmAffinityRule(\"cluster_vm_affinity_rule\", {\n    computeClusterId: cluster.id,\n    virtualMachineIds: vm.map(v =\u003e v.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"dc1\")\ndatastore = vsphere.get_datastore(datacenter_id=dc.id,\n    name=\"datastore1\")\ncluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=\"cluster1\")\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"network1\")\nvm = []\nfor range in [{\"value\": i} for i in range(0, 2)]:\n    vm.append(vsphere.VirtualMachine(f\"vm-{range['value']}\",\n        datastore_id=datastore.id,\n        disks=[{\n            \"label\": \"disk0\",\n            \"size\": 20,\n        }],\n        guest_id=\"other3xLinux64Guest\",\n        memory=2048,\n        network_interfaces=[{\n            \"networkId\": network.id,\n        }],\n        num_cpus=2,\n        resource_pool_id=cluster.resource_pool_id))\ncluster_vm_affinity_rule = vsphere.ComputeClusterVmAffinityRule(\"clusterVmAffinityRule\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[__item.id for __item in vm])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastore = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore1\",\n        })));\n        var cluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"cluster1\",\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"network1\",\n        })));\n        var vm = new List\u003cVSphere.VirtualMachine\u003e();\n        for (var rangeIndex = 0; rangeIndex \u003c 2; rangeIndex++)\n        {\n            var range = new { Value = rangeIndex };\n            vm.Add(new VSphere.VirtualMachine($\"vm-{range.Value}\", new VSphere.VirtualMachineArgs\n            {\n                DatastoreId = datastore.Apply(datastore =\u003e datastore.Id),\n                Disks = \n                {\n                    new VSphere.Inputs.VirtualMachineDiskArgs\n                    {\n                        Label = \"disk0\",\n                        Size = 20,\n                    },\n                },\n                GuestId = \"other3xLinux64Guest\",\n                Memory = 2048,\n                NetworkInterfaces = \n                {\n                    new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                    {\n                        NetworkId = network.Apply(network =\u003e network.Id),\n                    },\n                },\n                NumCpus = 2,\n                ResourcePoolId = cluster.Apply(cluster =\u003e cluster.ResourcePoolId),\n            }));\n        }\n        var clusterVmAffinityRule = new VSphere.ComputeClusterVmAffinityRule(\"clusterVmAffinityRule\", new VSphere.ComputeClusterVmAffinityRuleArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            VirtualMachineIds = vm.Select(__item =\u003e __item.Id).ToList(),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAntiAffinityRule:ComputeClusterVmAntiAffinityRule": {
            "description": "The `vsphere..ComputeClusterVmAntiAffinityRule` resource can be used to\nmanage VM anti-affinity rules in a cluster, either created by the\n`vsphere..ComputeCluster` resource or looked up\nby the `vsphere..ComputeCluster` data source.\n\nThis rule can be used to tell a set to virtual machines to run on different\nhosts within a cluster, useful for preventing single points of failure in\napplication cluster scenarios. When configured, DRS will make a best effort to\nensure that the virtual machines run on different hosts, or prevent any\noperation that would keep that from happening, depending on the value of the\n`mandatory` flag.\n\n\u003e Keep in mind that this rule can only be used to tell VMs to run separately\non _non-specific_ hosts - specific hosts cannot be specified with this rule.\nFor that, see the\n`vsphere..ComputeClusterVmHostRule`\nresource.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below creates two virtual machines in a cluster using the\n`vsphere..VirtualMachine` resource, creating the\nvirtual machines in the cluster looked up by the\n`vsphere..ComputeCluster` data source. It\nthen creates an anti-affinity rule for these two virtual machines, ensuring\nthey will run on different hosts whenever possible.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastore = dc.apply(dc =\u003e vsphere.getDatastore({\n    datacenterId: dc.id,\n    name: \"datastore1\",\n}, { async: true }));\nconst cluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: \"cluster1\",\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"network1\",\n}, { async: true }));\nconst vm: vsphere.VirtualMachine[] = [];\nfor (let i = 0; i \u003c 2; i++) {\n    vm.push(new vsphere.VirtualMachine(`vm-${i}`, {\n        datastoreId: datastore.id,\n        disks: [{\n            label: \"disk0\",\n            size: 20,\n        }],\n        guestId: \"other3xLinux64Guest\",\n        memory: 2048,\n        networkInterfaces: [{\n            networkId: network.id,\n        }],\n        numCpus: 2,\n        resourcePoolId: cluster.resourcePoolId,\n    }));\n}\nconst clusterVmAntiAffinityRule = new vsphere.ComputeClusterVmAntiAffinityRule(\"cluster_vm_anti_affinity_rule\", {\n    computeClusterId: cluster.id,\n    virtualMachineIds: vm.map(v =\u003e v.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"dc1\")\ndatastore = vsphere.get_datastore(datacenter_id=dc.id,\n    name=\"datastore1\")\ncluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=\"cluster1\")\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"network1\")\nvm = []\nfor range in [{\"value\": i} for i in range(0, 2)]:\n    vm.append(vsphere.VirtualMachine(f\"vm-{range['value']}\",\n        datastore_id=datastore.id,\n        disks=[{\n            \"label\": \"disk0\",\n            \"size\": 20,\n        }],\n        guest_id=\"other3xLinux64Guest\",\n        memory=2048,\n        network_interfaces=[{\n            \"networkId\": network.id,\n        }],\n        num_cpus=2,\n        resource_pool_id=cluster.resource_pool_id))\ncluster_vm_anti_affinity_rule = vsphere.ComputeClusterVmAntiAffinityRule(\"clusterVmAntiAffinityRule\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[__item.id for __item in vm])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastore = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore1\",\n        })));\n        var cluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"cluster1\",\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"network1\",\n        })));\n        var vm = new List\u003cVSphere.VirtualMachine\u003e();\n        for (var rangeIndex = 0; rangeIndex \u003c 2; rangeIndex++)\n        {\n            var range = new { Value = rangeIndex };\n            vm.Add(new VSphere.VirtualMachine($\"vm-{range.Value}\", new VSphere.VirtualMachineArgs\n            {\n                DatastoreId = datastore.Apply(datastore =\u003e datastore.Id),\n                Disks = \n                {\n                    new VSphere.Inputs.VirtualMachineDiskArgs\n                    {\n                        Label = \"disk0\",\n                        Size = 20,\n                    },\n                },\n                GuestId = \"other3xLinux64Guest\",\n                Memory = 2048,\n                NetworkInterfaces = \n                {\n                    new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                    {\n                        NetworkId = network.Apply(network =\u003e network.Id),\n                    },\n                },\n                NumCpus = 2,\n                ResourcePoolId = cluster.Apply(cluster =\u003e cluster.ResourcePoolId),\n            }));\n        }\n        var clusterVmAntiAffinityRule = new VSphere.ComputeClusterVmAntiAffinityRule(\"clusterVmAntiAffinityRule\", new VSphere.ComputeClusterVmAntiAffinityRuleArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            VirtualMachineIds = vm.Select(__item =\u003e __item.Id).ToList(),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmDependencyRule:ComputeClusterVmDependencyRule": {
            "description": "The `vsphere..ComputeClusterVmDependencyRule` resource can be used to manage\nVM dependency rules in a cluster, either created by the\n`vsphere..ComputeCluster` resource or looked up\nby the `vsphere..ComputeCluster` data source.\n\nA virtual machine dependency rule applies to vSphere HA, and allows\nuser-defined startup orders for virtual machines in the case of host failure.\nVirtual machines are supplied via groups, which can be managed via the\n`vsphere..ComputeClusterVmGroup`\nresource.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below creates two virtual machine in a cluster using the\n`vsphere..VirtualMachine` resource in a cluster\nlooked up by the `vsphere..ComputeCluster`\ndata source. It then creates a group with this virtual machine. Two groups are created, each with one of the created VMs. Finally, a rule is created to ensure that `vm1` starts before `vm2`.\n\n\u003e Note how `dependency_vm_group_name` and\n`vm_group_name` are sourced off of the `name` attributes from\nthe `vsphere..ComputeClusterVmGroup`\nresource. This is to ensure that the rule is not created before the groups\nexist, which may not possibly happen in the event that the names came from a\n\"static\" source such as a variable.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastore = dc.apply(dc =\u003e vsphere.getDatastore({\n    datacenterId: dc.id,\n    name: \"datastore1\",\n}, { async: true }));\nconst cluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: \"cluster1\",\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"network1\",\n}, { async: true }));\nconst vm1 = new vsphere.VirtualMachine(\"vm1\", {\n    datastoreId: datastore.id,\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n    guestId: \"other3xLinux64Guest\",\n    memory: 2048,\n    networkInterfaces: [{\n        networkId: network.id,\n    }],\n    numCpus: 2,\n    resourcePoolId: cluster.resourcePoolId,\n});\nconst vm2 = new vsphere.VirtualMachine(\"vm2\", {\n    datastoreId: datastore.id,\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n    guestId: \"other3xLinux64Guest\",\n    memory: 2048,\n    networkInterfaces: [{\n        networkId: network.id,\n    }],\n    numCpus: 2,\n    resourcePoolId: cluster.resourcePoolId,\n});\nconst clusterVmGroup1 = new vsphere.ComputeClusterVmGroup(\"cluster_vm_group1\", {\n    computeClusterId: cluster.id,\n    virtualMachineIds: [vm1.id],\n});\nconst clusterVmGroup2 = new vsphere.ComputeClusterVmGroup(\"cluster_vm_group2\", {\n    computeClusterId: cluster.id,\n    virtualMachineIds: [vm2.id],\n});\nconst clusterVmDependencyRule = new vsphere.ComputeClusterVmDependencyRule(\"cluster_vm_dependency_rule\", {\n    computeClusterId: cluster.id,\n    dependencyVmGroupName: clusterVmGroup1.name,\n    vmGroupName: clusterVmGroup2.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"dc1\")\ndatastore = vsphere.get_datastore(datacenter_id=dc.id,\n    name=\"datastore1\")\ncluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=\"cluster1\")\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"network1\")\nvm1 = vsphere.VirtualMachine(\"vm1\",\n    datastore_id=datastore.id,\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }],\n    guest_id=\"other3xLinux64Guest\",\n    memory=2048,\n    network_interfaces=[{\n        \"networkId\": network.id,\n    }],\n    num_cpus=2,\n    resource_pool_id=cluster.resource_pool_id)\nvm2 = vsphere.VirtualMachine(\"vm2\",\n    datastore_id=datastore.id,\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }],\n    guest_id=\"other3xLinux64Guest\",\n    memory=2048,\n    network_interfaces=[{\n        \"networkId\": network.id,\n    }],\n    num_cpus=2,\n    resource_pool_id=cluster.resource_pool_id)\ncluster_vm_group1 = vsphere.ComputeClusterVmGroup(\"clusterVmGroup1\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[vm1.id])\ncluster_vm_group2 = vsphere.ComputeClusterVmGroup(\"clusterVmGroup2\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[vm2.id])\ncluster_vm_dependency_rule = vsphere.ComputeClusterVmDependencyRule(\"clusterVmDependencyRule\",\n    compute_cluster_id=cluster.id,\n    dependency_vm_group_name=cluster_vm_group1.name,\n    vm_group_name=cluster_vm_group2.name)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastore = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore1\",\n        })));\n        var cluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"cluster1\",\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"network1\",\n        })));\n        var vm1 = new VSphere.VirtualMachine(\"vm1\", new VSphere.VirtualMachineArgs\n        {\n            DatastoreId = datastore.Apply(datastore =\u003e datastore.Id),\n            Disks = \n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n            GuestId = \"other3xLinux64Guest\",\n            Memory = 2048,\n            NetworkInterfaces = \n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(network =\u003e network.Id),\n                },\n            },\n            NumCpus = 2,\n            ResourcePoolId = cluster.Apply(cluster =\u003e cluster.ResourcePoolId),\n        });\n        var vm2 = new VSphere.VirtualMachine(\"vm2\", new VSphere.VirtualMachineArgs\n        {\n            DatastoreId = datastore.Apply(datastore =\u003e datastore.Id),\n            Disks = \n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n            GuestId = \"other3xLinux64Guest\",\n            Memory = 2048,\n            NetworkInterfaces = \n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(network =\u003e network.Id),\n                },\n            },\n            NumCpus = 2,\n            ResourcePoolId = cluster.Apply(cluster =\u003e cluster.ResourcePoolId),\n        });\n        var clusterVmGroup1 = new VSphere.ComputeClusterVmGroup(\"clusterVmGroup1\", new VSphere.ComputeClusterVmGroupArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            VirtualMachineIds = \n            {\n                vm1.Id,\n            },\n        });\n        var clusterVmGroup2 = new VSphere.ComputeClusterVmGroup(\"clusterVmGroup2\", new VSphere.ComputeClusterVmGroupArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            VirtualMachineIds = \n            {\n                vm2.Id,\n            },\n        });\n        var clusterVmDependencyRule = new VSphere.ComputeClusterVmDependencyRule(\"clusterVmDependencyRule\", new VSphere.ComputeClusterVmDependencyRuleArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            DependencyVmGroupName = clusterVmGroup1.Name,\n            VmGroupName = clusterVmGroup2.Name,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "required": [
                "computeClusterId",
                "dependencyVmGroupName",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "dependencyVmGroupName",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmDependencyRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "dependencyVmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmGroup:ComputeClusterVmGroup": {
            "description": "The `vsphere..ComputeClusterVmGroup` resource can be used to manage groups of\nvirtual machines in a cluster, either created by the\n[`vsphere..ComputeCluster`][tf-vsphere-cluster-resource] resource or looked up\nby the [`vsphere..ComputeCluster`][tf-vsphere-cluster-data-source] data source.\n\n[tf-vsphere-cluster-resource]: /docs/providers/vsphere/r/compute_cluster.html\n[tf-vsphere-cluster-data-source]: /docs/providers/vsphere/d/compute_cluster.html\n\nThis resource mainly serves as an input to the\n[`vsphere..ComputeClusterVmDependencyRule`][tf-vsphere-cluster-vm-dependency-rule-resource]\nand\n[`vsphere..ComputeClusterVmHostRule`][tf-vsphere-cluster-vm-host-rule-resource]\nresources. See the individual resource documentation pages for more information.\n\n[tf-vsphere-cluster-vm-dependency-rule-resource]: /docs/providers/vsphere/r/compute_cluster_vm_dependency_rule.html\n[tf-vsphere-cluster-vm-host-rule-resource]: /docs/providers/vsphere/r/compute_cluster_vm_host_rule.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below creates two virtual machines in a cluster using the\n`vsphere..VirtualMachine` resource, creating the\nvirtual machine in the cluster looked up by the\n`vsphere..ComputeCluster` data source. It\nthen creates a group from these two virtual machines.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastore = dc.apply(dc =\u003e vsphere.getDatastore({\n    datacenterId: dc.id,\n    name: \"datastore1\",\n}, { async: true }));\nconst cluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: \"cluster1\",\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"network1\",\n}, { async: true }));\nconst vm: vsphere.VirtualMachine[] = [];\nfor (let i = 0; i \u003c 2; i++) {\n    vm.push(new vsphere.VirtualMachine(`vm-${i}`, {\n        datastoreId: datastore.id,\n        disks: [{\n            label: \"disk0\",\n            size: 20,\n        }],\n        guestId: \"other3xLinux64Guest\",\n        memory: 2048,\n        networkInterfaces: [{\n            networkId: network.id,\n        }],\n        numCpus: 2,\n        resourcePoolId: cluster.resourcePoolId,\n    }));\n}\nconst clusterVmGroup = new vsphere.ComputeClusterVmGroup(\"cluster_vm_group\", {\n    computeClusterId: cluster.id,\n    virtualMachineIds: vm.map(v =\u003e v.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"dc1\")\ndatastore = vsphere.get_datastore(datacenter_id=dc.id,\n    name=\"datastore1\")\ncluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=\"cluster1\")\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"network1\")\nvm = []\nfor range in [{\"value\": i} for i in range(0, 2)]:\n    vm.append(vsphere.VirtualMachine(f\"vm-{range['value']}\",\n        datastore_id=datastore.id,\n        disks=[{\n            \"label\": \"disk0\",\n            \"size\": 20,\n        }],\n        guest_id=\"other3xLinux64Guest\",\n        memory=2048,\n        network_interfaces=[{\n            \"networkId\": network.id,\n        }],\n        num_cpus=2,\n        resource_pool_id=cluster.resource_pool_id))\ncluster_vm_group = vsphere.ComputeClusterVmGroup(\"clusterVmGroup\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[__item.id for __item in vm])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastore = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore1\",\n        })));\n        var cluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"cluster1\",\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"network1\",\n        })));\n        var vm = new List\u003cVSphere.VirtualMachine\u003e();\n        for (var rangeIndex = 0; rangeIndex \u003c 2; rangeIndex++)\n        {\n            var range = new { Value = rangeIndex };\n            vm.Add(new VSphere.VirtualMachine($\"vm-{range.Value}\", new VSphere.VirtualMachineArgs\n            {\n                DatastoreId = datastore.Apply(datastore =\u003e datastore.Id),\n                Disks = \n                {\n                    new VSphere.Inputs.VirtualMachineDiskArgs\n                    {\n                        Label = \"disk0\",\n                        Size = 20,\n                    },\n                },\n                GuestId = \"other3xLinux64Guest\",\n                Memory = 2048,\n                NetworkInterfaces = \n                {\n                    new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                    {\n                        NetworkId = network.Apply(network =\u003e network.Id),\n                    },\n                },\n                NumCpus = 2,\n                ResourcePoolId = cluster.Apply(cluster =\u003e cluster.ResourcePoolId),\n            }));\n        }\n        var clusterVmGroup = new VSphere.ComputeClusterVmGroup(\"clusterVmGroup\", new VSphere.ComputeClusterVmGroupArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            VirtualMachineIds = vm.Select(__item =\u003e __item.Id).ToList(),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines in this\ngroup.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmHostRule:ComputeClusterVmHostRule": {
            "description": "The `vsphere..ComputeClusterVmHostRule` resource can be used to manage\nVM-to-host rules in a cluster, either created by the\n`vsphere..ComputeCluster` resource or looked up\nby the `vsphere..ComputeCluster` data source.\n\nThis resource can create both _affinity rules_, where virtual machines run on\nspecified hosts, or _anti-affinity_ rules, where virtual machines run on hosts\noutside of the ones specified in the rule. Virtual machines and hosts are\nsupplied via groups, which can be managed via the\n`vsphere..ComputeClusterVmGroup` and\n`vsphere..ComputeClusterHostGroup`\nresources.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below creates a virtual machine in a cluster using the\n`vsphere..VirtualMachine` resource in a cluster\nlooked up by the `vsphere..ComputeCluster`\ndata source. It then creates a group with this virtual machine. It also creates\na host group off of the host looked up via the\n`vsphere..Host` data source. Finally, this\nvirtual machine is configured to run specifically on that host via a\n`vsphere..ComputeClusterVmHostRule` resource.\n\n\u003e Note how `vm_group_name` and\n`affinity_host_group_name` are sourced off of the\n`name` attributes from the\n`vsphere..ComputeClusterVmGroup` and\n`vsphere..ComputeClusterHostGroup`\nresources. This is to ensure that the rule is not created before the groups\nexist, which may not possibly happen in the event that the names came from a\n\"static\" source such as a variable.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastore = dc.apply(dc =\u003e vsphere.getDatastore({\n    datacenterId: dc.id,\n    name: \"datastore1\",\n}, { async: true }));\nconst cluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: \"cluster1\",\n}, { async: true }));\nconst host = dc.apply(dc =\u003e vsphere.getHost({\n    datacenterId: dc.id,\n    name: \"esxi1\",\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"network1\",\n}, { async: true }));\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    datastoreId: datastore.id,\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n    guestId: \"other3xLinux64Guest\",\n    memory: 2048,\n    networkInterfaces: [{\n        networkId: network.id,\n    }],\n    numCpus: 2,\n    resourcePoolId: cluster.resourcePoolId,\n});\nconst clusterVmGroup = new vsphere.ComputeClusterVmGroup(\"cluster_vm_group\", {\n    computeClusterId: cluster.id,\n    virtualMachineIds: [vm.id],\n});\nconst clusterHostGroup = new vsphere.ComputeClusterHostGroup(\"cluster_host_group\", {\n    computeClusterId: cluster.id,\n    hostSystemIds: [host.id],\n});\nconst clusterVmHostRule = new vsphere.ComputeClusterVmHostRule(\"cluster_vm_host_rule\", {\n    affinityHostGroupName: clusterHostGroup.name,\n    computeClusterId: cluster.id,\n    vmGroupName: clusterVmGroup.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"dc1\")\ndatastore = vsphere.get_datastore(datacenter_id=dc.id,\n    name=\"datastore1\")\ncluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=\"cluster1\")\nhost = vsphere.get_host(datacenter_id=dc.id,\n    name=\"esxi1\")\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"network1\")\nvm = vsphere.VirtualMachine(\"vm\",\n    datastore_id=datastore.id,\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }],\n    guest_id=\"other3xLinux64Guest\",\n    memory=2048,\n    network_interfaces=[{\n        \"networkId\": network.id,\n    }],\n    num_cpus=2,\n    resource_pool_id=cluster.resource_pool_id)\ncluster_vm_group = vsphere.ComputeClusterVmGroup(\"clusterVmGroup\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[vm.id])\ncluster_host_group = vsphere.ComputeClusterHostGroup(\"clusterHostGroup\",\n    compute_cluster_id=cluster.id,\n    host_system_ids=[host.id])\ncluster_vm_host_rule = vsphere.ComputeClusterVmHostRule(\"clusterVmHostRule\",\n    affinity_host_group_name=cluster_host_group.name,\n    compute_cluster_id=cluster.id,\n    vm_group_name=cluster_vm_group.name)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastore = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore1\",\n        })));\n        var cluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"cluster1\",\n        })));\n        var host = dc.Apply(dc =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"esxi1\",\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"network1\",\n        })));\n        var vm = new VSphere.VirtualMachine(\"vm\", new VSphere.VirtualMachineArgs\n        {\n            DatastoreId = datastore.Apply(datastore =\u003e datastore.Id),\n            Disks = \n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n            GuestId = \"other3xLinux64Guest\",\n            Memory = 2048,\n            NetworkInterfaces = \n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(network =\u003e network.Id),\n                },\n            },\n            NumCpus = 2,\n            ResourcePoolId = cluster.Apply(cluster =\u003e cluster.ResourcePoolId),\n        });\n        var clusterVmGroup = new VSphere.ComputeClusterVmGroup(\"clusterVmGroup\", new VSphere.ComputeClusterVmGroupArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            VirtualMachineIds = \n            {\n                vm.Id,\n            },\n        });\n        var clusterHostGroup = new VSphere.ComputeClusterHostGroup(\"clusterHostGroup\", new VSphere.ComputeClusterHostGroupArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            HostSystemIds = \n            {\n                host.Apply(host =\u003e host.Id),\n            },\n        });\n        var clusterVmHostRule = new VSphere.ComputeClusterVmHostRule(\"clusterVmHostRule\", new VSphere.ComputeClusterVmHostRuleArgs\n        {\n            AffinityHostGroupName = clusterHostGroup.Name,\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            VmGroupName = clusterVmGroup.Name,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmHostRule resources.\n",
                "properties": {
                    "affinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                    },
                    "antiAffinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                    },
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the virtual machine group to use\nwith this rule.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibrary:ContentLibrary": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description of the Content Library.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Content Library.\n"
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID on which to store Content Library\nitems.\n"
                }
            },
            "required": [
                "name",
                "storageBackings"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description of the Content Library.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the Content Library.\n"
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID on which to store Content Library\nitems.\n"
                }
            },
            "requiredInputs": [
                "storageBackings"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibrary resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description of the Content Library.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Content Library.\n"
                    },
                    "storageBackings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object reference ID on which to store Content Library\nitems.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibraryItem:ContentLibraryItem": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description for the item.\n"
                },
                "fileUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of files to download for the Content Library item.\n"
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the Content Library the item should be created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the Content Library.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\n"
                }
            },
            "required": [
                "fileUrls",
                "libraryId",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description for the item.\n"
                },
                "fileUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of files to download for the Content Library item.\n"
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the Content Library the item should be created in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the Content Library.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\n"
                }
            },
            "requiredInputs": [
                "fileUrls",
                "libraryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibraryItem resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description for the item.\n"
                    },
                    "fileUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of files to download for the Content Library item.\n"
                    },
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the Content Library the item should be created in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the item to be created in the Content Library.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of content library item.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/customAttribute:CustomAttribute": {
            "properties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, click here. Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, click here. Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomAttribute resources.\n",
                "properties": {
                    "managedObjectType": {
                        "type": "string",
                        "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, click here. Forces a new\nresource if changed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datacenter:Datacenter": {
            "description": "Provides a VMware vSphere datacenter resource. This can be used as the primary\ncontainer of inventory objects such as hosts and virtual machines.\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### Create datacenter on the root folder\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodDatacenter = new vsphere.Datacenter(\"prod_datacenter\", {});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_datacenter = vsphere.Datacenter(\"prodDatacenter\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var prodDatacenter = new VSphere.Datacenter(\"prodDatacenter\", new VSphere.DatacenterArgs\n        {\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Create datacenter on a subfolder\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst researchDatacenter = new vsphere.Datacenter(\"research_datacenter\", {\n    folder: \"/research/\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nresearch_datacenter = vsphere.Datacenter(\"researchDatacenter\", folder=\"/research/\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var researchDatacenter = new VSphere.Datacenter(\"researchDatacenter\", new VSphere.DatacenterArgs\n        {\n            Folder = \"/research/\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value \nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "Managed object ID of this datacenter.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "moid",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value \nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Datacenter resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to value \nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n"
                    },
                    "moid": {
                        "type": "string",
                        "description": "Managed object ID of this datacenter.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreCluster:DatastoreCluster": {
            "description": "The `vsphere..DatastoreCluster` resource can be used to create and manage\ndatastore clusters. This can be used to create groups of datastores with a\nshared management interface, allowing for resource control and load balancing\nthrough Storage DRS.\n\nFor more information on vSphere datastore clusters and Storage DRS, see [this\npage][ref-vsphere-datastore-clusters].\n\n[ref-vsphere-datastore-clusters]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-598DF695-107E-406B-9C95-0AF961FC227A.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** Storage DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map of advanced Storage DRS\nsettings that are not exposed via the provider or the vSphere client.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The global automation level for all\nvirtual machines in this datastore cluster. Default: `manual`.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When `true`, all disks in a\nsingle virtual machine will be kept on the same datastore. Default: `true`.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The free space threshold to use.\nWhen set to `utilization`, `drs_space_utilization_threshold` is used, and\nwhen set to `freeSpace`, `drs_free_space_threshold` is used. Default:\n`utilization`.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of difference between space utilization in datastores before storage\nDRS makes decisions to balance the space. Default: `5` percent.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in\nmilliseconds, that storage DRS uses to make recommendations to move disks\nfrom this datastore. Default: `15` seconds.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for\nthis datastore cluster. Default: `true`.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load\nin datastores in the cluster before storage DRS makes recommendations to\nbalance the load. Default: `5` percent.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable\nIOPS of all virtual machines on the datastore before storage DRS makes\nrecommendations to move VMs off of a datastore. Note that this setting should\nonly be set if `sdrs_io_reservable_percent_threshold` cannot make an accurate\nestimate of the capacity of the datastores in your cluster, and should be set\nto roughly 50-60% of the worst case peak performance of the backing LUNs.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of actual estimated performance of the datastore (in IOPS) that\nstorage DRS uses to make recommendations to move VMs off of a datastore when\nthe total reservable IOPS exceeds the threshold. Default: `60` percent.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS\nthreshold setting to use, `sdrs_io_reservable_percent_threshold` in the event\nof `automatic`, or `sdrs_io_reservable_iops_threshold` in the event of\n`manual`. Default: `automatic`.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in\nminutes. Default: `480` minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "datacenterId",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key/value map of advanced Storage DRS\nsettings that are not exposed via the provider or the vSphere client.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The global automation level for all\nvirtual machines in this datastore cluster. Default: `manual`.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When `true`, all disks in a\nsingle virtual machine will be kept on the same datastore. Default: `true`.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The free space threshold to use.\nWhen set to `utilization`, `drs_space_utilization_threshold` is used, and\nwhen set to `freeSpace`, `drs_free_space_threshold` is used. Default:\n`utilization`.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of difference between space utilization in datastores before storage\nDRS makes decisions to balance the space. Default: `5` percent.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in\nmilliseconds, that storage DRS uses to make recommendations to move disks\nfrom this datastore. Default: `15` seconds.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for\nthis datastore cluster. Default: `true`.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load\nin datastores in the cluster before storage DRS makes recommendations to\nbalance the load. Default: `5` percent.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable\nIOPS of all virtual machines on the datastore before storage DRS makes\nrecommendations to move VMs off of a datastore. Note that this setting should\nonly be set if `sdrs_io_reservable_percent_threshold` cannot make an accurate\nestimate of the capacity of the datastores in your cluster, and should be set\nto roughly 50-60% of the worst case peak performance of the backing LUNs.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in\npercent, of actual estimated performance of the datastore (in IOPS) that\nstorage DRS uses to make recommendations to move VMs off of a datastore when\nthe total reservable IOPS exceeds the threshold. Default: `60` percent.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS\nthreshold setting to use, `sdrs_io_reservable_percent_threshold` in the event\nof `automatic`, or `sdrs_io_reservable_iops_threshold` in the event of\n`manual`. Default: `automatic`.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in\nminutes. Default: `480` minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default\nautomation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore cluster.\n"
                    },
                    "sdrsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A key/value map of advanced Storage DRS\nsettings that are not exposed via the provider or the vSphere client.\n"
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "The global automation level for all\nvirtual machines in this datastore cluster. Default: `manual`.\n"
                    },
                    "sdrsDefaultIntraVmAffinity": {
                        "type": "boolean",
                        "description": "When `true`, all disks in a\nsingle virtual machine will be kept on the same datastore. Default: `true`.\n"
                    },
                    "sdrsEnabled": {
                        "type": "boolean",
                        "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                    },
                    "sdrsFreeSpaceThreshold": {
                        "type": "integer",
                        "description": "The free space threshold to use.\nWhen set to `utilization`, `drs_space_utilization_threshold` is used, and\nwhen set to `freeSpace`, `drs_free_space_threshold` is used. Default:\n`utilization`.\n"
                    },
                    "sdrsFreeSpaceThresholdMode": {
                        "type": "string",
                        "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                    },
                    "sdrsFreeSpaceUtilizationDifference": {
                        "type": "integer",
                        "description": "The threshold, in\npercent, of difference between space utilization in datastores before storage\nDRS makes decisions to balance the space. Default: `5` percent.\n"
                    },
                    "sdrsIoBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting I/O load imbalances.\n"
                    },
                    "sdrsIoLatencyThreshold": {
                        "type": "integer",
                        "description": "The I/O latency threshold, in\nmilliseconds, that storage DRS uses to make recommendations to move disks\nfrom this datastore. Default: `15` seconds.\n"
                    },
                    "sdrsIoLoadBalanceEnabled": {
                        "type": "boolean",
                        "description": "Enable I/O load balancing for\nthis datastore cluster. Default: `true`.\n"
                    },
                    "sdrsIoLoadImbalanceThreshold": {
                        "type": "integer",
                        "description": "The difference between load\nin datastores in the cluster before storage DRS makes recommendations to\nbalance the load. Default: `5` percent.\n"
                    },
                    "sdrsIoReservableIopsThreshold": {
                        "type": "integer",
                        "description": "The threshold of reservable\nIOPS of all virtual machines on the datastore before storage DRS makes\nrecommendations to move VMs off of a datastore. Note that this setting should\nonly be set if `sdrs_io_reservable_percent_threshold` cannot make an accurate\nestimate of the capacity of the datastores in your cluster, and should be set\nto roughly 50-60% of the worst case peak performance of the backing LUNs.\n"
                    },
                    "sdrsIoReservablePercentThreshold": {
                        "type": "integer",
                        "description": "The threshold, in\npercent, of actual estimated performance of the datastore (in IOPS) that\nstorage DRS uses to make recommendations to move VMs off of a datastore when\nthe total reservable IOPS exceeds the threshold. Default: `60` percent.\n"
                    },
                    "sdrsIoReservableThresholdMode": {
                        "type": "string",
                        "description": "The reservable IOPS\nthreshold setting to use, `sdrs_io_reservable_percent_threshold` in the event\nof `automatic`, or `sdrs_io_reservable_iops_threshold` in the event of\n`manual`. Default: `automatic`.\n"
                    },
                    "sdrsLoadBalanceInterval": {
                        "type": "integer",
                        "description": "The storage DRS poll interval, in\nminutes. Default: `480` minutes.\n"
                    },
                    "sdrsPolicyEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting storage and VM policy violations.\n"
                    },
                    "sdrsRuleEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting affinity rule violations.\n"
                    },
                    "sdrsSpaceBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when correcting disk space imbalances.\n"
                    },
                    "sdrsSpaceUtilizationThreshold": {
                        "type": "integer",
                        "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                    },
                    "sdrsVmEvacuationAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default\nautomation settings when generating recommendations for datastore evacuation.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreClusterVmAntiAffinityRule:DatastoreClusterVmAntiAffinityRule": {
            "description": "The `vsphere..DatastoreClusterVmAntiAffinityRule` resource can be used to\nmanage VM anti-affinity rules in a datastore cluster, either created by the\n`vsphere..DatastoreCluster` resource or looked up\nby the `vsphere..DatastoreCluster` data source.\n\nThis rule can be used to tell a set to virtual machines to run on different\ndatastores within a cluster, useful for preventing single points of failure in\napplication cluster scenarios. When configured, Storage DRS will make a best effort to\nensure that the virtual machines run on different datastores, or prevent any\noperation that would keep that from happening, depending on the value of the\n`mandatory` flag.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** Storage DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below creates two virtual machines in a cluster using the\n`vsphere..VirtualMachine` resource, creating the\nvirtual machines in the datastore cluster looked up by the\n`vsphere..DatastoreCluster` data\nsource. It then creates an anti-affinity rule for these two virtual machines,\nensuring they will run on different datastores whenever possible.\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastoreCluster = dc.apply(dc =\u003e vsphere.getDatastoreCluster({\n    datacenterId: dc.id,\n    name: \"datastore-cluster1\",\n}, { async: true }));\nconst cluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: \"cluster1\",\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"network1\",\n}, { async: true }));\nconst vm: vsphere.VirtualMachine[] = [];\nfor (let i = 0; i \u003c 2; i++) {\n    vm.push(new vsphere.VirtualMachine(`vm-${i}`, {\n        datastoreClusterId: datastoreCluster.id,\n        disks: [{\n            label: \"disk0\",\n            size: 20,\n        }],\n        guestId: \"other3xLinux64Guest\",\n        memory: 2048,\n        networkInterfaces: [{\n            networkId: network.id,\n        }],\n        numCpus: 2,\n        resourcePoolId: cluster.resourcePoolId,\n    }));\n}\nconst clusterVmAntiAffinityRule = new vsphere.DatastoreClusterVmAntiAffinityRule(\"cluster_vm_anti_affinity_rule\", {\n    datastoreClusterId: datastoreCluster.id,\n    virtualMachineIds: vm.map(v =\u003e v.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"dc1\")\ndatastore_cluster = vsphere.get_datastore_cluster(datacenter_id=dc.id,\n    name=\"datastore-cluster1\")\ncluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=\"cluster1\")\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"network1\")\nvm = []\nfor range in [{\"value\": i} for i in range(0, 2)]:\n    vm.append(vsphere.VirtualMachine(f\"vm-{range['value']}\",\n        datastore_cluster_id=datastore_cluster.id,\n        disks=[{\n            \"label\": \"disk0\",\n            \"size\": 20,\n        }],\n        guest_id=\"other3xLinux64Guest\",\n        memory=2048,\n        network_interfaces=[{\n            \"networkId\": network.id,\n        }],\n        num_cpus=2,\n        resource_pool_id=cluster.resource_pool_id))\ncluster_vm_anti_affinity_rule = vsphere.DatastoreClusterVmAntiAffinityRule(\"clusterVmAntiAffinityRule\",\n    datastore_cluster_id=datastore_cluster.id,\n    virtual_machine_ids=[__item.id for __item in vm])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastoreCluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastoreCluster.InvokeAsync(new VSphere.GetDatastoreClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore-cluster1\",\n        })));\n        var cluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"cluster1\",\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"network1\",\n        })));\n        var vm = new List\u003cVSphere.VirtualMachine\u003e();\n        for (var rangeIndex = 0; rangeIndex \u003c 2; rangeIndex++)\n        {\n            var range = new { Value = rangeIndex };\n            vm.Add(new VSphere.VirtualMachine($\"vm-{range.Value}\", new VSphere.VirtualMachineArgs\n            {\n                DatastoreClusterId = datastoreCluster.Apply(datastoreCluster =\u003e datastoreCluster.Id),\n                Disks = \n                {\n                    new VSphere.Inputs.VirtualMachineDiskArgs\n                    {\n                        Label = \"disk0\",\n                        Size = 20,\n                    },\n                },\n                GuestId = \"other3xLinux64Guest\",\n                Memory = 2048,\n                NetworkInterfaces = \n                {\n                    new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                    {\n                        NetworkId = network.Apply(network =\u003e network.Id),\n                    },\n                },\n                NumCpus = 2,\n                ResourcePoolId = cluster.Apply(cluster =\u003e cluster.ResourcePoolId),\n            }));\n        }\n        var clusterVmAntiAffinityRule = new VSphere.DatastoreClusterVmAntiAffinityRule(\"clusterVmAntiAffinityRule\", new VSphere.DatastoreClusterVmAntiAffinityRuleArgs\n        {\n            DatastoreClusterId = datastoreCluster.Apply(datastoreCluster =\u003e datastoreCluster.Id),\n            VirtualMachineIds = vm.Select(__item =\u003e __item.Id).ToList(),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n"
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedPortGroup:DistributedPortGroup": {
            "description": "The `vsphere..DistributedPortGroup` resource can be used to manage vSphere\ndistributed virtual port groups. These port groups are connected to distributed\nvirtual switches, which can be managed by the\n`vsphere..DistributedVirtualSwitch` resource.\n\nDistributed port groups can be used as networks for virtual machines, allowing\nVMs to use the networking supplied by a distributed virtual switch (DVS), with\na set of policies that apply to that individual newtork, if desired.\n\nFor an overview on vSphere networking concepts, see [this\npage][ref-vsphere-net-concepts]. For more information on vSphere DVS\nportgroups, see [this page][ref-vsphere-dvportgroup].\n\n[ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html\n[ref-vsphere-dvportgroup]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-69933F6E-2442-46CF-AA17-1196CB9A0A09.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### Overriding DVS policies\n\nAll of the default port policies available in the\n`vsphere..DistributedVirtualSwitch` resource can be overridden on the port\ngroup level by specifying new settings for them.\n\nAs an example, we also take this example from the\n`vsphere..DistributedVirtualSwitch` resource where we manually specify our\nuplink count and uplink order. While the DVS has a default policy of using the\nfirst uplink as an active uplink and the second one as a standby, the\noverridden port group policy means that both uplinks will be used as active\nuplinks in this specific port group.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dvs = new vsphere.DistributedVirtualSwitch(\"dvs\", {\n    activeUplinks: [\"tfup1\"],\n    datacenterId: vsphere_datacenter_dc.id,\n    standbyUplinks: [\"tfup2\"],\n    uplinks: [\n        \"tfup1\",\n        \"tfup2\",\n    ],\n});\nconst pg = new vsphere.DistributedPortGroup(\"pg\", {\n    activeUplinks: [\n        \"tfup1\",\n        \"tfup2\",\n    ],\n    distributedVirtualSwitchUuid: dvs.id,\n    standbyUplinks: [],\n    vlanId: 1000,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndvs = vsphere.DistributedVirtualSwitch(\"dvs\",\n    active_uplinks=[\"tfup1\"],\n    datacenter_id=data[\"vsphere..Datacenter\"][\"dc\"][\"id\"],\n    standby_uplinks=[\"tfup2\"],\n    uplinks=[\n        \"tfup1\",\n        \"tfup2\",\n    ])\npg = vsphere.DistributedPortGroup(\"pg\",\n    active_uplinks=[\n        \"tfup1\",\n        \"tfup2\",\n    ],\n    distributed_virtual_switch_uuid=dvs.id,\n    standby_uplinks=[],\n    vlan_id=1000)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dvs = new VSphere.DistributedVirtualSwitch(\"dvs\", new VSphere.DistributedVirtualSwitchArgs\n        {\n            ActiveUplinks = \n            {\n                \"tfup1\",\n            },\n            DatacenterId = data.Vsphere_datacenter.Dc.Id,\n            StandbyUplinks = \n            {\n                \"tfup2\",\n            },\n            Uplinks = \n            {\n                \"tfup1\",\n                \"tfup2\",\n            },\n        });\n        var pg = new VSphere.DistributedPortGroup(\"pg\", new VSphere.DistributedPortGroupArgs\n        {\n            ActiveUplinks = \n            {\n                \"tfup1\",\n                \"tfup2\",\n            },\n            DistributedVirtualSwitchUuid = dvs.Id,\n            StandbyUplinks = {},\n            VlanId = 1000,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the port shutdown\npolicy to be overridden on an individual port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "Version string of the configuration that this spec is trying to change.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the DVS to add the\nport group to. Forces a new resource if changed.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The generated UUID of the portgroup.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a port in this port group to be\nmoved to another port group while it is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the Netflow\npolicy on this port group to be overridden on an individual\nport.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network\nresource pool set on this port group to be overridden on an individual port.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset a port's settings to the\nsettings defined on this port group policy when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the security policy\nsettings defined in this port group policy to be\noverridden on an individual port.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the traffic shaping\noptions on this port group policy to be overridden\non an individual port.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any traffic filters on\nthis port group to be overridden on an individual port.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the uplink teaming\noptions on this port group to be overridden on an\nindividual port.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the VLAN settings\non this port group to be overridden on an individual port.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "directpathGen2Allowed",
                "distributedVirtualSwitchUuid",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "key",
                "lacpEnabled",
                "lacpMode",
                "name",
                "netflowEnabled",
                "notifySwitches",
                "numberOfPorts",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "vlanId",
                "vlanRanges"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the port shutdown\npolicy to be overridden on an individual port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the DVS to add the\nport group to. Forces a new resource if changed.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a port in this port group to be\nmoved to another port group while it is connected.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the Netflow\npolicy on this port group to be overridden on an individual\nport.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network\nresource pool set on this port group to be overridden on an individual port.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset a port's settings to the\nsettings defined on this port group policy when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the security policy\nsettings defined in this port group policy to be\noverridden on an individual port.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the traffic shaping\noptions on this port group policy to be overridden\non an individual port.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any traffic filters on\nthis port group to be overridden on an individual port.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the uplink teaming\noptions on this port group to be overridden on an\nindividual port.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the VLAN settings\non this port group to be overridden on an individual port.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "requiredInputs": [
                "distributedVirtualSwitchUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedPortGroup resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "autoExpand": {
                        "type": "boolean",
                        "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Indicates whether to block all ports by default.\n"
                    },
                    "blockOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the port shutdown\npolicy to be overridden on an individual port.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing on the ports this policy applies to.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "Version string of the configuration that this spec is trying to change.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue string to set for port group.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description for the port group.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "The ID of the DVS to add the\nport group to. Forces a new resource if changed.\n"
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The generated UUID of the portgroup.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable LACP on all uplink ports.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                    },
                    "livePortMovingAllowed": {
                        "type": "boolean",
                        "description": "Allow a port in this port group to be\nmoved to another port group while it is connected.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether to enable netflow on all ports.\n"
                    },
                    "netflowOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the Netflow\npolicy on this port group to be overridden on an individual\nport.\n"
                    },
                    "networkResourcePoolKey": {
                        "type": "string",
                        "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                    },
                    "networkResourcePoolOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the network\nresource pool set on this port group to be overridden on an individual port.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                    },
                    "portConfigResetAtDisconnect": {
                        "type": "boolean",
                        "description": "Reset a port's settings to the\nsettings defined on this port group policy when the port disconnects.\n"
                    },
                    "portNameFormat": {
                        "type": "string",
                        "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "The secondary VLAN ID for this port.\n"
                    },
                    "securityPolicyOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the security policy\nsettings defined in this port group policy to be\noverridden on an individual port.\n"
                    },
                    "shapingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the traffic shaping\noptions on this port group policy to be overridden\non an individual port.\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                    },
                    "trafficFilterOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow any traffic filters on\nthis port group to be overridden on an individual port.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                    },
                    "uplinkTeamingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the uplink teaming\noptions on this port group to be overridden on an\nindividual port.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the VLAN settings\non this port group to be overridden on an individual port.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                        },
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch": {
            "description": "The `vsphere..DistributedVirtualSwitch` resource can be used to manage VMware\nDistributed Virtual Switches.\n\nAn essential component of a distributed, scalable VMware datacenter, the\nvSphere Distributed Virtual Switch (DVS) provides centralized management and\nmonitoring of the networking configuration of all the hosts that are associated\nwith the switch. In addition to adding port groups (see the\n`vsphere..DistributedPortGroup` resource) that can\nbe used as networks for virtual machines, a DVS can be configured to perform\nadvanced high availability, traffic shaping, network monitoring, and more.\n\nFor an overview on vSphere networking concepts, see [this\npage][ref-vsphere-net-concepts]. For more information on vSphere DVS, see [this\npage][ref-vsphere-dvs].\n\n[ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html\n[ref-vsphere-dvs]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-375B45C7-684C-4C51-BA3C-70E48DFABF04.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### Uplink name and count control\n\nThe following abridged example below demonstrates how you can manage the number\nof uplinks, and the name of the uplinks via the `uplinks` parameter.\n\nNote that if you change the uplink naming and count after creating the DVS, you\nmay need to explicitly specify `active_uplinks` and `standby_uplinks` as these\nvalues are saved to state after creation, regardless of being\nspecified in config, and will drift if not modified, causing errors.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dvs = new vsphere.DistributedVirtualSwitch(\"dvs\", {\n    activeUplinks: [\"tfup1\"],\n    datacenterId: vsphere_datacenter_dc.id,\n    standbyUplinks: [\"tfup2\"],\n    uplinks: [\n        \"tfup1\",\n        \"tfup2\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndvs = vsphere.DistributedVirtualSwitch(\"dvs\",\n    active_uplinks=[\"tfup1\"],\n    datacenter_id=data[\"vsphere..Datacenter\"][\"dc\"][\"id\"],\n    standby_uplinks=[\"tfup2\"],\n    uplinks=[\n        \"tfup1\",\n        \"tfup2\",\n    ])\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dvs = new VSphere.DistributedVirtualSwitch(\"dvs\", new VSphere.DistributedVirtualSwitchArgs\n        {\n            ActiveUplinks = \n            {\n                \"tfup1\",\n            },\n            DatacenterId = data.Vsphere_datacenter.Dc.Id,\n            StandbyUplinks = \n            {\n                \"tfup2\",\n            },\n            Uplinks = \n            {\n                \"tfup1\",\n                \"tfup2\",\n            },\n        });\n    }\n\n}\n```\n\n\u003e **NOTE:** The default uplink names when a DVS is created are `uplink1`\nthrough to `uplink4`, however this default is not guaranteed to be stable and\nyou are encouraged to set your own.\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of active uplinks to be used in load\nbalancing. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not a virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Shuts down all ports in the port groups that\nthis policy applies to, effectively blocking all network access to connected\nvirtual devices.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enables beacon probing as an additional measure\nto detect NIC failure.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "The version string of the configuration that this spec is trying to change.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the DVS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nDVS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual switch.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the distributed\nvirtual switch will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the DVS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 for the ports\nfor which this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits\nper second if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is enabled\non the port for egress traffic.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts\nin bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will re-activate failed\nuplinks higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder to create the DVS in. Forces a new resource\nif changed.\n"
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "Use the `host` block to declare a host specification. The\noptions are:\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in\nbits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is\nenabled on the port for ingress traffic.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during\nbursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments found\nbelow.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the switch. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Enables LACP for the ports that this policy\napplies to.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The LACP mode. Can be one of `active` or `passive`.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the switch. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the distributed virtual switch.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nactive flows are forced to be exported to the collector. Allowed range is\n`60` to `3600`. Default: `60`.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the Netflow\ncollector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed\nSwitch Version 6.0 or later. Must be set before Netflow can be enabled.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "Port for the Netflow collector. This\nmust be set before Netflow can be enabled.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Enables Netflow on all ports that this policy\napplies to.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nidle flows are forced to be exported to the collector. Allowed range is `10`\nto `600`. Default: `15`.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to\ntraffic that has both source and destination served by the same host.\nDefault: `false`.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation domain ID for\nthe Netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to\nthe number of packets analyzed. The default is `0`, which indicates that the\nswitch should analyze all packets. The maximum value is `1000`, which\nindicates an analysis rate of 0.001%.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable\nnetwork I/O control. Default: `false`.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The version of network I/O\ncontrol to use. Can be one of `version2` or `version3`. Default: `version2`.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will notify the\nbroadcast network of an uplink failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "Used to define a secondary VLAN\nID when using private VLANs.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of standby uplinks to be used in\nfailover. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The uplink teaming policy. Can be one of\n`loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "Forward all traffic transmitted by ports for which\nthis policy applies to its DVS uplinks.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of strings that uniquely identifies the names\nof the uplinks on the DVS across hosts. The number of items in this list\ncontrols the number of uplinks that exist on the DVS, in addition to the\nnames.  See here for an example on how to\nuse this option.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "- The version of the DVS to create. The default is to\ncreate the DVS at the latest version supported by the version of vSphere\nbeing used. A DVS can be upgraded to another version, but cannot be\ndowngraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "Used to denote VLAN trunking. Use the `min_vlan`\nand `max_vlan` sub-arguments to define the tagged VLAN range. Multiple\n`vlan_range` definitions are allowed, but they must not overlap. Example\nbelow:\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "datacenterId",
                "directpathGen2Allowed",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "faulttoleranceMaximumMbit",
                "faulttoleranceReservationMbit",
                "faulttoleranceShareCount",
                "faulttoleranceShareLevel",
                "hbrMaximumMbit",
                "hbrReservationMbit",
                "hbrShareCount",
                "hbrShareLevel",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "iscsiMaximumMbit",
                "iscsiReservationMbit",
                "iscsiShareCount",
                "iscsiShareLevel",
                "lacpApiVersion",
                "lacpEnabled",
                "lacpMode",
                "managementMaximumMbit",
                "managementReservationMbit",
                "managementShareCount",
                "managementShareLevel",
                "maxMtu",
                "multicastFilteringMode",
                "name",
                "netflowEnabled",
                "networkResourceControlVersion",
                "nfsMaximumMbit",
                "nfsReservationMbit",
                "nfsShareCount",
                "nfsShareLevel",
                "notifySwitches",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "uplinks",
                "vdpMaximumMbit",
                "vdpReservationMbit",
                "vdpShareCount",
                "vdpShareLevel",
                "version",
                "virtualmachineMaximumMbit",
                "virtualmachineReservationMbit",
                "virtualmachineShareCount",
                "virtualmachineShareLevel",
                "vlanId",
                "vlanRanges",
                "vmotionMaximumMbit",
                "vmotionReservationMbit",
                "vmotionShareCount",
                "vmotionShareLevel",
                "vsanMaximumMbit",
                "vsanReservationMbit",
                "vsanShareCount",
                "vsanShareLevel"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of active uplinks to be used in load\nbalancing. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not a virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Shuts down all ports in the port groups that\nthis policy applies to, effectively blocking all network access to connected\nvirtual devices.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enables beacon probing as an additional measure\nto detect NIC failure.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the DVS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nDVS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual switch.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the distributed\nvirtual switch will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the DVS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 for the ports\nfor which this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits\nper second if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if egress traffic shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is enabled\non the port for egress traffic.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts\nin bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will re-activate failed\nuplinks higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder to create the DVS in. Forces a new resource\nif changed.\n"
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "Use the `host` block to declare a host specification. The\noptions are:\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in\nbits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in\nbytes if ingress traffic shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "`true` if the traffic shaper is\nenabled on the port for ingress traffic.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during\nbursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments found\nbelow.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the switch. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Enables LACP for the ports that this policy\napplies to.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The LACP mode. Can be one of `active` or `passive`.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the switch. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the distributed virtual switch.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nactive flows are forced to be exported to the collector. Allowed range is\n`60` to `3600`. Default: `60`.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the Netflow\ncollector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed\nSwitch Version 6.0 or later. Must be set before Netflow can be enabled.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "Port for the Netflow collector. This\nmust be set before Netflow can be enabled.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Enables Netflow on all ports that this policy\napplies to.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which\nidle flows are forced to be exported to the collector. Allowed range is `10`\nto `600`. Default: `15`.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to\ntraffic that has both source and destination served by the same host.\nDefault: `false`.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation domain ID for\nthe Netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to\nthe number of packets analyzed. The default is `0`, which indicates that the\nswitch should analyze all packets. The maximum value is `1000`, which\nindicates an analysis rate of 0.001%.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable\nnetwork I/O control. Default: `false`.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The version of network I/O\ncontrol to use. Can be one of `version2` or `version3`. Default: `version2`.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If `true`, the teaming policy will notify the\nbroadcast network of an uplink failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "Used to define a secondary VLAN\nID when using private VLANs.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of standby uplinks to be used in\nfailover. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The uplink teaming policy. Can be one of\n`loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "Forward all traffic transmitted by ports for which\nthis policy applies to its DVS uplinks.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of strings that uniquely identifies the names\nof the uplinks on the DVS across hosts. The number of items in this list\ncontrols the number of uplinks that exist on the DVS, in addition to the\nnames.  See here for an example on how to\nuse this option.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "- The version of the DVS to create. The default is to\ncreate the DVS at the latest version supported by the version of vSphere\nbeing used. A DVS can be upgraded to another version, but cannot be\ndowngraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "Used to denote VLAN trunking. Use the `min_vlan`\nand `max_vlan` sub-arguments to define the tagged VLAN range. Multiple\n`vlan_range` definitions are allowed, but they must not overlap. Example\nbelow:\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedVirtualSwitch resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of active uplinks to be used in load\nbalancing. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not a virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Shuts down all ports in the port groups that\nthis policy applies to, effectively blocking all network access to connected\nvirtual devices.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enables beacon probing as an additional measure\nto detect NIC failure.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "The version string of the configuration that this spec is trying to change.\n"
                    },
                    "contactDetail": {
                        "type": "string",
                        "description": "The detailed contact information for the person\nwho is responsible for the DVS.\n"
                    },
                    "contactName": {
                        "type": "string",
                        "description": "The name of the person who is responsible for the\nDVS.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual switch.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter where the distributed\nvirtual switch will be created. Forces a new resource if changed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A detailed description for the DVS.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 for the ports\nfor which this policy applies to.\n"
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits\nper second if egress traffic shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in\nbytes if egress traffic shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "`true` if the traffic shaper is enabled\non the port for egress traffic.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts\nin bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If `true`, the teaming policy will re-activate failed\nuplinks higher in precedence when they come back up.\n"
                    },
                    "faulttoleranceMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                    },
                    "faulttoleranceShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder to create the DVS in. Forces a new resource\nif changed.\n"
                    },
                    "hbrMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                    },
                    "hbrShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                        },
                        "description": "Use the `host` block to declare a host specification. The\noptions are:\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in\nbits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in\nbytes if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "`true` if the traffic shaper is\nenabled on the port for ingress traffic.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during\nbursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ipv4Address": {
                        "type": "string",
                        "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments found\nbelow.\n"
                    },
                    "iscsiMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                    },
                    "iscsiShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "lacpApiVersion": {
                        "type": "string",
                        "description": "The Link Aggregation Control Protocol group\nversion to use with the switch. Possible values are `singleLag` and\n`multipleLag`.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Enables LACP for the ports that this policy\napplies to.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The LACP mode. Can be one of `active` or `passive`.\n"
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                    },
                    "managementMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                    },
                    "managementShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "maxMtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the virtual\nswitch.\n"
                    },
                    "multicastFilteringMode": {
                        "type": "string",
                        "description": "The multicast filtering mode to use\nwith the switch. Can be one of `legacyFiltering` or `snooping`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the distributed virtual switch.\n"
                    },
                    "netflowActiveFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which\nactive flows are forced to be exported to the collector. Allowed range is\n`60` to `3600`. Default: `60`.\n"
                    },
                    "netflowCollectorIpAddress": {
                        "type": "string",
                        "description": "IP address for the Netflow\ncollector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed\nSwitch Version 6.0 or later. Must be set before Netflow can be enabled.\n"
                    },
                    "netflowCollectorPort": {
                        "type": "integer",
                        "description": "Port for the Netflow collector. This\nmust be set before Netflow can be enabled.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Enables Netflow on all ports that this policy\napplies to.\n"
                    },
                    "netflowIdleFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which\nidle flows are forced to be exported to the collector. Allowed range is `10`\nto `600`. Default: `15`.\n"
                    },
                    "netflowInternalFlowsOnly": {
                        "type": "boolean",
                        "description": "Whether to limit analysis to\ntraffic that has both source and destination served by the same host.\nDefault: `false`.\n"
                    },
                    "netflowObservationDomainId": {
                        "type": "integer",
                        "description": "The observation domain ID for\nthe Netflow collector.\n"
                    },
                    "netflowSamplingRate": {
                        "type": "integer",
                        "description": "The ratio of total number of packets to\nthe number of packets analyzed. The default is `0`, which indicates that the\nswitch should analyze all packets. The maximum value is `1000`, which\nindicates an analysis rate of 0.001%.\n"
                    },
                    "networkResourceControlEnabled": {
                        "type": "boolean",
                        "description": "Set to `true` to enable\nnetwork I/O control. Default: `false`.\n"
                    },
                    "networkResourceControlVersion": {
                        "type": "string",
                        "description": "The version of network I/O\ncontrol to use. Can be one of `version2` or `version3`. Default: `version2`.\n"
                    },
                    "nfsMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                    },
                    "nfsShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If `true`, the teaming policy will notify the\nbroadcast network of an uplink failover, triggering cache updates.\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "Used to define a secondary VLAN\nID when using private VLANs.\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of standby uplinks to be used in\nfailover. These uplinks need to match the definitions in the\n`uplinks` DVS argument. See\nhere for more details.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The uplink teaming policy. Can be one of\n`loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "Forward all traffic transmitted by ports for which\nthis policy applies to its DVS uplinks.\n"
                    },
                    "uplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of strings that uniquely identifies the names\nof the uplinks on the DVS across hosts. The number of items in this list\ncontrols the number of uplinks that exist on the DVS, in addition to the\nnames.  See here for an example on how to\nuse this option.\n"
                    },
                    "vdpMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                    },
                    "vdpShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "- The version of the DVS to create. The default is to\ncreate the DVS at the latest version supported by the version of vSphere\nbeing used. A DVS can be upgraded to another version, but cannot be\ndowngraded.\n"
                    },
                    "virtualmachineMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                    },
                    "virtualmachineShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                        },
                        "description": "Used to denote VLAN trunking. Use the `min_vlan`\nand `max_vlan` sub-arguments to define the tagged VLAN range. Multiple\n`vlan_range` definitions are allowed, but they must not overlap. Example\nbelow:\n"
                    },
                    "vmotionMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                    },
                    "vmotionShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vsanMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                    },
                    "vsanShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/dpmHostOverride:DpmHostOverride": {
            "description": "The `vsphere..DpmHostOverride` resource can be used to add a DPM override to a\ncluster for a particular host. This allows you to control the power management\nsettings for individual hosts in the cluster while leaving any unspecified ones\nat the default power management settings.\n\nFor more information on DPM within vSphere clusters, see [this\npage][ref-vsphere-cluster-dpm].\n\n[ref-vsphere-cluster-dpm]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-5E5E349A-4644-4C9C-B434-1C0243EBDC80.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n"
                }
            },
            "required": [
                "computeClusterId",
                "hostSystemId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DpmHostOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for this host. Default:\n`false`.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of the host.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/drsVmOverride:DrsVmOverride": {
            "description": "The `vsphere..DrsVmOverride` resource can be used to add a DRS override to a\ncluster for a specific virtual machine. With this resource, one can enable or\ndisable DRS and control the automation level for a single virtual machine\nwithout affecting the rest of the cluster.\n\nFor more information on vSphere clusters and DRS, see [this\npage][ref-vsphere-drs-clusters].\n\n[ref-vsphere-drs-clusters]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-8ACF3502-5314-469F-8CC9-4A9BD5925BC2.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n\u003e **NOTE:** vSphere DRS requires a vSphere Enterprise Plus license.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below creates a virtual machine in a cluster using the\n`vsphere..VirtualMachine` resource, creating the\nvirtual machine in the cluster looked up by the\n`vsphere..ComputeCluster` data source, but also\npinning the VM to a host defined by the\n`vsphere..Host` data source, which is assumed to\nbe a host within the cluster. To ensure that the VM stays on this host and does\nnot need to be migrated back at any point in time, an override is entered using\nthe `vsphere..DrsVmOverride` resource that disables DRS for this virtual\nmachine, ensuring that it does not move.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastore = dc.apply(dc =\u003e vsphere.getDatastore({\n    datacenterId: dc.id,\n    name: \"datastore1\",\n}, { async: true }));\nconst cluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: \"cluster1\",\n}, { async: true }));\nconst host = dc.apply(dc =\u003e vsphere.getHost({\n    datacenterId: dc.id,\n    name: \"esxi1\",\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"network1\",\n}, { async: true }));\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    datastoreId: datastore.id,\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n    guestId: \"other3xLinux64Guest\",\n    hostSystemId: host.id,\n    memory: 2048,\n    networkInterfaces: [{\n        networkId: network.id,\n    }],\n    numCpus: 2,\n    resourcePoolId: cluster.resourcePoolId,\n});\nconst drsVmOverride = new vsphere.DrsVmOverride(\"drs_vm_override\", {\n    computeClusterId: cluster.id,\n    drsEnabled: false,\n    virtualMachineId: vm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"dc1\")\ndatastore = vsphere.get_datastore(datacenter_id=dc.id,\n    name=\"datastore1\")\ncluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=\"cluster1\")\nhost = vsphere.get_host(datacenter_id=dc.id,\n    name=\"esxi1\")\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"network1\")\nvm = vsphere.VirtualMachine(\"vm\",\n    datastore_id=datastore.id,\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }],\n    guest_id=\"other3xLinux64Guest\",\n    host_system_id=host.id,\n    memory=2048,\n    network_interfaces=[{\n        \"networkId\": network.id,\n    }],\n    num_cpus=2,\n    resource_pool_id=cluster.resource_pool_id)\ndrs_vm_override = vsphere.DrsVmOverride(\"drsVmOverride\",\n    compute_cluster_id=cluster.id,\n    drs_enabled=False,\n    virtual_machine_id=vm.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastore = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore1\",\n        })));\n        var cluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"cluster1\",\n        })));\n        var host = dc.Apply(dc =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"esxi1\",\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"network1\",\n        })));\n        var vm = new VSphere.VirtualMachine(\"vm\", new VSphere.VirtualMachineArgs\n        {\n            DatastoreId = datastore.Apply(datastore =\u003e datastore.Id),\n            Disks = \n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n            GuestId = \"other3xLinux64Guest\",\n            HostSystemId = host.Apply(host =\u003e host.Id),\n            Memory = 2048,\n            NetworkInterfaces = \n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(network =\u003e network.Id),\n                },\n            },\n            NumCpus = 2,\n            ResourcePoolId = cluster.Apply(cluster =\u003e cluster.ResourcePoolId),\n        });\n        var drsVmOverride = new VSphere.DrsVmOverride(\"drsVmOverride\", new VSphere.DrsVmOverrideArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            DrsEnabled = false,\n            VirtualMachineId = vm.Id,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DrsVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/file:File": {
            "description": "The `vsphere..File` resource can be used to upload files (such as virtual disk\nfiles) from the host machine that this provider is running on to a target\ndatastore.  The resource can also be used to copy files between datastores, or\nfrom one location to another on the same datastore.\n\nUpdates to destination parameters such as `datacenter`, `datastore`, or\n`destination_file` will move the managed file a new destination based on the\nvalues of the new settings.  If any source parameter is changed, such as\n`source_datastore`, `source_datacenter` or `source_file`), the resource will be\nre-created. Depending on if destination parameters are being changed as well,\nthis may result in the destination file either being overwritten or deleted at\nthe old location.\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### Uploading a file\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuDiskUpload = new vsphere.File(\"ubuntu_disk_upload\", {\n    datacenter: \"my_datacenter\",\n    datastore: \"local\",\n    destinationFile: \"/my_path/disks/custom_ubuntu.vmdk\",\n    sourceFile: \"/home/ubuntu/my_disks/custom_ubuntu.vmdk\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_disk_upload = vsphere.File(\"ubuntuDiskUpload\",\n    datacenter=\"my_datacenter\",\n    datastore=\"local\",\n    destination_file=\"/my_path/disks/custom_ubuntu.vmdk\",\n    source_file=\"/home/ubuntu/my_disks/custom_ubuntu.vmdk\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ubuntuDiskUpload = new VSphere.File(\"ubuntuDiskUpload\", new VSphere.FileArgs\n        {\n            Datacenter = \"my_datacenter\",\n            Datastore = \"local\",\n            DestinationFile = \"/my_path/disks/custom_ubuntu.vmdk\",\n            SourceFile = \"/home/ubuntu/my_disks/custom_ubuntu.vmdk\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Copying a file\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuDiskCopy = new vsphere.File(\"ubuntu_disk_copy\", {\n    datacenter: \"my_datacenter\",\n    datastore: \"local\",\n    destinationFile: \"/my_path/custom_ubuntu_id.vmdk\",\n    sourceDatacenter: \"my_datacenter\",\n    sourceDatastore: \"local\",\n    sourceFile: \"/my_path/disks/custom_ubuntu.vmdk\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_disk_copy = vsphere.File(\"ubuntuDiskCopy\",\n    datacenter=\"my_datacenter\",\n    datastore=\"local\",\n    destination_file=\"/my_path/custom_ubuntu_id.vmdk\",\n    source_datacenter=\"my_datacenter\",\n    source_datastore=\"local\",\n    source_file=\"/my_path/disks/custom_ubuntu.vmdk\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var ubuntuDiskCopy = new VSphere.File(\"ubuntuDiskCopy\", new VSphere.FileArgs\n        {\n            Datacenter = \"my_datacenter\",\n            Datastore = \"local\",\n            DestinationFile = \"/my_path/custom_ubuntu_id.vmdk\",\n            SourceDatacenter = \"my_datacenter\",\n            SourceDatastore = \"local\",\n            SourceFile = \"/my_path/disks/custom_ubuntu.vmdk\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter if any missing for copy operation.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter in which the file will be\nuploaded to.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to upload the\nfile to.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter in which the file\nwill be copied from. Forces a new resource if changed.\n"
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore in which file will\nbe copied from. Forces a new resource if changed.\n"
                },
                "sourceFile": {
                    "type": "string",
                    "description": "The path to the file being uploaded from the\nhost to vSphere or copied within vSphere. Forces a new resource if\nchanged.\n"
                }
            },
            "required": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "inputProperties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter if any missing for copy operation.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter in which the file will be\nuploaded to.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to upload the\nfile to.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter in which the file\nwill be copied from. Forces a new resource if changed.\n"
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore in which file will\nbe copied from. Forces a new resource if changed.\n"
                },
                "sourceFile": {
                    "type": "string",
                    "description": "The path to the file being uploaded from the\nhost to vSphere or copied within vSphere. Forces a new resource if\nchanged.\n"
                }
            },
            "requiredInputs": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering File resources.\n",
                "properties": {
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Create directories in `destination_file`\npath parameter if any missing for copy operation.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of a datacenter in which the file will be\nuploaded to.\n"
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore in which to upload the\nfile to.\n"
                    },
                    "destinationFile": {
                        "type": "string",
                        "description": "The path to where the file should be uploaded\nor copied to on vSphere.\n"
                    },
                    "sourceDatacenter": {
                        "type": "string",
                        "description": "The name of a datacenter in which the file\nwill be copied from. Forces a new resource if changed.\n"
                    },
                    "sourceDatastore": {
                        "type": "string",
                        "description": "The name of the datastore in which file will\nbe copied from. Forces a new resource if changed.\n"
                    },
                    "sourceFile": {
                        "type": "string",
                        "description": "The path to the file being uploaded from the\nhost to vSphere or copied within vSphere. Forces a new resource if\nchanged.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/folder:Folder": {
            "description": "The `vsphere..Folder` resource can be used to manage vSphere inventory folders.\nThe resource supports creating folders of the 5 major types - datacenter\nfolders, host and cluster folders, virtual machine folders, datastore folders,\nand network folders.\n\nPaths are always relative to the specific type of folder you are creating.\nSubfolders are discovered by parsing the relative path specified in `path`, so\n`foo/bar` will create a folder named `bar` in the parent folder `foo`, as long\nas that folder exists.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe basic example below creates a virtual machine folder named\n`test-folder` in the default datacenter's VM hierarchy. \n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({ async: true }));\nconst folder = new vsphere.Folder(\"folder\", {\n    datacenterId: dc.id,\n    path: \"test-folder\",\n    type: \"vm\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter()\nfolder = vsphere.Folder(\"folder\",\n    datacenter_id=dc.id,\n    path=\"test-folder\",\n    type=\"vm\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync());\n        var folder = new VSphere.Folder(\"folder\", new VSphere.FolderArgs\n        {\n            DatacenterId = dc.Apply(dc =\u003e dc.Id),\n            Path = \"test-folder\",\n            Type = \"vm\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Example with subfolders\n\nThe below example builds off of the above by first creating a folder named\n`test-parent`, and then locating `test-folder` in that\nfolder. To ensure the parent is created first, we create an interpolation\ndependency off the parent's `path` attribute.\n\nNote that if you change parents (for example, went from the above basic\nconfiguration to this one), your folder will be moved to be under the correct\nparent.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({ async: true }));\nconst parent = new vsphere.Folder(\"parent\", {\n    datacenterId: dc.id,\n    path: \"test-parent\",\n    type: \"vm\",\n});\nconst folder = new vsphere.Folder(\"folder\", {\n    datacenterId: dc.id,\n    path: pulumi.interpolate`${parent.path}/test-folder`,\n    type: \"vm\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter()\nparent = vsphere.Folder(\"parent\",\n    datacenter_id=dc.id,\n    path=\"test-parent\",\n    type=\"vm\")\nfolder = vsphere.Folder(\"folder\",\n    datacenter_id=dc.id,\n    path=parent.path.apply(lambda path: f\"{path}/test-folder\"),\n    type=\"vm\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync());\n        var parent = new VSphere.Folder(\"parent\", new VSphere.FolderArgs\n        {\n            DatacenterId = dc.Apply(dc =\u003e dc.Id),\n            Path = \"test-parent\",\n            Type = \"vm\",\n        });\n        var folder = new VSphere.Folder(\"folder\", new VSphere.FolderArgs\n        {\n            DatacenterId = dc.Apply(dc =\u003e dc.Id),\n            Path = parent.Path.Apply(path =\u003e $\"{path}/test-folder\"),\n            Type = \"vm\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "path",
                "type"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "path",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Folder resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n"
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/haVmOverride:HaVmOverride": {
            "description": "The `vsphere..HaVmOverride` resource can be used to add an override for\nvSphere HA settings on a cluster for a specific virtual machine. With this\nresource, one can control specific HA settings so that they are different than\nthe cluster default, accommodating the needs of that specific virtual machine,\nwhile not affecting the rest of the cluster.\n\nFor more information on vSphere HA, see [this page][ref-vsphere-ha-clusters].\n\n[ref-vsphere-ha-clusters]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.avail.doc/GUID-5432CA24-14F1-44E3-87FB-61D937831CF6.html\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe example below creates a virtual machine in a cluster using the\n`vsphere..VirtualMachine` resource, creating the\nvirtual machine in the cluster looked up by the\n`vsphere..ComputeCluster` data source.\n\nConsidering a scenario where this virtual machine is of high value to the\napplication or organization for which it does its work, it's been determined in\nthe event of a host failure, that this should be one of the first virtual\nmachines to be started by vSphere HA during recovery. Hence, its\n`ha_vm_restart_priority` as been set to `highest`,\nwhich, assuming that the default restart priority is `medium` and no other\nvirtual machine has been assigned the `highest` priority, will mean that this\nVM will be started before any other virtual machine in the event of host\nfailure.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastore = dc.apply(dc =\u003e vsphere.getDatastore({\n    datacenterId: dc.id,\n    name: \"datastore1\",\n}, { async: true }));\nconst cluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: \"cluster1\",\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"network1\",\n}, { async: true }));\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    datastoreId: datastore.id,\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n    guestId: \"other3xLinux64Guest\",\n    memory: 2048,\n    networkInterfaces: [{\n        networkId: network.id,\n    }],\n    numCpus: 2,\n    resourcePoolId: cluster.resourcePoolId,\n});\nconst haVmOverride = new vsphere.HaVmOverride(\"ha_vm_override\", {\n    computeClusterId: cluster.id,\n    haVmRestartPriority: \"highest\",\n    virtualMachineId: vm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"dc1\")\ndatastore = vsphere.get_datastore(datacenter_id=dc.id,\n    name=\"datastore1\")\ncluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=\"cluster1\")\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"network1\")\nvm = vsphere.VirtualMachine(\"vm\",\n    datastore_id=datastore.id,\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }],\n    guest_id=\"other3xLinux64Guest\",\n    memory=2048,\n    network_interfaces=[{\n        \"networkId\": network.id,\n    }],\n    num_cpus=2,\n    resource_pool_id=cluster.resource_pool_id)\nha_vm_override = vsphere.HaVmOverride(\"haVmOverride\",\n    compute_cluster_id=cluster.id,\n    ha_vm_restart_priority=\"highest\",\n    virtual_machine_id=vm.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastore = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore1\",\n        })));\n        var cluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"cluster1\",\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"network1\",\n        })));\n        var vm = new VSphere.VirtualMachine(\"vm\", new VSphere.VirtualMachineArgs\n        {\n            DatastoreId = datastore.Apply(datastore =\u003e datastore.Id),\n            Disks = \n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n            GuestId = \"other3xLinux64Guest\",\n            Memory = 2048,\n            NetworkInterfaces = \n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(network =\u003e network.Id),\n                },\n            },\n            NumCpus = 2,\n            ResourcePoolId = cluster.Apply(cluster =\u003e cluster.ResourcePoolId),\n        });\n        var haVmOverride = new VSphere.HaVmOverride(\"haVmOverride\", new VSphere.HaVmOverrideArgs\n        {\n            ComputeClusterId = cluster.Apply(cluster =\u003e cluster.Id),\n            HaVmRestartPriority = \"highest\",\n            VirtualMachineId = vm.Id,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non this virtual machine if an APD status on an affected datastore clears in\nthe middle of an APD event. Can be one of `useClusterDefault`, `none` or\n`reset`.  Default: `useClusterDefault`.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of `clusterDefault`, `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `clusterDefault`.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Use `-1` to use\nthe cluster default. Default: `-1`.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `clusterDefault`, `disabled`, `warning`, or\n`restartAggressive`. Default: `clusterDefault`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual\nmachine when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `clusterIsolationResponse`, `none`, `powerOff`, or\n`shutdown`. Default: `clusterIsolationResponse`.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual\nmachine is not received within this configured interval, the virtual machine\nis marked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to this virtual machine when responding to a failure event. Default:\n`3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on this virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or\nnot the cluster's default settings or the VM override settings specified in\nthis resource are used for virtual machine monitoring. The default is `true`\n(use cluster defaults) - set to `false` to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for the virtual\nmachine when vSphere detects a host failure. Can be one of\n`clusterRestartPriority`, `lowest`, `low`, `medium`, `high`, or `highest`.\nDefault: `clusterRestartPriority`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that\nvSphere HA will wait for this virtual machine to be ready. Use `-1` to\nspecify the cluster default.  Default: `-1`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take\non this virtual machine if an APD status on an affected datastore clears in\nthe middle of an APD event. Can be one of `useClusterDefault`, `none` or\n`reset`.  Default: `useClusterDefault`.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of `clusterDefault`, `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `clusterDefault`.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Use `-1` to use\nthe cluster default. Default: `-1`.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this\nvirtual machine when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `clusterDefault`, `disabled`, `warning`, or\n`restartAggressive`. Default: `clusterDefault`.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual\nmachine when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `clusterIsolationResponse`, `none`, `powerOff`, or\n`shutdown`. Default: `clusterIsolationResponse`.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual\nmachine is not received within this configured interval, the virtual machine\nis marked as failed. The value is in seconds. Default: `30`.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will\nperform to this virtual machine when responding to a failure event. Default:\n`3`\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after\npowering on this virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or\nnot the cluster's default settings or the VM override settings specified in\nthis resource are used for virtual machine monitoring. The default is `true`\n(use cluster defaults) - set to `false` to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for the virtual\nmachine when vSphere detects a host failure. Can be one of\n`clusterRestartPriority`, `lowest`, `low`, `medium`, `high`, or `highest`.\nDefault: `clusterRestartPriority`.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that\nvSphere HA will wait for this virtual machine to be ready. Use `-1` to\nspecify the cluster default.  Default: `-1`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HaVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "Controls the action to take\non this virtual machine if an APD status on an affected datastore clears in\nthe middle of an APD event. Can be one of `useClusterDefault`, `none` or\n`reset`.  Default: `useClusterDefault`.\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this\nvirtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of `clusterDefault`, `disabled`, `warning`,\n`restartConservative`, or `restartAggressive`.  Default: `clusterDefault`.\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "Controls the delay in minutes\nto wait after an APD timeout event to execute the response action defined in\n`ha_datastore_apd_response`. Use `-1` to use\nthe cluster default. Default: `-1`.\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this\nvirtual machine when the cluster has detected a permanent device loss to a\nrelevant datastore. Can be one of `clusterDefault`, `disabled`, `warning`, or\n`restartAggressive`. Default: `clusterDefault`.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on this virtual\nmachine when a host has detected that it has been isolated from the rest of\nthe cluster. Can be one of `clusterIsolationResponse`, `none`, `powerOff`, or\n`shutdown`. Default: `clusterIsolationResponse`.\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "If a heartbeat from this virtual\nmachine is not received within this configured interval, the virtual machine\nis marked as failed. The value is in seconds. Default: `30`.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The length of the reset window in\nwhich `ha_vm_maximum_resets` can operate. When this\nwindow expires, no more resets are attempted regardless of the setting\nconfigured in `ha_vm_maximum_resets`. `-1` means no window, meaning an\nunlimited reset time is allotted. The value is specified in seconds. Default:\n`-1` (no window).\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will\nperform to this virtual machine when responding to a failure event. Default:\n`3`\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after\npowering on this virtual machine before monitoring for heartbeats. Default:\n`120` (2 minutes).\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use\nwhen HA is enabled in the cluster. Can be one of `vmMonitoringDisabled`,\n`vmMonitoringOnly`, or `vmAndAppMonitoring`. Default: `vmMonitoringDisabled`.\n"
                    },
                    "haVmMonitoringUseClusterDefaults": {
                        "type": "boolean",
                        "description": "Determines whether or\nnot the cluster's default settings or the VM override settings specified in\nthis resource are used for virtual machine monitoring. The default is `true`\n(use cluster defaults) - set to `false` to have overrides take effect.\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The restart priority for the virtual\nmachine when vSphere detects a host failure. Can be one of\n`clusterRestartPriority`, `lowest`, `low`, `medium`, `high`, or `highest`.\nDefault: `clusterRestartPriority`.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds, that\nvSphere HA will wait for this virtual machine to be ready. Use `-1` to\nspecify the cluster default.  Default: `-1`.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/host:Host": {
            "description": "Provides a VMware vSphere host resource. This represents an ESXi host that\ncan be used either as part of a Compute Cluster or Standalone.\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### Create a standalone host\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = vsphere.getDatacenter({\n    name: \"my-datacenter\",\n});\nconst h1 = new vsphere.Host(\"h1\", {\n    hostname: \"10.10.10.1\",\n    username: \"root\",\n    password: \"password\",\n    license: \"00000-00000-00000-00000i-00000\",\n    datacenter: dc.then(dc =\u003e dc.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"my-datacenter\")\nh1 = vsphere.Host(\"h1\",\n    hostname=\"10.10.10.1\",\n    username=\"root\",\n    password=\"password\",\n    license=\"00000-00000-00000-00000i-00000\",\n    datacenter=dc.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"my-datacenter\",\n        }));\n        var h1 = new VSphere.Host(\"h1\", new VSphere.HostArgs\n        {\n            Hostname = \"10.10.10.1\",\n            Username = \"root\",\n            Password = \"password\",\n            License = \"00000-00000-00000-00000i-00000\",\n            Datacenter = dc.Apply(dc =\u003e dc.Id),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Create host in a compute cluster\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = vsphere.getDatacenter({\n    name: \"TfDatacenter\",\n});\nconst c1 = dc.then(dc =\u003e vsphere.getComputeCluster({\n    name: \"DC0_C0\",\n    datacenterId: dc.id,\n}));\nconst h1 = new vsphere.Host(\"h1\", {\n    hostname: \"10.10.10.1\",\n    username: \"root\",\n    password: \"password\",\n    license: \"00000-00000-00000-00000i-00000\",\n    cluster: c1.then(c1 =\u003e c1.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"TfDatacenter\")\nc1 = vsphere.get_compute_cluster(name=\"DC0_C0\",\n    datacenter_id=dc.id)\nh1 = vsphere.Host(\"h1\",\n    hostname=\"10.10.10.1\",\n    username=\"root\",\n    password=\"password\",\n    license=\"00000-00000-00000-00000i-00000\",\n    cluster=c1.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"TfDatacenter\",\n        }));\n        var c1 = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            Name = \"DC0_C0\",\n            DatacenterId = dc.Id,\n        })));\n        var h1 = new VSphere.Host(\"h1\", new VSphere.HostArgs\n        {\n            Hostname = \"10.10.10.1\",\n            Username = \"root\",\n            Password = \"password\",\n            License = \"00000-00000-00000-00000i-00000\",\n            Cluster = c1.Apply(c1 =\u003e c1.Id),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n## Importing \n\nAn existing host can be [imported][docs-import] into this resource\nvia supplying the host's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n    }\n\n}\n```\n\nThe above would import the host with ID `host-123`.\n",
            "properties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconected.\nDefault is `false`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to true then it will force the host to be added, even\nif the host is already connected to a different vSphere instance. Default is `false`\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host. Default is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the the\nCA that signed the host's certificate should be trusted. If the CA is not trusted\nand no thumbprint is set then the operation will fail.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "required": [
                "hostname",
                "password",
                "username"
            ],
            "inputProperties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconected.\nDefault is `false`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to true then it will force the host to be added, even\nif the host is already connected to a different vSphere instance. Default is `false`\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host. Default is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the the\nCA that signed the host's certificate should be trusted. If the CA is not trusted\nand no thumbprint is set then the operation will fail.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "requiredInputs": [
                "hostname",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Host resources.\n",
                "properties": {
                    "cluster": {
                        "type": "string",
                        "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set.\n"
                    },
                    "connected": {
                        "type": "boolean",
                        "description": "If set to false then the host will be disconected.\nDefault is `false`.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                    },
                    "force": {
                        "type": "boolean",
                        "description": "If set to true then it will force the host to be added, even\nif the host is already connected to a different vSphere instance. Default is `false`\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "FQDN or IP address of the host to be added.\n"
                    },
                    "license": {
                        "type": "string",
                        "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                    },
                    "lockdown": {
                        "type": "string",
                        "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                    },
                    "maintenance": {
                        "type": "boolean",
                        "description": "Set the management state of the host. Default is `false`.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password that will be used by vSphere to authenticate\nto the host.\n"
                    },
                    "thumbprint": {
                        "type": "string",
                        "description": "Host's certificate SHA-1 thumbprint. If not set the the\nCA that signed the host's certificate should be trusted. If the CA is not trusted\nand no thumbprint is set then the operation will fail.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostPortGroup:HostPortGroup": {
            "description": "The `vsphere..HostPortGroup` resource can be used to manage vSphere standard\nport groups on an ESXi host. These port groups are connected to standard\nvirtual switches, which can be managed by the\n`vsphere..HostVirtualSwitch` resource.\n\nFor an overview on vSphere networking concepts, see [this page][ref-vsphere-net-concepts].\n\n[ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### Create a virtual switch and bind a port group to it\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst esxiHost = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n    name: \"esxi1\",\n}, { async: true }));\nconst switchHostVirtualSwitch = new vsphere.HostVirtualSwitch(\"switch\", {\n    activeNics: [\"vmnic0\"],\n    hostSystemId: esxiHost.id,\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    hostSystemId: esxiHost.id,\n    virtualSwitchName: switchHostVirtualSwitch.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nesxi_host = vsphere.get_host(datacenter_id=datacenter.id,\n    name=\"esxi1\")\nswitch = vsphere.HostVirtualSwitch(\"switch\",\n    active_nics=[\"vmnic0\"],\n    host_system_id=esxi_host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    host_system_id=esxi_host.id,\n    virtual_switch_name=switch.name)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var esxiHost = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"esxi1\",\n        })));\n        var @switch = new VSphere.HostVirtualSwitch(\"switch\", new VSphere.HostVirtualSwitchArgs\n        {\n            ActiveNics = \n            {\n                \"vmnic0\",\n            },\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n            NetworkAdapters = \n            {\n                \"vmnic0\",\n                \"vmnic1\",\n            },\n            StandbyNics = \n            {\n                \"vmnic1\",\n            },\n        });\n        var pg = new VSphere.HostPortGroup(\"pg\", new VSphere.HostPortGroupArgs\n        {\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n            VirtualSwitchName = @switch.Name,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Create a port group with VLAN set and some overrides\n\nThis example sets the trunk mode VLAN (`4095`, which passes through all tags)\nand sets\n`allow_promiscuous`\nto ensure that all traffic is seen on the port. The latter setting overrides\nthe implicit default of `false` set on the virtual switch.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst esxiHost = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n    name: \"esxi1\",\n}, { async: true }));\nconst switchHostVirtualSwitch = new vsphere.HostVirtualSwitch(\"switch\", {\n    activeNics: [\"vmnic0\"],\n    hostSystemId: esxiHost.id,\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    allowPromiscuous: true,\n    hostSystemId: esxiHost.id,\n    virtualSwitchName: switchHostVirtualSwitch.name,\n    vlanId: 4095,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nesxi_host = vsphere.get_host(datacenter_id=datacenter.id,\n    name=\"esxi1\")\nswitch = vsphere.HostVirtualSwitch(\"switch\",\n    active_nics=[\"vmnic0\"],\n    host_system_id=esxi_host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    allow_promiscuous=True,\n    host_system_id=esxi_host.id,\n    virtual_switch_name=switch.name,\n    vlan_id=4095)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var esxiHost = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"esxi1\",\n        })));\n        var @switch = new VSphere.HostVirtualSwitch(\"switch\", new VSphere.HostVirtualSwitchArgs\n        {\n            ActiveNics = \n            {\n                \"vmnic0\",\n            },\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n            NetworkAdapters = \n            {\n                \"vmnic0\",\n                \"vmnic1\",\n            },\n            StandbyNics = \n            {\n                \"vmnic1\",\n            },\n        });\n        var pg = new VSphere.HostPortGroup(\"pg\", new VSphere.HostPortGroupArgs\n        {\n            AllowPromiscuous = true,\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n            VirtualSwitchName = @switch.Name,\n            VlanId = 4095,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "computedPolicy": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "ports": {
                    "$ref": "#/types/vsphere:/HostPortGroupPorts:HostPortGroupPorts",
                    "description": "A list of ports that currently exist and are used on this port group.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "required": [
                "computedPolicy",
                "hostSystemId",
                "key",
                "name",
                "ports",
                "virtualSwitchName"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "requiredInputs": [
                "hostSystemId",
                "virtualSwitchName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostPortGroup resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active network adapters used for load balancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                    },
                    "computedPolicy": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The key for this port group as returned from the vSphere API.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.  Forces a new resource if\nchanged.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "ports": {
                        "$ref": "#/types/vsphere:/HostPortGroupPorts:HostPortGroupPorts",
                        "description": "A list of ports that currently exist and are used on this port group.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Enable traffic shaping on this virtual switch or port group.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby network adapters used for failover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                    },
                    "virtualSwitchName": {
                        "type": "string",
                        "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostVirtualSwitch:HostVirtualSwitch": {
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of active network adapters used for load\nbalancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own. Default: `true`.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed. Default: `true`.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port. Default:\n`false`.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "The interval, in seconds, that a NIC beacon\npacket is sent out. This can be used with `check_beacon` to\noffer link failure capability beyond link status only. Default: `1`.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing - this requires that the\n`beacon_interval` option has been set in the bridge\noptions. If this is set to `false`, only link status is used to check for\nfailed NICs.  Default: `false`.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will re-activate\nfailed interfaces higher in precedence when they come back up.  Default:\n`true`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic. Default: `listen`.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type.  Valid\ntypes are `cpd` and `lldp`. Default: `cdp`.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n"
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The network interfaces to bind to the bridge.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will\nnotify the broadcast network of a NIC failover, triggering cache updates.\nDefault: `true`.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per\nsecond if traffic shaping is enabled. Default: `0`\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if\nshaping is enabled. Default: `0`\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the traffic shaper for\nports managed by this virtual switch. Default: `false`.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in\nbits per second if traffic shaping is enabled. Default: `0`\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of standby network adapters used for\nfailover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one\nof `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`. Default: `loadbalance_srcid`.\n"
                }
            },
            "required": [
                "activeNics",
                "hostSystemId",
                "name",
                "networkAdapters",
                "standbyNics"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of active network adapters used for load\nbalancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own. Default: `true`.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed. Default: `true`.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port. Default:\n`false`.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "The interval, in seconds, that a NIC beacon\npacket is sent out. This can be used with `check_beacon` to\noffer link failure capability beyond link status only. Default: `1`.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing - this requires that the\n`beacon_interval` option has been set in the bridge\noptions. If this is set to `false`, only link status is used to check for\nfailed NICs.  Default: `false`.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will re-activate\nfailed interfaces higher in precedence when they come back up.  Default:\n`true`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic. Default: `listen`.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type.  Valid\ntypes are `cpd` and `lldp`. Default: `cdp`.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n"
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The network interfaces to bind to the bridge.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If set to `true`, the teaming policy will\nnotify the broadcast network of a NIC failover, triggering cache updates.\nDefault: `true`.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per\nsecond if traffic shaping is enabled. Default: `0`\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if\nshaping is enabled. Default: `0`\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the traffic shaper for\nports managed by this virtual switch. Default: `false`.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in\nbits per second if traffic shaping is enabled. Default: `0`\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of standby network adapters used for\nfailover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one\nof `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`. Default: `loadbalance_srcid`.\n"
                }
            },
            "requiredInputs": [
                "activeNics",
                "hostSystemId",
                "networkAdapters",
                "standbyNics"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostVirtualSwitch resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of active network adapters used for load\nbalancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual\nnetwork adapter is allowed to send network traffic with a different MAC\naddress than that of its own. Default: `true`.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access\nControl (MAC) address can be changed. Default: `true`.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This\nflag indicates whether or not all traffic is seen on a given port. Default:\n`false`.\n"
                    },
                    "beaconInterval": {
                        "type": "integer",
                        "description": "The interval, in seconds, that a NIC beacon\npacket is sent out. This can be used with `check_beacon` to\noffer link failure capability beyond link status only. Default: `1`.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing - this requires that the\n`beacon_interval` option has been set in the bridge\noptions. If this is set to `false`, only link status is used to check for\nfailed NICs.  Default: `false`.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If set to `true`, the teaming policy will re-activate\nfailed interfaces higher in precedence when they come back up.  Default:\n`true`.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n"
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to `advertise` or `listen`\nfor link discovery traffic. Default: `listen`.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type.  Valid\ntypes are `cpd` and `lldp`. Default: `cdp`.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n"
                    },
                    "networkAdapters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The network interfaces to bind to the bridge.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If set to `true`, the teaming policy will\nnotify the broadcast network of a NIC failover, triggering cache updates.\nDefault: `true`.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per\nsecond if traffic shaping is enabled. Default: `0`\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if\nshaping is enabled. Default: `0`\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Set to `true` to enable the traffic shaper for\nports managed by this virtual switch. Default: `false`.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in\nbits per second if traffic shaping is enabled. Default: `0`\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of standby network adapters used for\nfailover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one\nof `loadbalance_ip`, `loadbalance_srcmac`, `loadbalance_srcid`, or\n`failover_explicit`. Default: `loadbalance_srcid`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/license:License": {
            "description": "Provides a VMware vSphere license resource. This can be used to add and remove license keys.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst licenseKey = new vsphere.License(\"licenseKey\", {\n    labels: {\n        VpxClientLicenseLabel: \"Hello World\",\n        Workflow: \"Hello World\",\n    },\n    licenseKey: \"452CQ-2EK54-K8742-00000-00000\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlicense_key = vsphere.License(\"licenseKey\",\n    labels={\n        \"VpxClientLicenseLabel\": \"Hello World\",\n        \"Workflow\": \"Hello World\",\n    },\n    license_key=\"452CQ-2EK54-K8742-00000-00000\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var licenseKey = new VSphere.License(\"licenseKey\", new VSphere.LicenseArgs\n        {\n            Labels = \n            {\n                { \"VpxClientLicenseLabel\", \"Hello World\" },\n                { \"Workflow\", \"Hello World\" },\n            },\n            LicenseKey = \"452CQ-2EK54-K8742-00000-00000\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "editionKey": {
                    "type": "string",
                    "description": "The product edition of the license key.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name for the license.\n"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of units (example: CPUs) contained in the license.\n"
                },
                "used": {
                    "type": "integer",
                    "description": "The number of units (example: CPUs) assigned to this license.\n"
                }
            },
            "required": [
                "editionKey",
                "licenseKey",
                "name",
                "total",
                "used"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n"
                }
            },
            "requiredInputs": [
                "licenseKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering License resources.\n",
                "properties": {
                    "editionKey": {
                        "type": "string",
                        "description": "The product edition of the license key.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                    },
                    "licenseKey": {
                        "type": "string",
                        "description": "The license key to add.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name for the license.\n"
                    },
                    "total": {
                        "type": "integer",
                        "description": "Total number of units (example: CPUs) contained in the license.\n"
                    },
                    "used": {
                        "type": "integer",
                        "description": "The number of units (example: CPUs) assigned to this license.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/nasDatastore:NasDatastore": {
            "description": "The `vsphere..NasDatastore` resource can be used to create and manage NAS\ndatastores on an ESXi host or a set of hosts. The resource supports mounting\nNFS v3 and v4.1 shares to be used as datastores.\n\n\u003e **NOTE:** Unlike `vsphere..VmfsDatastore`, a NAS\ndatastore is only mounted on the hosts you choose to mount it on. To mount on\nmultiple hosts, you must specify each host that you want to add in the\n`host_system_ids` argument.\n\n{{% examples %}}\n{{% /examples %}}\n",
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n"
                },
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "protocolEndpoint": {
                    "type": "string",
                    "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nserver or servers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n"
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n"
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "freeSpace",
                "hostSystemIds",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "protocolEndpoint",
                "remoteHosts",
                "remotePath",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nserver or servers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n"
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n"
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n"
                }
            },
            "requiredInputs": [
                "hostSystemIds",
                "remoteHosts",
                "remotePath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NasDatastore resources.\n",
                "properties": {
                    "accessMode": {
                        "type": "string",
                        "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n"
                    },
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "protocolEndpoint": {
                        "type": "string",
                        "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                    },
                    "remoteHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The hostnames or IP addresses of the remote\nserver or servers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n"
                    },
                    "remotePath": {
                        "type": "string",
                        "description": "The remote path of the mount point. Forces a new\nresource if changed.\n"
                    },
                    "securityType": {
                        "type": "string",
                        "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n"
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/resourcePool:ResourcePool": {
            "description": "The `vsphere..ResourcePool` resource can be used to create and manage\nresource pools in standalone hosts or on compute clusters.\n\nFor more information on vSphere resource pools, see [this\npage][ref-vsphere-resource_pools].\n\n[ref-vsphere-resource_pools]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-60077B40-66FF-4625-934A-641703ED7601.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe following example sets up a resource pool in a compute cluster which uses\nthe default settings for CPU and memory reservations, shares, and limits. The\ncompute cluster needs to already exist in vSphere.  \n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst config = new pulumi.Config();\nconst datacenter = config.get(\"datacenter\") || \"dc1\";\nconst cluster = config.get(\"cluster\") || \"cluster1\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: datacenter,\n}, { async: true }));\nconst computeCluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: cluster,\n}, { async: true }));\nconst resourcePool = new vsphere.ResourcePool(\"resource_pool\", {\n    parentResourcePoolId: computeCluster.resourcePoolId,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nconfig = pulumi.Config()\ndatacenter = config.get(\"datacenter\")\nif datacenter is None:\n    datacenter = \"dc1\"\ncluster = config.get(\"cluster\")\nif cluster is None:\n    cluster = \"cluster1\"\ndc = vsphere.get_datacenter(name=datacenter)\ncompute_cluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=cluster)\nresource_pool = vsphere.ResourcePool(\"resourcePool\", parent_resource_pool_id=compute_cluster.resource_pool_id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var config = new Config();\n        var datacenter = config.Get(\"datacenter\") ?? \"dc1\";\n        var cluster = config.Get(\"cluster\") ?? \"cluster1\";\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = datacenter,\n        }));\n        var computeCluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = cluster,\n        })));\n        var resourcePool = new VSphere.ResourcePool(\"resourcePool\", new VSphere.ResourcePoolArgs\n        {\n            ParentResourcePoolId = computeCluster.Apply(computeCluster =\u003e computeCluster.ResourcePoolId),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourcePool resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a resource pool will not exceed\nthis limit, even if there are available resources. Set to `-1` for unlimited.\nDefault: `-1`\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource pool.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/storageDrsVmOverride:StorageDrsVmOverride": {
            "description": "The `vsphere..StorageDrsVmOverride` resource can be used to add a Storage DRS\noverride to a datastore cluster for a specific virtual machine. With this\nresource, one can enable or disable Storage DRS, and control the automation\nlevel and disk affinity for a single virtual machine without affecting the rest\nof the datastore cluster.\n\nFor more information on vSphere datastore clusters and Storage DRS, see [this\npage][ref-vsphere-datastore-clusters].\n\n[ref-vsphere-datastore-clusters]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-598DF695-107E-406B-9C95-0AF961FC227A.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastoreCluster = dc.apply(dc =\u003e vsphere.getDatastoreCluster({\n    datacenterId: dc.id,\n    name: \"datastore-cluster1\",\n}, { async: true }));\nconst memberDatastore = dc.apply(dc =\u003e vsphere.getDatastore({\n    datacenterId: dc.id,\n    name: \"datastore-cluster1-member1\",\n}, { async: true }));\nconst pool = dc.apply(dc =\u003e vsphere.getResourcePool({\n    datacenterId: dc.id,\n    name: \"cluster1/Resources\",\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"public\",\n}, { async: true }));\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    datastoreId: memberDatastore.id,\n    disks: [{\n        label: \"disk0\",\n        size: 20,\n    }],\n    guestId: \"other3xLinux64Guest\",\n    memory: 1024,\n    networkInterfaces: [{\n        networkId: network.id,\n    }],\n    numCpus: 2,\n    resourcePoolId: pool.id,\n});\nconst drsVmOverride = new vsphere.StorageDrsVmOverride(\"drs_vm_override\", {\n    datastoreClusterId: datastoreCluster.id,\n    sdrsEnabled: \"false\",\n    virtualMachineId: vm.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"dc1\")\ndatastore_cluster = vsphere.get_datastore_cluster(datacenter_id=dc.id,\n    name=\"datastore-cluster1\")\nmember_datastore = vsphere.get_datastore(datacenter_id=dc.id,\n    name=\"datastore-cluster1-member1\")\npool = vsphere.get_resource_pool(datacenter_id=dc.id,\n    name=\"cluster1/Resources\")\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"public\")\nvm = vsphere.VirtualMachine(\"vm\",\n    datastore_id=member_datastore.id,\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 20,\n    }],\n    guest_id=\"other3xLinux64Guest\",\n    memory=1024,\n    network_interfaces=[{\n        \"networkId\": network.id,\n    }],\n    num_cpus=2,\n    resource_pool_id=pool.id)\ndrs_vm_override = vsphere.StorageDrsVmOverride(\"drsVmOverride\",\n    datastore_cluster_id=datastore_cluster.id,\n    sdrs_enabled=False,\n    virtual_machine_id=vm.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastoreCluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastoreCluster.InvokeAsync(new VSphere.GetDatastoreClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore-cluster1\",\n        })));\n        var memberDatastore = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore-cluster1-member1\",\n        })));\n        var pool = dc.Apply(dc =\u003e Output.Create(VSphere.GetResourcePool.InvokeAsync(new VSphere.GetResourcePoolArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"cluster1/Resources\",\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"public\",\n        })));\n        var vm = new VSphere.VirtualMachine(\"vm\", new VSphere.VirtualMachineArgs\n        {\n            DatastoreId = memberDatastore.Apply(memberDatastore =\u003e memberDatastore.Id),\n            Disks = \n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n            GuestId = \"other3xLinux64Guest\",\n            Memory = 1024,\n            NetworkInterfaces = \n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(network =\u003e network.Id),\n                },\n            },\n            NumCpus = 2,\n            ResourcePoolId = pool.Apply(pool =\u003e pool.Id),\n        });\n        var drsVmOverride = new VSphere.StorageDrsVmOverride(\"drsVmOverride\", new VSphere.StorageDrsVmOverrideArgs\n        {\n            DatastoreClusterId = datastoreCluster.Apply(datastoreCluster =\u003e datastoreCluster.Id),\n            SdrsEnabled = false,\n            VirtualMachineId = vm.Id,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageDrsVmOverride resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n"
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                    },
                    "sdrsEnabled": {
                        "type": "string",
                        "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                    },
                    "sdrsIntraVmAffinity": {
                        "type": "string",
                        "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tag:Tag": {
            "description": "The `vsphere..Tag` resource can be used to create and manage tags, which allow\nyou to attach metadata to objects in the vSphere inventory to make these\nobjects more sortable and searchable.\n\nFor more information about tags, click [here][ext-tags-general].\n\n[ext-tags-general]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vcenterhost.doc/GUID-E8E854DD-AA97-4E0C-8419-CE84F93C4058.html\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThis example creates a tag named `test-tag`. This tag is assigned the\n`test-category` category, which was created by the\n`vsphere..TagCategory` resource. The resulting\ntag can be assigned to VMs and datastores only, and can be the only value in\nthe category that can be assigned, as per the restrictions defined by the\ncategory.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = new vsphere.TagCategory(\"category\", {\n    associableTypes: [\n        \"VirtualMachine\",\n        \"Datastore\",\n    ],\n    cardinality: \"SINGLE\",\n    description: \"Managed by Pulumi\",\n});\nconst tag = new vsphere.Tag(\"tag\", {\n    categoryId: category.id,\n    description: \"Managed by Pulumi\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.TagCategory(\"category\",\n    associable_types=[\n        \"VirtualMachine\",\n        \"Datastore\",\n    ],\n    cardinality=\"SINGLE\",\n    description=\"Managed by Pulumi\")\ntag = vsphere.Tag(\"tag\",\n    category_id=category.id,\n    description=\"Managed by Pulumi\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var category = new VSphere.TagCategory(\"category\", new VSphere.TagCategoryArgs\n        {\n            AssociableTypes = \n            {\n                \"VirtualMachine\",\n                \"Datastore\",\n            },\n            Cardinality = \"SINGLE\",\n            Description = \"Managed by Pulumi\",\n        });\n        var tag = new VSphere.Tag(\"tag\", new VSphere.TagArgs\n        {\n            CategoryId = category.Id,\n            Description = \"Managed by Pulumi\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "required": [
                "categoryId",
                "name"
            ],
            "inputProperties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "requiredInputs": [
                "categoryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tag resources.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the tag.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tagCategory:TagCategory": {
            "properties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "required": [
                "associableTypes",
                "cardinality",
                "name"
            ],
            "inputProperties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "requiredInputs": [
                "associableTypes",
                "cardinality"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagCategory resources.\n",
                "properties": {
                    "associableTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                    },
                    "cardinality": {
                        "type": "string",
                        "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the category.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappContainer:VappContainer": {
            "description": "The `vsphere..VappContainer` resource can be used to create and manage\nvApps.\n\nFor more information on vSphere vApps, see [this\npage][ref-vsphere-vapp].\n\n[ref-vsphere-vapp]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-2A95EBB8-1779-40FA-B4FB-4D0845750879.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe basic example below sets up a vApp container in a compute cluster which uses\nthe default settings for CPU and memory reservations, shares, and limits. The\ncompute cluster needs to already exist in vSphere.  \n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst config = new pulumi.Config();\nconst datacenter = config.get(\"datacenter\") || \"dc1\";\nconst cluster = config.get(\"cluster\") || \"cluster1\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: datacenter,\n}, { async: true }));\nconst computeCluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: cluster,\n}, { async: true }));\nconst vappContainer = new vsphere.VappContainer(\"vapp_container\", {\n    parentResourcePoolId: computeCluster.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nconfig = pulumi.Config()\ndatacenter = config.get(\"datacenter\")\nif datacenter is None:\n    datacenter = \"dc1\"\ncluster = config.get(\"cluster\")\nif cluster is None:\n    cluster = \"cluster1\"\ndc = vsphere.get_datacenter(name=datacenter)\ncompute_cluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=cluster)\nvapp_container = vsphere.VappContainer(\"vappContainer\", parent_resource_pool_id=compute_cluster.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var config = new Config();\n        var datacenter = config.Get(\"datacenter\") ?? \"dc1\";\n        var cluster = config.Get(\"cluster\") ?? \"cluster1\";\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = datacenter,\n        }));\n        var computeCluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = cluster,\n        })));\n        var vappContainer = new VSphere.VappContainer(\"vappContainer\", new VSphere.VappContainerArgs\n        {\n            ParentResourcePoolId = computeCluster.Apply(computeCluster =\u003e computeCluster.Id),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Example with virtual machine\n\nThe below example builds off the basic example, but includes a virtual machine\nin the new vApp container. To accomplish this, the `resource_pool_id` of the\nvirtual machine is set to the `id` of the vApp container.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst config = new pulumi.Config();\nconst datacenter = config.get(\"datacenter\") || \"dc1\";\nconst cluster = config.get(\"cluster\") || \"cluster1\";\n\nconst dc = pulumi.output(vsphere.getDatacenter({\n    name: datacenter,\n}, { async: true }));\nconst computeCluster = dc.apply(dc =\u003e vsphere.getComputeCluster({\n    datacenterId: dc.id,\n    name: cluster,\n}, { async: true }));\nconst network = dc.apply(dc =\u003e vsphere.getNetwork({\n    datacenterId: dc.id,\n    name: \"network1\",\n}, { async: true }));\nconst datastore = dc.apply(dc =\u003e vsphere.getDatastore({\n    datacenterId: dc.id,\n    name: \"datastore1\",\n}, { async: true }));\nconst vappContainer = new vsphere.VappContainer(\"vapp_container\", {\n    parentResourcePoolId: computeCluster.id,\n});\nconst vm = new vsphere.VirtualMachine(\"vm\", {\n    datastoreId: datastore.id,\n    disks: [{\n        label: \"disk0\",\n        size: 1,\n    }],\n    guestId: \"ubuntu64Guest\",\n    memory: 1024,\n    networkInterfaces: [{\n        networkId: network.id,\n    }],\n    numCpus: 2,\n    resourcePoolId: vappContainer.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nconfig = pulumi.Config()\ndatacenter = config.get(\"datacenter\")\nif datacenter is None:\n    datacenter = \"dc1\"\ncluster = config.get(\"cluster\")\nif cluster is None:\n    cluster = \"cluster1\"\ndc = vsphere.get_datacenter(name=datacenter)\ncompute_cluster = vsphere.get_compute_cluster(datacenter_id=dc.id,\n    name=cluster)\nnetwork = vsphere.get_network(datacenter_id=dc.id,\n    name=\"network1\")\ndatastore = vsphere.get_datastore(datacenter_id=dc.id,\n    name=\"datastore1\")\nvapp_container = vsphere.VappContainer(\"vappContainer\", parent_resource_pool_id=compute_cluster.id)\nvm = vsphere.VirtualMachine(\"vm\",\n    datastore_id=datastore.id,\n    disks=[{\n        \"label\": \"disk0\",\n        \"size\": 1,\n    }],\n    guest_id=\"ubuntu64Guest\",\n    memory=1024,\n    network_interfaces=[{\n        \"networkId\": network.id,\n    }],\n    num_cpus=2,\n    resource_pool_id=vapp_container.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var config = new Config();\n        var datacenter = config.Get(\"datacenter\") ?? \"dc1\";\n        var cluster = config.Get(\"cluster\") ?? \"cluster1\";\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = datacenter,\n        }));\n        var computeCluster = dc.Apply(dc =\u003e Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = dc.Id,\n            Name = cluster,\n        })));\n        var network = dc.Apply(dc =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"network1\",\n        })));\n        var datastore = dc.Apply(dc =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = dc.Id,\n            Name = \"datastore1\",\n        })));\n        var vappContainer = new VSphere.VappContainer(\"vappContainer\", new VSphere.VappContainerArgs\n        {\n            ParentResourcePoolId = computeCluster.Apply(computeCluster =\u003e computeCluster.Id),\n        });\n        var vm = new VSphere.VirtualMachine(\"vm\", new VSphere.VirtualMachineArgs\n        {\n            DatastoreId = datastore.Apply(datastore =\u003e datastore.Id),\n            Disks = \n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 1,\n                },\n            },\n            GuestId = \"ubuntu64Guest\",\n            Memory = 1024,\n            NetworkInterfaces = \n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(network =\u003e network.Id),\n                },\n            },\n            NumCpus = 2,\n            ResourcePoolId = vappContainer.Id,\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappContainer resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container.\n"
                    },
                    "parentFolderId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappEntity:VappEntity": {
            "properties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n"
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "required": [
                "containerId",
                "targetId"
            ],
            "inputProperties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n"
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "requiredInputs": [
                "containerId",
                "targetId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappEntity resources.\n",
                "properties": {
                    "containerId": {
                        "type": "string",
                        "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "startAction": {
                        "type": "string",
                        "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                    },
                    "startDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                    },
                    "startOrder": {
                        "type": "integer",
                        "description": "Order to start and stop target in vApp. Default: 1\n"
                    },
                    "stopAction": {
                        "type": "string",
                        "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                    },
                    "stopDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "targetId": {
                        "type": "string",
                        "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n"
                    },
                    "waitForGuest": {
                        "type": "boolean",
                        "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualDisk:VirtualDisk": {
            "description": "The `vsphere..VirtualDisk` resource can be used to create virtual disks outside\nof any given `vsphere..VirtualMachine`\nresource. These disks can be attached to a virtual machine by creating a disk\nblock with the `attach` parameter.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst myDisk = new vsphere.VirtualDisk(\"myDisk\", {\n    datacenter: \"Datacenter\",\n    datastore: \"local\",\n    size: 2,\n    type: \"thin\",\n    vmdkPath: \"myDisk.vmdk\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nmy_disk = vsphere.VirtualDisk(\"myDisk\",\n    datacenter=\"Datacenter\",\n    datastore=\"local\",\n    size=2,\n    type=\"thin\",\n    vmdk_path=\"myDisk.vmdk\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var myDisk = new VSphere.VirtualDisk(\"myDisk\", new VSphere.VirtualDiskArgs\n        {\n            Datacenter = \"Datacenter\",\n            Datastore = \"local\",\n            Size = 2,\n            Type = \"thin\",\n            VmdkPath = \"myDisk.vmdk\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead"
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when when ESXi or if there is only one datacenter in\nyour infrastructure.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB).\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n"
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n"
                }
            },
            "required": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "inputProperties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead"
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when when ESXi or if there is only one datacenter in\nyour infrastructure.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB).\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n"
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n"
                }
            },
            "requiredInputs": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualDisk resources.\n",
                "properties": {
                    "adapterType": {
                        "type": "string",
                        "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n",
                        "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead"
                    },
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when when ESXi or if there is only one datacenter in\nyour infrastructure.\n"
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore in which to create the\ndisk.\n"
                    },
                    "size": {
                        "type": "integer",
                        "description": "Size of the disk (in GB).\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n"
                    },
                    "vmdkPath": {
                        "type": "string",
                        "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachine:VirtualMachine": {
            "properties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system\nwhen `guest_id` is `other` or `other-64`.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "A user-provided description of the virtual machine.\nThe default is no annotation.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting\nthe boot sequence. The default is no delay.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before\nretrying the boot sequence. This only valid if `boot_retry_enabled` is true.\nDefault: `10000` (10 seconds).\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a virtual machine that\nfails to boot will try again after the delay defined in `boot_retry_delay`.\nDefault: `false`.\n"
                },
                "cdrom": {
                    "$ref": "#/types/vsphere:/VirtualMachineCdrom:VirtualMachineCdrom",
                    "description": "A specification for a CDROM device on this virtual\nmachine. See CDROM options below.\n"
                },
                "changeVersion": {
                    "type": "string",
                    "description": "A unique identifier for a given version of the last\nconfiguration applied, such the timestamp of the last update to the\nconfiguration.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:/VirtualMachineClone:VirtualMachineClone",
                    "description": "When specified, the VM will be created as a clone of a\nspecified template. Optional customization options can be submitted as well.\nSee creating a virtual machine from a\ntemplate for more details.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual\nmachine while it is running.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be removed to this\nvirtual machine while it is running.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of CPU (in MHz) that this virtual\nmachine can consume, regardless of available resources. The default is no\nlimit.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance\ncounters on this virtual machine. Default: `false`.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of CPU (in MHz) that this virtual\nmachine is guaranteed. The default is no reservation.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The number of CPU shares allocated to the\nvirtual machine when the `cpu_share_level` is `custom`.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for CPU resources. Can be\none of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual machine.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter id. Required only when deploying\nan ovf template.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster ID to use. This setting\napplies to entire virtual machine and implies that you wish to use Storage\nDRS with this virtual machine. See the section on virtual machine\nmigration for details on changing this value.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n"
                },
                "defaultIpAddress": {
                    "type": "string",
                    "description": "The IP address selected by the provider to be used with\nany provisioners configured on this resource.\nWhenever possible, this is the first IPv4 address that is reachable through\nthe default gateway configured on the machine, then the first reachable IPv6\naddress, and then the first general discovered address if neither exist. If\nVMware tools is not running on the virtual machine, or if the VM is powered\noff, this value will be blank.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on this virtual\nmachine. See disk options below.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "When the `firmware` type is set to is\n`efi`, this enables EFI secure boot. Default: `false`.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to\nthe virtual machine, allowing access to them in the guest. Default: `false`.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging of virtual machine events to a\nlog file stored in the virtual machine directory. Default: `false`.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization)\nsetting for this virtual machine. Can be one of `automatic`, `on`, or `off`.\nDefault: `automatic`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for this virtual\nmachine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware interface to use on the virtual machine.\nCan be one of `bios` or `EFI`. Default: `bios`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The path to the folder to put this virtual machine in,\nrelative to the datacenter that the resource pool is in.\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "If a guest shutdown failed or timed out while\nupdating or destroying (see\n`shutdown_wait_timeout`), force the power-off of\nthe virtual machine. Default: `true`.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system type. For a\nfull list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.\n"
                },
                "guestIpAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The current list of IP addresses on this machine,\nincluding the value of `default_ip_address`. If VMware tools is not running\non the virtual machine, or if the VM is powered off, this list will be empty.\n* `moid`: The managed object reference ID of the created\nvirtual machine.\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version number. Valid range\nis from 4 to 15. The hardware version cannot be downgraded. See [virtual\nmachine hardware compatibility][virtual-machine-hardware-compatibility] for\nmore details.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "An optional managed object reference\nID of a host to put this virtual machine on. See the\nsection on virtual machine migration for\ndetails on changing this value. If a `host_system_id` is not supplied,\nvSphere will select a host in the resource pool to place the virtual machine,\naccording to any defaults or DRS policies in place.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The (non-nested) hardware virtualization setting for\nthis virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:\n`hvAuto`.\n"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to\nignore while waiting for an available IP address using either of the waiters.\nAny IP addresses in this list will be ignored if they show up so that the\nwaiter will continue to wait for a real IP address. Default: [].\n"
                },
                "imported": {
                    "type": "boolean",
                    "description": "This is flagged if the virtual machine has been imported, or the\nstate has been migrated from a previous version of the resource. It\ninfluences the behavior of the first post-import apply operation. See the\nsection on importing below.\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the\nvirtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that\nrequire frequent access to mouse or keyboard devices. Can be one of `low`,\n`normal`, `medium`, or `high`.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The size of the virtual machine's memory, in MB.\nDefault: `1024` (1 GB).\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to this\nvirtual machine while it is running.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) that this\nvirtual machine can consume, regardless of available resources. The default\nis no limit.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) that this\nvirtual machine is guaranteed. The default is no reservation.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The number of memory shares allocated to\nthe virtual machine when the `memory_share_level` is `custom`.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for memory resources.\nCan be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait\nfor a virtual machine migration to complete before failing. Default: 10\nminutes. Also see the section on virtual machine\nmigration.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "The machine object ID from VMWare\n"
                },
                "name": {
                    "type": "string",
                    "description": "An alias for both `label` and `path`, the latter when\nusing `attach`. Required if not using `label`.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on\nthis virtual machine, facilitating nested virtualization in the guest.\nDefault: `false`.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this\nvirtual machine. See network interface options\nbelow.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores per socket in this\nvirtual machine. The number of vCPUs on the virtual machine will be\n`num_cpus` divided by `num_cores_per_socket`. If specified, the value\nsupplied to `num_cpus` must be evenly divisible by this value. Default: `1`.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The total number of virtual processor cores to assign\nto this virtual machine. Default: `1`.\n"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "When specified, the VM will be deployed from the\nprovided ovf template. See creating a virtual machine from a\novf template for more details.\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "rebootRequired": {
                    "type": "boolean",
                    "description": "Value internal to the provider used to determine if a\nconfiguration set change requires a reboot. This value is only useful during\nan update process and gets reset on refresh.\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the resource pool to put this virtual machine in.\nSee the section on virtual machine migration\nfor details on changing this value.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable the execution of\npost-power-on scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable the execution of\npost-resume scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable the execution of\npre-reboot scripts when VMware tools is installed. Default: `false`.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable the execution\nof pre-shutdown scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable the execution of\npre-standby scripts when VMware tools is installed. Default: `true`.\n"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Default: `noSharing`.\n"
                },
                "scsiControllerCount": {
                    "type": "integer",
                    "description": "The number of SCSI controllers that\nthis provider manages on this virtual machine. This directly affects the amount\nof disks you can add to the virtual machine and the maximum disk unit number.\nNote that lowering this value does not remove controllers. Default: `1`.\n"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The type of SCSI bus this virtual machine will have.\nCan be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or\npvscsi (VMware Paravirtual). Defualt: `pvscsi`.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait\nfor a graceful guest shutdown when making necessary updates to the virtual\nmachine. If `force_power_off` is set to true, the VM will be force powered-off\nafter this timeout, otherwise an error is returned. Default: 3 minutes.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The UUID of the storage policy to assign to this disk.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for this\nvirtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.\nDefault: `inherit`.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable guest clock synchronization with\nthe host. Requires VMware tools to be installed. Default: `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual disk's VMDK file. This is used to track the\nvirtual disk on the virtual machine.\n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "Optional vApp configuration. The only sub-key available\nis `properties`, which is a key/value map of properties for virtual machines\nimported from OVF or OVA files. See Using vApp properties to supply OVF/OVA\nconfiguration for\nmore details.\n"
                },
                "vappTransports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Computed value which is only valid for cloned virtual\nmachines. A list of vApp transport methods supported by the source virtual\nmachine or template.\n"
                },
                "vmwareToolsStatus": {
                    "type": "string",
                    "description": "The state of VMware tools in the guest. This will\ndetermine the proper course of action for some device operations.\n"
                },
                "vmxPath": {
                    "type": "string",
                    "description": "The path of the virtual machine's configuration file in the VM's\ndatastore.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to\nwait for an available guest IP address on this virtual machine. This should\nonly be used if your version of VMware Tools does not allow the\n`wait_for_guest_net_timeout` waiter to be\nused. A value less than 1 disables the waiter. Default: 0.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest\nnetwork waiter waits for a routable address. When `false`, the waiter does\nnot wait for a default gateway, nor are IP addresses checked against any\ndiscovered default gateways as part of its success criteria. This property is\nignored if the `wait_for_guest_ip_timeout`\nwaiter is used. Default: `true`.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to\nwait for an available IP address on this virtual machine's NICs. Older\nversions of VMware Tools do not populate this property. In those cases, this\nwaiter can be disabled and the\n`wait_for_guest_ip_timeout` waiter can be used\ninstead. A value less than 1 disables the waiter. Default: 5 minutes.\n"
                }
            },
            "required": [
                "changeVersion",
                "cpuShareCount",
                "datastoreId",
                "defaultIpAddress",
                "disks",
                "guestIpAddresses",
                "hardwareVersion",
                "hostSystemId",
                "imported",
                "memoryShareCount",
                "moid",
                "name",
                "rebootRequired",
                "resourcePoolId",
                "uuid",
                "vappTransports",
                "vmwareToolsStatus",
                "vmxPath"
            ],
            "inputProperties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system\nwhen `guest_id` is `other` or `other-64`.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "A user-provided description of the virtual machine.\nThe default is no annotation.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting\nthe boot sequence. The default is no delay.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before\nretrying the boot sequence. This only valid if `boot_retry_enabled` is true.\nDefault: `10000` (10 seconds).\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a virtual machine that\nfails to boot will try again after the delay defined in `boot_retry_delay`.\nDefault: `false`.\n"
                },
                "cdrom": {
                    "$ref": "#/types/vsphere:/VirtualMachineCdrom:VirtualMachineCdrom",
                    "description": "A specification for a CDROM device on this virtual\nmachine. See CDROM options below.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:/VirtualMachineClone:VirtualMachineClone",
                    "description": "When specified, the VM will be created as a clone of a\nspecified template. Optional customization options can be submitted as well.\nSee creating a virtual machine from a\ntemplate for more details.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual\nmachine while it is running.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be removed to this\nvirtual machine while it is running.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of CPU (in MHz) that this virtual\nmachine can consume, regardless of available resources. The default is no\nlimit.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance\ncounters on this virtual machine. Default: `false`.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of CPU (in MHz) that this virtual\nmachine is guaranteed. The default is no reservation.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The number of CPU shares allocated to the\nvirtual machine when the `cpu_share_level` is `custom`.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for CPU resources. Can be\none of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual machine.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The datacenter id. Required only when deploying\nan ovf template.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster ID to use. This setting\napplies to entire virtual machine and implies that you wish to use Storage\nDRS with this virtual machine. See the section on virtual machine\nmigration for details on changing this value.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on this virtual\nmachine. See disk options below.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "When the `firmware` type is set to is\n`efi`, this enables EFI secure boot. Default: `false`.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to\nthe virtual machine, allowing access to them in the guest. Default: `false`.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging of virtual machine events to a\nlog file stored in the virtual machine directory. Default: `false`.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization)\nsetting for this virtual machine. Can be one of `automatic`, `on`, or `off`.\nDefault: `automatic`.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for this virtual\nmachine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware interface to use on the virtual machine.\nCan be one of `bios` or `EFI`. Default: `bios`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The path to the folder to put this virtual machine in,\nrelative to the datacenter that the resource pool is in.\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "If a guest shutdown failed or timed out while\nupdating or destroying (see\n`shutdown_wait_timeout`), force the power-off of\nthe virtual machine. Default: `true`.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system type. For a\nfull list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version number. Valid range\nis from 4 to 15. The hardware version cannot be downgraded. See [virtual\nmachine hardware compatibility][virtual-machine-hardware-compatibility] for\nmore details.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "An optional managed object reference\nID of a host to put this virtual machine on. See the\nsection on virtual machine migration for\ndetails on changing this value. If a `host_system_id` is not supplied,\nvSphere will select a host in the resource pool to place the virtual machine,\naccording to any defaults or DRS policies in place.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The (non-nested) hardware virtualization setting for\nthis virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:\n`hvAuto`.\n"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to\nignore while waiting for an available IP address using either of the waiters.\nAny IP addresses in this list will be ignored if they show up so that the\nwaiter will continue to wait for a real IP address. Default: [].\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the\nvirtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that\nrequire frequent access to mouse or keyboard devices. Can be one of `low`,\n`normal`, `medium`, or `high`.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The size of the virtual machine's memory, in MB.\nDefault: `1024` (1 GB).\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to this\nvirtual machine while it is running.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) that this\nvirtual machine can consume, regardless of available resources. The default\nis no limit.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) that this\nvirtual machine is guaranteed. The default is no reservation.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The number of memory shares allocated to\nthe virtual machine when the `memory_share_level` is `custom`.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for memory resources.\nCan be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait\nfor a virtual machine migration to complete before failing. Default: 10\nminutes. Also see the section on virtual machine\nmigration.\n"
                },
                "name": {
                    "type": "string",
                    "description": "An alias for both `label` and `path`, the latter when\nusing `attach`. Required if not using `label`.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on\nthis virtual machine, facilitating nested virtualization in the guest.\nDefault: `false`.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this\nvirtual machine. See network interface options\nbelow.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores per socket in this\nvirtual machine. The number of vCPUs on the virtual machine will be\n`num_cpus` divided by `num_cores_per_socket`. If specified, the value\nsupplied to `num_cpus` must be evenly divisible by this value. Default: `1`.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The total number of virtual processor cores to assign\nto this virtual machine. Default: `1`.\n"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "When specified, the VM will be deployed from the\nprovided ovf template. See creating a virtual machine from a\novf template for more details.\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the resource pool to put this virtual machine in.\nSee the section on virtual machine migration\nfor details on changing this value.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable the execution of\npost-power-on scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable the execution of\npost-resume scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable the execution of\npre-reboot scripts when VMware tools is installed. Default: `false`.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable the execution\nof pre-shutdown scripts when VMware tools is installed. Default: `true`.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable the execution of\npre-standby scripts when VMware tools is installed. Default: `true`.\n"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Default: `noSharing`.\n"
                },
                "scsiControllerCount": {
                    "type": "integer",
                    "description": "The number of SCSI controllers that\nthis provider manages on this virtual machine. This directly affects the amount\nof disks you can add to the virtual machine and the maximum disk unit number.\nNote that lowering this value does not remove controllers. Default: `1`.\n"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The type of SCSI bus this virtual machine will have.\nCan be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or\npvscsi (VMware Paravirtual). Defualt: `pvscsi`.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait\nfor a graceful guest shutdown when making necessary updates to the virtual\nmachine. If `force_power_off` is set to true, the VM will be force powered-off\nafter this timeout, otherwise an error is returned. Default: 3 minutes.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The UUID of the storage policy to assign to this disk.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for this\nvirtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.\nDefault: `inherit`.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable guest clock synchronization with\nthe host. Requires VMware tools to be installed. Default: `false`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "Optional vApp configuration. The only sub-key available\nis `properties`, which is a key/value map of properties for virtual machines\nimported from OVF or OVA files. See Using vApp properties to supply OVF/OVA\nconfiguration for\nmore details.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to\nwait for an available guest IP address on this virtual machine. This should\nonly be used if your version of VMware Tools does not allow the\n`wait_for_guest_net_timeout` waiter to be\nused. A value less than 1 disables the waiter. Default: 0.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest\nnetwork waiter waits for a routable address. When `false`, the waiter does\nnot wait for a default gateway, nor are IP addresses checked against any\ndiscovered default gateways as part of its success criteria. This property is\nignored if the `wait_for_guest_ip_timeout`\nwaiter is used. Default: `true`.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to\nwait for an available IP address on this virtual machine's NICs. Older\nversions of VMware Tools do not populate this property. In those cases, this\nwaiter can be disabled and the\n`wait_for_guest_ip_timeout` waiter can be used\ninstead. A value less than 1 disables the waiter. Default: 5 minutes.\n"
                }
            },
            "requiredInputs": [
                "resourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachine resources.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The guest name for the operating system\nwhen `guest_id` is `other` or `other-64`.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "A user-provided description of the virtual machine.\nThe default is no annotation.\n"
                    },
                    "bootDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before starting\nthe boot sequence. The default is no delay.\n"
                    },
                    "bootRetryDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before\nretrying the boot sequence. This only valid if `boot_retry_enabled` is true.\nDefault: `10000` (10 seconds).\n"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean",
                        "description": "If set to true, a virtual machine that\nfails to boot will try again after the delay defined in `boot_retry_delay`.\nDefault: `false`.\n"
                    },
                    "cdrom": {
                        "$ref": "#/types/vsphere:/VirtualMachineCdrom:VirtualMachineCdrom",
                        "description": "A specification for a CDROM device on this virtual\nmachine. See CDROM options below.\n"
                    },
                    "changeVersion": {
                        "type": "string",
                        "description": "A unique identifier for a given version of the last\nconfiguration applied, such the timestamp of the last update to the\nconfiguration.\n"
                    },
                    "clone": {
                        "$ref": "#/types/vsphere:/VirtualMachineClone:VirtualMachineClone",
                        "description": "When specified, the VM will be created as a clone of a\nspecified template. Optional customization options can be submitted as well.\nSee creating a virtual machine from a\ntemplate for more details.\n"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to this virtual\nmachine while it is running.\n"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be removed to this\nvirtual machine while it is running.\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The maximum amount of CPU (in MHz) that this virtual\nmachine can consume, regardless of available resources. The default is no\nlimit.\n"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean",
                        "description": "Enable CPU performance\ncounters on this virtual machine. Default: `false`.\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "The amount of CPU (in MHz) that this virtual\nmachine is guaranteed. The default is no reservation.\n"
                    },
                    "cpuShareCount": {
                        "type": "integer",
                        "description": "The number of CPU shares allocated to the\nvirtual machine when the `cpu_share_level` is `custom`.\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The allocation level for CPU resources. Can be\none of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue strings to set for virtual machine.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The datacenter id. Required only when deploying\nan ovf template.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster ID to use. This setting\napplies to entire virtual machine and implies that you wish to use Storage\nDRS with this virtual machine. See the section on virtual machine\nmigration for details on changing this value.\n"
                    },
                    "datastoreId": {
                        "type": "string",
                        "description": "The datastore ID that the ISO is located in.\nRequried for using a datastore ISO. Conflicts with `client_device`.\n"
                    },
                    "defaultIpAddress": {
                        "type": "string",
                        "description": "The IP address selected by the provider to be used with\nany provisioners configured on this resource.\nWhenever possible, this is the first IPv4 address that is reachable through\nthe default gateway configured on the machine, then the first reachable IPv6\naddress, and then the first general discovered address if neither exist. If\nVMware tools is not running on the virtual machine, or if the VM is powered\noff, this value will be blank.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:/VirtualMachineDisk:VirtualMachineDisk"
                        },
                        "description": "A specification for a virtual disk device on this virtual\nmachine. See disk options below.\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean",
                        "description": "When the `firmware` type is set to is\n`efi`, this enables EFI secure boot. Default: `false`.\n"
                    },
                    "enableDiskUuid": {
                        "type": "boolean",
                        "description": "Expose the UUIDs of attached virtual disks to\nthe virtual machine, allowing access to them in the guest. Default: `false`.\n"
                    },
                    "enableLogging": {
                        "type": "boolean",
                        "description": "Enable logging of virtual machine events to a\nlog file stored in the virtual machine directory. Default: `false`.\n"
                    },
                    "eptRviMode": {
                        "type": "string",
                        "description": "The EPT/RVI (hardware memory virtualization)\nsetting for this virtual machine. Can be one of `automatic`, `on`, or `off`.\nDefault: `automatic`.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Extra configuration data for this virtual\nmachine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata.\n"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware interface to use on the virtual machine.\nCan be one of `bios` or `EFI`. Default: `bios`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The path to the folder to put this virtual machine in,\nrelative to the datacenter that the resource pool is in.\n"
                    },
                    "forcePowerOff": {
                        "type": "boolean",
                        "description": "If a guest shutdown failed or timed out while\nupdating or destroying (see\n`shutdown_wait_timeout`), force the power-off of\nthe virtual machine. Default: `true`.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID for the operating system type. For a\nfull list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.\n"
                    },
                    "guestIpAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The current list of IP addresses on this machine,\nincluding the value of `default_ip_address`. If VMware tools is not running\non the virtual machine, or if the VM is powered off, this list will be empty.\n* `moid`: The managed object reference ID of the created\nvirtual machine.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version number. Valid range\nis from 4 to 15. The hardware version cannot be downgraded. See [virtual\nmachine hardware compatibility][virtual-machine-hardware-compatibility] for\nmore details.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "An optional managed object reference\nID of a host to put this virtual machine on. See the\nsection on virtual machine migration for\ndetails on changing this value. If a `host_system_id` is not supplied,\nvSphere will select a host in the resource pool to place the virtual machine,\naccording to any defaults or DRS policies in place.\n"
                    },
                    "hvMode": {
                        "type": "string",
                        "description": "The (non-nested) hardware virtualization setting for\nthis virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:\n`hvAuto`.\n"
                    },
                    "ignoredGuestIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP addresses and CIDR networks to\nignore while waiting for an available IP address using either of the waiters.\nAny IP addresses in this list will be ignored if they show up so that the\nwaiter will continue to wait for a real IP address. Default: [].\n"
                    },
                    "imported": {
                        "type": "boolean",
                        "description": "This is flagged if the virtual machine has been imported, or the\nstate has been migrated from a previous version of the resource. It\ninfluences the behavior of the first post-import apply operation. See the\nsection on importing below.\n"
                    },
                    "latencySensitivity": {
                        "type": "string",
                        "description": "Controls the scheduling delay of the\nvirtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that\nrequire frequent access to mouse or keyboard devices. Can be one of `low`,\n`normal`, `medium`, or `high`.\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\nDefault: `1024` (1 GB).\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow memory to be added to this\nvirtual machine while it is running.\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The maximum amount of memory (in MB) that this\nvirtual machine can consume, regardless of available resources. The default\nis no limit.\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "The amount of memory (in MB) that this\nvirtual machine is guaranteed. The default is no reservation.\n"
                    },
                    "memoryShareCount": {
                        "type": "integer",
                        "description": "The number of memory shares allocated to\nthe virtual machine when the `memory_share_level` is `custom`.\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The allocation level for memory resources.\nCan be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.\n"
                    },
                    "migrateWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait\nfor a virtual machine migration to complete before failing. Default: 10\nminutes. Also see the section on virtual machine\nmigration.\n"
                    },
                    "moid": {
                        "type": "string",
                        "description": "The machine object ID from VMWare\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "An alias for both `label` and `path`, the latter when\nusing `attach`. Required if not using `label`.\n"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean",
                        "description": "Enable nested hardware virtualization on\nthis virtual machine, facilitating nested virtualization in the guest.\nDefault: `false`.\n"
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                        },
                        "description": "A specification for a virtual NIC on this\nvirtual machine. See network interface options\nbelow.\n"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per socket in this\nvirtual machine. The number of vCPUs on the virtual machine will be\n`num_cpus` divided by `num_cores_per_socket`. If specified, the value\nsupplied to `num_cpus` must be evenly divisible by this value. Default: `1`.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The total number of virtual processor cores to assign\nto this virtual machine. Default: `1`.\n"
                    },
                    "ovfDeploy": {
                        "$ref": "#/types/vsphere:/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                        "description": "When specified, the VM will be deployed from the\nprovided ovf template. See creating a virtual machine from a\novf template for more details.\n"
                    },
                    "poweronTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                    },
                    "rebootRequired": {
                        "type": "boolean",
                        "description": "Value internal to the provider used to determine if a\nconfiguration set change requires a reboot. This value is only useful during\nan update process and gets reset on refresh.\n"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the resource pool to put this virtual machine in.\nSee the section on virtual machine migration\nfor details on changing this value.\n"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean",
                        "description": "Enable the execution of\npost-power-on scripts when VMware tools is installed. Default: `true`.\n"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean",
                        "description": "Enable the execution of\npost-resume scripts when VMware tools is installed. Default: `true`.\n"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean",
                        "description": "Enable the execution of\npre-reboot scripts when VMware tools is installed. Default: `false`.\n"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean",
                        "description": "Enable the execution\nof pre-shutdown scripts when VMware tools is installed. Default: `true`.\n"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean",
                        "description": "Enable the execution of\npre-standby scripts when VMware tools is installed. Default: `true`.\n"
                    },
                    "scsiBusSharing": {
                        "type": "string",
                        "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Default: `noSharing`.\n"
                    },
                    "scsiControllerCount": {
                        "type": "integer",
                        "description": "The number of SCSI controllers that\nthis provider manages on this virtual machine. This directly affects the amount\nof disks you can add to the virtual machine and the maximum disk unit number.\nNote that lowering this value does not remove controllers. Default: `1`.\n"
                    },
                    "scsiType": {
                        "type": "string",
                        "description": "The type of SCSI bus this virtual machine will have.\nCan be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or\npvscsi (VMware Paravirtual). Defualt: `pvscsi`.\n"
                    },
                    "shutdownWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait\nfor a graceful guest shutdown when making necessary updates to the virtual\nmachine. If `force_power_off` is set to true, the VM will be force powered-off\nafter this timeout, otherwise an error is returned. Default: 3 minutes.\n"
                    },
                    "storagePolicyId": {
                        "type": "string",
                        "description": "The UUID of the storage policy to assign to this disk.\n"
                    },
                    "swapPlacementPolicy": {
                        "type": "string",
                        "description": "The swap file placement policy for this\nvirtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.\nDefault: `inherit`.\n"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean",
                        "description": "Enable guest clock synchronization with\nthe host. Requires VMware tools to be installed. Default: `false`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "The UUID of the virtual disk's VMDK file. This is used to track the\nvirtual disk on the virtual machine.\n"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:/VirtualMachineVapp:VirtualMachineVapp",
                        "description": "Optional vApp configuration. The only sub-key available\nis `properties`, which is a key/value map of properties for virtual machines\nimported from OVF or OVA files. See Using vApp properties to supply OVF/OVA\nconfiguration for\nmore details.\n"
                    },
                    "vappTransports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Computed value which is only valid for cloned virtual\nmachines. A list of vApp transport methods supported by the source virtual\nmachine or template.\n"
                    },
                    "vmwareToolsStatus": {
                        "type": "string",
                        "description": "The state of VMware tools in the guest. This will\ndetermine the proper course of action for some device operations.\n"
                    },
                    "vmxPath": {
                        "type": "string",
                        "description": "The path of the virtual machine's configuration file in the VM's\ndatastore.\n"
                    },
                    "waitForGuestIpTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to\nwait for an available guest IP address on this virtual machine. This should\nonly be used if your version of VMware Tools does not allow the\n`wait_for_guest_net_timeout` waiter to be\nused. A value less than 1 disables the waiter. Default: 0.\n"
                    },
                    "waitForGuestNetRoutable": {
                        "type": "boolean",
                        "description": "Controls whether or not the guest\nnetwork waiter waits for a routable address. When `false`, the waiter does\nnot wait for a default gateway, nor are IP addresses checked against any\ndiscovered default gateways as part of its success criteria. This property is\nignored if the `wait_for_guest_ip_timeout`\nwaiter is used. Default: `true`.\n"
                    },
                    "waitForGuestNetTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to\nwait for an available IP address on this virtual machine's NICs. Older\nversions of VMware Tools do not populate this property. In those cases, this\nwaiter can be disabled and the\n`wait_for_guest_ip_timeout` waiter can be used\ninstead. A value less than 1 disables the waiter. Default: 5 minutes.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachineSnapshot:VirtualMachineSnapshot": {
            "description": "The `vsphere..VirtualMachineSnapshot` resource can be used to manage snapshots\nfor a virtual machine.\n\nFor more information on managing snapshots and how they work in VMware, see\n[here][ext-vm-snapshot-management].\n\n[ext-vm-snapshot-management]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-CA948C69-7F58-4519-AEB1-739545EA94E5.html\n\n\u003e **NOTE:** A snapshot in VMware differs from traditional disk snapshots, and\ncan contain the actual running state of the virtual machine, data for all disks\nthat have not been set to be independent from the snapshot (including ones that\nhave been attached via the `attach`\nparameter to the `vsphere..VirtualMachine` `disk` block), and even the\nconfiguration of the virtual machine at the time of the snapshot. Virtual\nmachine, disk activity, and configuration changes post-snapshot are not\nincluded in the original state. Use this resource with care! Neither VMware nor\nHashiCorp recommends retaining snapshots for a extended period of time and does\nNOT recommend using them as as backup feature. For more information on the\nlimitation of virtual machine snapshots, see [here][ext-vm-snap-limitations].\n\n[ext-vm-snap-limitations]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-53F65726-A23B-4CF0-A7D5-48E584B88613.html\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst demo1 = new vsphere.VirtualMachineSnapshot(\"demo1\", {\n    consolidate: true,\n    description: \"This is Demo Snapshot\",\n    memory: true,\n    quiesce: true,\n    removeChildren: false,\n    snapshotName: \"Snapshot Name\",\n    virtualMachineUuid: \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndemo1 = vsphere.VirtualMachineSnapshot(\"demo1\",\n    consolidate=\"true\",\n    description=\"This is Demo Snapshot\",\n    memory=\"true\",\n    quiesce=\"true\",\n    remove_children=\"false\",\n    snapshot_name=\"Snapshot Name\",\n    virtual_machine_uuid=\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var demo1 = new VSphere.VirtualMachineSnapshot(\"demo1\", new VSphere.VirtualMachineSnapshotArgs\n        {\n            Consolidate = \"true\",\n            Description = \"This is Demo Snapshot\",\n            Memory = \"true\",\n            Quiesce = \"true\",\n            RemoveChildren = \"false\",\n            SnapshotName = \"Snapshot Name\",\n            VirtualMachineUuid = \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n"
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n"
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n"
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n"
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n"
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n"
                }
            },
            "required": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "inputProperties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n"
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n"
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n"
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n"
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n"
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n"
                }
            },
            "requiredInputs": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachineSnapshot resources.\n",
                "properties": {
                    "consolidate": {
                        "type": "boolean",
                        "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the snapshot.\n"
                    },
                    "memory": {
                        "type": "boolean",
                        "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n"
                    },
                    "quiesce": {
                        "type": "boolean",
                        "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n"
                    },
                    "removeChildren": {
                        "type": "boolean",
                        "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n"
                    },
                    "snapshotName": {
                        "type": "string",
                        "description": "The name of the snapshot.\n"
                    },
                    "virtualMachineUuid": {
                        "type": "string",
                        "description": "The virtual machine UUID.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vmfsDatastore:VmfsDatastore": {
            "description": "The `vsphere..VmfsDatastore` resource can be used to create and manage VMFS\ndatastores on an ESXi host or a set of hosts. The resource supports using any\nSCSI device that can generally be used in a datastore, such as local disks, or\ndisks presented to a host or multiple hosts over Fibre Channel or iSCSI.\nDevices can be specified manually, or discovered using the\n[`vsphere..getVmfsDisks`][data-source-vmfs-disks] data source.\n\n[data-source-vmfs-disks]: /docs/providers/vsphere/d/vmfs_disks.html \n\n## Auto-Mounting of Datastores Within vCenter\n\nNote that the current behaviour of this resource will auto-mount any created\ndatastores to any other host within vCenter that has access to the same disk.\n\nExample: You want to create a datastore with a iSCSI LUN that is visible on 3\nhosts in a single vSphere cluster (`esxi1`, `esxi2` and `esxi3`). When you\ncreate the datastore on `esxi1`, the datastore will be automatically mounted on\n`esxi2` and `esxi3`, without the need to configure the resource on either of\nthose two hosts.\n\nFuture versions of this resource may allow you to control the hosts that a\ndatastore is mounted to, but currently, this automatic behaviour cannot be\nchanged, so keep this in mind when writing your configurations and deploying\nyour disks.\n\n## Increasing Datastore Size\n\nTo increase the size of a datastore, you must add additional disks to the\n`disks` attribute. Expanding the size of a datastore by increasing the size of\nan already provisioned disk is currently not supported (but may be in future\nversions of this resource).\n\n\u003e **NOTE:** You cannot decrease the size of a datastore. If the resource\ndetects disks removed from the configuration, the provider will give an error. \n\n[cmd-taint]: /docs/commands/taint.html\n\n{{% examples %}}\n## Example Usage\n\n{{% example %}}\n### Addition of local disks on a single host\n\nThe following example uses the default datacenter and default host to add a\ndatastore with local disks to a single ESXi server.\n\n\u003e **NOTE:** There are some situations where datastore creation will not work\nwhen working through vCenter (usually when trying to create a datastore on a\nsingle host with local disks). If you experience trouble creating the datastore\nyou need through vCenter, break the datstore off into a different configuration\nand deploy it using the ESXi server as the provider endpoint, using a similar\nconfiguration to what is below.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({ async: true }));\nconst esxiHost = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n}, { async: true }));\nconst datastore = new vsphere.VmfsDatastore(\"datastore\", {\n    disks: [\n        \"mpx.vmhba1:C0:T1:L0\",\n        \"mpx.vmhba1:C0:T2:L0\",\n        \"mpx.vmhba1:C0:T2:L0\",\n    ],\n    hostSystemId: esxiHost.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter()\nesxi_host = vsphere.get_host(datacenter_id=datacenter.id)\ndatastore = vsphere.VmfsDatastore(\"datastore\",\n    disks=[\n        \"mpx.vmhba1:C0:T1:L0\",\n        \"mpx.vmhba1:C0:T2:L0\",\n        \"mpx.vmhba1:C0:T2:L0\",\n    ],\n    host_system_id=esxi_host.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync());\n        var esxiHost = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n        })));\n        var datastore = new VSphere.VmfsDatastore(\"datastore\", new VSphere.VmfsDatastoreArgs\n        {\n            Disks = \n            {\n                \"mpx.vmhba1:C0:T1:L0\",\n                \"mpx.vmhba1:C0:T2:L0\",\n                \"mpx.vmhba1:C0:T2:L0\",\n            },\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Auto-detection of disks via `vsphere..getVmfsDisks`\n\nThe following example makes use of the\n`vsphere..getVmfsDisks` data source to auto-detect\nexported iSCSI LUNS matching a certain NAA vendor ID (in this case, LUNs\nexported from a [NetApp][ext-netapp]). These discovered disks are then loaded\ninto `vsphere..VmfsDatastore`. The datastore is also placed in the\n`datastore-folder` folder afterwards.\n\n[ext-netapp]: https://kb.netapp.com/support/s/article/ka31A0000000rLRQAY/how-to-match-a-lun-s-naa-number-to-its-serial-number?language=en_US\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst esxiHost = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n    name: \"esxi1\",\n}, { async: true }));\nconst available = esxiHost.apply(esxiHost =\u003e vsphere.getVmfsDisks({\n    filter: \"naa.60a98000\",\n    hostSystemId: esxiHost.id,\n    rescan: true,\n}, { async: true }));\nconst datastore = new vsphere.VmfsDatastore(\"datastore\", {\n    disks: available.disks,\n    folder: \"datastore-folder\",\n    hostSystemId: esxiHost.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nesxi_host = vsphere.get_host(datacenter_id=datacenter.id,\n    name=\"esxi1\")\navailable = vsphere.get_vmfs_disks(filter=\"naa.60a98000\",\n    host_system_id=esxi_host.id,\n    rescan=True)\ndatastore = vsphere.VmfsDatastore(\"datastore\",\n    disks=available.disks,\n    folder=\"datastore-folder\",\n    host_system_id=esxi_host.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var esxiHost = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"esxi1\",\n        })));\n        var available = esxiHost.Apply(esxiHost =\u003e Output.Create(VSphere.GetVmfsDisks.InvokeAsync(new VSphere.GetVmfsDisksArgs\n        {\n            Filter = \"naa.60a98000\",\n            HostSystemId = esxiHost.Id,\n            Rescan = true,\n        })));\n        var datastore = new VSphere.VmfsDatastore(\"datastore\", new VSphere.VmfsDatastoreArgs\n        {\n            Disks = available.Apply(available =\u003e available.Disks),\n            Folder = \"datastore-folder\",\n            HostSystemId = esxiHost.Apply(esxiHost =\u003e esxiHost.Id),\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "properties": {
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "disks",
                "freeSpace",
                "hostSystemId",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n"
                }
            },
            "requiredInputs": [
                "disks",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmfsDatastore resources.\n",
                "properties": {
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The disks to use with the datastore.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n"
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n"
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vnic:Vnic": {
            "description": "Provides a VMware vSphere vnic resource.\n\n## Example Usages\n\n### Create a vnic attached to a portgroup using the default TCP/IP stack\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst dc = vsphere.getDatacenter({\n    name: \"mydc\",\n});\nconst h1 = dc.then(dc =\u003e vsphere.getHost({\n    name: \"esxi1.host.test\",\n    datacenterId: dc.id,\n}));\nconst hvs1 = new vsphere.HostVirtualSwitch(\"hvs1\", {\n    hostSystemId: h1.then(h1 =\u003e h1.id),\n    networkAdapters: [\n        \"vmnic3\",\n        \"vmnic4\",\n    ],\n    activeNics: [\"vmnic3\"],\n    standbyNics: [\"vmnic4\"],\n});\nconst p1 = new vsphere.HostPortGroup(\"p1\", {\n    virtualSwitchName: hvs1.name,\n    hostSystemId: h1.then(h1 =\u003e h1.id),\n});\nconst v1 = new vsphere.Vnic(\"v1\", {\n    host: h1.then(h1 =\u003e h1.id),\n    portgroup: p1.name,\n    ipv4: {\n        dhcp: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndc = vsphere.get_datacenter(name=\"mydc\")\nh1 = vsphere.get_host(name=\"esxi1.host.test\",\n    datacenter_id=dc.id)\nhvs1 = vsphere.HostVirtualSwitch(\"hvs1\",\n    host_system_id=h1.id,\n    network_adapters=[\n        \"vmnic3\",\n        \"vmnic4\",\n    ],\n    active_nics=[\"vmnic3\"],\n    standby_nics=[\"vmnic4\"])\np1 = vsphere.HostPortGroup(\"p1\",\n    virtual_switch_name=hvs1.name,\n    host_system_id=h1.id)\nv1 = vsphere.Vnic(\"v1\",\n    host=h1.id,\n    portgroup=p1.name,\n    ipv4={\n        \"dhcp\": True,\n    })\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"mydc\",\n        }));\n        var h1 = dc.Apply(dc =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            Name = \"esxi1.host.test\",\n            DatacenterId = dc.Id,\n        })));\n        var hvs1 = new VSphere.HostVirtualSwitch(\"hvs1\", new VSphere.HostVirtualSwitchArgs\n        {\n            HostSystemId = h1.Apply(h1 =\u003e h1.Id),\n            NetworkAdapters = \n            {\n                \"vmnic3\",\n                \"vmnic4\",\n            },\n            ActiveNics = \n            {\n                \"vmnic3\",\n            },\n            StandbyNics = \n            {\n                \"vmnic4\",\n            },\n        });\n        var p1 = new VSphere.HostPortGroup(\"p1\", new VSphere.HostPortGroupArgs\n        {\n            VirtualSwitchName = hvs1.Name,\n            HostSystemId = h1.Apply(h1 =\u003e h1.Id),\n        });\n        var v1 = new VSphere.Vnic(\"v1\", new VSphere.VnicArgs\n        {\n            Host = h1.Apply(h1 =\u003e h1.Id),\n            Portgroup = p1.Name,\n            Ipv4 = new VSphere.Inputs.VnicIpv4Args\n            {\n                Dhcp = true,\n            },\n        });\n    }\n\n}\n```\n\n## Importing \n\nAn existing vNic can be [imported][docs-import] into this resource\nvia supplying the vNic's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n```\n```python\nimport pulumi\n```\n```csharp\nusing Pulumi;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n    }\n\n}\n```\n\nThe above would import the the vnic `vmk2` from host with ID `host-123`.\n",
            "properties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to. \n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n"
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See  ipv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See  ipv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default: `defaultTcpipStack`)\n"
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                }
            },
            "required": [
                "host",
                "mac",
                "mtu"
            ],
            "inputProperties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to. \n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n"
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See  ipv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See  ipv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default: `defaultTcpipStack`)\n"
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                }
            },
            "requiredInputs": [
                "host"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vnic resources.\n",
                "properties": {
                    "distributedPortGroup": {
                        "type": "string",
                        "description": "Key of the distributed portgroup the nic will connect to. \n"
                    },
                    "distributedSwitchPort": {
                        "type": "string",
                        "description": "UUID of the DVSwitch the nic will be attached to. Do not set if you set portgroup.\n"
                    },
                    "host": {
                        "type": "string",
                        "description": "ESX host the interface belongs to\n"
                    },
                    "ipv4": {
                        "$ref": "#/types/vsphere:/VnicIpv4:VnicIpv4",
                        "description": "IPv4 settings. Either this or `ipv6` needs to be set. See  ipv4 options below.\n"
                    },
                    "ipv6": {
                        "$ref": "#/types/vsphere:/VnicIpv6:VnicIpv6",
                        "description": "IPv6 settings. Either this or `ipv6` needs to be set. See  ipv6 options below.\n"
                    },
                    "mac": {
                        "type": "string",
                        "description": "MAC address of the interface.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "MTU of the interface.\n"
                    },
                    "netstack": {
                        "type": "string",
                        "description": "TCP/IP stack setting for this interface. Possible values are 'defaultTcpipStack', 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default: `defaultTcpipStack`)\n"
                    },
                    "portgroup": {
                        "type": "string",
                        "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "vsphere:index/getComputeCluster:getComputeCluster": {
            "description": "The `vsphere..ComputeCluster` data source can be used to discover the ID of a\ncluster in vSphere. This is useful to fetch the ID of a cluster that you want\nto use for virtual machine placement via the\n`vsphere..VirtualMachine` resource, allowing\nyou to specify the cluster's root resource pool directly versus using the alias\navailable through the `vsphere..ResourcePool`\ndata source.\n\n\u003e You may also wish to see the\n`vsphere..ComputeCluster` resource for further\ndetails about clusters or how to work with them.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst computeCluster = vsphere_datacenter_dc.id.apply(id =\u003e vsphere.getComputeCluster({\n    datacenterId: id,\n    name: \"compute-cluster1\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ncompute_cluster = vsphere.get_compute_cluster(datacenter_id=data[\"vsphere..Datacenter\"][\"dc\"][\"id\"],\n    name=\"compute-cluster1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var computeCluster = Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs\n        {\n            DatacenterId = data.Vsphere_datacenter.Dc.Id,\n            Name = \"compute-cluster1\",\n        }));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the cluster is located in.  This can\nbe omitted if the search path used in `name` is an absolute path.  For\ndefault datacenters, use the id attribute from an empty `vsphere..Datacenter`\ndata source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "resourcePoolId",
                    "id"
                ]
            }
        },
        "vsphere:index/getContentLibrary:getContentLibrary": {
            "description": "The `vsphere..ContentLibrary` data source can be used to discover the ID of a Content Library.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst library = pulumi.output(vsphere.getContentLibrary({\n    name: \"Content Library Test\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlibrary = vsphere.get_content_library(name=\"Content Library Test\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var library = Output.Create(VSphere.GetContentLibrary.InvokeAsync(new VSphere.GetContentLibraryArgs\n        {\n            Name = \"Content Library Test\",\n        }));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibrary.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the Content Library.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibrary.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getContentLibraryItem:getContentLibraryItem": {
            "description": "The `vsphere..ContentLibraryItem` data source can be used to discover the ID of a Content Library item.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nconnections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst library = vsphere.getContentLibrary({\n    name: \"Content Library Test\",\n});\nconst item = library.then(library =\u003e vsphere.getContentLibraryItem({\n    name: \"Ubuntu Bionic 18.04\",\n    libraryId: library.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlibrary = vsphere.get_content_library(name=\"Content Library Test\")\nitem = vsphere.get_content_library_item(name=\"Ubuntu Bionic 18.04\",\n    library_id=library.id)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var library = Output.Create(VSphere.GetContentLibrary.InvokeAsync(new VSphere.GetContentLibraryArgs\n        {\n            Name = \"Content Library Test\",\n        }));\n        var item = library.Apply(library =\u003e Output.Create(VSphere.GetContentLibraryItem.InvokeAsync(new VSphere.GetContentLibraryItemArgs\n        {\n            Name = \"Ubuntu Bionic 18.04\",\n            LibraryId = library.Id,\n        })));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibraryItem.\n",
                "properties": {
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the Content Library the item exists in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the Content Library.\n"
                    }
                },
                "type": "object",
                "required": [
                    "libraryId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibraryItem.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "libraryId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "libraryId",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getCustomAttribute:getCustomAttribute": {
            "description": "The `vsphere..CustomAttribute` data source can be used to reference custom \nattributes that are not managed by this provider. Its attributes are exactly the \nsame as the `vsphere..CustomAttribute` resource, \nand, like importing, the data source takes a name to search on. The `id` and \nother attributes are then populated with the data found by the search.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections \nand require vCenter.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst attribute = pulumi.output(vsphere.getCustomAttribute({\n    name: \"test-attribute\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nattribute = vsphere.get_custom_attribute(name=\"test-attribute\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var attribute = Output.Create(VSphere.GetCustomAttribute.InvokeAsync(new VSphere.GetCustomAttributeArgs\n        {\n            Name = \"test-attribute\",\n        }));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomAttribute.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomAttribute.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "managedObjectType": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "managedObjectType",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getDatacenter:getDatacenter": {
            "description": "The `vsphere..Datacenter` data source can be used to discover the ID of a\nvSphere datacenter. This can then be used with resources or data sources that\nrequire a datacenter, such as the `vsphere..Host`\ndata source.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatacenter.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This can be a name or path.\nCan be omitted if there is only one datacenter in your inventory.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatacenter.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            }
        },
        "vsphere:index/getDatastore:getDatastore": {
            "description": "The `vsphere..getDatastore` data source can be used to discover the ID of a\ndatastore in vSphere. This is useful to fetch the ID of a datastore that you\nwant to use to create virtual machines in using the\n`vsphere..VirtualMachine` resource. \n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastore = datacenter.apply(datacenter =\u003e vsphere.getDatastore({\n    datacenterId: datacenter.id,\n    name: \"datastore1\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ndatastore = vsphere.get_datastore(datacenter_id=datacenter.id,\n    name=\"datastore1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastore = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"datastore1\",\n        })));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the datastore is located in. This\ncan be omitted if the search path used in `name` is an absolute path. For\ndefault datacenters, use the id attribute from an empty `vsphere..Datacenter`\ndata source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getDatastoreCluster:getDatastoreCluster": {
            "description": "The `vsphere..DatastoreCluster` data source can be used to discover the ID of a\ndatastore cluster in vSphere. This is useful to fetch the ID of a datastore\ncluster that you want to use to assign datastores to using the\n`vsphere..NasDatastore` or\n`vsphere..VmfsDatastore` resources, or create\nvirtual machines in using the\n`vsphere..VirtualMachine` resource. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst datastoreCluster = vsphere_datacenter_dc.id.apply(id =\u003e vsphere.getDatastoreCluster({\n    datacenterId: id,\n    name: \"datastore-cluster1\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ndatastore_cluster = vsphere.get_datastore_cluster(datacenter_id=data[\"vsphere..Datacenter\"][\"dc\"][\"id\"],\n    name=\"datastore-cluster1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var datastoreCluster = Output.Create(VSphere.GetDatastoreCluster.InvokeAsync(new VSphere.GetDatastoreClusterArgs\n        {\n            DatacenterId = data.Vsphere_datacenter.Dc.Id,\n            Name = \"datastore-cluster1\",\n        }));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the datastore cluster is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the id attribute from an empty\n`vsphere..Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the datastore cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getDistributedVirtualSwitch:getDistributedVirtualSwitch": {
            "description": "The `vsphere..DistributedVirtualSwitch` data source can be used to discover\nthe ID and uplink data of a of a vSphere distributed virtual switch (DVS). This\ncan then be used with resources or data sources that require a DVS, such as the\n`vsphere..DistributedPortGroup` resource, for which\nan example is shown below.\n\n\n\u003e **NOTE:** This data source requires vCenter and is not available on direct\nESXi connections.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nThe following example locates a DVS that is named `test-dvs`, in the\ndatacenter `dc1`. It then uses this DVS to set up a\n`vsphere..DistributedPortGroup` resource that uses the first uplink as a\nprimary uplink and the second uplink as a secondary.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst dvs = datacenter.apply(datacenter =\u003e vsphere.getDistributedVirtualSwitch({\n    datacenterId: datacenter.id,\n    name: \"test-dvs\",\n}, { async: true }));\nconst pg = new vsphere.DistributedPortGroup(\"pg\", {\n    activeUplinks: [dvs.apply(dvs =\u003e dvs.uplinks[0])],\n    distributedVirtualSwitchUuid: dvs.id,\n    standbyUplinks: [dvs.apply(dvs =\u003e dvs.uplinks[1])],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ndvs = vsphere.get_distributed_virtual_switch(datacenter_id=datacenter.id,\n    name=\"test-dvs\")\npg = vsphere.DistributedPortGroup(\"pg\",\n    active_uplinks=[dvs.uplinks[0]],\n    distributed_virtual_switch_uuid=dvs.id,\n    standby_uplinks=[dvs.uplinks[1]])\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var dvs = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetDistributedVirtualSwitch.InvokeAsync(new VSphere.GetDistributedVirtualSwitchArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"test-dvs\",\n        })));\n        var pg = new VSphere.DistributedPortGroup(\"pg\", new VSphere.DistributedPortGroupArgs\n        {\n            ActiveUplinks = \n            {\n                dvs.Apply(dvs =\u003e dvs.Uplinks[0]),\n            },\n            DistributedVirtualSwitchUuid = dvs.Apply(dvs =\u003e dvs.Id),\n            StandbyUplinks = \n            {\n                dvs.Apply(dvs =\u003e dvs.Uplinks[1]),\n            },\n        });\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the DVS is located in. This can be\nomitted if the search path used in `name` is an absolute path. For default\ndatacenters, use the id attribute from an empty `vsphere..Datacenter` data\nsource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the distributed virtual switch. This can be a\nname or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "uplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "uplinks",
                    "id"
                ]
            }
        },
        "vsphere:index/getFolder:getFolder": {
            "description": "The `vsphere..Folder` data source can be used to get the general attributes of a\nvSphere inventory folder. Paths are absolute and include must include the\ndatacenter.  \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst folder = pulumi.output(vsphere.getFolder({\n    path: \"/dc1/datastore/folder1\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nfolder = vsphere.get_folder(path=\"/dc1/datastore/folder1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var folder = Output.Create(VSphere.GetFolder.InvokeAsync(new VSphere.GetFolderArgs\n        {\n            Path = \"/dc1/datastore/folder1\",\n        }));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFolder.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The absolute path of the folder. For example, given a\ndefault datacenter of `default-dc`, a folder of type `vm`, and a folder name\nof `test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`. The valid folder types to be used in\nthe path are: `vm`, `host`, `datacenter`, `datastore`, or `network`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFolder.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "path": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "path",
                    "id"
                ]
            }
        },
        "vsphere:index/getHost:getHost": {
            "description": "The `vsphere..Host` data source can be used to discover the ID of a vSphere\nhost. This can then be used with resources or data sources that require a host\nmanaged object reference ID.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst host = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n    name: \"esxi1\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nhost = vsphere.get_host(datacenter_id=datacenter.id,\n    name=\"esxi1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var host = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"esxi1\",\n        })));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of a datacenter.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host. This can be a name or path. Can be\nomitted if there is only one host in your inventory.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID of the host's\nroot resource pool.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "resourcePoolId",
                    "id"
                ]
            }
        },
        "vsphere:index/getNetwork:getNetwork": {
            "description": "The `vsphere..getNetwork` data source can be used to discover the ID of a network\nin vSphere. This can be any network that can be used as the backing for a\nnetwork interface for `vsphere..VirtualMachine` or any other vSphere resource\nthat requires a network. This includes standard (host-based) port groups, DVS\nport groups, or opaque networks such as those managed by NSX.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst net = datacenter.apply(datacenter =\u003e vsphere.getNetwork({\n    datacenterId: datacenter.id,\n    name: \"test-net\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nnet = vsphere.get_network(datacenter_id=datacenter.id,\n    name=\"test-net\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var net = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"test-net\",\n        })));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the network is located in. This can\nbe omitted if the search path used in `name` is an absolute path. For default\ndatacenters, use the id attribute from an empty `vsphere..Datacenter` data\nsource.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "For distributed port group type \nnetwork objects, the ID of the distributed virtual switch the given port group\nbelongs to. It is useful to differentiate port groups with same name using the\nDistributed virtual switch ID.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the network. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "type",
                    "id"
                ]
            }
        },
        "vsphere:index/getPolicy:getPolicy": {
            "description": "The `vsphere..getPolicy` data source can be used to discover the UUID of a\nvSphere storage policy. This can then be used with resources or data sources that\nrequire a storage policy.\n\n\u003e **NOTE:** Storage policy support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst policy = pulumi.output(vsphere.getPolicy({\n    name: \"policy1\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\npolicy = vsphere.get_policy(name=\"policy1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var policy = Output.Create(VSphere.GetPolicy.InvokeAsync(new VSphere.GetPolicyArgs\n        {\n            Name = \"policy1\",\n        }));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPolicy.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getResourcePool:getResourcePool": {
            "description": "The `vsphere..ResourcePool` data source can be used to discover the ID of a\nresource pool in vSphere. This is useful to fetch the ID of a resource pool\nthat you want to use to create virtual machines in using the\n`vsphere..VirtualMachine` resource. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst pool = datacenter.apply(datacenter =\u003e vsphere.getResourcePool({\n    datacenterId: datacenter.id,\n    name: \"resource-pool-1\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\npool = vsphere.get_resource_pool(datacenter_id=datacenter.id,\n    name=\"resource-pool-1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var pool = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetResourcePool.InvokeAsync(new VSphere.GetResourcePoolArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"resource-pool-1\",\n        })));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% example %}}\n### Specifying the root resource pool for a standalone host\n\n\u003e **NOTE:** Fetching the root resource pool for a cluster can now be done\ndirectly via the `vsphere..ComputeCluster`\ndata source.\n\nAll compute resources in vSphere (clusters, standalone hosts, and standalone\nESXi) have a resource pool, even if one has not been explicitly created. This\nresource pool is referred to as the _root resource pool_ and can be looked up\nby specifying the path as per the example below:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst pool = vsphere_datacenter_dc.id.apply(id =\u003e vsphere.getResourcePool({\n    datacenterId: id,\n    name: \"esxi1/Resources\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\npool = vsphere.get_resource_pool(datacenter_id=data[\"vsphere..Datacenter\"][\"dc\"][\"id\"],\n    name=\"esxi1/Resources\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var pool = Output.Create(VSphere.GetResourcePool.InvokeAsync(new VSphere.GetResourcePoolArgs\n        {\n            DatacenterId = data.Vsphere_datacenter.Dc.Id,\n            Name = \"esxi1/Resources\",\n        }));\n    }\n\n}\n```\n\nFor more information on the root resource pool, see [Managing Resource\nPools][vmware-docs-resource-pools] in the vSphere documentation.\n\n[vmware-docs-resource-pools]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-60077B40-66FF-4625-934A-641703ED7601.html\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the resource pool is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the id attribute from an empty\n`vsphere..Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource pool. This can be a name or\npath. This is required when using vCenter.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "id"
                ]
            }
        },
        "vsphere:index/getTag:getTag": {
            "description": "The `vsphere..Tag` data source can be used to reference tags that are not\nmanaged by this provider. Its attributes are exactly the same as the `vsphere..Tag`\nresource, and, like importing, the data source takes a name and\ncategory to search on. The `id` and other attributes are then populated with\nthe data found by the search.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = pulumi.output(vsphere.getTagCategory({\n    name: \"test-category\",\n}, { async: true }));\nconst tag = category.apply(category =\u003e vsphere.getTag({\n    categoryId: category.id,\n    name: \"test-tag\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"test-category\")\ntag = vsphere.get_tag(category_id=category.id,\n    name=\"test-tag\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var category = Output.Create(VSphere.GetTagCategory.InvokeAsync(new VSphere.GetTagCategoryArgs\n        {\n            Name = \"test-category\",\n        }));\n        var tag = category.Apply(category =\u003e Output.Create(VSphere.GetTag.InvokeAsync(new VSphere.GetTagArgs\n        {\n            CategoryId = category.Id,\n            Name = \"test-tag\",\n        })));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The ID of the tag category the tag is located in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the tag.\n"
                    }
                },
                "type": "object",
                "required": [
                    "categoryId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "categoryId",
                    "description",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getTagCategory:getTagCategory": {
            "description": "The `vsphere..TagCategory` data source can be used to reference tag categories\nthat are not managed by this provider. Its attributes are exactly the same as the\n`vsphere..TagCategory` resource, and, like importing,\nthe data source takes a name to search on. The `id` and other attributes are\nthen populated with the data found by the search.\n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = pulumi.output(vsphere.getTagCategory({\n    name: \"test-category\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"test-category\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var category = Output.Create(VSphere.GetTagCategory.InvokeAsync(new VSphere.GetTagCategoryArgs\n        {\n            Name = \"test-category\",\n        }));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTagCategory.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the tag category.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTagCategory.\n",
                "properties": {
                    "associableTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "cardinality": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "associableTypes",
                    "cardinality",
                    "description",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getVappContainer:getVappContainer": {
            "description": "The `vsphere..VappContainer` data source can be used to discover the ID of a\nvApp container in vSphere. This is useful to fetch the ID of a vApp container\nthat you want to use to create virtual machines in using the\n`vsphere..VirtualMachine` resource. \n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst pool = datacenter.apply(datacenter =\u003e vsphere.getVappContainer({\n    datacenterId: datacenter.id,\n    name: \"vapp-container-1\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\npool = vsphere.get_vapp_container(datacenter_id=datacenter.id,\n    name=\"vapp-container-1\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var pool = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetVappContainer.InvokeAsync(new VSphere.GetVappContainerArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"vapp-container-1\",\n        })));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the vApp container is located in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container. This can be a name or\npath.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "name",
                    "id"
                ]
            }
        },
        "vsphere:index/getVirtualMachine:getVirtualMachine": {
            "description": "The `vsphere..VirtualMachine` data source can be used to find the UUID of an\nexisting virtual machine or template. Its most relevant purpose is for finding\nthe UUID of a template to be used as the source for cloning into a new\n`vsphere..VirtualMachine` resource. It also\nreads the guest ID so that can be supplied as well.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst template = datacenter.apply(datacenter =\u003e vsphere.getVirtualMachine({\n    datacenterId: datacenter.id,\n    name: \"test-vm-template\",\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\ntemplate = vsphere.get_virtual_machine(datacenter_id=datacenter.id,\n    name=\"test-vm-template\")\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var template = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetVirtualMachine.InvokeAsync(new VSphere.GetVirtualMachineArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"test-vm-template\",\n        })));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVirtualMachine.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the virtual machine is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the `id` attribute from an empty\n`vsphere..Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual machine. This can be a name or\npath.\n"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer",
                        "description": "The number of SCSI controllers to\nscan for disk attributes and controller types on. Default: `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVirtualMachine.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The alternate guest name of the virtual machine when\nguest_id is a non-specific operating system, like `otherGuest`.\n"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:/getVirtualMachineDisk:getVirtualMachineDisk"
                        },
                        "description": "Information about each of the disks on this virtual machine or\ntemplate. These are sorted by bus and unit number so that they can be applied\nto a `vsphere..VirtualMachine` resource in the order the resource expects\nwhile cloning. This is useful for discovering certain disk settings while\nperforming a linked clone, as all settings that are output by this data\nsource must be the same on the destination virtual machine as the source.\nOnly the first number of controllers defined by `scsi_controller_scan_count`\nare scanned for disks. The sub-attributes are:\n"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware type for this virtual machine. Can be `bios` or `efi`.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID of the virtual machine or template.\n"
                    },
                    "guestIpAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of IP addresses as reported by VMWare tools.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "networkInterfaceTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The network interface types for each network\ninterface found on the virtual machine, in device bus order. Will be one of\n`e1000`, `e1000e`, `pcnet32`, `sriov`, `vmxnet2`, or `vmxnet3`.\n"
                    },
                    "scsiBusSharing": {
                        "type": "string",
                        "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Only the first number of\ncontrollers defined by `scsi_controller_scan_count` are scanned.\n"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "type": "string",
                        "description": "The common type of all SCSI controllers on this virtual machine.\nWill be one of `lsilogic` (LSI Logic Parallel), `lsilogic-sas` (LSI Logic\nSAS), `pvscsi` (VMware Paravirtual), `buslogic` (BusLogic), or `mixed` when\nthere are multiple controller types. Only the first number of controllers\ndefined by `scsi_controller_scan_count` are scanned.\n"
                    }
                },
                "type": "object",
                "required": [
                    "alternateGuestName",
                    "disks",
                    "firmware",
                    "guestId",
                    "guestIpAddresses",
                    "name",
                    "networkInterfaceTypes",
                    "scsiBusSharing",
                    "scsiType",
                    "id"
                ]
            }
        },
        "vsphere:index/getVmfsDisks:getVmfsDisks": {
            "description": "The `vsphere..getVmfsDisks` data source can be used to discover the storage\ndevices available on an ESXi host. This data source can be combined with the\n`vsphere..VmfsDatastore` resource to create VMFS\ndatastores based off a set of discovered disks.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = pulumi.output(vsphere.getDatacenter({\n    name: \"dc1\",\n}, { async: true }));\nconst host = datacenter.apply(datacenter =\u003e vsphere.getHost({\n    datacenterId: datacenter.id,\n    name: \"esxi1\",\n}, { async: true }));\nconst available = host.apply(host =\u003e vsphere.getVmfsDisks({\n    filter: \"mpx.vmhba1:C0:T[12]:L0\",\n    hostSystemId: host.id,\n    rescan: true,\n}, { async: true }));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc1\")\nhost = vsphere.get_host(datacenter_id=datacenter.id,\n    name=\"esxi1\")\navailable = vsphere.get_vmfs_disks(filter=\"mpx.vmhba1:C0:T[12]:L0\",\n    host_system_id=host.id,\n    rescan=True)\n```\n```csharp\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nclass MyStack : Stack\n{\n    public MyStack()\n    {\n        var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs\n        {\n            Name = \"dc1\",\n        }));\n        var host = datacenter.Apply(datacenter =\u003e Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs\n        {\n            DatacenterId = datacenter.Id,\n            Name = \"esxi1\",\n        })));\n        var available = host.Apply(host =\u003e Output.Create(VSphere.GetVmfsDisks.InvokeAsync(new VSphere.GetVmfsDisksArgs\n        {\n            Filter = \"mpx.vmhba1:C0:T[12]:L0\",\n            HostSystemId = host.Id,\n            Rescan = true,\n        })));\n    }\n\n}\n```\n\n{{% /example %}}\n{{% /examples %}}\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVmfsDisks.\n",
                "properties": {
                    "filter": {
                        "type": "string",
                        "description": "A regular expression to filter the disks against. Only\ndisks with canonical names that match will be included.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to look for disks on.\n"
                    },
                    "rescan": {
                        "type": "boolean",
                        "description": "Whether or not to rescan storage adapters before\nsearching for disks. This may lengthen the time it takes to perform the\nsearch. Default: `false`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostSystemId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVmfsDisks.\n",
                "properties": {
                    "disks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A lexicographically sorted list of devices discovered by the\noperation, matching the supplied `filter`, if provided.\n"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "hostSystemId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "rescan": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "disks",
                    "hostSystemId",
                    "id"
                ]
            }
        }
    },
    "language": {
        "csharp": {
            "namespaces": {
                "vsphere": "VSphere"
            },
            "packageReferences": {
                "Pulumi": "2.*",
                "System.Collections.Immutable": "1.6.0"
            }
        },
        "nodejs": {
            "dependencies": {
                "@pulumi/pulumi": "^2.0.0",
                "builtin-modules": "3.0.0",
                "read-package-tree": "^5.2.1",
                "resolve": "^1.8.1"
            },
            "devDependencies": {
                "@types/node": "^10.9.2"
            },
            "packageDescription": "A Pulumi package for creating vsphere resources",
            "packageName": "",
            "typescriptVersion": ""
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=2.0.0,\u003c3.0.0"
            }
        }
    }
}