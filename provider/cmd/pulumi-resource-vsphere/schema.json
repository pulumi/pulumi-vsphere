{
    "name": "vsphere",
    "description": "A Pulumi package for creating vsphere resources",
    "keywords": [
        "pulumi",
        "vsphere"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`vsphere` Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere).",
    "repository": "https://github.com/pulumi/pulumi-vsphere",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "vsphere": "VSphere"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating vsphere resources",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vsphere` repo](https://github.com/pulumi/pulumi-vsphere/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vsphere` repo](https://github.com/hashicorp/terraform-provider-vsphere/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0",
                "builtin-modules": "3.0.0",
                "read-package-tree": "^5.2.1",
                "resolve": "^1.8.1"
            },
            "devDependencies": {
                "@types/node": "^10.9.2"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-vsphere)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-vsphere` repo](https://github.com/pulumi/pulumi-vsphere/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-vsphere` repo](https://github.com/hashicorp/terraform-provider-vsphere/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "defaults": [
            "password",
            "user"
        ]
    },
    "types": {
        "vsphere:index/ComputeClusterHostImage:ComputeClusterHostImage": {
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterHostImageComponent:ComputeClusterHostImageComponent"
                    },
                    "description": "List of custom components.\n"
                },
                "esxVersion": {
                    "type": "string",
                    "description": "The ESXi version which the image is based on.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/ComputeClusterHostImageComponent:ComputeClusterHostImageComponent": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The identifier for the component.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version to use.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup": {
            "properties": {
                "cache": {
                    "type": "string",
                    "description": "Cache disk.\n"
                },
                "storages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of storage disks.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/ComputeClusterVsanFaultDomain:ComputeClusterVsanFaultDomain": {
            "properties": {
                "faultDomains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanFaultDomainFaultDomain:ComputeClusterVsanFaultDomainFaultDomain"
                    },
                    "description": "The configuration for single fault domain.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/ComputeClusterVsanFaultDomainFaultDomain:ComputeClusterVsanFaultDomainFaultDomain": {
            "properties": {
                "hostIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the fault domain.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "hostIds",
                "name"
            ]
        },
        "vsphere:index/ComputeClusterVsanStretchedCluster:ComputeClusterVsanStretchedCluster": {
            "properties": {
                "preferredFaultDomainHostIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the first fault domain.\n"
                },
                "preferredFaultDomainName": {
                    "type": "string",
                    "description": "The name of prepferred fault domain.\n"
                },
                "secondaryFaultDomainHostIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the second fault domain.\n"
                },
                "secondaryFaultDomainName": {
                    "type": "string",
                    "description": "The name of secondary fault domain.\n"
                },
                "witnessNode": {
                    "type": "string",
                    "description": "The managed object IDs of the host selected as witness node when enable stretched cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "preferredFaultDomainHostIds",
                "secondaryFaultDomainHostIds",
                "witnessNode"
            ]
        },
        "vsphere:index/ContentLibraryPublication:ContentLibraryPublication": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "Method to authenticate users. Must be `NONE` or `BASIC`.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "Password used by subscribers to authenticate.\n",
                    "willReplaceOnChanges": true
                },
                "publishUrl": {
                    "type": "string",
                    "description": "The URL of the published content library.\n",
                    "willReplaceOnChanges": true
                },
                "published": {
                    "type": "boolean",
                    "description": "Publish the content library. Default `false`.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Username used by subscribers to authenticate. Currently can only be `vcsp`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "password",
                        "publishUrl",
                        "username"
                    ]
                }
            }
        },
        "vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription": {
            "properties": {
                "authenticationMethod": {
                    "type": "string",
                    "description": "Authentication method to connect ro a published content library. Must be `NONE` or `BASIC`.\n",
                    "willReplaceOnChanges": true
                },
                "automaticSync": {
                    "type": "boolean",
                    "description": "Enable automatic synchronization with the published library. Default `false`.\n",
                    "willReplaceOnChanges": true
                },
                "onDemand": {
                    "type": "boolean",
                    "description": "Download the library from a content only when needed. Default `true`.\n",
                    "willReplaceOnChanges": true
                },
                "password": {
                    "type": "string",
                    "description": "Password used for authentication.\n",
                    "willReplaceOnChanges": true
                },
                "subscriptionUrl": {
                    "type": "string",
                    "description": "URL of the published content library.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Username used for authentication.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "password",
                        "username"
                    ]
                }
            }
        },
        "vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer",
                    "description": "The minimum VLAN to use in the range.\n"
                },
                "minVlan": {
                    "type": "integer",
                    "description": "The minimum VLAN to use in the range.\n"
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost": {
            "properties": {
                "devices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name of the physical NIC to be added to the proxy switch.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host this specification applies to.\n"
                }
            },
            "type": "object",
            "required": [
                "hostSystemId"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping": {
            "properties": {
                "primaryVlanId": {
                    "type": "integer",
                    "description": "The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n"
                },
                "pvlanType": {
                    "type": "string",
                    "description": "The private VLAN type. Valid values are promiscuous, community and isolated.\n"
                },
                "secondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.\n"
                }
            },
            "type": "object",
            "required": [
                "primaryVlanId",
                "pvlanType",
                "secondaryVlanId"
            ]
        },
        "vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange": {
            "properties": {
                "maxVlan": {
                    "type": "integer",
                    "description": "The minimum VLAN to use in the range.\n"
                },
                "minVlan": {
                    "type": "integer",
                    "description": "The minimum VLAN to use in the range.\n"
                }
            },
            "type": "object",
            "required": [
                "maxVlan",
                "minVlan"
            ]
        },
        "vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission": {
            "properties": {
                "isGroup": {
                    "type": "boolean",
                    "description": "Whether `user_or_group` field refers to a user or a\ngroup. True for a group and false for a user.\n"
                },
                "propagate": {
                    "type": "boolean",
                    "description": "Whether or not this permission propagates down the\nhierarchy to sub-entities.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The role id of the role to be given to the user on\nthe specified entity.\n"
                },
                "userOrGroup": {
                    "type": "string",
                    "description": "The user/group getting the permission.\n"
                }
            },
            "type": "object",
            "required": [
                "isGroup",
                "propagate",
                "roleId",
                "userOrGroup"
            ]
        },
        "vsphere:index/GuestOsCustomizationSpec:GuestOsCustomizationSpec": {
            "properties": {
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of DNS servers for a virtual network adapter with a static IP address.\n"
                },
                "dnsSuffixLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS search domains to add to the DNS configuration on the virtual machine.\n"
                },
                "ipv4Gateway": {
                    "type": "string",
                    "description": "The IPv4 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.\n"
                },
                "ipv6Gateway": {
                    "type": "string",
                    "description": "The IPv6 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.\n"
                },
                "linuxOptions": {
                    "$ref": "#/types/vsphere:index/GuestOsCustomizationSpecLinuxOptions:GuestOsCustomizationSpecLinuxOptions",
                    "description": "A list of configuration options specific to Linux virtual machines.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/GuestOsCustomizationSpecNetworkInterface:GuestOsCustomizationSpecNetworkInterface"
                    },
                    "description": "A specification of network interface configuration options.\n"
                },
                "windowsOptions": {
                    "$ref": "#/types/vsphere:index/GuestOsCustomizationSpecWindowsOptions:GuestOsCustomizationSpecWindowsOptions",
                    "description": "A list of configuration options specific to Windows virtual machines.\n"
                },
                "windowsSysprepText": {
                    "type": "string",
                    "description": "Use this option to specify a windows sysprep file directly.\n",
                    "secret": true
                }
            },
            "type": "object"
        },
        "vsphere:index/GuestOsCustomizationSpecLinuxOptions:GuestOsCustomizationSpecLinuxOptions": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "The domain name for this virtual machine.\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "The hostname for this virtual machine.\n"
                },
                "hwClockUtc": {
                    "type": "boolean",
                    "description": "Specifies whether or not the hardware clock should be in UTC or not.\n"
                },
                "scriptText": {
                    "type": "string",
                    "description": "The customization script to run before and or after guest customization\n",
                    "secret": true
                },
                "timeZone": {
                    "type": "string",
                    "description": "Customize the time zone on the VM. This should be a time zone-style entry, like America/Los_Angeles.\n"
                }
            },
            "type": "object",
            "required": [
                "domain",
                "hostName"
            ]
        },
        "vsphere:index/GuestOsCustomizationSpecNetworkInterface:GuestOsCustomizationSpecNetworkInterface": {
            "properties": {
                "dnsDomain": {
                    "type": "string",
                    "description": "A DNS search domain to add to the DNS configuration on the virtual machine.\n"
                },
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Network-interface specific DNS settings for Windows operating systems. Ignored on Linux.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "The IPv4 address assigned to this network adapter. If left blank, DHCP is used.\n"
                },
                "ipv4Netmask": {
                    "type": "integer",
                    "description": "The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is selected.\n"
                },
                "ipv6Address": {
                    "type": "string",
                    "description": "The IPv6 address assigned to this network adapter. If left blank, default auto-configuration is used.\n"
                },
                "ipv6Netmask": {
                    "type": "integer",
                    "description": "The IPv6 CIDR netmask for the supplied IP address. Ignored if auto-configuration is selected.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/GuestOsCustomizationSpecWindowsOptions:GuestOsCustomizationSpecWindowsOptions": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "The new administrator password for this virtual machine.\n",
                    "secret": true
                },
                "autoLogon": {
                    "type": "boolean",
                    "description": "Specifies whether or not the VM automatically logs on as Administrator.\n"
                },
                "autoLogonCount": {
                    "type": "integer",
                    "description": "Specifies how many times the VM should auto-logon the Administrator account when auto_logon is true.\n"
                },
                "computerName": {
                    "type": "string",
                    "description": "The host name for this virtual machine.\n"
                },
                "domainAdminPassword": {
                    "type": "string",
                    "description": "The password of the domain administrator used to join this virtual machine to the domain.\n",
                    "secret": true
                },
                "domainAdminUser": {
                    "type": "string",
                    "description": "The user account of the domain administrator used to join this virtual machine to the domain.\n"
                },
                "domainOu": {
                    "type": "string",
                    "description": "The MachineObjectOU which specifies the full LDAP path name of the OU to which the virtual machine belongs.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the user of this virtual machine.\n"
                },
                "joinDomain": {
                    "type": "string",
                    "description": "The domain that the virtual machine should join.\n"
                },
                "organizationName": {
                    "type": "string",
                    "description": "The organization name this virtual machine is being installed for.\n"
                },
                "productKey": {
                    "type": "string",
                    "description": "The product key for this virtual machine.\n",
                    "secret": true
                },
                "runOnceCommandLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of commands to run at first user logon, after guest customization.\n"
                },
                "timeZone": {
                    "type": "integer",
                    "description": "The new time zone for the virtual machine. This is a sysprep-dictated timezone code.\n"
                },
                "workgroup": {
                    "type": "string",
                    "description": "The workgroup for this virtual machine if not joining a domain.\n"
                }
            },
            "type": "object",
            "required": [
                "computerName"
            ]
        },
        "vsphere:index/HostPortGroupPort:HostPortGroupPort": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n"
                },
                "macAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The MAC addresses of the network service of the virtual machine connected on this port.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type type of the entity connected on this port. Possible values are host (VMKkernel), systemManagement (service console), virtualMachine, or unknown.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "macAddresses",
                        "type"
                    ]
                }
            }
        },
        "vsphere:index/HostService:HostService": {
            "properties": {
                "ntpd": {
                    "$ref": "#/types/vsphere:index/HostServiceNtpd:HostServiceNtpd",
                    "description": "service has three settings, `enabled` sets service to running or not running, `policy` sets service based on setting of `on` which sets service to \"Start and stop with host\", `off` which sets service to \"Start and stop manually\", `automatic` which sets service to \"Start and stop with port usage\".\n\n\u003e **NOTE:** `services` only supports ntpd service today.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/HostServiceNtpd:HostServiceNtpd": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Whether the NTP service is enabled. Default is false.\n"
                },
                "ntpServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "policy": {
                    "type": "string",
                    "description": "The policy for the NTP service. Valid values are 'Start and stop with host', 'Start and stop manually', 'Start and stop with port usage'.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ntpServers"
                    ]
                }
            }
        },
        "vsphere:index/OfflineSoftwareDepotComponent:OfflineSoftwareDepotComponent": {
            "properties": {
                "displayName": {
                    "type": "string",
                    "description": "The name of the component. Useful for easier identification.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The identifier of the component.\n"
                },
                "versions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of available versions of the component.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "displayName",
                        "key",
                        "versions"
                    ]
                }
            }
        },
        "vsphere:index/SupervisorEgressCidr:SupervisorEgressCidr": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Network address.\n"
                },
                "prefix": {
                    "type": "integer",
                    "description": "Subnet prefix.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "prefix"
            ]
        },
        "vsphere:index/SupervisorIngressCidr:SupervisorIngressCidr": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Network address.\n"
                },
                "prefix": {
                    "type": "integer",
                    "description": "Subnet prefix.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "prefix"
            ]
        },
        "vsphere:index/SupervisorManagementNetwork:SupervisorManagementNetwork": {
            "properties": {
                "addressCount": {
                    "type": "integer",
                    "description": "Number of addresses to allocate. Starts from 'starting_address'\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Gateway IP address.\n"
                },
                "network": {
                    "type": "string",
                    "description": "ID of the network. (e.g. a distributed port group).\n"
                },
                "startingAddress": {
                    "type": "string",
                    "description": "Starting address of the management network range.\n"
                },
                "subnetMask": {
                    "type": "string",
                    "description": "Subnet mask.\n"
                }
            },
            "type": "object",
            "required": [
                "addressCount",
                "gateway",
                "network",
                "startingAddress",
                "subnetMask"
            ]
        },
        "vsphere:index/SupervisorNamespace:SupervisorNamespace": {
            "properties": {
                "contentLibraries": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of content libraries.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the namespace.\n"
                },
                "vmClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of virtual machine classes.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "vsphere:index/SupervisorPodCidr:SupervisorPodCidr": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Network address.\n"
                },
                "prefix": {
                    "type": "integer",
                    "description": "Subnet prefix.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "prefix"
            ]
        },
        "vsphere:index/SupervisorServiceCidr:SupervisorServiceCidr": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "Network address.\n"
                },
                "prefix": {
                    "type": "integer",
                    "description": "Subnet prefix.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "prefix"
            ]
        },
        "vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom": {
            "properties": {
                "clientDevice": {
                    "type": "boolean",
                    "description": "Indicates whether the device should be mapped to a remote client device\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID the ISO is located on.\n"
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.\n"
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path to the ISO file on the datastore.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "deviceAddress",
                        "key"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineClone:VirtualMachineClone": {
            "properties": {
                "customizationSpec": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizationSpec:VirtualMachineCloneCustomizationSpec",
                    "description": "The customization specification for the virtual machine post-clone.\n"
                },
                "customize": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize",
                    "description": "The customization specification for the virtual machine post-clone.\n"
                },
                "linkedClone": {
                    "type": "boolean",
                    "description": "Whether or not to create a linked clone when cloning. When this option is used, the source VM must have a single snapshot associated with it.\n"
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Mapping of ovf networks to the networks to use in vSphere.\n"
                },
                "ovfStorageMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Mapping of ovf storage to the datastores to use in vSphere.\n"
                },
                "templateUuid": {
                    "type": "string",
                    "description": "The UUID of the source virtual machine or template.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The timeout, in minutes, to wait for the virtual machine clone to complete.\n"
                }
            },
            "type": "object",
            "required": [
                "templateUuid"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomizationSpec:VirtualMachineCloneCustomizationSpec": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The UUID of the virtual machine.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for guest OS customization to complete before returning with an error. Setting this value to 0 or a negative value skips the waiter. Default: 10.\n"
                }
            },
            "type": "object",
            "required": [
                "id"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomize:VirtualMachineCloneCustomize": {
            "properties": {
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of DNS servers for a virtual network adapter with a static IP address.\n"
                },
                "dnsSuffixLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS search domains to add to the DNS configuration on the virtual machine.\n"
                },
                "ipv4Gateway": {
                    "type": "string",
                    "description": "The IPv4 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.\n"
                },
                "ipv6Gateway": {
                    "type": "string",
                    "description": "The IPv6 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.\n"
                },
                "linuxOptions": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions",
                    "description": "A list of configuration options specific to Linux virtual machines.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface"
                    },
                    "description": "A specification of network interface configuration options.\n"
                },
                "timeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for guest OS customization to complete before returning with an error. Setting this value to 0 or a negative value skips the waiter. Default: 10.\n"
                },
                "windowsOptions": {
                    "$ref": "#/types/vsphere:index/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions",
                    "description": "A list of configuration options specific to Windows virtual machines.\n"
                },
                "windowsSysprepText": {
                    "type": "string",
                    "description": "Use this option to specify a windows sysprep file directly.\n",
                    "secret": true
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineCloneCustomizeLinuxOptions:VirtualMachineCloneCustomizeLinuxOptions": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "The domain name for this virtual machine.\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "The hostname for this virtual machine.\n"
                },
                "hwClockUtc": {
                    "type": "boolean",
                    "description": "Specifies whether or not the hardware clock should be in UTC or not.\n"
                },
                "scriptText": {
                    "type": "string",
                    "description": "The customization script to run before and or after guest customization\n",
                    "secret": true
                },
                "timeZone": {
                    "type": "string",
                    "description": "Customize the time zone on the VM. This should be a time zone-style entry, like America/Los_Angeles.\n"
                }
            },
            "type": "object",
            "required": [
                "domain",
                "hostName"
            ]
        },
        "vsphere:index/VirtualMachineCloneCustomizeNetworkInterface:VirtualMachineCloneCustomizeNetworkInterface": {
            "properties": {
                "dnsDomain": {
                    "type": "string",
                    "description": "A DNS search domain to add to the DNS configuration on the virtual machine.\n"
                },
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Network-interface specific DNS settings for Windows operating systems. Ignored on Linux.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "The IPv4 address assigned to this network adapter. If left blank, DHCP is used.\n"
                },
                "ipv4Netmask": {
                    "type": "integer",
                    "description": "The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is selected.\n"
                },
                "ipv6Address": {
                    "type": "string",
                    "description": "The IPv6 address assigned to this network adapter. If left blank, default auto-configuration is used.\n"
                },
                "ipv6Netmask": {
                    "type": "integer",
                    "description": "The IPv6 CIDR netmask for the supplied IP address. Ignored if auto-configuration is selected.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineCloneCustomizeWindowsOptions:VirtualMachineCloneCustomizeWindowsOptions": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "The new administrator password for this virtual machine.\n",
                    "secret": true
                },
                "autoLogon": {
                    "type": "boolean",
                    "description": "Specifies whether or not the VM automatically logs on as Administrator.\n"
                },
                "autoLogonCount": {
                    "type": "integer",
                    "description": "Specifies how many times the VM should auto-logon the Administrator account when auto_logon is true.\n"
                },
                "computerName": {
                    "type": "string",
                    "description": "The host name for this virtual machine.\n"
                },
                "domainAdminPassword": {
                    "type": "string",
                    "description": "The password of the domain administrator used to join this virtual machine to the domain.\n",
                    "secret": true
                },
                "domainAdminUser": {
                    "type": "string",
                    "description": "The user account of the domain administrator used to join this virtual machine to the domain.\n"
                },
                "domainOu": {
                    "type": "string",
                    "description": "The MachineObjectOU which specifies the full LDAP path name of the OU to which the virtual machine belongs.\n"
                },
                "fullName": {
                    "type": "string",
                    "description": "The full name of the user of this virtual machine.\n"
                },
                "joinDomain": {
                    "type": "string",
                    "description": "The domain that the virtual machine should join.\n"
                },
                "organizationName": {
                    "type": "string",
                    "description": "The organization name this virtual machine is being installed for.\n"
                },
                "productKey": {
                    "type": "string",
                    "description": "The product key for this virtual machine.\n",
                    "secret": true
                },
                "runOnceCommandLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of commands to run at first user logon, after guest customization.\n"
                },
                "timeZone": {
                    "type": "integer",
                    "description": "The new time zone for the virtual machine. This is a sysprep-dictated timezone code.\n"
                },
                "workgroup": {
                    "type": "string",
                    "description": "The workgroup for this virtual machine if not joining a domain.\n"
                }
            },
            "type": "object",
            "required": [
                "computerName"
            ]
        },
        "vsphere:index/VirtualMachineDisk:VirtualMachineDisk": {
            "properties": {
                "attach": {
                    "type": "boolean",
                    "description": "If this is true, the disk is attached instead of created. Implies keep_on_remove.\n"
                },
                "controllerType": {
                    "type": "string",
                    "description": "The type of controller the disk should be connected to. Must be 'scsi', 'sata', or 'ide'.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The datastore ID for this virtual disk, if different than the virtual machine.\n"
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.\n"
                },
                "diskMode": {
                    "type": "string",
                    "description": "The mode of this this virtual disk for purposes of writes and snapshotting. Can be one of append, independent_nonpersistent, independent_persistent, nonpersistent, persistent, or undoable.\n"
                },
                "diskSharing": {
                    "type": "string",
                    "description": "The sharing mode of this virtual disk. Can be one of sharingMultiWriter or sharingNone.\n"
                },
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "The virtual disk file zeroing policy when thin_provision is not true. The default is false, which lazily-zeros the disk, speeding up thick-provisioned disk creation time.\n"
                },
                "ioLimit": {
                    "type": "integer",
                    "description": "The upper limit of IOPS that this disk can use.\n"
                },
                "ioReservation": {
                    "type": "integer",
                    "description": "The I/O guarantee that this disk has, in IOPS.\n"
                },
                "ioShareCount": {
                    "type": "integer",
                    "description": "The share count for this disk when the share level is custom.\n"
                },
                "ioShareLevel": {
                    "type": "string",
                    "description": "The share allocation level for this disk. Can be one of low, normal, high, or custom.\n"
                },
                "keepOnRemove": {
                    "type": "boolean",
                    "description": "Set to true to keep the underlying VMDK file when removing this virtual disk from configuration.\n"
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n"
                },
                "label": {
                    "type": "string",
                    "description": "A unique label for this disk.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The full path of the virtual disk. This can only be provided if attach is set to true, otherwise it is a read-only value.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GB.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The ID of the storage policy to assign to the virtual disk in VM.\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "If true, this disk is thin provisioned, with space for the file being allocated on an as-needed basis.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The unique device number for this disk. This number determines where on the SCSI bus this device will be attached.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual machine. Also exposed as the `id` of the resource.\n"
                },
                "writeThrough": {
                    "type": "boolean",
                    "description": "If true, writes for this disk are sent directly to the filesystem immediately instead of being buffered.\n"
                }
            },
            "type": "object",
            "required": [
                "label"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "datastoreId",
                        "deviceAddress",
                        "key",
                        "label",
                        "path",
                        "storagePolicyId",
                        "uuid"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The controller type. Can be one of e1000, e1000e, sriov, vmxnet3, or vrdma.\n"
                },
                "bandwidthLimit": {
                    "type": "integer",
                    "description": "The upper bandwidth limit of this network interface, in Mbits/sec.\n"
                },
                "bandwidthReservation": {
                    "type": "integer",
                    "description": "The bandwidth reservation of this network interface, in Mbits/sec.\n"
                },
                "bandwidthShareCount": {
                    "type": "integer",
                    "description": "The share count for this network interface when the share level is custom.\n"
                },
                "bandwidthShareLevel": {
                    "type": "string",
                    "description": "The bandwidth share allocation level for this interface. Can be one of low, normal, high, or custom.\n"
                },
                "deviceAddress": {
                    "type": "string",
                    "description": "The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.\n"
                },
                "key": {
                    "type": "integer",
                    "description": "The ID of the device within the virtual machine.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of this network interface. Can only be manually set if use_static_mac is true.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The ID of the network to connect this network interface to.\n"
                },
                "ovfMapping": {
                    "type": "string",
                    "description": "Mapping of network interface to OVF network.\n",
                    "willReplaceOnChanges": true
                },
                "physicalFunction": {
                    "type": "string",
                    "description": "The ID of the Physical SR-IOV NIC to attach to, e.g. '0000:d8:00.0'\n"
                },
                "useStaticMac": {
                    "type": "boolean",
                    "description": "If true, the mac_address field is treated as a static MAC address and set accordingly.\n"
                }
            },
            "type": "object",
            "required": [
                "networkId"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "bandwidthShareCount",
                        "deviceAddress",
                        "key",
                        "macAddress",
                        "networkId"
                    ]
                }
            }
        },
        "vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy": {
            "properties": {
                "allowUnverifiedSslCert": {
                    "type": "boolean",
                    "description": "Allow unverified ssl certificates while deploying ovf/ova from url.\n"
                },
                "deploymentOption": {
                    "type": "string",
                    "description": "The Deployment option to be chosen. If empty, the default option is used.\n",
                    "willReplaceOnChanges": true
                },
                "diskProvisioning": {
                    "type": "string",
                    "description": "An optional disk provisioning. If set, all the disks in the deployed ovf will have the same specified disk type (e.g., thin provisioned).\n",
                    "willReplaceOnChanges": true
                },
                "enableHiddenProperties": {
                    "type": "boolean",
                    "description": "Allow properties with ovf:userConfigurable=false to be set.\n",
                    "willReplaceOnChanges": true
                },
                "ipAllocationPolicy": {
                    "type": "string",
                    "description": "The IP allocation policy.\n",
                    "willReplaceOnChanges": true
                },
                "ipProtocol": {
                    "type": "string",
                    "description": "The IP protocol.\n",
                    "willReplaceOnChanges": true
                },
                "localOvfPath": {
                    "type": "string",
                    "description": "The absolute path to the ovf/ova file in the local system.\n",
                    "willReplaceOnChanges": true
                },
                "ovfNetworkMap": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The mapping of name of network identifiers from the ovf descriptor to network UUID in the VI infrastructure.\n",
                    "willReplaceOnChanges": true
                },
                "remoteOvfUrl": {
                    "type": "string",
                    "description": "URL to the remote ovf/ova file to be deployed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "vsphere:index/VirtualMachineVapp:VirtualMachineVapp": {
            "properties": {
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of customizable vApp properties and their values. Allows customization of VMs cloned from OVF templates which have customizable vApp properties.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule": {
            "properties": {
                "includeDatastoresWithTags": {
                    "type": "boolean",
                    "description": "Include datastores with the given tags or exclude. Default `true`.\n"
                },
                "tagCategory": {
                    "type": "string",
                    "description": "Name of the tag category.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Name of tags to select from the given category.\n"
                }
            },
            "type": "object",
            "required": [
                "tagCategory",
                "tags"
            ]
        },
        "vsphere:index/VnicIpv4:VnicIpv4": {
            "properties": {
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n"
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP is not set.\n"
                },
                "ip": {
                    "type": "string",
                    "description": "address of the interface, if DHCP is not set.\n"
                },
                "netmask": {
                    "type": "string",
                    "description": "netmask of the interface, if DHCP is not set.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/VnicIpv6:VnicIpv6": {
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IPv6 addresses\n"
                },
                "autoconfig": {
                    "type": "boolean",
                    "description": "Use IPv6 Autoconfiguration (RFC2462).\n"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "Use DHCP to configure the interface's IPv4 stack.\n"
                },
                "gw": {
                    "type": "string",
                    "description": "IP address of the default gateway, if DHCP or autoconfig is not set.\n"
                }
            },
            "type": "object"
        },
        "vsphere:index/getGuestOsCustomizationSpec:getGuestOsCustomizationSpec": {
            "properties": {
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS servers for a virtual network adapter with a static IP address.\n"
                },
                "dnsSuffixLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of DNS search domains to add to the DNS configuration on the virtual machine.\n"
                },
                "linuxOptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/getGuestOsCustomizationSpecLinuxOption:getGuestOsCustomizationSpecLinuxOption"
                    },
                    "description": "A list of configuration options specific to Linux.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/getGuestOsCustomizationSpecNetworkInterface:getGuestOsCustomizationSpecNetworkInterface"
                    },
                    "description": "A specification of network interface configuration options.\n"
                },
                "windowsOptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/getGuestOsCustomizationSpecWindowsOption:getGuestOsCustomizationSpecWindowsOption"
                    },
                    "description": "A list of configuration options specific to Windows.\n"
                },
                "windowsSysprepText": {
                    "type": "string",
                    "description": "Use this option to specify use of a Windows Sysprep file.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "dnsServerLists",
                "dnsSuffixLists",
                "linuxOptions",
                "networkInterfaces",
                "windowsOptions",
                "windowsSysprepText"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getGuestOsCustomizationSpecLinuxOption:getGuestOsCustomizationSpecLinuxOption": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "The domain name for this virtual machine.\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "The hostname for this virtual machine.\n"
                },
                "hwClockUtc": {
                    "type": "boolean",
                    "description": "Specifies whether or not the hardware clock should be in UTC or not.\n"
                },
                "scriptText": {
                    "type": "string",
                    "description": "The customization script to run before and or after guest customization.\n",
                    "secret": true
                },
                "timeZone": {
                    "type": "string",
                    "description": "Set the time zone on the guest operating system. For a list of the acceptable values for Linux customization specifications, see [List of Time Zone Database Zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) on Wikipedia.\n"
                }
            },
            "type": "object",
            "required": [
                "domain",
                "hostName",
                "hwClockUtc",
                "scriptText",
                "timeZone"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getGuestOsCustomizationSpecNetworkInterface:getGuestOsCustomizationSpecNetworkInterface": {
            "properties": {
                "dnsDomain": {
                    "type": "string",
                    "description": "A DNS search domain to add to the DNS configuration on the virtual machine.\n"
                },
                "dnsServerLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Network-interface specific DNS settings for Windows operating systems. Ignored on Linux.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "The IPv4 address assigned to this network adapter. If left blank, DHCP is used.\n"
                },
                "ipv4Netmask": {
                    "type": "integer",
                    "description": "The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is selected.\n"
                },
                "ipv6Address": {
                    "type": "string",
                    "description": "The IPv6 address assigned to this network adapter. If left blank, default auto-configuration is used.\n"
                },
                "ipv6Netmask": {
                    "type": "integer",
                    "description": "The IPv6 CIDR netmask for the supplied IP address. Ignored if auto-configuration is selected.\n"
                }
            },
            "type": "object",
            "required": [
                "dnsDomain",
                "dnsServerLists",
                "ipv4Address",
                "ipv4Netmask",
                "ipv6Address",
                "ipv6Netmask"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getGuestOsCustomizationSpecWindowsOption:getGuestOsCustomizationSpecWindowsOption": {
            "properties": {
                "adminPassword": {
                    "type": "string",
                    "description": "The new administrator password for this virtual machine.\n",
                    "secret": true
                },
                "autoLogon": {
                    "type": "boolean",
                    "description": "Specifies whether or not the guest operating system automatically logs on as Administrator.\n"
                },
                "autoLogonCount": {
                    "type": "integer",
                    "description": "Specifies how many times the guest operating system should auto-logon the Administrator account when `auto_logon` is `true`.\n"
                },
                "computerName": {
                    "type": "string",
                    "description": "The hostname for this virtual machine.\n"
                },
                "domainAdminPassword": {
                    "type": "string",
                    "description": "The user account used to join this virtual machine to the Active Directory domain.\n",
                    "secret": true
                },
                "domainAdminUser": {
                    "type": "string",
                    "description": "The user account of the domain administrator used to join this virtual machine to the domain.\n"
                },
                "domainOu": {
                    "type": "string",
                    "description": "The MachineObjectOU which specifies the full LDAP path name of the OU to which the virtual machine belongs.\n"
                },
                "joinDomain": {
                    "type": "string",
                    "description": "The Active Directory domain for the virtual machine to join.\n"
                },
                "runOnceCommandLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of commands to run at first user logon, after guest customization.\n"
                },
                "timeZone": {
                    "type": "integer",
                    "description": "The new time zone for the virtual machine. This is a sysprep-dictated timezone code.\n"
                },
                "workgroup": {
                    "type": "string",
                    "description": "The workgroup for this virtual machine if not joining an Active Directory domain.\n"
                }
            },
            "type": "object",
            "required": [
                "adminPassword",
                "autoLogon",
                "autoLogonCount",
                "computerName",
                "domainAdminUser",
                "domainOu",
                "joinDomain",
                "runOnceCommandLists",
                "timeZone",
                "workgroup"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getHostVgpuProfileVgpuProfile:getHostVgpuProfileVgpuProfile": {
            "properties": {
                "diskSnapshotSupported": {
                    "type": "boolean",
                    "description": "Indicates whether the GPU plugin on this host is\ncapable of disk-only snapshots when VM is not powered off.\n"
                },
                "memorySnapshotSupported": {
                    "type": "boolean",
                    "description": "Indicates whether the GPU plugin on this host\nis capable of memory snapshots.\n"
                },
                "migrateSupported": {
                    "type": "boolean",
                    "description": "Indicates whether the GPU plugin on this host is\ncapable of migration.\n"
                },
                "suspendSupported": {
                    "type": "boolean",
                    "description": "Indicates whether the GPU plugin on this host is\ncapable of suspend-resume.\n"
                },
                "vgpu": {
                    "type": "string",
                    "description": "Name of a particular vGPU available as a shared GPU device (vGPU\nprofile).\n"
                }
            },
            "type": "object",
            "required": [
                "diskSnapshotSupported",
                "memorySnapshotSupported",
                "migrateSupported",
                "suspendSupported",
                "vgpu"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getVirtualMachineDisk:getVirtualMachineDisk": {
            "properties": {
                "eagerlyScrub": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been eager zeroed.\n"
                },
                "label": {
                    "type": "string",
                    "description": "The label for the disk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the disk, in GIB.\n"
                },
                "thinProvisioned": {
                    "type": "boolean",
                    "description": "Set to `true` if the disk has been thin provisioned.\n"
                },
                "unitNumber": {
                    "type": "integer",
                    "description": "The disk number on the storage bus.\n"
                }
            },
            "type": "object",
            "required": [
                "eagerlyScrub",
                "label",
                "size",
                "thinProvisioned",
                "unitNumber"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getVirtualMachineNetworkInterface:getVirtualMachineNetworkInterface": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The network interface types for each network interface found\non the virtual machine, in device bus order. Will be one of `e1000`,\n`e1000e`, `vmxnet3vrdma`, or `vmxnet3`.\n"
                },
                "bandwidthLimit": {
                    "type": "integer",
                    "description": "The upper bandwidth limit of this network interface,\nin Mbits/sec.\n"
                },
                "bandwidthReservation": {
                    "type": "integer",
                    "description": "The bandwidth reservation of this network\ninterface, in Mbits/sec.\n"
                },
                "bandwidthShareCount": {
                    "type": "integer",
                    "description": "The share count for this network interface when the\nshare level is custom.\n"
                },
                "bandwidthShareLevel": {
                    "type": "string",
                    "description": "The bandwidth share allocation level for this\ninterface. Can be one of `low`, `normal`, `high`, or `custom`.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC address of this network interface.\n"
                },
                "networkId": {
                    "type": "string",
                    "description": "The managed object reference ID of the network this interface\nis connected to.\n"
                },
                "physicalFunction": {
                    "type": "string",
                    "description": "The ID of the Physical SR-IOV NIC to attach to, e.g. '0000:d8:00.0'\n"
                }
            },
            "type": "object",
            "required": [
                "adapterType",
                "bandwidthShareCount",
                "macAddress",
                "networkId",
                "physicalFunction"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp": {
            "properties": {
                "properties": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of customizable vApp properties and their values. Allows customization of VMs cloned from OVF templates which have customizable vApp properties.\n"
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the vsphere package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n"
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n"
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n"
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n"
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n"
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n"
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n"
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n"
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "required": [
            "password",
            "user"
        ],
        "inputProperties": {
            "allowUnverifiedSsl": {
                "type": "boolean",
                "description": "If set, VMware vSphere client will permit unverifiable SSL certificates.\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_ALLOW_UNVERIFIED_SSL"
                    ]
                }
            },
            "apiTimeout": {
                "type": "integer",
                "description": "API timeout in minutes (Default: 5)\n"
            },
            "clientDebug": {
                "type": "boolean",
                "description": "govmomi debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG"
                    ]
                }
            },
            "clientDebugPath": {
                "type": "string",
                "description": "govmomi debug path for debug\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH"
                    ]
                }
            },
            "clientDebugPathRun": {
                "type": "string",
                "description": "govmomi debug path for a single run\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_CLIENT_DEBUG_PATH_RUN"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "The user password for vSphere API operations.\n"
            },
            "persistSession": {
                "type": "boolean",
                "description": "Persist vSphere client sessions to disk\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_PERSIST_SESSION"
                    ]
                }
            },
            "restSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere REST API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_REST_SESSION_PATH"
                    ]
                }
            },
            "user": {
                "type": "string",
                "description": "The user name for vSphere API operations.\n"
            },
            "vcenterServer": {
                "type": "string",
                "deprecationMessage": "This field has been renamed to vsphere_server."
            },
            "vimKeepAlive": {
                "type": "integer",
                "description": "Keep alive interval for the VIM session in minutes\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_KEEP_ALIVE"
                    ]
                }
            },
            "vimSessionPath": {
                "type": "string",
                "description": "The directory to save vSphere SOAP API sessions to\n",
                "defaultInfo": {
                    "environment": [
                        "VSPHERE_VIM_SESSION_PATH"
                    ]
                }
            },
            "vsphereServer": {
                "type": "string",
                "description": "The vSphere Server name for vSphere API operations.\n"
            }
        },
        "requiredInputs": [
            "password",
            "user"
        ]
    },
    "resources": {
        "vsphere:index/computeCluster:ComputeCluster": {
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power operations in this cluster. Can be one of manual or automated.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual\nmachines in the cluster. Requires that DRS be enabled.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This\naffects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher\nsetting.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or\nfullyAutomated.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "When true, allows individual VM overrides within this cluster to be set.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate\nmore imbalance while a higher setting will tolerate less.\n"
                },
                "drsScaleDescendantsShares": {
                    "type": "string",
                    "description": "Enable scalable shares for all descendants of this cluster.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists\nfor testing and is not recommended in normal use.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated\nfailover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS\nwill ignore the host when making recommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual\nmachine operations. The maximum is one less than the number of hosts in the cluster.\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces\nwarnings only, whereas a value of 100 disables the setting.\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are\npermitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,\nslotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service\nissues.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by\nsubtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting\nfrom the total amount of resources in the cluster. Disable to supply user-defined values.\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in\nthe cluster to reserve for failover.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in\nthe cluster to reserve for failover.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values\nto CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines\ncurrently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an\naffected datastore clears in the middle of an APD event. Can be one of none or reset.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or\nrestartAggressive.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute\nthe response action defined in ha_datastore_apd_response.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when\nha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or\nallFeasibleDsWithUserPreference.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.\nCan be one of none, powerOff, or shutdown.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to\nfailures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move\non to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as\nfailed. The value is in seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay in seconds after ready condition is met. A VM is considered ready at this point.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,\nhigh, or highest.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before\nproceeding with the next priority.\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout for each host maintenance mode operation when removing hosts from a cluster.\n"
                },
                "hostImage": {
                    "$ref": "#/types/vsphere:index/ComputeClusterHostImage:ComputeClusterHostImage",
                    "description": "Details about the host image which should be applied to the cluster.\n"
                },
                "hostManaged": {
                    "type": "boolean",
                    "description": "Must be set if cluster enrollment is managed from host resource.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that\nthis cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update providers configured for this cluster.\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this\ncannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID of the primary\nresource pool for this cluster. This can be passed directly to the\n`resource_pool_id`\nattribute of the\n`vsphere.VirtualMachine` resource.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "vsanCompressionEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN compression service is enabled for the cluster.\n"
                },
                "vsanDedupEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN deduplication service is enabled for the cluster.\n"
                },
                "vsanDiskGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                    },
                    "description": "A list of disk UUIDs to add to the vSAN cluster.\n"
                },
                "vsanDitEncryptionEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN data-in-transit encryption is enabled for the cluster.\n"
                },
                "vsanDitRekeyInterval": {
                    "type": "integer",
                    "description": "When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).\n"
                },
                "vsanEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN service is enabled for the cluster.\n"
                },
                "vsanEsaEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN ESA service is enabled for the cluster.\n"
                },
                "vsanFaultDomains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanFaultDomain:ComputeClusterVsanFaultDomain"
                    },
                    "description": "The configuration for vSAN fault domains.\n"
                },
                "vsanNetworkDiagnosticModeEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN network diagnostic mode is enabled for the cluster.\n"
                },
                "vsanPerformanceEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN performance service is enabled for the cluster.\n"
                },
                "vsanRemoteDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the vSAN datastore to be mounted on the cluster.\n"
                },
                "vsanStretchedCluster": {
                    "$ref": "#/types/vsphere:index/ComputeClusterVsanStretchedCluster:ComputeClusterVsanStretchedCluster",
                    "description": "The configuration for stretched cluster.\n"
                },
                "vsanUnmapEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN unmap service is enabled for the cluster.\n"
                },
                "vsanVerboseModeEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN verbose mode is enabled for the cluster.\n"
                }
            },
            "required": [
                "datacenterId",
                "name",
                "resourcePoolId",
                "vsanDiskGroups",
                "vsanDitRekeyInterval"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power operations in this cluster. Can be one of manual or automated.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual\nmachines in the cluster. Requires that DRS be enabled.\n"
                },
                "dpmThreshold": {
                    "type": "integer",
                    "description": "A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This\naffects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher\nsetting.\n"
                },
                "drsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for DRS and DPM.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or\nfullyAutomated.\n"
                },
                "drsEnablePredictiveDrs": {
                    "type": "boolean",
                    "description": "When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.\n"
                },
                "drsEnableVmOverrides": {
                    "type": "boolean",
                    "description": "When true, allows individual VM overrides within this cluster to be set.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Enable DRS for this cluster.\n"
                },
                "drsMigrationThreshold": {
                    "type": "integer",
                    "description": "A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate\nmore imbalance while a higher setting will tolerate less.\n"
                },
                "drsScaleDescendantsShares": {
                    "type": "string",
                    "description": "Enable scalable shares for all descendants of this cluster.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                },
                "forceEvacuateOnDestroy": {
                    "type": "boolean",
                    "description": "Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists\nfor testing and is not recommended in normal use.\n"
                },
                "haAdmissionControlFailoverHostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated\nfailover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS\nwill ignore the host when making recommendations.\n"
                },
                "haAdmissionControlHostFailureTolerance": {
                    "type": "integer",
                    "description": "The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual\nmachine operations. The maximum is one less than the number of hosts in the cluster.\n"
                },
                "haAdmissionControlPerformanceTolerance": {
                    "type": "integer",
                    "description": "The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces\nwarnings only, whereas a value of 100 disables the setting.\n"
                },
                "haAdmissionControlPolicy": {
                    "type": "string",
                    "description": "The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are\npermitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,\nslotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service\nissues.\n"
                },
                "haAdmissionControlResourcePercentageAutoCompute": {
                    "type": "boolean",
                    "description": "When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by\nsubtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting\nfrom the total amount of resources in the cluster. Disable to supply user-defined values.\n"
                },
                "haAdmissionControlResourcePercentageCpu": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in\nthe cluster to reserve for failover.\n"
                },
                "haAdmissionControlResourcePercentageMemory": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in\nthe cluster to reserve for failover.\n"
                },
                "haAdmissionControlSlotPolicyExplicitCpu": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.\n"
                },
                "haAdmissionControlSlotPolicyExplicitMemory": {
                    "type": "integer",
                    "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.\n"
                },
                "haAdmissionControlSlotPolicyUseExplicitSize": {
                    "type": "boolean",
                    "description": "When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values\nto CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines\ncurrently in the cluster.\n"
                },
                "haAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for vSphere HA.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an\naffected datastore clears in the middle of an APD event. Can be one of none or reset.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or\nrestartAggressive.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute\nthe response action defined in ha_datastore_apd_response.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.\n"
                },
                "haEnabled": {
                    "type": "boolean",
                    "description": "Enable vSphere HA for this cluster.\n"
                },
                "haHeartbeatDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when\nha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.\n"
                },
                "haHeartbeatDatastorePolicy": {
                    "type": "string",
                    "description": "The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or\nallFeasibleDsWithUserPreference.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.\nCan be one of none, powerOff, or shutdown.\n"
                },
                "haHostMonitoring": {
                    "type": "string",
                    "description": "Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.\n"
                },
                "haVmComponentProtection": {
                    "type": "string",
                    "description": "Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to\nfailures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.\n"
                },
                "haVmDependencyRestartCondition": {
                    "type": "string",
                    "description": "The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move\non to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as\nfailed. The value is in seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                },
                "haVmRestartAdditionalDelay": {
                    "type": "integer",
                    "description": "Additional delay in seconds after ready condition is met. A VM is considered ready at this point.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,\nhigh, or highest.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before\nproceeding with the next priority.\n"
                },
                "hostClusterExitTimeout": {
                    "type": "integer",
                    "description": "The timeout for each host maintenance mode operation when removing hosts from a cluster.\n"
                },
                "hostImage": {
                    "$ref": "#/types/vsphere:index/ComputeClusterHostImage:ComputeClusterHostImage",
                    "description": "Details about the host image which should be applied to the cluster.\n"
                },
                "hostManaged": {
                    "type": "boolean",
                    "description": "Must be set if cluster enrollment is managed from host resource.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the hosts to put in the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the cluster.\n"
                },
                "proactiveHaAutomationLevel": {
                    "type": "string",
                    "description": "The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.\n"
                },
                "proactiveHaEnabled": {
                    "type": "boolean",
                    "description": "Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.\n"
                },
                "proactiveHaModerateRemediation": {
                    "type": "string",
                    "description": "The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that\nthis cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.\n"
                },
                "proactiveHaProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of IDs for health update providers configured for this cluster.\n"
                },
                "proactiveHaSevereRemediation": {
                    "type": "string",
                    "description": "The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this\ncannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "vsanCompressionEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN compression service is enabled for the cluster.\n"
                },
                "vsanDedupEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN deduplication service is enabled for the cluster.\n"
                },
                "vsanDiskGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                    },
                    "description": "A list of disk UUIDs to add to the vSAN cluster.\n"
                },
                "vsanDitEncryptionEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN data-in-transit encryption is enabled for the cluster.\n"
                },
                "vsanDitRekeyInterval": {
                    "type": "integer",
                    "description": "When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).\n"
                },
                "vsanEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN service is enabled for the cluster.\n"
                },
                "vsanEsaEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN ESA service is enabled for the cluster.\n"
                },
                "vsanFaultDomains": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanFaultDomain:ComputeClusterVsanFaultDomain"
                    },
                    "description": "The configuration for vSAN fault domains.\n"
                },
                "vsanNetworkDiagnosticModeEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN network diagnostic mode is enabled for the cluster.\n"
                },
                "vsanPerformanceEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN performance service is enabled for the cluster.\n"
                },
                "vsanRemoteDatastoreIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of the vSAN datastore to be mounted on the cluster.\n"
                },
                "vsanStretchedCluster": {
                    "$ref": "#/types/vsphere:index/ComputeClusterVsanStretchedCluster:ComputeClusterVsanStretchedCluster",
                    "description": "The configuration for stretched cluster.\n"
                },
                "vsanUnmapEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN unmap service is enabled for the cluster.\n"
                },
                "vsanVerboseModeEnabled": {
                    "type": "boolean",
                    "description": "Whether the vSAN verbose mode is enabled for the cluster.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter Server.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the cluster in. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power operations in this cluster. Can be one of manual or automated.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual\nmachines in the cluster. Requires that DRS be enabled.\n"
                    },
                    "dpmThreshold": {
                        "type": "integer",
                        "description": "A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This\naffects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher\nsetting.\n"
                    },
                    "drsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Advanced configuration options for DRS and DPM.\n"
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or\nfullyAutomated.\n"
                    },
                    "drsEnablePredictiveDrs": {
                        "type": "boolean",
                        "description": "When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations.\n"
                    },
                    "drsEnableVmOverrides": {
                        "type": "boolean",
                        "description": "When true, allows individual VM overrides within this cluster to be set.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Enable DRS for this cluster.\n"
                    },
                    "drsMigrationThreshold": {
                        "type": "integer",
                        "description": "A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate\nmore imbalance while a higher setting will tolerate less.\n"
                    },
                    "drsScaleDescendantsShares": {
                        "type": "string",
                        "description": "Enable scalable shares for all descendants of this cluster.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this cluster in.\nThis is a path relative to the datacenter you are deploying the cluster to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a cluster named `compute-cluster-test` in a\nhost folder located at `/dc1/host/foo/bar`, with the final inventory path\nbeing `/dc1/host/foo/bar/datastore-cluster-test`.\n"
                    },
                    "forceEvacuateOnDestroy": {
                        "type": "boolean",
                        "description": "Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists\nfor testing and is not recommended in normal use.\n"
                    },
                    "haAdmissionControlFailoverHostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated\nfailover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS\nwill ignore the host when making recommendations.\n"
                    },
                    "haAdmissionControlHostFailureTolerance": {
                        "type": "integer",
                        "description": "The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual\nmachine operations. The maximum is one less than the number of hosts in the cluster.\n"
                    },
                    "haAdmissionControlPerformanceTolerance": {
                        "type": "integer",
                        "description": "The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces\nwarnings only, whereas a value of 100 disables the setting.\n"
                    },
                    "haAdmissionControlPolicy": {
                        "type": "string",
                        "description": "The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are\npermitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage,\nslotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service\nissues.\n"
                    },
                    "haAdmissionControlResourcePercentageAutoCompute": {
                        "type": "boolean",
                        "description": "When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by\nsubtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting\nfrom the total amount of resources in the cluster. Disable to supply user-defined values.\n"
                    },
                    "haAdmissionControlResourcePercentageCpu": {
                        "type": "integer",
                        "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in\nthe cluster to reserve for failover.\n"
                    },
                    "haAdmissionControlResourcePercentageMemory": {
                        "type": "integer",
                        "description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in\nthe cluster to reserve for failover.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitCpu": {
                        "type": "integer",
                        "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz.\n"
                    },
                    "haAdmissionControlSlotPolicyExplicitMemory": {
                        "type": "integer",
                        "description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB.\n"
                    },
                    "haAdmissionControlSlotPolicyUseExplicitSize": {
                        "type": "boolean",
                        "description": "When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values\nto CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines\ncurrently in the cluster.\n"
                    },
                    "haAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Advanced configuration options for vSphere HA.\n"
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an\naffected datastore clears in the middle of an APD event. Can be one of none or reset.\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or\nrestartAggressive.\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "When ha_vm_component_protection is enabled, controls the delay in seconds to wait after an APD timeout event to execute\nthe response action defined in ha_datastore_apd_response.\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has\ndetected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive.\n"
                    },
                    "haEnabled": {
                        "type": "boolean",
                        "description": "Enable vSphere HA for this cluster.\n"
                    },
                    "haHeartbeatDatastoreIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when\nha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.\n"
                    },
                    "haHeartbeatDatastorePolicy": {
                        "type": "string",
                        "description": "The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or\nallFeasibleDsWithUserPreference.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster.\nCan be one of none, powerOff, or shutdown.\n"
                    },
                    "haHostMonitoring": {
                        "type": "string",
                        "description": "Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled.\n"
                    },
                    "haVmComponentProtection": {
                        "type": "string",
                        "description": "Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to\nfailures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled.\n"
                    },
                    "haVmDependencyRestartCondition": {
                        "type": "string",
                        "description": "The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move\non to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen.\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as\nfailed. The value is in seconds.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will perform to a virtual machine when responding to a failure event.\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats.\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                    },
                    "haVmRestartAdditionalDelay": {
                        "type": "integer",
                        "description": "Additional delay in seconds after ready condition is met. A VM is considered ready at this point.\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium,\nhigh, or highest.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before\nproceeding with the next priority.\n"
                    },
                    "hostClusterExitTimeout": {
                        "type": "integer",
                        "description": "The timeout for each host maintenance mode operation when removing hosts from a cluster.\n"
                    },
                    "hostImage": {
                        "$ref": "#/types/vsphere:index/ComputeClusterHostImage:ComputeClusterHostImage",
                        "description": "Details about the host image which should be applied to the cluster.\n"
                    },
                    "hostManaged": {
                        "type": "boolean",
                        "description": "Must be set if cluster enrollment is managed from host resource.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of the hosts to put in the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the cluster.\n"
                    },
                    "proactiveHaAutomationLevel": {
                        "type": "string",
                        "description": "The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual.\n"
                    },
                    "proactiveHaEnabled": {
                        "type": "boolean",
                        "description": "Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation.\n"
                    },
                    "proactiveHaModerateRemediation": {
                        "type": "string",
                        "description": "The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that\nthis cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode.\n"
                    },
                    "proactiveHaProviderIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of IDs for health update providers configured for this cluster.\n"
                    },
                    "proactiveHaSevereRemediation": {
                        "type": "string",
                        "description": "The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this\ncannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode.\n"
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID of the primary\nresource pool for this cluster. This can be passed directly to the\n`resource_pool_id`\nattribute of the\n`vsphere.VirtualMachine` resource.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "vsanCompressionEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN compression service is enabled for the cluster.\n"
                    },
                    "vsanDedupEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN deduplication service is enabled for the cluster.\n"
                    },
                    "vsanDiskGroups": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/ComputeClusterVsanDiskGroup:ComputeClusterVsanDiskGroup"
                        },
                        "description": "A list of disk UUIDs to add to the vSAN cluster.\n"
                    },
                    "vsanDitEncryptionEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN data-in-transit encryption is enabled for the cluster.\n"
                    },
                    "vsanDitRekeyInterval": {
                        "type": "integer",
                        "description": "When vsan_dit_encryption_enabled is enabled, sets the rekey interval of data-in-transit encryption (in minutes).\n"
                    },
                    "vsanEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN service is enabled for the cluster.\n"
                    },
                    "vsanEsaEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN ESA service is enabled for the cluster.\n"
                    },
                    "vsanFaultDomains": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/ComputeClusterVsanFaultDomain:ComputeClusterVsanFaultDomain"
                        },
                        "description": "The configuration for vSAN fault domains.\n"
                    },
                    "vsanNetworkDiagnosticModeEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN network diagnostic mode is enabled for the cluster.\n"
                    },
                    "vsanPerformanceEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN performance service is enabled for the cluster.\n"
                    },
                    "vsanRemoteDatastoreIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of the vSAN datastore to be mounted on the cluster.\n"
                    },
                    "vsanStretchedCluster": {
                        "$ref": "#/types/vsphere:index/ComputeClusterVsanStretchedCluster:ComputeClusterVsanStretchedCluster",
                        "description": "The configuration for stretched cluster.\n"
                    },
                    "vsanUnmapEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN unmap service is enabled for the cluster.\n"
                    },
                    "vsanVerboseModeEnabled": {
                        "type": "boolean",
                        "description": "Whether the vSAN verbose mode is enabled for the cluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterHostGroup:ComputeClusterHostGroup": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterVmGroup`\nresource. Make sure your names are unique across both resources.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to put in the cluster.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterVmGroup`\nresource. Make sure your names are unique across both resources.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterHostGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to put in the cluster.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterVmGroup`\nresource. Make sure your names are unique across both resources.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAffinityRule:ComputeClusterVmAffinityRule": {
            "description": "The `vsphere.ComputeClusterVmAffinityRule` resource can be used to\nmanage virtual machine affinity rules in a cluster, either created by the\n`vsphere.ComputeCluster` resource or looked up\nby the `vsphere.ComputeCluster` data source.\n\nThis rule can be used to tell a set of virtual machines to run together on the\nsame host within a cluster. When configured, DRS will make a best effort to\nensure that the virtual machines run on the same host, or prevent any operation\nthat would keep that from happening, depending on the value of the\n`mandatory` flag.\n\n\u003e An affinity rule can only be used to place virtual machines on the same\n_non-specific_ hosts. It cannot be used to pin virtual machines to a host.\nTo enable this capability, use the\n`vsphere.ComputeClusterVmHostRule`\nresource.\n\n\u003e **NOTE:** This resource requires vCenter Server and is not available on\ndirect ESXi host connections.\n\n## Example Usage\n\nThe following example creates two virtual machines in a cluster using the\n`vsphere.VirtualMachine` resource, creating the\nvirtual machines in the cluster looked up by the\n`vsphere.ComputeCluster` data source. It\nthen creates an affinity rule for these two virtual machines, ensuring they\nwill run on the same host whenever possible.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore-01\",\n    datacenterId: datacenter.id,\n}));\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"VM Network\",\n    datacenterId: datacenter.id,\n}));\nconst vm: vsphere.VirtualMachine[] = [];\nfor (const range = {value: 0}; range.value \u003c 2; range.value++) {\n    vm.push(new vsphere.VirtualMachine(`vm-${range.value}`, {\n        name: `foo-${range.value}`,\n        resourcePoolId: cluster.then(cluster =\u003e cluster.resourcePoolId),\n        datastoreId: datastore.then(datastore =\u003e datastore.id),\n        numCpus: 1,\n        memory: 1024,\n        guestId: \"otherLinux64Guest\",\n        networkInterfaces: [{\n            networkId: network.then(network =\u003e network.id),\n        }],\n        disks: [{\n            label: \"disk0\",\n            size: 20,\n        }],\n    }));\n}\nconst vmAffinityRule = new vsphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\", {\n    name: \"vm-affinity-rule\",\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: vm.map((v, k) =\u003e [k, v]).map(([, ]) =\u003e (v.id)),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore-01\",\n    datacenter_id=datacenter.id)\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nnetwork = vsphere.get_network(name=\"VM Network\",\n    datacenter_id=datacenter.id)\nvm = []\nfor range in [{\"value\": i} for i in range(0, 2)]:\n    vm.append(vsphere.VirtualMachine(f\"vm-{range['value']}\",\n        name=f\"foo-{range['value']}\",\n        resource_pool_id=cluster.resource_pool_id,\n        datastore_id=datastore.id,\n        num_cpus=1,\n        memory=1024,\n        guest_id=\"otherLinux64Guest\",\n        network_interfaces=[{\n            \"network_id\": network.id,\n        }],\n        disks=[{\n            \"label\": \"disk0\",\n            \"size\": 20,\n        }]))\nvm_affinity_rule = vsphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\",\n    name=\"vm-affinity-rule\",\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[v.id for k, v in vm])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"VM Network\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vm = new List\u003cVSphere.VirtualMachine\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c 2; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        vm.Add(new VSphere.VirtualMachine($\"vm-{range.Value}\", new()\n        {\n            Name = $\"foo-{range.Value}\",\n            ResourcePoolId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n            DatastoreId = datastore.Apply(getDatastoreResult =\u003e getDatastoreResult.Id),\n            NumCpus = 1,\n            Memory = 1024,\n            GuestId = \"otherLinux64Guest\",\n            NetworkInterfaces = new[]\n            {\n                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs\n                {\n                    NetworkId = network.Apply(getNetworkResult =\u003e getNetworkResult.Id),\n                },\n            },\n            Disks = new[]\n            {\n                new VSphere.Inputs.VirtualMachineDiskArgs\n                {\n                    Label = \"disk0\",\n                    Size = 20,\n                },\n            },\n        }));\n    }\n    var vmAffinityRule = new VSphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\", new()\n    {\n        Name = \"vm-affinity-rule\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        VirtualMachineIds = vm.Select((value, i) =\u003e new { Key = i.ToString(), Value = pair.Value }).Select(v =\u003e \n        {\n            return v.Id;\n        }).ToList(),\n    });\n\n});\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nThe following example creates an affinity rule for a set of virtual machines\nin the cluster by looking up the virtual machine UUIDs from the\n`vsphere.VirtualMachine` data source.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vms = [\n    \"foo-0\",\n    \"foo-1\",\n];\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst vmsGetVirtualMachine = (new Array(vms.length)).map((_, i) =\u003e i).map(__index =\u003e (vsphere.getVirtualMachine({\n    name: vms[__index],\n    datacenterId: _arg0_.id,\n})));\nconst vmAffinityRule = new vsphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\", {\n    name: \"vm-affinity-rule\",\n    enabled: true,\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    virtualMachineIds: vmsGetVirtualMachine.map(__item =\u003e __item.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvms = [\n    \"foo-0\",\n    \"foo-1\",\n]\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nvms_get_virtual_machine = [vsphere.get_virtual_machine(name=vms[__index],\n    datacenter_id=datacenter.id) for __index in range(len(vms))]\nvm_affinity_rule = vsphere.ComputeClusterVmAffinityRule(\"vm_affinity_rule\",\n    name=\"vm-affinity-rule\",\n    enabled=True,\n    compute_cluster_id=cluster.id,\n    virtual_machine_ids=[__item.id for __item in vms_get_virtual_machine])\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Importing\n\nAn existing rule can be imported into this resource by supplying\nboth the path to the cluster, and the name the rule. If the name or cluster is\nnot found, or if the rule is of a different type, an error will be returned. An\nexample is below:\n\n```\nterraform import vsphere_compute_cluster_vm_affinity_rule.vm_affinity_rule \\\n  '{\"compute_cluster_path\": \"/dc-01/host/cluster-01\", \\\n  \"name\": \"vm-affinity-rule\"}'\n```\n",
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non the same host together.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmAntiAffinityRule:ComputeClusterVmAntiAffinityRule": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non hosts different from each other.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmDependencyRule:ComputeClusterVmDependencyRule": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "required": [
                "computeClusterId",
                "dependencyVmGroupName",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "dependencyVmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "dependencyVmGroupName",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmDependencyRule resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "dependencyVmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that this\nrule depends on. The VMs defined in the group specified by\n`vm_group_name` will not be started until the VMs in this\ngroup are started.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the VM group that is the subject of\nthis rule. The VMs defined in this group will not be started until the VMs in\nthe group specified by\n`dependency_vm_group_name` are started.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmGroup:ComputeClusterVmGroup": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterHostGroup`\nresource. Make sure your names are unique across both resources.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines in this\ngroup.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterHostGroup`\nresource. Make sure your names are unique across both resources.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmGroup resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VM group. This must be unique in the\ncluster. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines in this\ngroup.\n\n\u003e **NOTE:** The namespace for cluster names on this resource (defined by the\n`name` argument) is shared with the\n`vsphere.ComputeClusterHostGroup`\nresource. Make sure your names are unique across both resources.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/computeClusterVmHostRule:ComputeClusterVmHostRule": {
            "properties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** One of `affinity_host_group_name` or\n`anti_affinity_host_group_name` must be\ndefined, but not both.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "required": [
                "computeClusterId",
                "name",
                "vmGroupName"
            ],
            "inputProperties": {
                "affinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                },
                "antiAffinityHostGroupName": {
                    "type": "string",
                    "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                },
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** One of `affinity_host_group_name` or\n`anti_affinity_host_group_name` must be\ndefined, but not both.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the\ncluster.\n"
                },
                "vmGroupName": {
                    "type": "string",
                    "description": "The name of the virtual machine group to use\nwith this rule.\n"
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "vmGroupName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ComputeClusterVmHostRule resources.\n",
                "properties": {
                    "affinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the virtual\nmachines defined in `vm_group_name` will be run on the\nhosts defined in this host group.\n"
                    },
                    "antiAffinityHostGroupName": {
                        "type": "string",
                        "description": "When this field is used, the\nvirtual machines defined in `vm_group_name` will _not_ be\nrun on the hosts defined in this host group.\n"
                    },
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the group in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n\n\u003e **NOTE:** One of `affinity_host_group_name` or\n`anti_affinity_host_group_name` must be\ndefined, but not both.\n\n\u003e **NOTE:** The namespace for rule names on this resource (defined by the\n`name` argument) is shared with all rules in the cluster - consider\nthis when naming your rules.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the\ncluster.\n"
                    },
                    "vmGroupName": {
                        "type": "string",
                        "description": "The name of the virtual machine group to use\nwith this rule.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibrary:ContentLibrary": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the content library.\n"
                },
                "publication": {
                    "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                    "description": "Options to publish a local content library.\n"
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID of the datastore on which to store the content library items.\n"
                },
                "subscription": {
                    "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                    "description": "Options subscribe to a published content library.\n"
                }
            },
            "required": [
                "name",
                "publication",
                "storageBackings"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the content library.\n",
                    "willReplaceOnChanges": true
                },
                "publication": {
                    "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                    "description": "Options to publish a local content library.\n",
                    "willReplaceOnChanges": true
                },
                "storageBackings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object reference ID of the datastore on which to store the content library items.\n",
                    "willReplaceOnChanges": true
                },
                "subscription": {
                    "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                    "description": "Options subscribe to a published content library.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "storageBackings"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibrary resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description for the content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "publication": {
                        "$ref": "#/types/vsphere:index/ContentLibraryPublication:ContentLibraryPublication",
                        "description": "Options to publish a local content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "storageBackings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object reference ID of the datastore on which to store the content library items.\n",
                        "willReplaceOnChanges": true
                    },
                    "subscription": {
                        "$ref": "#/types/vsphere:index/ContentLibrarySubscription:ContentLibrarySubscription",
                        "description": "Options subscribe to a published content library.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/contentLibraryItem:ContentLibraryItem": {
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library item.\n"
                },
                "fileUrl": {
                    "type": "string",
                    "description": "File to import as the content library item.\n"
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the content library in which to create the item.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the content library.\n"
                },
                "sourceUuid": {
                    "type": "string",
                    "description": "Virtual machine UUID to clone to content library.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\nOne of \"ovf\", \"iso\", or \"vm-template\". Default: `ovf`.\n"
                }
            },
            "required": [
                "libraryId",
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A description for the content library item.\n",
                    "willReplaceOnChanges": true
                },
                "fileUrl": {
                    "type": "string",
                    "description": "File to import as the content library item.\n",
                    "willReplaceOnChanges": true
                },
                "libraryId": {
                    "type": "string",
                    "description": "The ID of the content library in which to create the item.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the item to be created in the content library.\n",
                    "willReplaceOnChanges": true
                },
                "sourceUuid": {
                    "type": "string",
                    "description": "Virtual machine UUID to clone to content library.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Type of content library item.\nOne of \"ovf\", \"iso\", or \"vm-template\". Default: `ovf`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "libraryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ContentLibraryItem resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A description for the content library item.\n",
                        "willReplaceOnChanges": true
                    },
                    "fileUrl": {
                        "type": "string",
                        "description": "File to import as the content library item.\n",
                        "willReplaceOnChanges": true
                    },
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the content library in which to create the item.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the item to be created in the content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceUuid": {
                        "type": "string",
                        "description": "Virtual machine UUID to clone to content library.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of content library item.\nOne of \"ovf\", \"iso\", or \"vm-template\". Default: `ovf`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/customAttribute:CustomAttribute": {
            "properties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, review the Managed Object Types. Forces a new resource if changed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "managedObjectType": {
                    "type": "string",
                    "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, review the Managed Object Types. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the custom attribute.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomAttribute resources.\n",
                "properties": {
                    "managedObjectType": {
                        "type": "string",
                        "description": "The object type that this attribute may be\napplied to. If not set, the custom attribute may be applied to any object\ntype. For a full list, review the Managed Object Types. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datacenter:Datacenter": {
            "description": "Provides a VMware vSphere datacenter resource. This can be used as the primary\ncontainer of inventory objects such as hosts and virtual machines.\n\n## Example Usage\n\n### Create datacenter on the root folder\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodDatacenter = new vsphere.Datacenter(\"prod_datacenter\", {name: \"my_prod_datacenter\"});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_datacenter = vsphere.Datacenter(\"prod_datacenter\", name=\"my_prod_datacenter\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodDatacenter = new VSphere.Datacenter(\"prod_datacenter\", new()\n    {\n        Name = \"my_prod_datacenter\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDatacenter(ctx, \"prod_datacenter\", \u0026vsphere.DatacenterArgs{\n\t\t\tName: pulumi.String(\"my_prod_datacenter\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.Datacenter;\nimport com.pulumi.vsphere.DatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var prodDatacenter = new Datacenter(\"prodDatacenter\", DatacenterArgs.builder()\n            .name(\"my_prod_datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodDatacenter:\n    type: vsphere:Datacenter\n    name: prod_datacenter\n    properties:\n      name: my_prod_datacenter\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Create datacenter on a subfolder\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst researchDatacenter = new vsphere.Datacenter(\"research_datacenter\", {\n    name: \"my_research_datacenter\",\n    folder: \"/research/\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nresearch_datacenter = vsphere.Datacenter(\"research_datacenter\",\n    name=\"my_research_datacenter\",\n    folder=\"/research/\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var researchDatacenter = new VSphere.Datacenter(\"research_datacenter\", new()\n    {\n        Name = \"my_research_datacenter\",\n        Folder = \"/research/\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewDatacenter(ctx, \"research_datacenter\", \u0026vsphere.DatacenterArgs{\n\t\t\tName:   pulumi.String(\"my_research_datacenter\"),\n\t\t\tFolder: pulumi.String(\"/research/\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.Datacenter;\nimport com.pulumi.vsphere.DatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var researchDatacenter = new Datacenter(\"researchDatacenter\", DatacenterArgs.builder()\n            .name(\"my_research_datacenter\")\n            .folder(\"/research/\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  researchDatacenter:\n    type: vsphere:Datacenter\n    name: research_datacenter\n    properties:\n      name: my_research_datacenter\n      folder: /research/\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Importing\n\nAn existing datacenter can be [imported][docs-import] into this resource\nvia supplying the full path to the datacenter. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```\nterraform import vsphere_datacenter.dc /dc1\n```\n\nThe above would import the datacenter named `dc1`.\n",
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value\nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "Managed object ID of this datacenter.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "moid",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to value\nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Datacenter resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to value\nstrings to set for datacenter resource. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder where the datacenter should be created.\nForces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "moid": {
                        "type": "string",
                        "description": "Managed object ID of this datacenter.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This name needs to be unique\nwithin the folder. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreCluster:DatastoreCluster": {
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for storage DRS.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all virtual machines in this storage cluster.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When true, storage DRS keeps VMDKs for individual VMs on the same datastore by default.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The threshold, in GB, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in percent, of difference between space utilization in datastores before storage DRS makes decisions to\nbalance the space.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in milliseconds, that storage DRS uses to make recommendations to move disks from this\ndatastore.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for this datastore cluster.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load in datastores in the cluster before storage DRS makes recommendations to balance the load.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable IOPS of all virtual machines on the datastore before storage DRS makes recommendations to\nmove VMs off of a datastore.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent, of actual estimated performance of the datastore (in IOPS) that storage DRS uses to make\nrecommendations to move VMs off of a datastore when the total reservable IOPS exceeds the threshold.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS threshold to use, percent in the event of automatic, or manual threshold in the event of manual.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "datacenterId",
                "name"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore cluster.\n"
                },
                "sdrsAdvancedOptions": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Advanced configuration options for storage DRS.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "The default automation level for all virtual machines in this storage cluster.\n"
                },
                "sdrsDefaultIntraVmAffinity": {
                    "type": "boolean",
                    "description": "When true, storage DRS keeps VMDKs for individual VMs on the same datastore by default.\n"
                },
                "sdrsEnabled": {
                    "type": "boolean",
                    "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                },
                "sdrsFreeSpaceThreshold": {
                    "type": "integer",
                    "description": "The threshold, in GB, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsFreeSpaceThresholdMode": {
                    "type": "string",
                    "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                },
                "sdrsFreeSpaceUtilizationDifference": {
                    "type": "integer",
                    "description": "The threshold, in percent, of difference between space utilization in datastores before storage DRS makes decisions to\nbalance the space.\n"
                },
                "sdrsIoBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting I/O load imbalances.\n"
                },
                "sdrsIoLatencyThreshold": {
                    "type": "integer",
                    "description": "The I/O latency threshold, in milliseconds, that storage DRS uses to make recommendations to move disks from this\ndatastore.\n"
                },
                "sdrsIoLoadBalanceEnabled": {
                    "type": "boolean",
                    "description": "Enable I/O load balancing for this datastore cluster.\n"
                },
                "sdrsIoLoadImbalanceThreshold": {
                    "type": "integer",
                    "description": "The difference between load in datastores in the cluster before storage DRS makes recommendations to balance the load.\n"
                },
                "sdrsIoReservableIopsThreshold": {
                    "type": "integer",
                    "description": "The threshold of reservable IOPS of all virtual machines on the datastore before storage DRS makes recommendations to\nmove VMs off of a datastore.\n"
                },
                "sdrsIoReservablePercentThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent, of actual estimated performance of the datastore (in IOPS) that storage DRS uses to make\nrecommendations to move VMs off of a datastore when the total reservable IOPS exceeds the threshold.\n"
                },
                "sdrsIoReservableThresholdMode": {
                    "type": "string",
                    "description": "The reservable IOPS threshold to use, percent in the event of automatic, or manual threshold in the event of manual.\n"
                },
                "sdrsLoadBalanceInterval": {
                    "type": "integer",
                    "description": "The storage DRS poll interval, in minutes.\n"
                },
                "sdrsPolicyEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting storage and VM policy violations.\n"
                },
                "sdrsRuleEnforcementAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting affinity rule violations.\n"
                },
                "sdrsSpaceBalanceAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when correcting disk space imbalances.\n"
                },
                "sdrsSpaceUtilizationThreshold": {
                    "type": "integer",
                    "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                },
                "sdrsVmEvacuationAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the default automation settings when generating recommendations for datastore evacuation.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreCluster resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute ids to attribute\nvalue strings to set for the datastore cluster. See\n[here][docs-setting-custom-attributes] for a reference on how to set values\nfor custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe datacenter to create the datastore cluster in. Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore\ncluster in.  This is a path relative to the datacenter you are deploying the\ndatastore to.  Example: for the `dc1` datacenter, and a provided `folder` of\n`foo/bar`, The provider will place a datastore cluster named\n`datastore-cluster-test` in a datastore folder located at\n`/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/datastore-cluster-test`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore cluster.\n"
                    },
                    "sdrsAdvancedOptions": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Advanced configuration options for storage DRS.\n"
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "The default automation level for all virtual machines in this storage cluster.\n"
                    },
                    "sdrsDefaultIntraVmAffinity": {
                        "type": "boolean",
                        "description": "When true, storage DRS keeps VMDKs for individual VMs on the same datastore by default.\n"
                    },
                    "sdrsEnabled": {
                        "type": "boolean",
                        "description": "Enable Storage DRS for this datastore cluster.\nDefault: `false`.\n"
                    },
                    "sdrsFreeSpaceThreshold": {
                        "type": "integer",
                        "description": "The threshold, in GB, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                    },
                    "sdrsFreeSpaceThresholdMode": {
                        "type": "string",
                        "description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to\nfreeSpace, drs_free_space_threshold is used.\n"
                    },
                    "sdrsFreeSpaceUtilizationDifference": {
                        "type": "integer",
                        "description": "The threshold, in percent, of difference between space utilization in datastores before storage DRS makes decisions to\nbalance the space.\n"
                    },
                    "sdrsIoBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when correcting I/O load imbalances.\n"
                    },
                    "sdrsIoLatencyThreshold": {
                        "type": "integer",
                        "description": "The I/O latency threshold, in milliseconds, that storage DRS uses to make recommendations to move disks from this\ndatastore.\n"
                    },
                    "sdrsIoLoadBalanceEnabled": {
                        "type": "boolean",
                        "description": "Enable I/O load balancing for this datastore cluster.\n"
                    },
                    "sdrsIoLoadImbalanceThreshold": {
                        "type": "integer",
                        "description": "The difference between load in datastores in the cluster before storage DRS makes recommendations to balance the load.\n"
                    },
                    "sdrsIoReservableIopsThreshold": {
                        "type": "integer",
                        "description": "The threshold of reservable IOPS of all virtual machines on the datastore before storage DRS makes recommendations to\nmove VMs off of a datastore.\n"
                    },
                    "sdrsIoReservablePercentThreshold": {
                        "type": "integer",
                        "description": "The threshold, in percent, of actual estimated performance of the datastore (in IOPS) that storage DRS uses to make\nrecommendations to move VMs off of a datastore when the total reservable IOPS exceeds the threshold.\n"
                    },
                    "sdrsIoReservableThresholdMode": {
                        "type": "string",
                        "description": "The reservable IOPS threshold to use, percent in the event of automatic, or manual threshold in the event of manual.\n"
                    },
                    "sdrsLoadBalanceInterval": {
                        "type": "integer",
                        "description": "The storage DRS poll interval, in minutes.\n"
                    },
                    "sdrsPolicyEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when correcting storage and VM policy violations.\n"
                    },
                    "sdrsRuleEnforcementAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when correcting affinity rule violations.\n"
                    },
                    "sdrsSpaceBalanceAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when correcting disk space imbalances.\n"
                    },
                    "sdrsSpaceUtilizationThreshold": {
                        "type": "integer",
                        "description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore.\n"
                    },
                    "sdrsVmEvacuationAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the default automation settings when generating recommendations for datastore evacuation.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/datastoreClusterVmAntiAffinityRule:DatastoreClusterVmAntiAffinityRule": {
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n\n\u003e **NOTE:** The minimum length of `virtual_machine_ids` is 2.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "name",
                "virtualMachineIds"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Enable this rule in the cluster. Default: `true`.\n"
                },
                "mandatory": {
                    "type": "boolean",
                    "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the rule. This must be unique in the cluster.\n"
                },
                "virtualMachineIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n\n\u003e **NOTE:** The minimum length of `virtual_machine_ids` is 2.\n"
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatastoreClusterVmAntiAffinityRule resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the group in.  Forces\na new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Enable this rule in the cluster. Default: `true`.\n"
                    },
                    "mandatory": {
                        "type": "boolean",
                        "description": "When this value is `true`, prevents any virtual\nmachine operations that may violate this rule. Default: `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the rule. This must be unique in the cluster.\n"
                    },
                    "virtualMachineIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The UUIDs of the virtual machines to run\non different datastores from each other.\n\n\u003e **NOTE:** The minimum length of `virtual_machine_ids` is 2.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedPortGroup:DistributedPortGroup": {
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n\n\u003e **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`\nmay lead to errors when the port count grows past the amount specified.  If you\nspecify `number_of_ports`, you may wish to set `auto_expand` to `false`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the blocked setting of an individual port to override the setting in the portgroup.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "The current version of the port group configuration,\nincremented by subsequent updates to the port group.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\n\u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD\nvalue string to set for port group. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n=======\nvalue string to set for port group.\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e 69c6e040 (fork)\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the VDS to add the\nport group to. Forces a new resource if changed.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The generated UUID of the port group.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a live port to be moved in and out of the portgroup.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network resource pool of an individual port to override the setting in the portgroup.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n\n[ext-vsphere-portname-format]: https://developer.broadcom.com/xapis/virtual-infrastructure-json-api/latest/data-structures/DVPortgroupConfigInfo/\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow security policy settings on a port to override those on the portgroup.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the traffic shaping policies of an individual port to override the settings in the portgroup.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any filter policies set on the individual port to override those in the portgroup.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the uplink teaming policies on a port to override those on the portgroup.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the VLAN configuration on a port to override those on the portgroup.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "directpathGen2Allowed",
                "distributedVirtualSwitchUuid",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "key",
                "lacpEnabled",
                "lacpMode",
                "name",
                "netflowEnabled",
                "notifySwitches",
                "numberOfPorts",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "vlanId",
                "vlanRanges"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "autoExpand": {
                    "type": "boolean",
                    "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n\n\u003e **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`\nmay lead to errors when the port count grows past the amount specified.  If you\nspecify `number_of_ports`, you may wish to set `auto_expand` to `false`.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "blockOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the blocked setting of an individual port to override the setting in the portgroup.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\n\u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD\nvalue string to set for port group. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n=======\nvalue string to set for port group.\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e 69c6e040 (fork)\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "description": {
                    "type": "string",
                    "description": "An optional description for the port group.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "distributedVirtualSwitchUuid": {
                    "type": "string",
                    "description": "The ID of the VDS to add the\nport group to. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "livePortMovingAllowed": {
                    "type": "boolean",
                    "description": "Allow a live port to be moved in and out of the portgroup.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.\n"
                },
                "networkResourcePoolKey": {
                    "type": "string",
                    "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                },
                "networkResourcePoolOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the network resource pool of an individual port to override the setting in the portgroup.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                },
                "portConfigResetAtDisconnect": {
                    "type": "boolean",
                    "description": "Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.\n"
                },
                "portNameFormat": {
                    "type": "string",
                    "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n\n[ext-vsphere-portname-format]: https://developer.broadcom.com/xapis/virtual-infrastructure-json-api/latest/data-structures/DVPortgroupConfigInfo/\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "securityPolicyOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow security policy settings on a port to override those on the portgroup.\n"
                },
                "shapingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the traffic shaping policies of an individual port to override the settings in the portgroup.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "trafficFilterOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow any filter policies set on the individual port to override those in the portgroup.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                },
                "uplinkTeamingOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the uplink teaming policies on a port to override those on the portgroup.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanOverrideAllowed": {
                    "type": "boolean",
                    "description": "Allow the VLAN configuration on a port to override those on the portgroup.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                }
            },
            "requiredInputs": [
                "distributedVirtualSwitchUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedPortGroup resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "autoExpand": {
                        "type": "boolean",
                        "description": "Allows the port group to create additional ports\npast the limit specified in `number_of_ports` if necessary. Default: `true`.\n\n\u003e **NOTE:** Using `auto_expand` with a statically defined `number_of_ports`\nmay lead to errors when the port count grows past the amount specified.  If you\nspecify `number_of_ports`, you may wish to set `auto_expand` to `false`.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Indicates whether to block all ports by default.\n"
                    },
                    "blockOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the blocked setting of an individual port to override the setting in the portgroup.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing on the ports this policy applies to.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "The current version of the port group configuration,\nincremented by subsequent updates to the port group.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\n\u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD\nvalue string to set for port group. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n=======\nvalue string to set for port group.\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e 69c6e040 (fork)\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "An optional description for the port group.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "The ID of the VDS to add the\nport group to. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "key": {
                        "type": "string",
                        "description": "The generated UUID of the port group.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable LACP on all uplink ports.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                    },
                    "livePortMovingAllowed": {
                        "type": "boolean",
                        "description": "Allow a live port to be moved in and out of the portgroup.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether to enable netflow on all ports.\n"
                    },
                    "netflowOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.\n"
                    },
                    "networkResourcePoolKey": {
                        "type": "string",
                        "description": "The key of a network resource pool\nto associate with this port group. The default is `-1`, which implies no\nassociation.\n"
                    },
                    "networkResourcePoolOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the network resource pool of an individual port to override the setting in the portgroup.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports available on this port\ngroup. Cannot be decreased below the amount of used ports on the port group.\n"
                    },
                    "portConfigResetAtDisconnect": {
                        "type": "boolean",
                        "description": "Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.\n"
                    },
                    "portNameFormat": {
                        "type": "string",
                        "description": "An optional formatting policy for naming of\nthe ports in this port group. See the `portNameFormat` attribute listed\n[here][ext-vsphere-portname-format] for details on the format syntax.\n\n[ext-vsphere-portname-format]: https://developer.broadcom.com/xapis/virtual-infrastructure-json-api/latest/data-structures/DVPortgroupConfigInfo/\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "The secondary VLAN ID for this port.\n"
                    },
                    "securityPolicyOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow security policy settings on a port to override those on the portgroup.\n"
                    },
                    "shapingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the traffic shaping policies of an individual port to override the settings in the portgroup.\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                    },
                    "trafficFilterOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow any filter policies set on the individual port to override those in the portgroup.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The port group type. Can be one of `earlyBinding` (static\nbinding) or `ephemeral`. Default: `earlyBinding`.\n"
                    },
                    "uplinkTeamingOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the uplink teaming policies on a port to override those on the portgroup.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanOverrideAllowed": {
                        "type": "boolean",
                        "description": "Allow the VLAN configuration on a port to override those on the portgroup.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedPortGroupVlanRange:DistributedPortGroupVlanRange"
                        },
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/distributedVirtualSwitch:DistributedVirtualSwitch": {
            "properties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "backupnfcMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                },
                "backupnfcShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "configVersion": {
                    "type": "string",
                    "description": "The current version of the VDS configuration, incremented\nby subsequent updates to the VDS.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the VDS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nVDS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for VDS.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand requires vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VDS will be\ncreated. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the VDS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder in which to create the VDS.\nForces a new resource if changed.\n"
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "A host member specification.\n"
                },
                "ignoreOtherPvlanMappings": {
                    "type": "boolean",
                    "description": "Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the VDS. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the VDS.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the VDS. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VDS.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which active flows are forced to be exported to the collector.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the netflow collector, using IPv4 or IPv6.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "The port for the netflow collector.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which idle flows are forced to be exported to the collector.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to traffic that has both source and destination served by the same host.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation Domain ID for the netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all\npackets are analyzed.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The network I/O control version to use. Can be one of version2 or version3.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "pvlanMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                    },
                    "description": "A private VLAN (PVLAN) mapping.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS\nacross hosts.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the VDS. BY default, a VDS is created\nat the latest version supported by the vSphere version if not specified.\nA VDS can be upgraded to a newer version, but can not be downgraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "required": [
                "activeUplinks",
                "allowForgedTransmits",
                "allowMacChanges",
                "allowPromiscuous",
                "backupnfcMaximumMbit",
                "backupnfcReservationMbit",
                "backupnfcShareCount",
                "backupnfcShareLevel",
                "blockAllPorts",
                "checkBeacon",
                "configVersion",
                "datacenterId",
                "directpathGen2Allowed",
                "egressShapingAverageBandwidth",
                "egressShapingBurstSize",
                "egressShapingEnabled",
                "egressShapingPeakBandwidth",
                "failback",
                "faulttoleranceMaximumMbit",
                "faulttoleranceReservationMbit",
                "faulttoleranceShareCount",
                "faulttoleranceShareLevel",
                "hbrMaximumMbit",
                "hbrReservationMbit",
                "hbrShareCount",
                "hbrShareLevel",
                "ingressShapingAverageBandwidth",
                "ingressShapingBurstSize",
                "ingressShapingEnabled",
                "ingressShapingPeakBandwidth",
                "iscsiMaximumMbit",
                "iscsiReservationMbit",
                "iscsiShareCount",
                "iscsiShareLevel",
                "lacpApiVersion",
                "lacpEnabled",
                "lacpMode",
                "managementMaximumMbit",
                "managementReservationMbit",
                "managementShareCount",
                "managementShareLevel",
                "maxMtu",
                "multicastFilteringMode",
                "name",
                "netflowEnabled",
                "networkResourceControlVersion",
                "nfsMaximumMbit",
                "nfsReservationMbit",
                "nfsShareCount",
                "nfsShareLevel",
                "notifySwitches",
                "portPrivateSecondaryVlanId",
                "standbyUplinks",
                "teamingPolicy",
                "txUplink",
                "uplinks",
                "vdpMaximumMbit",
                "vdpReservationMbit",
                "vdpShareCount",
                "vdpShareLevel",
                "version",
                "virtualmachineMaximumMbit",
                "virtualmachineReservationMbit",
                "virtualmachineShareCount",
                "virtualmachineShareLevel",
                "vlanId",
                "vlanRanges",
                "vmotionMaximumMbit",
                "vmotionReservationMbit",
                "vmotionShareCount",
                "vmotionShareLevel",
                "vsanMaximumMbit",
                "vsanReservationMbit",
                "vsanShareCount",
                "vsanShareLevel"
            ],
            "inputProperties": {
                "activeUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "backupnfcMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                },
                "backupnfcShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                },
                "backupnfcShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "blockAllPorts": {
                    "type": "boolean",
                    "description": "Indicates whether to block all ports by default.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing on the ports this policy applies to.\n"
                },
                "contactDetail": {
                    "type": "string",
                    "description": "The detailed contact information for the person\nwho is responsible for the VDS.\n"
                },
                "contactName": {
                    "type": "string",
                    "description": "The name of the person who is responsible for the\nVDS.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for VDS.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand requires vCenter Server.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VDS will be\ncreated. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A detailed description for the VDS.\n"
                },
                "directpathGen2Allowed": {
                    "type": "boolean",
                    "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                },
                "egressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                },
                "egressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                },
                "egressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                },
                "egressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "faulttoleranceMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                },
                "faulttoleranceShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                },
                "faulttoleranceShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The folder in which to create the VDS.\nForces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "hbrMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                },
                "hbrShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                },
                "hbrShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                    },
                    "description": "A host member specification.\n"
                },
                "ignoreOtherPvlanMappings": {
                    "type": "boolean",
                    "description": "Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.\n"
                },
                "ingressShapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                },
                "ingressShapingEnabled": {
                    "type": "boolean",
                    "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                },
                "ingressShapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                },
                "ipv4Address": {
                    "type": "string",
                    "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments.\n"
                },
                "iscsiMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                },
                "iscsiShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                },
                "iscsiShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "lacpApiVersion": {
                    "type": "string",
                    "description": "The Link Aggregation Control Protocol group\nversion to use with the VDS. Possible values are `singleLag` and\n`multipleLag`.\n"
                },
                "lacpEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable LACP on all uplink ports.\n"
                },
                "lacpMode": {
                    "type": "string",
                    "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                },
                "managementMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                },
                "managementReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                },
                "managementShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                },
                "managementShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the VDS.\n"
                },
                "multicastFilteringMode": {
                    "type": "string",
                    "description": "The multicast filtering mode to use\nwith the VDS. Can be one of `legacyFiltering` or `snooping`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the VDS.\n"
                },
                "netflowActiveFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which active flows are forced to be exported to the collector.\n"
                },
                "netflowCollectorIpAddress": {
                    "type": "string",
                    "description": "IP address for the netflow collector, using IPv4 or IPv6.\n"
                },
                "netflowCollectorPort": {
                    "type": "integer",
                    "description": "The port for the netflow collector.\n"
                },
                "netflowEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether to enable netflow on all ports.\n"
                },
                "netflowIdleFlowTimeout": {
                    "type": "integer",
                    "description": "The number of seconds after which idle flows are forced to be exported to the collector.\n"
                },
                "netflowInternalFlowsOnly": {
                    "type": "boolean",
                    "description": "Whether to limit analysis to traffic that has both source and destination served by the same host.\n"
                },
                "netflowObservationDomainId": {
                    "type": "integer",
                    "description": "The observation Domain ID for the netflow collector.\n"
                },
                "netflowSamplingRate": {
                    "type": "integer",
                    "description": "The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all\npackets are analyzed.\n"
                },
                "networkResourceControlEnabled": {
                    "type": "boolean",
                    "description": "Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.\n"
                },
                "networkResourceControlVersion": {
                    "type": "string",
                    "description": "The network I/O control version to use. Can be one of version2 or version3.\n"
                },
                "nfsMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                },
                "nfsShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                },
                "nfsShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "portPrivateSecondaryVlanId": {
                    "type": "integer",
                    "description": "The secondary VLAN ID for this port.\n"
                },
                "pvlanMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                    },
                    "description": "A private VLAN (PVLAN) mapping.\n"
                },
                "standbyUplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                },
                "txUplink": {
                    "type": "boolean",
                    "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                },
                "uplinks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS\nacross hosts.\n"
                },
                "vdpMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                },
                "vdpShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                },
                "vdpShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "version": {
                    "type": "string",
                    "description": "The version of the VDS. BY default, a VDS is created\nat the latest version supported by the vSphere version if not specified.\nA VDS can be upgraded to a newer version, but can not be downgraded.\n"
                },
                "virtualmachineMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                },
                "virtualmachineShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                },
                "virtualmachineShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vlanRanges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                    },
                    "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                },
                "vmotionMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                },
                "vmotionShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                },
                "vmotionShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                },
                "vsanMaximumMbit": {
                    "type": "integer",
                    "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanReservationMbit": {
                    "type": "integer",
                    "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                },
                "vsanShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                },
                "vsanShareLevel": {
                    "type": "string",
                    "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                }
            },
            "requiredInputs": [
                "datacenterId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DistributedVirtualSwitch resources.\n",
                "properties": {
                    "activeUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "backupnfcMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.\n"
                    },
                    "backupnfcReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.\n"
                    },
                    "backupnfcShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the backupNfc traffic class for a custom share level.\n"
                    },
                    "backupnfcShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "blockAllPorts": {
                        "type": "boolean",
                        "description": "Indicates whether to block all ports by default.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing on the ports this policy applies to.\n"
                    },
                    "configVersion": {
                        "type": "string",
                        "description": "The current version of the VDS configuration, incremented\nby subsequent updates to the VDS.\n"
                    },
                    "contactDetail": {
                        "type": "string",
                        "description": "The detailed contact information for the person\nwho is responsible for the VDS.\n"
                    },
                    "contactName": {
                        "type": "string",
                        "description": "The name of the person who is responsible for the\nVDS.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue strings to set for VDS.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand requires vCenter Server.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter where the VDS will be\ncreated. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A detailed description for the VDS.\n"
                    },
                    "directpathGen2Allowed": {
                        "type": "boolean",
                        "description": "Allow VMDirectPath Gen2 on the ports this policy applies to.\n"
                    },
                    "egressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.\n"
                    },
                    "egressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for egress traffic on the port.\n"
                    },
                    "egressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "faulttoleranceMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.\n"
                    },
                    "faulttoleranceShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.\n"
                    },
                    "faulttoleranceShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The folder in which to create the VDS.\nForces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "hbrMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.\n"
                    },
                    "hbrShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the hbr traffic class for a custom share level.\n"
                    },
                    "hbrShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "hosts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchHost:DistributedVirtualSwitchHost"
                        },
                        "description": "A host member specification.\n"
                    },
                    "ignoreOtherPvlanMappings": {
                        "type": "boolean",
                        "description": "Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.\n"
                    },
                    "ingressShapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.\n"
                    },
                    "ingressShapingEnabled": {
                        "type": "boolean",
                        "description": "True if the traffic shaper is enabled for ingress traffic on the port.\n"
                    },
                    "ingressShapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.\n"
                    },
                    "ipv4Address": {
                        "type": "string",
                        "description": "An IPv4 address to identify the switch. This is\nmostly useful when used with the Netflow arguments.\n"
                    },
                    "iscsiMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.\n"
                    },
                    "iscsiShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.\n"
                    },
                    "iscsiShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "lacpApiVersion": {
                        "type": "string",
                        "description": "The Link Aggregation Control Protocol group\nversion to use with the VDS. Possible values are `singleLag` and\n`multipleLag`.\n"
                    },
                    "lacpEnabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable LACP on all uplink ports.\n"
                    },
                    "lacpMode": {
                        "type": "string",
                        "description": "The uplink LACP mode to use. Can be one of active or passive.\n"
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to `advertise` or `listen`\nfor link discovery traffic.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type. Valid\ntypes are `cdp` and `lldp`.\n"
                    },
                    "managementMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.\n"
                    },
                    "managementShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the management traffic class for a custom share level.\n"
                    },
                    "managementShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "maxMtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the VDS.\n"
                    },
                    "multicastFilteringMode": {
                        "type": "string",
                        "description": "The multicast filtering mode to use\nwith the VDS. Can be one of `legacyFiltering` or `snooping`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VDS.\n"
                    },
                    "netflowActiveFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which active flows are forced to be exported to the collector.\n"
                    },
                    "netflowCollectorIpAddress": {
                        "type": "string",
                        "description": "IP address for the netflow collector, using IPv4 or IPv6.\n"
                    },
                    "netflowCollectorPort": {
                        "type": "integer",
                        "description": "The port for the netflow collector.\n"
                    },
                    "netflowEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether to enable netflow on all ports.\n"
                    },
                    "netflowIdleFlowTimeout": {
                        "type": "integer",
                        "description": "The number of seconds after which idle flows are forced to be exported to the collector.\n"
                    },
                    "netflowInternalFlowsOnly": {
                        "type": "boolean",
                        "description": "Whether to limit analysis to traffic that has both source and destination served by the same host.\n"
                    },
                    "netflowObservationDomainId": {
                        "type": "integer",
                        "description": "The observation Domain ID for the netflow collector.\n"
                    },
                    "netflowSamplingRate": {
                        "type": "integer",
                        "description": "The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all\npackets are analyzed.\n"
                    },
                    "networkResourceControlEnabled": {
                        "type": "boolean",
                        "description": "Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.\n"
                    },
                    "networkResourceControlVersion": {
                        "type": "string",
                        "description": "The network I/O control version to use. Can be one of version2 or version3.\n"
                    },
                    "nfsMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.\n"
                    },
                    "nfsShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the nfs traffic class for a custom share level.\n"
                    },
                    "nfsShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "portPrivateSecondaryVlanId": {
                        "type": "integer",
                        "description": "The secondary VLAN ID for this port.\n"
                    },
                    "pvlanMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchPvlanMapping:DistributedVirtualSwitchPvlanMapping"
                        },
                        "description": "A private VLAN (PVLAN) mapping.\n"
                    },
                    "standbyUplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid,\nfailover_explicit, or loadbalance_loadbased.\n"
                    },
                    "txUplink": {
                        "type": "boolean",
                        "description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet\nforwarded done by the switch.\n"
                    },
                    "uplinks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS\nacross hosts.\n"
                    },
                    "vdpMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.\n"
                    },
                    "vdpShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vdp traffic class for a custom share level.\n"
                    },
                    "vdpShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "The version of the VDS. BY default, a VDS is created\nat the latest version supported by the vSphere version if not specified.\nA VDS can be upgraded to a newer version, but can not be downgraded.\n"
                    },
                    "virtualmachineMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.\n"
                    },
                    "virtualmachineShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.\n"
                    },
                    "virtualmachineShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vlanRanges": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/DistributedVirtualSwitchVlanRange:DistributedVirtualSwitchVlanRange"
                        },
                        "description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.\n"
                    },
                    "vmotionMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.\n"
                    },
                    "vmotionShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.\n"
                    },
                    "vmotionShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.\n"
                    },
                    "vsanMaximumMbit": {
                        "type": "integer",
                        "description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanReservationMbit": {
                        "type": "integer",
                        "description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.\n"
                    },
                    "vsanShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to the vsan traffic class for a custom share level.\n"
                    },
                    "vsanShareLevel": {
                        "type": "string",
                        "description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/dpmHostOverride:DpmHostOverride": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`dpm_enabled` or `dpm_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n"
                }
            },
            "required": [
                "computeClusterId",
                "hostSystemId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "dpmAutomationLevel": {
                    "type": "string",
                    "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`dpm_enabled` or `dpm_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "dpmEnabled": {
                    "type": "boolean",
                    "description": "Enable DPM support for this host. Default:\n`false`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of the host.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DpmHostOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "dpmAutomationLevel": {
                        "type": "string",
                        "description": "The automation level for host power\noperations on this host. Can be one of `manual` or `automated`. Default:\n`manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`dpm_enabled` or `dpm_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                    },
                    "dpmEnabled": {
                        "type": "boolean",
                        "description": "Enable DPM support for this host. Default:\n`false`.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of the host.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/drsVmOverride:DrsVmOverride": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n"
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`drs_enabled` or `drs_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "drsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`drs_enabled` or `drs_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                },
                "drsEnabled": {
                    "type": "boolean",
                    "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DrsVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the cluster to put the override in.  Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "drsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides the automation level for this virtual\nmachine in the cluster. Can be one of `manual`, `partiallyAutomated`, or\n`fullyAutomated`. Default: `manual`.\n\n\u003e **NOTE:** Using this resource _always_ implies an override, even if one of\n`drs_enabled` or `drs_automation_level` is omitted. Take note of the defaults\nfor both options.\n"
                    },
                    "drsEnabled": {
                        "type": "boolean",
                        "description": "Overrides the default DRS setting for this virtual\nmachine. Can be either `true` or `false`. Default: `false`.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/entityPermissions:EntityPermissions": {
            "properties": {
                "entityId": {
                    "type": "string",
                    "description": "The managed object id (uuid for some entities) on\nwhich permissions are to be created.\n"
                },
                "entityType": {
                    "type": "string",
                    "description": "The managed object type, types can be found in the\nmanaged object type section\n[here](https://developer.broadcom.com/xapis/vsphere-web-services-api/latest/).\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                    },
                    "description": "The permissions to be given on this entity. Keep\nthe permissions sorted alphabetically on `user_or_group` for a better user\nexperience.\n"
                }
            },
            "required": [
                "entityId",
                "entityType",
                "permissions"
            ],
            "inputProperties": {
                "entityId": {
                    "type": "string",
                    "description": "The managed object id (uuid for some entities) on\nwhich permissions are to be created.\n"
                },
                "entityType": {
                    "type": "string",
                    "description": "The managed object type, types can be found in the\nmanaged object type section\n[here](https://developer.broadcom.com/xapis/vsphere-web-services-api/latest/).\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                    },
                    "description": "The permissions to be given on this entity. Keep\nthe permissions sorted alphabetically on `user_or_group` for a better user\nexperience.\n"
                }
            },
            "requiredInputs": [
                "entityId",
                "entityType",
                "permissions"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EntityPermissions resources.\n",
                "properties": {
                    "entityId": {
                        "type": "string",
                        "description": "The managed object id (uuid for some entities) on\nwhich permissions are to be created.\n"
                    },
                    "entityType": {
                        "type": "string",
                        "description": "The managed object type, types can be found in the\nmanaged object type section\n[here](https://developer.broadcom.com/xapis/vsphere-web-services-api/latest/).\n"
                    },
                    "permissions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/EntityPermissionsPermission:EntityPermissionsPermission"
                        },
                        "description": "The permissions to be given on this entity. Keep\nthe permissions sorted alphabetically on `user_or_group` for a better user\nexperience.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/file:File": {
            "description": "## Example Usage\n\n### Uploading a File\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuVmdkUpload = new vsphere.File(\"ubuntu_vmdk_upload\", {\n    datacenter: \"dc-01\",\n    datastore: \"datastore-01\",\n    sourceFile: \"/my/src/path/custom_ubuntu.vmdk\",\n    destinationFile: \"/my/dst/path/custom_ubuntu.vmdk\",\n    createDirectories: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_vmdk_upload = vsphere.File(\"ubuntu_vmdk_upload\",\n    datacenter=\"dc-01\",\n    datastore=\"datastore-01\",\n    source_file=\"/my/src/path/custom_ubuntu.vmdk\",\n    destination_file=\"/my/dst/path/custom_ubuntu.vmdk\",\n    create_directories=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuVmdkUpload = new VSphere.File(\"ubuntu_vmdk_upload\", new()\n    {\n        Datacenter = \"dc-01\",\n        Datastore = \"datastore-01\",\n        SourceFile = \"/my/src/path/custom_ubuntu.vmdk\",\n        DestinationFile = \"/my/dst/path/custom_ubuntu.vmdk\",\n        CreateDirectories = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewFile(ctx, \"ubuntu_vmdk_upload\", \u0026vsphere.FileArgs{\n\t\t\tDatacenter:        pulumi.String(\"dc-01\"),\n\t\t\tDatastore:         pulumi.String(\"datastore-01\"),\n\t\t\tSourceFile:        pulumi.String(\"/my/src/path/custom_ubuntu.vmdk\"),\n\t\t\tDestinationFile:   pulumi.String(\"/my/dst/path/custom_ubuntu.vmdk\"),\n\t\t\tCreateDirectories: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.File;\nimport com.pulumi.vsphere.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntuVmdkUpload = new File(\"ubuntuVmdkUpload\", FileArgs.builder()\n            .datacenter(\"dc-01\")\n            .datastore(\"datastore-01\")\n            .sourceFile(\"/my/src/path/custom_ubuntu.vmdk\")\n            .destinationFile(\"/my/dst/path/custom_ubuntu.vmdk\")\n            .createDirectories(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuVmdkUpload:\n    type: vsphere:File\n    name: ubuntu_vmdk_upload\n    properties:\n      datacenter: dc-01\n      datastore: datastore-01\n      sourceFile: /my/src/path/custom_ubuntu.vmdk\n      destinationFile: /my/dst/path/custom_ubuntu.vmdk\n      createDirectories: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Copying a File\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst ubuntuCopy = new vsphere.File(\"ubuntu_copy\", {\n    sourceDatacenter: \"dc-01\",\n    datacenter: \"dc-01\",\n    sourceDatastore: \"datastore-01\",\n    datastore: \"datastore-01\",\n    sourceFile: \"/my/src/path/custom_ubuntu.vmdk\",\n    destinationFile: \"/my/dst/path/custom_ubuntu.vmdk\",\n    createDirectories: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nubuntu_copy = vsphere.File(\"ubuntu_copy\",\n    source_datacenter=\"dc-01\",\n    datacenter=\"dc-01\",\n    source_datastore=\"datastore-01\",\n    datastore=\"datastore-01\",\n    source_file=\"/my/src/path/custom_ubuntu.vmdk\",\n    destination_file=\"/my/dst/path/custom_ubuntu.vmdk\",\n    create_directories=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ubuntuCopy = new VSphere.File(\"ubuntu_copy\", new()\n    {\n        SourceDatacenter = \"dc-01\",\n        Datacenter = \"dc-01\",\n        SourceDatastore = \"datastore-01\",\n        Datastore = \"datastore-01\",\n        SourceFile = \"/my/src/path/custom_ubuntu.vmdk\",\n        DestinationFile = \"/my/dst/path/custom_ubuntu.vmdk\",\n        CreateDirectories = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewFile(ctx, \"ubuntu_copy\", \u0026vsphere.FileArgs{\n\t\t\tSourceDatacenter:  pulumi.String(\"dc-01\"),\n\t\t\tDatacenter:        pulumi.String(\"dc-01\"),\n\t\t\tSourceDatastore:   pulumi.String(\"datastore-01\"),\n\t\t\tDatastore:         pulumi.String(\"datastore-01\"),\n\t\t\tSourceFile:        pulumi.String(\"/my/src/path/custom_ubuntu.vmdk\"),\n\t\t\tDestinationFile:   pulumi.String(\"/my/dst/path/custom_ubuntu.vmdk\"),\n\t\t\tCreateDirectories: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.File;\nimport com.pulumi.vsphere.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ubuntuCopy = new File(\"ubuntuCopy\", FileArgs.builder()\n            .sourceDatacenter(\"dc-01\")\n            .datacenter(\"dc-01\")\n            .sourceDatastore(\"datastore-01\")\n            .datastore(\"datastore-01\")\n            .sourceFile(\"/my/src/path/custom_ubuntu.vmdk\")\n            .destinationFile(\"/my/dst/path/custom_ubuntu.vmdk\")\n            .createDirectories(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ubuntuCopy:\n    type: vsphere:File\n    name: ubuntu_copy\n    properties:\n      sourceDatacenter: dc-01\n      datacenter: dc-01\n      sourceDatastore: datastore-01\n      datastore: datastore-01\n      sourceFile: /my/src/path/custom_ubuntu.vmdk\n      destinationFile: /my/dst/path/custom_ubuntu.vmdk\n      createDirectories: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter on first apply if any are missing for copy operation.\n\n\u003e **NOTE:** Any directory created as part of the `create_directories` argument\nwill not be deleted when the resource is destroyed. New directories are not\ncreated if the `destination_file` path is changed in subsequent applies.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter to which the file will be\nuploaded.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore to which to upload the\nfile.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on the destination `datastore` in vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter from which the file\nwill be copied. Forces a new resource if changed.\n"
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore from which file will\nbe copied. Forces a new resource if changed.\n"
                },
                "sourceFile": {
                    "type": "string"
                }
            },
            "required": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "inputProperties": {
                "createDirectories": {
                    "type": "boolean",
                    "description": "Create directories in `destination_file`\npath parameter on first apply if any are missing for copy operation.\n\n\u003e **NOTE:** Any directory created as part of the `create_directories` argument\nwill not be deleted when the resource is destroyed. New directories are not\ncreated if the `destination_file` path is changed in subsequent applies.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of a datacenter to which the file will be\nuploaded.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore to which to upload the\nfile.\n"
                },
                "destinationFile": {
                    "type": "string",
                    "description": "The path to where the file should be uploaded\nor copied to on the destination `datastore` in vSphere.\n"
                },
                "sourceDatacenter": {
                    "type": "string",
                    "description": "The name of a datacenter from which the file\nwill be copied. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "sourceDatastore": {
                    "type": "string",
                    "description": "The name of the datastore from which file will\nbe copied. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "sourceFile": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datastore",
                "destinationFile",
                "sourceFile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering File resources.\n",
                "properties": {
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Create directories in `destination_file`\npath parameter on first apply if any are missing for copy operation.\n\n\u003e **NOTE:** Any directory created as part of the `create_directories` argument\nwill not be deleted when the resource is destroyed. New directories are not\ncreated if the `destination_file` path is changed in subsequent applies.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of a datacenter to which the file will be\nuploaded.\n"
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore to which to upload the\nfile.\n"
                    },
                    "destinationFile": {
                        "type": "string",
                        "description": "The path to where the file should be uploaded\nor copied to on the destination `datastore` in vSphere.\n"
                    },
                    "sourceDatacenter": {
                        "type": "string",
                        "description": "The name of a datacenter from which the file\nwill be copied. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceDatastore": {
                        "type": "string",
                        "description": "The name of the datastore from which file will\nbe copied. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "sourceFile": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/folder:Folder": {
            "properties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n\n\u003e **NOTE:** `path` can be modified - the resulting behavior is dependent on\nwhat section of `path` you are modifying. If you are modifying the parent (so\nany part before the last `/`), your folder will be moved to that new parent. If\nmodifying the name (the part after the last `/`), your folder will be renamed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n"
                }
            },
            "required": [
                "path",
                "type"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute\nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n\n\u003e **NOTE:** `path` can be modified - the resulting behavior is dependent on\nwhat section of `path` you are modifying. If you are modifying the parent (so\nany part before the last `/`), your folder will be moved to that new parent. If\nmodifying the name (the part after the last `/`), your folder will be renamed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "path",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Folder resources.\n",
                "properties": {
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute\nvalue strings to set for folder. See [here][docs-setting-custom-attributes]\nfor a reference on how to set values for custom attributes.\n\n[docs-setting-custom-attributes]: /docs/providers/vsphere/r/custom_attribute.html#using-custom-attributes-in-a-supported-resource\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter the folder will be created in.\nRequired for all folder types except for datacenter folders. Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The path of the folder to be created. This is relative to\nthe root of the type of folder you are creating, and the supplied datacenter.\nFor example, given a default datacenter of `default-dc`, a folder of type\n`vm` (denoting a virtual machine folder), and a supplied folder of\n`test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`.\n\n\u003e **NOTE:** `path` can be modified - the resulting behavior is dependent on\nwhat section of `path` you are modifying. If you are modifying the parent (so\nany part before the last `/`), your folder will be moved to that new parent. If\nmodifying the name (the part after the last `/`), your folder will be renamed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of folder to create. Allowed options are\n`datacenter` for datacenter folders, `host` for host and cluster folders,\n`vm` for virtual machine folders, `datastore` for datastore folders, and\n`network` for network folders. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/guestOsCustomization:GuestOsCustomization": {
            "description": "The `vsphere.GuestOsCustomization` resource can be used to a customization specification for a guest operating system.\n\n\u003e **NOTE:** The name attribute is unique identifier for the guest OS spec per VC.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst windows = new vsphere.GuestOsCustomization(\"windows\", {\n    name: \"windows\",\n    type: \"Windows\",\n    spec: {\n        windowsOptions: {\n            runOnceCommandLists: [\n                \"command-1\",\n                \"command-2\",\n            ],\n            computerName: \"windows\",\n            autoLogon: false,\n            autoLogonCount: 0,\n            adminPassword: \"VMware1!\",\n            timeZone: 4,\n            workgroup: \"workgroup\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nwindows = vsphere.GuestOsCustomization(\"windows\",\n    name=\"windows\",\n    type=\"Windows\",\n    spec={\n        \"windows_options\": {\n            \"run_once_command_lists\": [\n                \"command-1\",\n                \"command-2\",\n            ],\n            \"computer_name\": \"windows\",\n            \"auto_logon\": False,\n            \"auto_logon_count\": 0,\n            \"admin_password\": \"VMware1!\",\n            \"time_zone\": 4,\n            \"workgroup\": \"workgroup\",\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var windows = new VSphere.GuestOsCustomization(\"windows\", new()\n    {\n        Name = \"windows\",\n        Type = \"Windows\",\n        Spec = new VSphere.Inputs.GuestOsCustomizationSpecArgs\n        {\n            WindowsOptions = new VSphere.Inputs.GuestOsCustomizationSpecWindowsOptionsArgs\n            {\n                RunOnceCommandLists = new[]\n                {\n                    \"command-1\",\n                    \"command-2\",\n                },\n                ComputerName = \"windows\",\n                AutoLogon = false,\n                AutoLogonCount = 0,\n                AdminPassword = \"VMware1!\",\n                TimeZone = 4,\n                Workgroup = \"workgroup\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewGuestOsCustomization(ctx, \"windows\", \u0026vsphere.GuestOsCustomizationArgs{\n\t\t\tName: pulumi.String(\"windows\"),\n\t\t\tType: pulumi.String(\"Windows\"),\n\t\t\tSpec: \u0026vsphere.GuestOsCustomizationSpecArgs{\n\t\t\t\tWindowsOptions: \u0026vsphere.GuestOsCustomizationSpecWindowsOptionsArgs{\n\t\t\t\t\tRunOnceCommandLists: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"command-1\"),\n\t\t\t\t\t\tpulumi.String(\"command-2\"),\n\t\t\t\t\t},\n\t\t\t\t\tComputerName:   pulumi.String(\"windows\"),\n\t\t\t\t\tAutoLogon:      pulumi.Bool(false),\n\t\t\t\t\tAutoLogonCount: pulumi.Int(0),\n\t\t\t\t\tAdminPassword:  pulumi.String(\"VMware1!\"),\n\t\t\t\t\tTimeZone:       pulumi.Int(4),\n\t\t\t\t\tWorkgroup:      pulumi.String(\"workgroup\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.GuestOsCustomization;\nimport com.pulumi.vsphere.GuestOsCustomizationArgs;\nimport com.pulumi.vsphere.inputs.GuestOsCustomizationSpecArgs;\nimport com.pulumi.vsphere.inputs.GuestOsCustomizationSpecWindowsOptionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var windows = new GuestOsCustomization(\"windows\", GuestOsCustomizationArgs.builder()\n            .name(\"windows\")\n            .type(\"Windows\")\n            .spec(GuestOsCustomizationSpecArgs.builder()\n                .windowsOptions(GuestOsCustomizationSpecWindowsOptionsArgs.builder()\n                    .runOnceCommandLists(                    \n                        \"command-1\",\n                        \"command-2\")\n                    .computerName(\"windows\")\n                    .autoLogon(false)\n                    .autoLogonCount(0)\n                    .adminPassword(\"VMware1!\")\n                    .timeZone(4)\n                    .workgroup(\"workgroup\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  windows:\n    type: vsphere:GuestOsCustomization\n    properties:\n      name: windows\n      type: Windows\n      spec:\n        windowsOptions:\n          runOnceCommandLists:\n            - command-1\n            - command-2\n          computerName: windows\n          autoLogon: false\n          autoLogonCount: 0\n          adminPassword: VMware1!\n          timeZone: 4\n          workgroup: workgroup\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "changeVersion": {
                    "type": "string",
                    "description": "The number of last changed version to the customization specification.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description for the customization specification.\n"
                },
                "lastUpdateTime": {
                    "type": "string",
                    "description": "The time of last modification to the customization specification.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the customization specification is the unique identifier per vCenter Server instance.\n"
                },
                "spec": {
                    "$ref": "#/types/vsphere:index/GuestOsCustomizationSpec:GuestOsCustomizationSpec",
                    "description": "Container object for the Guest OS properties about to be customized . See virtual machine customizations\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of customization specification: One among: Windows, Linux.\n"
                }
            },
            "required": [
                "changeVersion",
                "lastUpdateTime",
                "name",
                "spec",
                "type"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "The description for the customization specification.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the customization specification is the unique identifier per vCenter Server instance.\n"
                },
                "spec": {
                    "$ref": "#/types/vsphere:index/GuestOsCustomizationSpec:GuestOsCustomizationSpec",
                    "description": "Container object for the Guest OS properties about to be customized . See virtual machine customizations\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of customization specification: One among: Windows, Linux.\n"
                }
            },
            "requiredInputs": [
                "spec",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GuestOsCustomization resources.\n",
                "properties": {
                    "changeVersion": {
                        "type": "string",
                        "description": "The number of last changed version to the customization specification.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description for the customization specification.\n"
                    },
                    "lastUpdateTime": {
                        "type": "string",
                        "description": "The time of last modification to the customization specification.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the customization specification is the unique identifier per vCenter Server instance.\n"
                    },
                    "spec": {
                        "$ref": "#/types/vsphere:index/GuestOsCustomizationSpec:GuestOsCustomizationSpec",
                        "description": "Container object for the Guest OS properties about to be customized . See virtual machine customizations\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of customization specification: One among: Windows, Linux.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/haVmOverride:HaVmOverride": {
            "properties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object ID of the cluster.\n"
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine if an APD status on an affected datastore clears in the middle of an\nAPD event. Can be one of useClusterDefault, none or reset.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, restartConservative, or restartAggressive.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in seconds to wait after an APD timeout event to execute the response action defined in\nha_datastore_apd_response. Specify -1 to use the cluster setting.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine when the cluster has detected a permanent device loss to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, or restartAggressive.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual machine when a host is isolated from the rest of the cluster. Can be one of\nclusterIsolationResponse, none, powerOff, or shutdown.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual machine is not received within this configured interval, the virtual machine is marked\nas failed. The value is in seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will perform to this virtual machine when responding to a failure event.\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after powering on this virtual machine before monitoring for heartbeats.\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use for this virtual machine. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or not the cluster's default settings or the VM override settings specified in this resource are used\nfor virtual machine monitoring. The default is true (use cluster defaults) - set to false to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for this virtual machine when vSphere detects a host failure. Can be one of clusterRestartPriority,\nlowest, low, medium, high, or highest.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that vSphere HA will wait for the virtual machine to be ready. Use -1 to use the cluster\ndefault.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The managed object ID of the virtual machine.\n"
                }
            },
            "required": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "computeClusterId": {
                    "type": "string",
                    "description": "The managed object ID of the cluster.\n",
                    "willReplaceOnChanges": true
                },
                "haDatastoreApdRecoveryAction": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine if an APD status on an affected datastore clears in the middle of an\nAPD event. Can be one of useClusterDefault, none or reset.\n"
                },
                "haDatastoreApdResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, restartConservative, or restartAggressive.\n"
                },
                "haDatastoreApdResponseDelay": {
                    "type": "integer",
                    "description": "Controls the delay in seconds to wait after an APD timeout event to execute the response action defined in\nha_datastore_apd_response. Specify -1 to use the cluster setting.\n"
                },
                "haDatastorePdlResponse": {
                    "type": "string",
                    "description": "Controls the action to take on this virtual machine when the cluster has detected a permanent device loss to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, or restartAggressive.\n"
                },
                "haHostIsolationResponse": {
                    "type": "string",
                    "description": "The action to take on this virtual machine when a host is isolated from the rest of the cluster. Can be one of\nclusterIsolationResponse, none, powerOff, or shutdown.\n"
                },
                "haVmFailureInterval": {
                    "type": "integer",
                    "description": "If a heartbeat from this virtual machine is not received within this configured interval, the virtual machine is marked\nas failed. The value is in seconds.\n"
                },
                "haVmMaximumFailureWindow": {
                    "type": "integer",
                    "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                },
                "haVmMaximumResets": {
                    "type": "integer",
                    "description": "The maximum number of resets that HA will perform to this virtual machine when responding to a failure event.\n"
                },
                "haVmMinimumUptime": {
                    "type": "integer",
                    "description": "The time, in seconds, that HA waits after powering on this virtual machine before monitoring for heartbeats.\n"
                },
                "haVmMonitoring": {
                    "type": "string",
                    "description": "The type of virtual machine monitoring to use for this virtual machine. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                },
                "haVmMonitoringUseClusterDefaults": {
                    "type": "boolean",
                    "description": "Determines whether or not the cluster's default settings or the VM override settings specified in this resource are used\nfor virtual machine monitoring. The default is true (use cluster defaults) - set to false to have overrides take effect.\n"
                },
                "haVmRestartPriority": {
                    "type": "string",
                    "description": "The restart priority for this virtual machine when vSphere detects a host failure. Can be one of clusterRestartPriority,\nlowest, low, medium, high, or highest.\n"
                },
                "haVmRestartTimeout": {
                    "type": "integer",
                    "description": "The maximum time, in seconds, that vSphere HA will wait for the virtual machine to be ready. Use -1 to use the cluster\ndefault.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The managed object ID of the virtual machine.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "computeClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HaVmOverride resources.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The managed object ID of the cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "haDatastoreApdRecoveryAction": {
                        "type": "string",
                        "description": "Controls the action to take on this virtual machine if an APD status on an affected datastore clears in the middle of an\nAPD event. Can be one of useClusterDefault, none or reset.\n"
                    },
                    "haDatastoreApdResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this virtual machine when the cluster has detected loss to all paths to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, restartConservative, or restartAggressive.\n"
                    },
                    "haDatastoreApdResponseDelay": {
                        "type": "integer",
                        "description": "Controls the delay in seconds to wait after an APD timeout event to execute the response action defined in\nha_datastore_apd_response. Specify -1 to use the cluster setting.\n"
                    },
                    "haDatastorePdlResponse": {
                        "type": "string",
                        "description": "Controls the action to take on this virtual machine when the cluster has detected a permanent device loss to a relevant\ndatastore. Can be one of clusterDefault, disabled, warning, or restartAggressive.\n"
                    },
                    "haHostIsolationResponse": {
                        "type": "string",
                        "description": "The action to take on this virtual machine when a host is isolated from the rest of the cluster. Can be one of\nclusterIsolationResponse, none, powerOff, or shutdown.\n"
                    },
                    "haVmFailureInterval": {
                        "type": "integer",
                        "description": "If a heartbeat from this virtual machine is not received within this configured interval, the virtual machine is marked\nas failed. The value is in seconds.\n"
                    },
                    "haVmMaximumFailureWindow": {
                        "type": "integer",
                        "description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are\nattempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset\ntime is allotted.\n"
                    },
                    "haVmMaximumResets": {
                        "type": "integer",
                        "description": "The maximum number of resets that HA will perform to this virtual machine when responding to a failure event.\n"
                    },
                    "haVmMinimumUptime": {
                        "type": "integer",
                        "description": "The time, in seconds, that HA waits after powering on this virtual machine before monitoring for heartbeats.\n"
                    },
                    "haVmMonitoring": {
                        "type": "string",
                        "description": "The type of virtual machine monitoring to use for this virtual machine. Can be one of vmMonitoringDisabled,\nvmMonitoringOnly, or vmAndAppMonitoring.\n"
                    },
                    "haVmMonitoringUseClusterDefaults": {
                        "type": "boolean",
                        "description": "Determines whether or not the cluster's default settings or the VM override settings specified in this resource are used\nfor virtual machine monitoring. The default is true (use cluster defaults) - set to false to have overrides take effect.\n"
                    },
                    "haVmRestartPriority": {
                        "type": "string",
                        "description": "The restart priority for this virtual machine when vSphere detects a host failure. Can be one of clusterRestartPriority,\nlowest, low, medium, high, or highest.\n"
                    },
                    "haVmRestartTimeout": {
                        "type": "integer",
                        "description": "The maximum time, in seconds, that vSphere HA will wait for the virtual machine to be ready. Use -1 to use the cluster\ndefault.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The managed object ID of the virtual machine.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/host:Host": {
            "description": "Provides a VMware vSphere host resource. This represents an ESXi host that\ncan be used either as a member of a cluster or as a standalone host.\n\n## Example Usage\n\n### Create a standalone host\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst thumbprint = vsphere.getHostThumbprint({\n    address: \"esx-01.example.com\",\n    insecure: true,\n});\nconst esx_01 = new vsphere.Host(\"esx-01\", {\n    hostname: \"esx-01.example.com\",\n    username: \"root\",\n    password: \"password\",\n    license: \"00000-00000-00000-00000-00000\",\n    thumbprint: thumbprint.then(thumbprint =\u003e thumbprint.id),\n    datacenter: datacenter.then(datacenter =\u003e datacenter.id),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nthumbprint = vsphere.get_host_thumbprint(address=\"esx-01.example.com\",\n    insecure=True)\nesx_01 = vsphere.Host(\"esx-01\",\n    hostname=\"esx-01.example.com\",\n    username=\"root\",\n    password=\"password\",\n    license=\"00000-00000-00000-00000-00000\",\n    thumbprint=thumbprint.id,\n    datacenter=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var thumbprint = VSphere.GetHostThumbprint.Invoke(new()\n    {\n        Address = \"esx-01.example.com\",\n        Insecure = true,\n    });\n\n    var esx_01 = new VSphere.Host(\"esx-01\", new()\n    {\n        Hostname = \"esx-01.example.com\",\n        Username = \"root\",\n        Password = \"password\",\n        License = \"00000-00000-00000-00000-00000\",\n        Thumbprint = thumbprint.Apply(getHostThumbprintResult =\u003e getHostThumbprintResult.Id),\n        Datacenter = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthumbprint, err := vsphere.GetHostThumbprint(ctx, \u0026vsphere.GetHostThumbprintArgs{\n\t\t\tAddress:  \"esx-01.example.com\",\n\t\t\tInsecure: pulumi.BoolRef(true),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHost(ctx, \"esx-01\", \u0026vsphere.HostArgs{\n\t\t\tHostname:   pulumi.String(\"esx-01.example.com\"),\n\t\t\tUsername:   pulumi.String(\"root\"),\n\t\t\tPassword:   pulumi.String(\"password\"),\n\t\t\tLicense:    pulumi.String(\"00000-00000-00000-00000-00000\"),\n\t\t\tThumbprint: pulumi.String(thumbprint.Id),\n\t\t\tDatacenter: pulumi.String(datacenter.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostThumbprintArgs;\nimport com.pulumi.vsphere.Host;\nimport com.pulumi.vsphere.HostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var thumbprint = VsphereFunctions.getHostThumbprint(GetHostThumbprintArgs.builder()\n            .address(\"esx-01.example.com\")\n            .insecure(true)\n            .build());\n\n        var esx_01 = new Host(\"esx-01\", HostArgs.builder()\n            .hostname(\"esx-01.example.com\")\n            .username(\"root\")\n            .password(\"password\")\n            .license(\"00000-00000-00000-00000-00000\")\n            .thumbprint(thumbprint.applyValue(getHostThumbprintResult -\u003e getHostThumbprintResult.id()))\n            .datacenter(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  esx-01:\n    type: vsphere:Host\n    properties:\n      hostname: esx-01.example.com\n      username: root\n      password: password\n      license: 00000-00000-00000-00000-00000\n      thumbprint: ${thumbprint.id}\n      datacenter: ${datacenter.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  thumbprint:\n    fn::invoke:\n      Function: vsphere:getHostThumbprint\n      Arguments:\n        address: esx-01.example.com\n        insecure: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Importing\n\nAn existing host can be [imported][docs-import] into this resource by supplying\nthe host's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```\nterraform import vsphere_host.esx-01 host-123\n```\n\nThe above would import the host with ID `host-123`.\n",
            "properties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster_managed`.\n"
                },
                "clusterManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconnected.\nDefault is `false`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute IDs and string\nvalues to apply to the resource. Please refer to the\n`vsphere_custom_attributes` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n\n[docs-host-thumbprint-data-source]: /docs/providers/vsphere/d/host_thumbprint.html\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to `true` then it will force the host to be added,\neven if the host is already connected to a different vCenter Server instance.\nDefault is `false`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host.\nDefault is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n",
                    "secret": true
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/HostService:HostService"
                    },
                    "description": "Set Services on host, the settings to be set are based on service being set as part of import.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. Please\nrefer to the `vsphere.Tag` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Tagging support is not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the\nCA that signed the host's certificate should be trusted. If the CA is not\ntrusted and no thumbprint is set then the operation will fail. See data source\n[`vsphere.getHostThumbprint`][docs-host-thumbprint-data-source].\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "required": [
                "hostname",
                "password",
                "username"
            ],
            "inputProperties": {
                "cluster": {
                    "type": "string",
                    "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster_managed`.\n"
                },
                "clusterManaged": {
                    "type": "boolean",
                    "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                },
                "connected": {
                    "type": "boolean",
                    "description": "If set to false then the host will be disconnected.\nDefault is `false`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of custom attribute IDs and string\nvalues to apply to the resource. Please refer to the\n`vsphere_custom_attributes` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n\n[docs-host-thumbprint-data-source]: /docs/providers/vsphere/d/host_thumbprint.html\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                },
                "force": {
                    "type": "boolean",
                    "description": "If set to `true` then it will force the host to be added,\neven if the host is already connected to a different vCenter Server instance.\nDefault is `false`.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "FQDN or IP address of the host to be added.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                },
                "lockdown": {
                    "type": "string",
                    "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                },
                "maintenance": {
                    "type": "boolean",
                    "description": "Set the management state of the host.\nDefault is `false`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password that will be used by vSphere to authenticate\nto the host.\n",
                    "secret": true
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/HostService:HostService"
                    },
                    "description": "Set Services on host, the settings to be set are based on service being set as part of import.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. Please\nrefer to the `vsphere.Tag` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Tagging support is not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                },
                "thumbprint": {
                    "type": "string",
                    "description": "Host's certificate SHA-1 thumbprint. If not set the\nCA that signed the host's certificate should be trusted. If the CA is not\ntrusted and no thumbprint is set then the operation will fail. See data source\n[`vsphere.getHostThumbprint`][docs-host-thumbprint-data-source].\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                }
            },
            "requiredInputs": [
                "hostname",
                "password",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Host resources.\n",
                "properties": {
                    "cluster": {
                        "type": "string",
                        "description": "The ID of the Compute Cluster this host should\nbe added to. This should not be set if `datacenter` is set. Conflicts with:\n`cluster_managed`.\n"
                    },
                    "clusterManaged": {
                        "type": "boolean",
                        "description": "Can be set to `true` if compute cluster\nmembership will be managed through the `compute_cluster` resource rather\nthan the`host` resource. Conflicts with: `cluster`.\n"
                    },
                    "connected": {
                        "type": "boolean",
                        "description": "If set to false then the host will be disconnected.\nDefault is `false`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of custom attribute IDs and string\nvalues to apply to the resource. Please refer to the\n`vsphere_custom_attributes` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Custom attributes are not supported on direct ESXi host\nconnections and require vCenter Server.\n\n[docs-host-thumbprint-data-source]: /docs/providers/vsphere/d/host_thumbprint.html\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The ID of the datacenter this host should\nbe added to. This should not be set if `cluster` is set.\n"
                    },
                    "force": {
                        "type": "boolean",
                        "description": "If set to `true` then it will force the host to be added,\neven if the host is already connected to a different vCenter Server instance.\nDefault is `false`.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "FQDN or IP address of the host to be added.\n"
                    },
                    "license": {
                        "type": "string",
                        "description": "The license key that will be applied to the host.\nThe license key is expected to be present in vSphere.\n"
                    },
                    "lockdown": {
                        "type": "string",
                        "description": "Set the lockdown state of the host. Valid options are\n`disabled`, `normal`, and `strict`. Default is `disabled`.\n"
                    },
                    "maintenance": {
                        "type": "boolean",
                        "description": "Set the management state of the host.\nDefault is `false`.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password that will be used by vSphere to authenticate\nto the host.\n",
                        "secret": true
                    },
                    "services": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/HostService:HostService"
                        },
                        "description": "Set Services on host, the settings to be set are based on service being set as part of import.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. Please\nrefer to the `vsphere.Tag` resource for more information on applying\ntags to resources.\n\n\u003e **NOTE:** Tagging support is not supported on direct ESXi host\nconnections and require vCenter Server.\n"
                    },
                    "thumbprint": {
                        "type": "string",
                        "description": "Host's certificate SHA-1 thumbprint. If not set the\nCA that signed the host's certificate should be trusted. If the CA is not\ntrusted and no thumbprint is set then the operation will fail. See data source\n[`vsphere.getHostThumbprint`][docs-host-thumbprint-data-source].\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username that will be used by vSphere to authenticate\nto the host.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostPortGroup:HostPortGroup": {
            "description": "The `vsphere.HostPortGroup` resource can be used to manage port groups on\nESXi hosts. These port groups are connected to standard switches, which\ncan be managed by the `vsphere.HostVirtualSwitch`\nresource.\n\nFor an overview on vSphere networking concepts, see [the product documentation][ref-vsphere-net-concepts].\n\n[ref-vsphere-net-concepts]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html\n\n## Example Usage\n\n**Create a Virtual Switch and Bind a Port Group:**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst hostVirtualSwitch = new vsphere.HostVirtualSwitch(\"host_virtual_switch\", {\n    name: \"switch-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    activeNics: [\"vmnic0\"],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    name: \"portgroup-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    virtualSwitchName: hostVirtualSwitch.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nhost_virtual_switch = vsphere.HostVirtualSwitch(\"host_virtual_switch\",\n    name=\"switch-01\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    active_nics=[\"vmnic0\"],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    name=\"portgroup-01\",\n    host_system_id=host.id,\n    virtual_switch_name=host_virtual_switch.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hostVirtualSwitch = new VSphere.HostVirtualSwitch(\"host_virtual_switch\", new()\n    {\n        Name = \"switch-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic0\",\n            \"vmnic1\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic0\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic1\",\n        },\n    });\n\n    var pg = new VSphere.HostPortGroup(\"pg\", new()\n    {\n        Name = \"portgroup-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        VirtualSwitchName = hostVirtualSwitch.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostVirtualSwitch, err := vsphere.NewHostVirtualSwitch(ctx, \"host_virtual_switch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"switch-01\"),\n\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tName:              pulumi.String(\"portgroup-01\"),\n\t\t\tHostSystemId:      pulumi.String(host.Id),\n\t\t\tVirtualSwitchName: hostVirtualSwitch.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport com.pulumi.vsphere.HostPortGroup;\nimport com.pulumi.vsphere.HostPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var hostVirtualSwitch = new HostVirtualSwitch(\"hostVirtualSwitch\", HostVirtualSwitchArgs.builder()\n            .name(\"switch-01\")\n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .networkAdapters(            \n                \"vmnic0\",\n                \"vmnic1\")\n            .activeNics(\"vmnic0\")\n            .standbyNics(\"vmnic1\")\n            .build());\n\n        var pg = new HostPortGroup(\"pg\", HostPortGroupArgs.builder()\n            .name(\"portgroup-01\")\n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .virtualSwitchName(hostVirtualSwitch.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hostVirtualSwitch:\n    type: vsphere:HostVirtualSwitch\n    name: host_virtual_switch\n    properties:\n      name: switch-01\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic0\n        - vmnic1\n      activeNics:\n        - vmnic0\n      standbyNics:\n        - vmnic1\n  pg:\n    type: vsphere:HostPortGroup\n    properties:\n      name: portgroup-01\n      hostSystemId: ${host.id}\n      virtualSwitchName: ${hostVirtualSwitch.name}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n**Create a Port Group with a VLAN and ab Override:**\n\nThis example sets the trunk mode VLAN (`4095`, which passes through all tags)\nand sets\n`allow_promiscuous`\nto ensure that all traffic is seen on the port. The setting overrides\nthe implicit default of `false` set on the standard switch.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst hostVirtualSwitch = new vsphere.HostVirtualSwitch(\"host_virtual_switch\", {\n    name: \"switch-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    activeNics: [\"vmnic0\"],\n    standbyNics: [\"vmnic1\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    name: \"portgroup-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    virtualSwitchName: hostVirtualSwitch.name,\n    vlanId: 4095,\n    allowPromiscuous: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nhost_virtual_switch = vsphere.HostVirtualSwitch(\"host_virtual_switch\",\n    name=\"switch-01\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic0\",\n        \"vmnic1\",\n    ],\n    active_nics=[\"vmnic0\"],\n    standby_nics=[\"vmnic1\"])\npg = vsphere.HostPortGroup(\"pg\",\n    name=\"portgroup-01\",\n    host_system_id=host.id,\n    virtual_switch_name=host_virtual_switch.name,\n    vlan_id=4095,\n    allow_promiscuous=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hostVirtualSwitch = new VSphere.HostVirtualSwitch(\"host_virtual_switch\", new()\n    {\n        Name = \"switch-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic0\",\n            \"vmnic1\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic0\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic1\",\n        },\n    });\n\n    var pg = new VSphere.HostPortGroup(\"pg\", new()\n    {\n        Name = \"portgroup-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        VirtualSwitchName = hostVirtualSwitch.Name,\n        VlanId = 4095,\n        AllowPromiscuous = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostVirtualSwitch, err := vsphere.NewHostVirtualSwitch(ctx, \"host_virtual_switch\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"switch-01\"),\n\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic0\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tName:              pulumi.String(\"portgroup-01\"),\n\t\t\tHostSystemId:      pulumi.String(host.Id),\n\t\t\tVirtualSwitchName: hostVirtualSwitch.Name,\n\t\t\tVlanId:            pulumi.Int(4095),\n\t\t\tAllowPromiscuous:  pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport com.pulumi.vsphere.HostPortGroup;\nimport com.pulumi.vsphere.HostPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var hostVirtualSwitch = new HostVirtualSwitch(\"hostVirtualSwitch\", HostVirtualSwitchArgs.builder()\n            .name(\"switch-01\")\n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .networkAdapters(            \n                \"vmnic0\",\n                \"vmnic1\")\n            .activeNics(\"vmnic0\")\n            .standbyNics(\"vmnic1\")\n            .build());\n\n        var pg = new HostPortGroup(\"pg\", HostPortGroupArgs.builder()\n            .name(\"portgroup-01\")\n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .virtualSwitchName(hostVirtualSwitch.name())\n            .vlanId(4095)\n            .allowPromiscuous(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hostVirtualSwitch:\n    type: vsphere:HostVirtualSwitch\n    name: host_virtual_switch\n    properties:\n      name: switch-01\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic0\n        - vmnic1\n      activeNics:\n        - vmnic0\n      standbyNics:\n        - vmnic1\n  pg:\n    type: vsphere:HostPortGroup\n    properties:\n      name: portgroup-01\n      hostSystemId: ${host.id}\n      virtualSwitchName: ${hostVirtualSwitch.name}\n      vlanId: 4095\n      allowPromiscuous: true\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Importing\n\nAn existing host port group can be imported into this resource\nusing the host port group's ID. An example is below:\n\n```\nterraform import vsphere_host_port_group.management tf-HostPortGroup:host-123:management\n```\n\nThe above would import the `management` host port group from host with ID `host-123`.\n",
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "computedPolicy": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n"
                },
                "key": {
                    "type": "string",
                    "description": "The key for this port group as returned from the vSphere API.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "ports": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/HostPortGroupPort:HostPortGroupPort"
                    },
                    "description": "A list of ports that currently exist and are used on this port group.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "required": [
                "computedPolicy",
                "hostSystemId",
                "key",
                "name",
                "ports",
                "virtualSwitchName"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the port group.  Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                },
                "virtualSwitchName": {
                    "type": "string",
                    "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "vlanId": {
                    "type": "integer",
                    "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                }
            },
            "requiredInputs": [
                "hostSystemId",
                "virtualSwitchName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostPortGroup resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active network adapters used for load balancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                    },
                    "computedPolicy": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map with a full set of the policy\noptions computed from defaults and overrides,\nexplaining the effective policy for this port group.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the port group up on. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "key": {
                        "type": "string",
                        "description": "The key for this port group as returned from the vSphere API.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the port group.  Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "ports": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/HostPortGroupPort:HostPortGroupPort"
                        },
                        "description": "A list of ports that currently exist and are used on this port group.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Enable traffic shaping on this virtual switch or port group.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby network adapters used for failover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                    },
                    "virtualSwitchName": {
                        "type": "string",
                        "description": "The name of the virtual switch to bind\nthis port group to. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "The VLAN ID/trunk mode for this port group.  An ID of\n`0` denotes no tagging, an ID of `1`-`4094` tags with the specific ID, and an\nID of `4095` enables trunk mode, allowing the guest to manage its own\ntagging. Default: `0`.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/hostVirtualSwitch:HostVirtualSwitch": {
            "properties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "Determines how often, in seconds, a beacon should be sent to probe for the validity of a link.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n"
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid values are cdp and lldp.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n"
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of network adapters to bind to this virtual switch.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n\n\u003e **NOTE:** Changing the port count requires a reboot of the host. This provider\nwill not restart the host for you.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                }
            },
            "required": [
                "activeNics",
                "hostSystemId",
                "name",
                "networkAdapters"
            ],
            "inputProperties": {
                "activeNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of active network adapters used for load balancing.\n"
                },
                "allowForgedTransmits": {
                    "type": "boolean",
                    "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                },
                "allowMacChanges": {
                    "type": "boolean",
                    "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                },
                "allowPromiscuous": {
                    "type": "boolean",
                    "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                },
                "beaconInterval": {
                    "type": "integer",
                    "description": "Determines how often, in seconds, a beacon should be sent to probe for the validity of a link.\n"
                },
                "checkBeacon": {
                    "type": "boolean",
                    "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                },
                "failback": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "linkDiscoveryOperation": {
                    "type": "string",
                    "description": "Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.\n"
                },
                "linkDiscoveryProtocol": {
                    "type": "string",
                    "description": "The discovery protocol type. Valid values are cdp and lldp.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                },
                "networkAdapters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of network adapters to bind to this virtual switch.\n"
                },
                "notifySwitches": {
                    "type": "boolean",
                    "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                },
                "numberOfPorts": {
                    "type": "integer",
                    "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n\n\u003e **NOTE:** Changing the port count requires a reboot of the host. This provider\nwill not restart the host for you.\n"
                },
                "shapingAverageBandwidth": {
                    "type": "integer",
                    "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                },
                "shapingBurstSize": {
                    "type": "integer",
                    "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                },
                "shapingEnabled": {
                    "type": "boolean",
                    "description": "Enable traffic shaping on this virtual switch or port group.\n"
                },
                "shapingPeakBandwidth": {
                    "type": "integer",
                    "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                },
                "standbyNics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of standby network adapters used for failover.\n"
                },
                "teamingPolicy": {
                    "type": "string",
                    "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                }
            },
            "requiredInputs": [
                "activeNics",
                "hostSystemId",
                "networkAdapters"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering HostVirtualSwitch resources.\n",
                "properties": {
                    "activeNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of active network adapters used for load balancing.\n"
                    },
                    "allowForgedTransmits": {
                        "type": "boolean",
                        "description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than\nthat of its own.\n"
                    },
                    "allowMacChanges": {
                        "type": "boolean",
                        "description": "Controls whether or not the Media Access Control (MAC) address can be changed.\n"
                    },
                    "allowPromiscuous": {
                        "type": "boolean",
                        "description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.\n"
                    },
                    "beaconInterval": {
                        "type": "integer",
                        "description": "Determines how often, in seconds, a beacon should be sent to probe for the validity of a link.\n"
                    },
                    "checkBeacon": {
                        "type": "boolean",
                        "description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used\nonly.\n"
                    },
                    "failback": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the virtual switch up on. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "linkDiscoveryOperation": {
                        "type": "string",
                        "description": "Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.\n"
                    },
                    "linkDiscoveryProtocol": {
                        "type": "string",
                        "description": "The discovery protocol type. Valid values are cdp and lldp.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The maximum transmission unit (MTU) for the virtual\nswitch. Default: `1500`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual switch. Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkAdapters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of network adapters to bind to this virtual switch.\n"
                    },
                    "notifySwitches": {
                        "type": "boolean",
                        "description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.\n"
                    },
                    "numberOfPorts": {
                        "type": "integer",
                        "description": "The number of ports to create with this\nvirtual switch. Default: `128`.\n\n\u003e **NOTE:** Changing the port count requires a reboot of the host. This provider\nwill not restart the host for you.\n"
                    },
                    "shapingAverageBandwidth": {
                        "type": "integer",
                        "description": "The average bandwidth in bits per second if traffic shaping is enabled.\n"
                    },
                    "shapingBurstSize": {
                        "type": "integer",
                        "description": "The maximum burst size allowed in bytes if traffic shaping is enabled.\n"
                    },
                    "shapingEnabled": {
                        "type": "boolean",
                        "description": "Enable traffic shaping on this virtual switch or port group.\n"
                    },
                    "shapingPeakBandwidth": {
                        "type": "integer",
                        "description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled.\n"
                    },
                    "standbyNics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of standby network adapters used for failover.\n"
                    },
                    "teamingPolicy": {
                        "type": "string",
                        "description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or\nfailover_explicit.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/license:License": {
            "description": "Provides a VMware vSphere license resource. This can be used to add and remove license keys.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.License;\nimport com.pulumi.vsphere.LicenseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var licenseKey = new License(\"licenseKey\", LicenseArgs.builder()\n            .licenseKey(\"452CQ-2EK54-K8742-00000-00000\")\n            .labels(Map.ofEntries(\n                Map.entry(\"vpxClientLicenseLabel\", \"Hello World\"),\n                Map.entry(\"workflow\", \"Hello World\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  licenseKey:\n    type: vsphere:License\n    properties:\n      licenseKey: 452CQ-2EK54-K8742-00000-00000\n      labels:\n        - vpxClientLicenseLabel: Hello World\n          workflow: Hello World\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "editionKey": {
                    "type": "string",
                    "description": "The product edition of the license key.\n"
                },
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name for the license.\n"
                },
                "total": {
                    "type": "integer",
                    "description": "Total number of units (example: CPUs) contained in the license.\n"
                },
                "used": {
                    "type": "integer",
                    "description": "The number of units (example: CPUs) assigned to this license.\n"
                }
            },
            "required": [
                "editionKey",
                "licenseKey",
                "name",
                "total",
                "used"
            ],
            "inputProperties": {
                "labels": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "The license key to add.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "licenseKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering License resources.\n",
                "properties": {
                    "editionKey": {
                        "type": "string",
                        "description": "The product edition of the license key.\n"
                    },
                    "labels": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of key/value pairs to be attached as labels (tags) to the license key.\n"
                    },
                    "licenseKey": {
                        "type": "string",
                        "description": "The license key to add.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name for the license.\n"
                    },
                    "total": {
                        "type": "integer",
                        "description": "Total number of units (example: CPUs) contained in the license.\n"
                    },
                    "used": {
                        "type": "integer",
                        "description": "The number of units (example: CPUs) assigned to this license.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/nasDatastore:NasDatastore": {
            "properties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n"
                },
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "protocolEndpoint": {
                    "type": "boolean",
                    "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nservers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n"
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n"
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "freeSpace",
                "hostSystemIds",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "protocolEndpoint",
                "remoteHosts",
                "remotePath",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "accessMode": {
                    "type": "string",
                    "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "remoteHosts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The hostnames or IP addresses of the remote\nservers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "remotePath": {
                    "type": "string",
                    "description": "The remote path of the mount point. Forces a new\nresource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "securityType": {
                    "type": "string",
                    "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "hostSystemIds",
                "remoteHosts",
                "remotePath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NasDatastore resources.\n",
                "properties": {
                    "accessMode": {
                        "type": "string",
                        "description": "Access mode for the mount point. Can be one of\n`readOnly` or `readWrite`. Note that `readWrite` does not necessarily mean\nthat the datastore will be read-write depending on the permissions of the\nactual share. Default: `readWrite`. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue strings to set on datasource resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The managed object IDs of\nthe hosts to mount the datastore on.\n"
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "protocolEndpoint": {
                        "type": "boolean",
                        "description": "Indicates that this NAS volume is a protocol endpoint.\nThis field is only populated if the host supports virtual datastores.\n"
                    },
                    "remoteHosts": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The hostnames or IP addresses of the remote\nservers. Only one element should be present for NFS v3 but multiple\ncan be present for NFS v4.1. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "remotePath": {
                        "type": "string",
                        "description": "The remote path of the mount point. Forces a new\nresource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "securityType": {
                        "type": "string",
                        "description": "The security type to use when using NFS v4.1.\nCan be one of `AUTH_SYS`, `SEC_KRB5`, or `SEC_KRB5I`. Forces a new resource\nif changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of NAS volume. Can be one of `NFS` (to denote\nv3) or `NFS41` (to denote NFS v4.1). Default: `NFS`. Forces a new resource if\nchanged.\n",
                        "willReplaceOnChanges": true
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/offlineSoftwareDepot:OfflineSoftwareDepot": {
            "description": "Provides a VMware vSphere offline software depot resource.\n\n## Example Usage\n\n",
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/OfflineSoftwareDepotComponent:OfflineSoftwareDepotComponent"
                    },
                    "description": "The list of custom components in the depot.\n"
                },
                "location": {
                    "type": "string",
                    "description": "The URL where the depot source is hosted.\n"
                }
            },
            "required": [
                "components",
                "location"
            ],
            "inputProperties": {
                "location": {
                    "type": "string",
                    "description": "The URL where the depot source is hosted.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "location"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OfflineSoftwareDepot resources.\n",
                "properties": {
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/OfflineSoftwareDepotComponent:OfflineSoftwareDepotComponent"
                        },
                        "description": "The list of custom components in the depot.\n"
                    },
                    "location": {
                        "type": "string",
                        "description": "The URL where the depot source is hosted.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/resourcePool:ResourcePool": {
            "description": "The `vsphere.ResourcePool` resource can be used to create and manage\nresource pools on DRS-enabled vSphere clusters or standalone ESXi hosts.\n\nFor more information on vSphere resource pools, please refer to the\n[product documentation][ref-vsphere-resource_pools].\n\n[ref-vsphere-resource_pools]: https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-resource-management/GUID-60077B40-66FF-4625-934A-641703ED7601.html\n\n## Example Usage\n\nThe following example sets up a resource pool in an existing compute cluster\nwith the default settings for CPU and memory reservations, shares, and limits.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst computeCluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst resourcePool = new vsphere.ResourcePool(\"resource_pool\", {\n    name: \"resource-pool-01\",\n    parentResourcePoolId: computeCluster.then(computeCluster =\u003e computeCluster.resourcePoolId),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncompute_cluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nresource_pool = vsphere.ResourcePool(\"resource_pool\",\n    name=\"resource-pool-01\",\n    parent_resource_pool_id=compute_cluster.resource_pool_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var resourcePool = new VSphere.ResourcePool(\"resource_pool\", new()\n    {\n        Name = \"resource-pool-01\",\n        ParentResourcePoolId = computeCluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcomputeCluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewResourcePool(ctx, \"resource_pool\", \u0026vsphere.ResourcePoolArgs{\n\t\t\tName:                 pulumi.String(\"resource-pool-01\"),\n\t\t\tParentResourcePoolId: pulumi.String(computeCluster.ResourcePoolId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.ResourcePool;\nimport com.pulumi.vsphere.ResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var resourcePool = new ResourcePool(\"resourcePool\", ResourcePoolArgs.builder()\n            .name(\"resource-pool-01\")\n            .parentResourcePoolId(computeCluster.applyValue(getComputeClusterResult -\u003e getComputeClusterResult.resourcePoolId()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  resourcePool:\n    type: vsphere:ResourcePool\n    name: resource_pool\n    properties:\n      name: resource-pool-01\n      parentResourcePoolId: ${computeCluster.resourcePoolId}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  computeCluster:\n    fn::invoke:\n      Function: vsphere:getComputeCluster\n      Arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nA virtual machine resource could be targeted to use the default resource pool\nof the cluster using the following:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vm = new vsphere.VirtualMachine(\"vm\", {resourcePoolId: cluster.resourcePoolId});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvm = vsphere.VirtualMachine(\"vm\", resource_pool_id=cluster[\"resourcePoolId\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vm = new VSphere.VirtualMachine(\"vm\", new()\n    {\n        ResourcePoolId = cluster.ResourcePoolId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachine(ctx, \"vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tResourcePoolId: pulumi.Any(cluster.ResourcePoolId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vm = new VirtualMachine(\"vm\", VirtualMachineArgs.builder()\n            .resourcePoolId(cluster.resourcePoolId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      resourcePoolId: ${cluster.resourcePoolId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nThe following example sets up a parent resource pool in an existing compute cluster\nwith a child resource pool nested below. Each resource pool is configured with\nthe default settings for CPU and memory reservations, shares, and limits.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst computeCluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst resourcePoolParent = new vsphere.ResourcePool(\"resource_pool_parent\", {\n    name: \"parent\",\n    parentResourcePoolId: computeCluster.then(computeCluster =\u003e computeCluster.resourcePoolId),\n});\nconst resourcePoolChild = new vsphere.ResourcePool(\"resource_pool_child\", {\n    name: \"child\",\n    parentResourcePoolId: resourcePoolParent.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncompute_cluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nresource_pool_parent = vsphere.ResourcePool(\"resource_pool_parent\",\n    name=\"parent\",\n    parent_resource_pool_id=compute_cluster.resource_pool_id)\nresource_pool_child = vsphere.ResourcePool(\"resource_pool_child\",\n    name=\"child\",\n    parent_resource_pool_id=resource_pool_parent.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var resourcePoolParent = new VSphere.ResourcePool(\"resource_pool_parent\", new()\n    {\n        Name = \"parent\",\n        ParentResourcePoolId = computeCluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.ResourcePoolId),\n    });\n\n    var resourcePoolChild = new VSphere.ResourcePool(\"resource_pool_child\", new()\n    {\n        Name = \"child\",\n        ParentResourcePoolId = resourcePoolParent.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcomputeCluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresourcePoolParent, err := vsphere.NewResourcePool(ctx, \"resource_pool_parent\", \u0026vsphere.ResourcePoolArgs{\n\t\t\tName:                 pulumi.String(\"parent\"),\n\t\t\tParentResourcePoolId: pulumi.String(computeCluster.ResourcePoolId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewResourcePool(ctx, \"resource_pool_child\", \u0026vsphere.ResourcePoolArgs{\n\t\t\tName:                 pulumi.String(\"child\"),\n\t\t\tParentResourcePoolId: resourcePoolParent.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.ResourcePool;\nimport com.pulumi.vsphere.ResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var resourcePoolParent = new ResourcePool(\"resourcePoolParent\", ResourcePoolArgs.builder()\n            .name(\"parent\")\n            .parentResourcePoolId(computeCluster.applyValue(getComputeClusterResult -\u003e getComputeClusterResult.resourcePoolId()))\n            .build());\n\n        var resourcePoolChild = new ResourcePool(\"resourcePoolChild\", ResourcePoolArgs.builder()\n            .name(\"child\")\n            .parentResourcePoolId(resourcePoolParent.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  resourcePoolParent:\n    type: vsphere:ResourcePool\n    name: resource_pool_parent\n    properties:\n      name: parent\n      parentResourcePoolId: ${computeCluster.resourcePoolId}\n  resourcePoolChild:\n    type: vsphere:ResourcePool\n    name: resource_pool_child\n    properties:\n      name: child\n      parentResourcePoolId: ${resourcePoolParent.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  computeCluster:\n    fn::invoke:\n      Function: vsphere:getComputeCluster\n      Arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Importing\n\nAn existing resource pool can be imported into this resource via\nthe path to the resource pool, using the following command:\n\n```\nterraform import vsphere_resource_pool.resource_pool /dc-01/host/cluster-01/Resources/resource-pool-01\n```\n\nThe above would import the resource pool named `resource-pool-01` that is located\nin the compute cluster `cluster-01` in the `dc-01` datacenter.\n\n### Settings that Require vSphere 7.0 or higher\n\nThese settings require vSphere 7.0 or higher:\n\n* `scale_descendants_shares`\n",
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool.\n"
                },
                "scaleDescendantsShares": {
                    "type": "string",
                    "description": "Determines if the shares of all\ndescendants of the resource pool are scaled up or down when the shares\nof the resource pool are scaled up or down. Can be one of `disabled` or\n`scaleCpuAndMemoryShares`. Default: `disabled`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the resource pool.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool.\n"
                },
                "scaleDescendantsShares": {
                    "type": "string",
                    "description": "Determines if the shares of all\ndescendants of the resource pool are scaled up or down when the shares\nof the resource pool are scaled up or down. Can be one of `disabled` or\n`scaleCpuAndMemoryShares`. Default: `disabled`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ResourcePool resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a resource\npool can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a resource pool will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the resource pool. Default: `0`\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource pool.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a resource pool\nfrom one parent resource pool to another, both must share a common root\nresource pool.\n"
                    },
                    "scaleDescendantsShares": {
                        "type": "string",
                        "description": "Determines if the shares of all\ndescendants of the resource pool are scaled up or down when the shares\nof the resource pool are scaled up or down. Can be one of `disabled` or\n`scaleCpuAndMemoryShares`. Default: `disabled`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/role:Role": {
            "properties": {
                "label": {
                    "type": "string",
                    "description": "The display label of the role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "rolePrivileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to be associated with this role.\n"
                }
            },
            "required": [
                "label",
                "name"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the role.\n"
                },
                "rolePrivileges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The privileges to be associated with this role.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Role resources.\n",
                "properties": {
                    "label": {
                        "type": "string",
                        "description": "The display label of the role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the role.\n"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges to be associated with this role.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/storageDrsVmOverride:StorageDrsVmOverride": {
            "properties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n"
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n"
                }
            },
            "required": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "inputProperties": {
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "sdrsAutomationLevel": {
                    "type": "string",
                    "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                },
                "sdrsEnabled": {
                    "type": "string",
                    "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                },
                "sdrsIntraVmAffinity": {
                    "type": "string",
                    "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                },
                "virtualMachineId": {
                    "type": "string",
                    "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datastoreClusterId",
                "virtualMachineId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageDrsVmOverride resources.\n",
                "properties": {
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datastore cluster to put the override in.\nForces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "sdrsAutomationLevel": {
                        "type": "string",
                        "description": "Overrides any Storage DRS automation\nlevels for this virtual machine. Can be one of `automated` or `manual`. When\nnot specified, the datastore cluster's settings are used according to the\nspecific SDRS subsystem.\n"
                    },
                    "sdrsEnabled": {
                        "type": "string",
                        "description": "Overrides the default Storage DRS setting for\nthis virtual machine. When not specified, the datastore cluster setting is\nused.\n"
                    },
                    "sdrsIntraVmAffinity": {
                        "type": "string",
                        "description": "Overrides the intra-VM affinity setting\nfor this virtual machine. When `true`, all disks for this virtual machine\nwill be kept on the same datastore. When `false`, Storage DRS may locate\nindividual disks on different datastores if it helps satisfy cluster\nrequirements. When not specified, the datastore cluster's settings are used.\n"
                    },
                    "virtualMachineId": {
                        "type": "string",
                        "description": "The UUID of the virtual machine to create\nthe override for.  Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/supervisor:Supervisor": {
            "description": "Provides a resource for configuring Workload Management.\n\n## Example Usage\n\n### S\n\n**Enable Workload Management on a compute cluster**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vmClass = new vsphere.VirtualMachineClass(\"vm_class\", {\n    name: \"custom-class\",\n    cpus: 4,\n    memory: 4096,\n});\nconst supervisor = new vsphere.Supervisor(\"supervisor\", {\n    cluster: \"\u003ccompute_cluster_id\u003e\",\n    storagePolicy: \"\u003cstorage_policy_name\u003e\",\n    contentLibrary: \"\u003ccontent_library_id\u003e\",\n    mainDns: \"10.0.0.250\",\n    workerDns: \"10.0.0.250\",\n    edgeCluster: \"\u003cedge_cluster_id\u003e\",\n    dvsUuid: \"\u003cdistributed_switch_uuid\u003e\",\n    sizingHint: \"MEDIUM\",\n    managementNetwork: {\n        network: \"\u003cportgroup_id\u003e\",\n        subnetMask: \"255.255.255.0\",\n        startingAddress: \"10.0.0.150\",\n        gateway: \"10.0.0.250\",\n        addressCount: 5,\n    },\n    ingressCidrs: [{\n        address: \"10.10.10.0\",\n        prefix: 24,\n    }],\n    egressCidrs: [{\n        address: \"10.10.11.0\",\n        prefix: 24,\n    }],\n    podCidrs: [{\n        address: \"10.244.10.0\",\n        prefix: 23,\n    }],\n    serviceCidr: {\n        address: \"10.10.12.0\",\n        prefix: 24,\n    },\n    searchDomains: \"vsphere.local\",\n    namespaces: [{\n        name: \"custom-namespace\",\n        contentLibraries: [],\n        vmClasses: [vmClass.id],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvm_class = vsphere.VirtualMachineClass(\"vm_class\",\n    name=\"custom-class\",\n    cpus=4,\n    memory=4096)\nsupervisor = vsphere.Supervisor(\"supervisor\",\n    cluster=\"\u003ccompute_cluster_id\u003e\",\n    storage_policy=\"\u003cstorage_policy_name\u003e\",\n    content_library=\"\u003ccontent_library_id\u003e\",\n    main_dns=\"10.0.0.250\",\n    worker_dns=\"10.0.0.250\",\n    edge_cluster=\"\u003cedge_cluster_id\u003e\",\n    dvs_uuid=\"\u003cdistributed_switch_uuid\u003e\",\n    sizing_hint=\"MEDIUM\",\n    management_network={\n        \"network\": \"\u003cportgroup_id\u003e\",\n        \"subnet_mask\": \"255.255.255.0\",\n        \"starting_address\": \"10.0.0.150\",\n        \"gateway\": \"10.0.0.250\",\n        \"address_count\": 5,\n    },\n    ingress_cidrs=[{\n        \"address\": \"10.10.10.0\",\n        \"prefix\": 24,\n    }],\n    egress_cidrs=[{\n        \"address\": \"10.10.11.0\",\n        \"prefix\": 24,\n    }],\n    pod_cidrs=[{\n        \"address\": \"10.244.10.0\",\n        \"prefix\": 23,\n    }],\n    service_cidr={\n        \"address\": \"10.10.12.0\",\n        \"prefix\": 24,\n    },\n    search_domains=\"vsphere.local\",\n    namespaces=[{\n        \"name\": \"custom-namespace\",\n        \"content_libraries\": [],\n        \"vm_classes\": [vm_class.id],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vmClass = new VSphere.VirtualMachineClass(\"vm_class\", new()\n    {\n        Name = \"custom-class\",\n        Cpus = 4,\n        Memory = 4096,\n    });\n\n    var supervisor = new VSphere.Supervisor(\"supervisor\", new()\n    {\n        Cluster = \"\u003ccompute_cluster_id\u003e\",\n        StoragePolicy = \"\u003cstorage_policy_name\u003e\",\n        ContentLibrary = \"\u003ccontent_library_id\u003e\",\n        MainDns = \"10.0.0.250\",\n        WorkerDns = \"10.0.0.250\",\n        EdgeCluster = \"\u003cedge_cluster_id\u003e\",\n        DvsUuid = \"\u003cdistributed_switch_uuid\u003e\",\n        SizingHint = \"MEDIUM\",\n        ManagementNetwork = new VSphere.Inputs.SupervisorManagementNetworkArgs\n        {\n            Network = \"\u003cportgroup_id\u003e\",\n            SubnetMask = \"255.255.255.0\",\n            StartingAddress = \"10.0.0.150\",\n            Gateway = \"10.0.0.250\",\n            AddressCount = 5,\n        },\n        IngressCidrs = new[]\n        {\n            new VSphere.Inputs.SupervisorIngressCidrArgs\n            {\n                Address = \"10.10.10.0\",\n                Prefix = 24,\n            },\n        },\n        EgressCidrs = new[]\n        {\n            new VSphere.Inputs.SupervisorEgressCidrArgs\n            {\n                Address = \"10.10.11.0\",\n                Prefix = 24,\n            },\n        },\n        PodCidrs = new[]\n        {\n            new VSphere.Inputs.SupervisorPodCidrArgs\n            {\n                Address = \"10.244.10.0\",\n                Prefix = 23,\n            },\n        },\n        ServiceCidr = new VSphere.Inputs.SupervisorServiceCidrArgs\n        {\n            Address = \"10.10.12.0\",\n            Prefix = 24,\n        },\n        SearchDomains = \"vsphere.local\",\n        Namespaces = new[]\n        {\n            new VSphere.Inputs.SupervisorNamespaceArgs\n            {\n                Name = \"custom-namespace\",\n                ContentLibraries = new() { },\n                VmClasses = new[]\n                {\n                    vmClass.Id,\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tvmClass, err := vsphere.NewVirtualMachineClass(ctx, \"vm_class\", \u0026vsphere.VirtualMachineClassArgs{\n\t\t\tName:   pulumi.String(\"custom-class\"),\n\t\t\tCpus:   pulumi.Int(4),\n\t\t\tMemory: pulumi.Int(4096),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewSupervisor(ctx, \"supervisor\", \u0026vsphere.SupervisorArgs{\n\t\t\tCluster:        pulumi.String(\"\u003ccompute_cluster_id\u003e\"),\n\t\t\tStoragePolicy:  pulumi.String(\"\u003cstorage_policy_name\u003e\"),\n\t\t\tContentLibrary: pulumi.String(\"\u003ccontent_library_id\u003e\"),\n\t\t\tMainDns:        pulumi.StringArray(\"10.0.0.250\"),\n\t\t\tWorkerDns:      pulumi.StringArray(\"10.0.0.250\"),\n\t\t\tEdgeCluster:    pulumi.String(\"\u003cedge_cluster_id\u003e\"),\n\t\t\tDvsUuid:        pulumi.String(\"\u003cdistributed_switch_uuid\u003e\"),\n\t\t\tSizingHint:     pulumi.String(\"MEDIUM\"),\n\t\t\tManagementNetwork: \u0026vsphere.SupervisorManagementNetworkArgs{\n\t\t\t\tNetwork:         pulumi.String(\"\u003cportgroup_id\u003e\"),\n\t\t\t\tSubnetMask:      pulumi.String(\"255.255.255.0\"),\n\t\t\t\tStartingAddress: pulumi.String(\"10.0.0.150\"),\n\t\t\t\tGateway:         pulumi.String(\"10.0.0.250\"),\n\t\t\t\tAddressCount:    pulumi.Int(5),\n\t\t\t},\n\t\t\tIngressCidrs: vsphere.SupervisorIngressCidrArray{\n\t\t\t\t\u0026vsphere.SupervisorIngressCidrArgs{\n\t\t\t\t\tAddress: pulumi.String(\"10.10.10.0\"),\n\t\t\t\t\tPrefix:  pulumi.Int(24),\n\t\t\t\t},\n\t\t\t},\n\t\t\tEgressCidrs: vsphere.SupervisorEgressCidrArray{\n\t\t\t\t\u0026vsphere.SupervisorEgressCidrArgs{\n\t\t\t\t\tAddress: pulumi.String(\"10.10.11.0\"),\n\t\t\t\t\tPrefix:  pulumi.Int(24),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPodCidrs: vsphere.SupervisorPodCidrArray{\n\t\t\t\t\u0026vsphere.SupervisorPodCidrArgs{\n\t\t\t\t\tAddress: pulumi.String(\"10.244.10.0\"),\n\t\t\t\t\tPrefix:  pulumi.Int(23),\n\t\t\t\t},\n\t\t\t},\n\t\t\tServiceCidr: \u0026vsphere.SupervisorServiceCidrArgs{\n\t\t\t\tAddress: pulumi.String(\"10.10.12.0\"),\n\t\t\t\tPrefix:  pulumi.Int(24),\n\t\t\t},\n\t\t\tSearchDomains: pulumi.String(\"vsphere.local\"),\n\t\t\tNamespaces: vsphere.SupervisorNamespaceArray{\n\t\t\t\t\u0026vsphere.SupervisorNamespaceArgs{\n\t\t\t\t\tName:             pulumi.String(\"custom-namespace\"),\n\t\t\t\t\tContentLibraries: pulumi.StringArray{},\n\t\t\t\t\tVmClasses: pulumi.StringArray{\n\t\t\t\t\t\tvmClass.ID(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachineClass;\nimport com.pulumi.vsphere.VirtualMachineClassArgs;\nimport com.pulumi.vsphere.Supervisor;\nimport com.pulumi.vsphere.SupervisorArgs;\nimport com.pulumi.vsphere.inputs.SupervisorManagementNetworkArgs;\nimport com.pulumi.vsphere.inputs.SupervisorIngressCidrArgs;\nimport com.pulumi.vsphere.inputs.SupervisorEgressCidrArgs;\nimport com.pulumi.vsphere.inputs.SupervisorPodCidrArgs;\nimport com.pulumi.vsphere.inputs.SupervisorServiceCidrArgs;\nimport com.pulumi.vsphere.inputs.SupervisorNamespaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vmClass = new VirtualMachineClass(\"vmClass\", VirtualMachineClassArgs.builder()\n            .name(\"custom-class\")\n            .cpus(4)\n            .memory(4096)\n            .build());\n\n        var supervisor = new Supervisor(\"supervisor\", SupervisorArgs.builder()\n            .cluster(\"\u003ccompute_cluster_id\u003e\")\n            .storagePolicy(\"\u003cstorage_policy_name\u003e\")\n            .contentLibrary(\"\u003ccontent_library_id\u003e\")\n            .mainDns(\"10.0.0.250\")\n            .workerDns(\"10.0.0.250\")\n            .edgeCluster(\"\u003cedge_cluster_id\u003e\")\n            .dvsUuid(\"\u003cdistributed_switch_uuid\u003e\")\n            .sizingHint(\"MEDIUM\")\n            .managementNetwork(SupervisorManagementNetworkArgs.builder()\n                .network(\"\u003cportgroup_id\u003e\")\n                .subnetMask(\"255.255.255.0\")\n                .startingAddress(\"10.0.0.150\")\n                .gateway(\"10.0.0.250\")\n                .addressCount(5)\n                .build())\n            .ingressCidrs(SupervisorIngressCidrArgs.builder()\n                .address(\"10.10.10.0\")\n                .prefix(24)\n                .build())\n            .egressCidrs(SupervisorEgressCidrArgs.builder()\n                .address(\"10.10.11.0\")\n                .prefix(24)\n                .build())\n            .podCidrs(SupervisorPodCidrArgs.builder()\n                .address(\"10.244.10.0\")\n                .prefix(23)\n                .build())\n            .serviceCidr(SupervisorServiceCidrArgs.builder()\n                .address(\"10.10.12.0\")\n                .prefix(24)\n                .build())\n            .searchDomains(\"vsphere.local\")\n            .namespaces(SupervisorNamespaceArgs.builder()\n                .name(\"custom-namespace\")\n                .contentLibraries()\n                .vmClasses(vmClass.id())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vmClass:\n    type: vsphere:VirtualMachineClass\n    name: vm_class\n    properties:\n      name: custom-class\n      cpus: 4\n      memory: 4096\n  supervisor:\n    type: vsphere:Supervisor\n    properties:\n      cluster: \u003ccompute_cluster_id\u003e\n      storagePolicy: \u003cstorage_policy_name\u003e\n      contentLibrary: \u003ccontent_library_id\u003e\n      mainDns: 10.0.0.250\n      workerDns: 10.0.0.250\n      edgeCluster: \u003cedge_cluster_id\u003e\n      dvsUuid: \u003cdistributed_switch_uuid\u003e\n      sizingHint: MEDIUM\n      managementNetwork:\n        network: \u003cportgroup_id\u003e\n        subnetMask: 255.255.255.0\n        startingAddress: 10.0.0.150\n        gateway: 10.0.0.250\n        addressCount: 5\n      ingressCidrs:\n        - address: 10.10.10.0\n          prefix: 24\n      egressCidrs:\n        - address: 10.10.11.0\n          prefix: 24\n      podCidrs:\n        - address: 10.244.10.0\n          prefix: 23\n      serviceCidr:\n        address: 10.10.12.0\n        prefix: 24\n      searchDomains: vsphere.local\n      namespaces:\n        - name: custom-namespace\n          contentLibraries: []\n          vmClasses:\n            - ${vmClass.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "cluster": {
                    "type": "string",
                    "description": "The identifier of the compute cluster.\n"
                },
                "contentLibrary": {
                    "type": "string",
                    "description": "The identifier of the subscribed content library.\n"
                },
                "dvsUuid": {
                    "type": "string",
                    "description": "The UUID of the distributed switch.\n"
                },
                "edgeCluster": {
                    "type": "string",
                    "description": "The identifier of the NSX Edge Cluster.\n"
                },
                "egressCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorEgressCidr:SupervisorEgressCidr"
                    },
                    "description": "CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.\n"
                },
                "ingressCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorIngressCidr:SupervisorIngressCidr"
                    },
                    "description": "CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.\n"
                },
                "mainDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the primary DNS servers.\n"
                },
                "managementNetwork": {
                    "$ref": "#/types/vsphere:index/SupervisorManagementNetwork:SupervisorManagementNetwork",
                    "description": "The configuration for the management network which the control plane VMs will be connected to.\n* * `network` - ID of the network. (e.g. a distributed port group).\n* * `starting_address` - Starting address of the management network range.\n* * `subnet_mask` - Subnet mask.\n* * `gateway` - Gateway IP address.\n* * `address_count` - Number of addresses to allocate. Starts from `starting_address`\n"
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorNamespace:SupervisorNamespace"
                    },
                    "description": "The list of namespaces to create in the Supervisor cluster\n"
                },
                "podCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorPodCidr:SupervisorPodCidr"
                    },
                    "description": "CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.\n"
                },
                "searchDomains": {
                    "type": "string",
                    "description": "List of DNS search domains.\n"
                },
                "serviceCidr": {
                    "$ref": "#/types/vsphere:index/SupervisorServiceCidr:SupervisorServiceCidr",
                    "description": "CIDR block from which Kubernetes allocates service cluster IP addresses.\n"
                },
                "sizingHint": {
                    "type": "string",
                    "description": "The size of the Kubernetes API server.\n"
                },
                "storagePolicy": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "workerDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the DNS servers to use for the worker nodes.\n"
                }
            },
            "required": [
                "cluster",
                "contentLibrary",
                "dvsUuid",
                "edgeCluster",
                "egressCidrs",
                "ingressCidrs",
                "mainDns",
                "managementNetwork",
                "podCidrs",
                "searchDomains",
                "serviceCidr",
                "sizingHint",
                "storagePolicy",
                "workerDns"
            ],
            "inputProperties": {
                "cluster": {
                    "type": "string",
                    "description": "The identifier of the compute cluster.\n"
                },
                "contentLibrary": {
                    "type": "string",
                    "description": "The identifier of the subscribed content library.\n"
                },
                "dvsUuid": {
                    "type": "string",
                    "description": "The UUID of the distributed switch.\n"
                },
                "edgeCluster": {
                    "type": "string",
                    "description": "The identifier of the NSX Edge Cluster.\n"
                },
                "egressCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorEgressCidr:SupervisorEgressCidr"
                    },
                    "description": "CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.\n"
                },
                "ingressCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorIngressCidr:SupervisorIngressCidr"
                    },
                    "description": "CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.\n"
                },
                "mainDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the primary DNS servers.\n"
                },
                "managementNetwork": {
                    "$ref": "#/types/vsphere:index/SupervisorManagementNetwork:SupervisorManagementNetwork",
                    "description": "The configuration for the management network which the control plane VMs will be connected to.\n* * `network` - ID of the network. (e.g. a distributed port group).\n* * `starting_address` - Starting address of the management network range.\n* * `subnet_mask` - Subnet mask.\n* * `gateway` - Gateway IP address.\n* * `address_count` - Number of addresses to allocate. Starts from `starting_address`\n"
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorNamespace:SupervisorNamespace"
                    },
                    "description": "The list of namespaces to create in the Supervisor cluster\n"
                },
                "podCidrs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/SupervisorPodCidr:SupervisorPodCidr"
                    },
                    "description": "CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.\n"
                },
                "searchDomains": {
                    "type": "string",
                    "description": "List of DNS search domains.\n"
                },
                "serviceCidr": {
                    "$ref": "#/types/vsphere:index/SupervisorServiceCidr:SupervisorServiceCidr",
                    "description": "CIDR block from which Kubernetes allocates service cluster IP addresses.\n"
                },
                "sizingHint": {
                    "type": "string",
                    "description": "The size of the Kubernetes API server.\n"
                },
                "storagePolicy": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "workerDns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of addresses of the DNS servers to use for the worker nodes.\n"
                }
            },
            "requiredInputs": [
                "cluster",
                "contentLibrary",
                "dvsUuid",
                "edgeCluster",
                "egressCidrs",
                "ingressCidrs",
                "mainDns",
                "managementNetwork",
                "podCidrs",
                "searchDomains",
                "serviceCidr",
                "sizingHint",
                "storagePolicy",
                "workerDns"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Supervisor resources.\n",
                "properties": {
                    "cluster": {
                        "type": "string",
                        "description": "The identifier of the compute cluster.\n"
                    },
                    "contentLibrary": {
                        "type": "string",
                        "description": "The identifier of the subscribed content library.\n"
                    },
                    "dvsUuid": {
                        "type": "string",
                        "description": "The UUID of the distributed switch.\n"
                    },
                    "edgeCluster": {
                        "type": "string",
                        "description": "The identifier of the NSX Edge Cluster.\n"
                    },
                    "egressCidrs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/SupervisorEgressCidr:SupervisorEgressCidr"
                        },
                        "description": "CIDR blocks from which NSX assigns IP addresses used for performing SNAT from container IPs to external IPs.\n"
                    },
                    "ingressCidrs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/SupervisorIngressCidr:SupervisorIngressCidr"
                        },
                        "description": "CIDR blocks from which NSX assigns IP addresses for Kubernetes Ingresses and Kubernetes Services of type LoadBalancer.\n"
                    },
                    "mainDns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of addresses of the primary DNS servers.\n"
                    },
                    "managementNetwork": {
                        "$ref": "#/types/vsphere:index/SupervisorManagementNetwork:SupervisorManagementNetwork",
                        "description": "The configuration for the management network which the control plane VMs will be connected to.\n* * `network` - ID of the network. (e.g. a distributed port group).\n* * `starting_address` - Starting address of the management network range.\n* * `subnet_mask` - Subnet mask.\n* * `gateway` - Gateway IP address.\n* * `address_count` - Number of addresses to allocate. Starts from `starting_address`\n"
                    },
                    "namespaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/SupervisorNamespace:SupervisorNamespace"
                        },
                        "description": "The list of namespaces to create in the Supervisor cluster\n"
                    },
                    "podCidrs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/SupervisorPodCidr:SupervisorPodCidr"
                        },
                        "description": "CIDR blocks from which Kubernetes allocates pod IP addresses. Minimum subnet size is 23.\n"
                    },
                    "searchDomains": {
                        "type": "string",
                        "description": "List of DNS search domains.\n"
                    },
                    "serviceCidr": {
                        "$ref": "#/types/vsphere:index/SupervisorServiceCidr:SupervisorServiceCidr",
                        "description": "CIDR block from which Kubernetes allocates service cluster IP addresses.\n"
                    },
                    "sizingHint": {
                        "type": "string",
                        "description": "The size of the Kubernetes API server.\n"
                    },
                    "storagePolicy": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    },
                    "workerDns": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of addresses of the DNS servers to use for the worker nodes.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tag:Tag": {
            "properties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "required": [
                "categoryId",
                "name"
            ],
            "inputProperties": {
                "categoryId": {
                    "type": "string",
                    "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A description for the tag.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                }
            },
            "requiredInputs": [
                "categoryId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Tag resources.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The unique identifier of the parent category in\nwhich this tag will be created. Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the tag.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The display name of the tag. The name must be unique\nwithin its category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/tagCategory:TagCategory": {
            "properties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n\n\u003e **NOTE:** You can add associable types to a category, but you cannot remove\nthem. Attempting to do so will result in an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "required": [
                "associableTypes",
                "cardinality",
                "name"
            ],
            "inputProperties": {
                "associableTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                },
                "cardinality": {
                    "type": "string",
                    "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A description for the category.\n\n\u003e **NOTE:** You can add associable types to a category, but you cannot remove\nthem. Attempting to do so will result in an error.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the category.\n"
                }
            },
            "requiredInputs": [
                "associableTypes",
                "cardinality"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering TagCategory resources.\n",
                "properties": {
                    "associableTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list object types that this category is\nvalid to be assigned to. For a full list, click\nhere.\n"
                    },
                    "cardinality": {
                        "type": "string",
                        "description": "The number of tags that can be assigned from this\ncategory to a single object at once. Can be one of `SINGLE` (object can only\nbe assigned one tag in this category), to `MULTIPLE` (object can be assigned\nmultiple tags in this category). Forces a new resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the category.\n\n\u003e **NOTE:** You can add associable types to a category, but you cannot remove\nthem. Attempting to do so will result in an error.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the category.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappContainer:VappContainer": {
            "properties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "required": [
                "cpuShares",
                "memoryShares",
                "name",
                "parentResourcePoolId"
            ],
            "inputProperties": {
                "cpuExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                },
                "cpuShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "memoryExpandable": {
                    "type": "boolean",
                    "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                },
                "memoryShares": {
                    "type": "integer",
                    "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the vApp container.\n"
                },
                "parentFolderId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                },
                "parentResourcePoolId": {
                    "type": "string",
                    "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource.\n"
                }
            },
            "requiredInputs": [
                "parentResourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappContainer resources.\n",
                "properties": {
                    "cpuExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited.\nDefault: `-1`\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `cpu_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "cpuShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`cpu_share_level` must be `custom`.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "memoryExpandable": {
                        "type": "boolean",
                        "description": "Determines if the reservation on a vApp\ncontainer can grow beyond the specified value if the parent resource pool has\nunreserved resources. Default: `true`\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The CPU utilization of a vApp container will not\nexceed this limit, even if there are available resources. Set to `-1` for\nunlimited. Default: `-1`\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "Amount of CPU (MHz) that is guaranteed\navailable to the vApp container. Default: `0`\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The CPU allocation level. The level is a\nsimplified view of shares. Levels map to a pre-determined set of numeric\nvalues for shares. Can be one of `low`, `normal`, `high`, or `custom`. When\n`low`, `normal`, or `high` are specified values in `memory_shares` will be\nignored.  Default: `normal`\n"
                    },
                    "memoryShares": {
                        "type": "integer",
                        "description": "The number of shares allocated for CPU. Used to\ndetermine resource allocation in case of resource contention. If this is set,\n`memory_share_level` must be `custom`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container.\n"
                    },
                    "parentFolderId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe vApp container's parent folder.\n"
                    },
                    "parentResourcePoolId": {
                        "type": "string",
                        "description": "The managed object ID\nof the parent resource pool. This can be the root resource pool for a cluster\nor standalone host, or a resource pool itself. When moving a vApp container\nfrom one parent resource pool to another, both must share a common root\nresource pool or the move will fail.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vappEntity:VappEntity": {
            "properties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n"
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "required": [
                "containerId",
                "targetId"
            ],
            "inputProperties": {
                "containerId": {
                    "type": "string",
                    "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n",
                    "willReplaceOnChanges": true
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "startAction": {
                    "type": "string",
                    "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                },
                "startDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                },
                "startOrder": {
                    "type": "integer",
                    "description": "Order to start and stop target in vApp. Default: 1\n"
                },
                "stopAction": {
                    "type": "string",
                    "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                },
                "stopDelay": {
                    "type": "integer",
                    "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "targetId": {
                    "type": "string",
                    "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n",
                    "willReplaceOnChanges": true
                },
                "waitForGuest": {
                    "type": "boolean",
                    "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                }
            },
            "requiredInputs": [
                "containerId",
                "targetId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VappEntity resources.\n",
                "properties": {
                    "containerId": {
                        "type": "string",
                        "description": "Managed object ID of the vApp\ncontainer the entity is a member of.\n",
                        "willReplaceOnChanges": true
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "startAction": {
                        "type": "string",
                        "description": "How to start the entity. Valid settings are none\nor powerOn. If set to none, then the entity does not participate in auto-start.\nDefault: powerOn\n"
                    },
                    "startDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order of entities to be started. Default: 120\n"
                    },
                    "startOrder": {
                        "type": "integer",
                        "description": "Order to start and stop target in vApp. Default: 1\n"
                    },
                    "stopAction": {
                        "type": "string",
                        "description": "Defines the stop action for the entity. Can be set\nto none, powerOff, guestShutdown, or suspend. If set to none, then the entity\ndoes not participate in auto-stop. Default: powerOff\n"
                    },
                    "stopDelay": {
                        "type": "integer",
                        "description": "Delay in seconds before continuing with the next\nentity in the order sequence. This is only used if the stopAction is\nguestShutdown. Default: 120\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "targetId": {
                        "type": "string",
                        "description": "Managed object ID of the entity\nto power on or power off. This can be a virtual machine or a vApp.\n",
                        "willReplaceOnChanges": true
                    },
                    "waitForGuest": {
                        "type": "boolean",
                        "description": "Determines if the VM should be marked as being\nstarted when VMware Tools are ready instead of waiting for `start_delay`. This\nproperty has no effect for vApps. Default: false\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualDisk:VirtualDisk": {
            "properties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n\n\u003e **NOTE:** `adapter_type` is **deprecated**: it does not dictate the type of\ncontroller that the virtual disk will be attached to on the virtual machine.\nPlease see the `scsi_type` parameter\nin the `vsphere.VirtualMachine` resource for information on how to control\ndisk controller types. This parameter will be removed in future versions of the\nvSphere provider.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere.VirtualMachine instead"
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n\n\u003e **NOTE:** Any directory created as part of the operation when\n`create_directories` is enabled will not be deleted when the resource is\ndestroyed.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when ESXi or if there is only one datacenter in\nyour infrastructure.\n"
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB). Decreasing the size of a disk is not possible.\nIf a disk of a smaller size is required then the original has to be destroyed along with its data and a new one has to be\ncreated.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n\n[docs-vmware-vm-disk-provisioning]: https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-vm-administration/GUID-4C0F4D73-82F2-4B81-8AA7-1DD752A8A5AC.html\n"
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n"
                }
            },
            "required": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "inputProperties": {
                "adapterType": {
                    "type": "string",
                    "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n\n\u003e **NOTE:** `adapter_type` is **deprecated**: it does not dictate the type of\ncontroller that the virtual disk will be attached to on the virtual machine.\nPlease see the `scsi_type` parameter\nin the `vsphere.VirtualMachine` resource for information on how to control\ndisk controller types. This parameter will be removed in future versions of the\nvSphere provider.\n",
                    "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere.VirtualMachine instead",
                    "willReplaceOnChanges": true
                },
                "createDirectories": {
                    "type": "boolean",
                    "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n\n\u003e **NOTE:** Any directory created as part of the operation when\n`create_directories` is enabled will not be deleted when the resource is\ndestroyed.\n",
                    "willReplaceOnChanges": true
                },
                "datacenter": {
                    "type": "string",
                    "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when ESXi or if there is only one datacenter in\nyour infrastructure.\n",
                    "willReplaceOnChanges": true
                },
                "datastore": {
                    "type": "string",
                    "description": "The name of the datastore in which to create the\ndisk.\n",
                    "willReplaceOnChanges": true
                },
                "size": {
                    "type": "integer",
                    "description": "Size of the disk (in GB). Decreasing the size of a disk is not possible.\nIf a disk of a smaller size is required then the original has to be destroyed along with its data and a new one has to be\ncreated.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n\n[docs-vmware-vm-disk-provisioning]: https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-vm-administration/GUID-4C0F4D73-82F2-4B81-8AA7-1DD752A8A5AC.html\n",
                    "willReplaceOnChanges": true
                },
                "vmdkPath": {
                    "type": "string",
                    "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "datastore",
                "size",
                "vmdkPath"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualDisk resources.\n",
                "properties": {
                    "adapterType": {
                        "type": "string",
                        "description": "The adapter type for this virtual disk. Can be\none of `ide`, `lsiLogic`, or `busLogic`.  Default: `lsiLogic`.\n\n\u003e **NOTE:** `adapter_type` is **deprecated**: it does not dictate the type of\ncontroller that the virtual disk will be attached to on the virtual machine.\nPlease see the `scsi_type` parameter\nin the `vsphere.VirtualMachine` resource for information on how to control\ndisk controller types. This parameter will be removed in future versions of the\nvSphere provider.\n",
                        "deprecationMessage": "this attribute has no effect on controller types - please use scsi_type in vsphere.VirtualMachine instead",
                        "willReplaceOnChanges": true
                    },
                    "createDirectories": {
                        "type": "boolean",
                        "description": "Tells the resource to create any\ndirectories that are a part of the `vmdk_path` parameter if they are missing.\nDefault: `false`.\n\n\u003e **NOTE:** Any directory created as part of the operation when\n`create_directories` is enabled will not be deleted when the resource is\ndestroyed.\n",
                        "willReplaceOnChanges": true
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The name of the datacenter in which to create the\ndisk. Can be omitted when ESXi or if there is only one datacenter in\nyour infrastructure.\n",
                        "willReplaceOnChanges": true
                    },
                    "datastore": {
                        "type": "string",
                        "description": "The name of the datastore in which to create the\ndisk.\n",
                        "willReplaceOnChanges": true
                    },
                    "size": {
                        "type": "integer",
                        "description": "Size of the disk (in GB). Decreasing the size of a disk is not possible.\nIf a disk of a smaller size is required then the original has to be destroyed along with its data and a new one has to be\ncreated.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of disk to create. Can be one of\n`eagerZeroedThick`, `lazy`, or `thin`. Default: `eagerZeroedThick`. For\ninformation on what each kind of disk provisioning policy means, click\n[here][docs-vmware-vm-disk-provisioning].\n\n[docs-vmware-vm-disk-provisioning]: https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-vm-administration/GUID-4C0F4D73-82F2-4B81-8AA7-1DD752A8A5AC.html\n",
                        "willReplaceOnChanges": true
                    },
                    "vmdkPath": {
                        "type": "string",
                        "description": "The path, including filename, of the virtual disk to\nbe created.  This needs to end in `.vmdk`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachine:VirtualMachine": {
            "properties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system when guest_id is otherGuest or otherGuest64.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "User-provided description of the virtual machine.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting the boot sequence.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.\n"
                },
                "cdroms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom"
                    },
                    "description": "A specification for a CDROM device on this virtual machine.\n"
                },
                "changeVersion": {
                    "type": "string",
                    "description": "A unique identifier for a given version of the last configuration was applied.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                    "description": "A specification for cloning a virtual machine from template.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance counters on this virtual machine.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to cpu for a custom share level.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for cpu resources. Can be one of high, low, normal, or custom.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VM is to be created.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The ID of a datastore cluster to put the virtual machine in.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual\ndisks that are created without datastores.\n"
                },
                "defaultIpAddress": {
                    "type": "string",
                    "description": "The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on this virtual machine.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "When the boot type set in firmware is efi, this enables EFI secure boot.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging on this virtual machine.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata, or configuration data for OVF images.\n"
                },
                "extraConfigRebootRequired": {
                    "type": "boolean",
                    "description": "Allow the virtual machine to be rebooted when a change to `extra_config` occurs.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware interface to use on the virtual machine. Can be one of bios or efi.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The name of the folder to locate the virtual machine in.\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system.\n"
                },
                "guestIpAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The current list of IP addresses on this machine, including the value of `default_ip_address`. If VMware Tools is not running on the virtual machine, or if the virtul machine is powered off, this list will be empty.\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version for the virtual machine.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The ID of an optional host system to pin the virtual machine to.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.\n"
                },
                "ideControllerCount": {
                    "type": "integer"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to ignore while waiting for an IP\n"
                },
                "imported": {
                    "type": "boolean",
                    "description": "Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard\ndevices. Can be one of low, normal, medium, or high.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The size of the virtual machine's memory, in MB.\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to this virtual machine while it is running.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                },
                "memoryReservationLockedToMax": {
                    "type": "boolean",
                    "description": "If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine's memory\nsize;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature\nmay only be enabled if it is currently possible to reserve all of the virtual machine's memory.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to memory for a custom share level.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for memory resources. Can be one of high, low, normal, or custom.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for a vMotion operation to complete before failing.\n"
                },
                "moid": {
                    "type": "string",
                    "description": "The managed object reference ID of the created virtual machine.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of this virtual machine.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this virtual machine.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus\nmust be evenly divisible by this value.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The number of virtual processors to assign to this virtual machine.\n"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "A specification for deploying a virtual machine from ovf/ova template.\n"
                },
                "pciDeviceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PCI passthrough devices\n"
                },
                "powerState": {
                    "type": "string",
                    "description": "A computed value for the current power state of the virtual machine. One of `on`, `off`, or `suspended`.\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "rebootRequired": {
                    "type": "boolean"
                },
                "replaceTrigger": {
                    "type": "string",
                    "description": "Triggers replacement of resource whenever it changes.\n"
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The ID of a resource pool to put the virtual machine in.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable the run of scripts after virtual machine power-on when VMware Tools is installed.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable the run of scripts after virtual machine resume when when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system reboot when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system standby when VMware Tools is installed.\n"
                },
                "sataControllerCount": {
                    "type": "integer"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.\n"
                },
                "scsiControllerCount": {
                    "type": "integer"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The ID of the storage policy to assign to the virtual machine home directory.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is\nsynchronized on startup and resume. Requires VMware Tools to be installed.\n"
                },
                "syncTimeWithHostPeriodically": {
                    "type": "boolean",
                    "description": "Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions\nsetting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "toolsUpgradePolicy": {
                    "type": "string",
                    "description": "Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.\n"
                },
                "uuid": {
                    "type": "string",
                    "description": "The UUID of the virtual machine. Also exposed as the `id` of the resource.\n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.\n"
                },
                "vappTransports": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.\n"
                },
                "vbsEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if Virtualization-based security is enabled for this virtual machine.\n"
                },
                "vmwareToolsStatus": {
                    "type": "string",
                    "description": "The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.\n"
                },
                "vmxPath": {
                    "type": "string",
                    "description": "The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.\n"
                },
                "vvtdEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD\nI/O Virtualization (AMD-Vi or IOMMU), is enabled.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for\na default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                }
            },
            "required": [
                "annotation",
                "changeVersion",
                "cpuShareCount",
                "datastoreId",
                "defaultIpAddress",
                "disks",
                "eptRviMode",
                "guestId",
                "guestIpAddresses",
                "hardwareVersion",
                "hostSystemId",
                "hvMode",
                "imported",
                "memoryShareCount",
                "moid",
                "name",
                "powerState",
                "rebootRequired",
                "resourcePoolId",
                "storagePolicyId",
                "uuid",
                "vappTransports",
                "vmwareToolsStatus",
                "vmxPath"
            ],
            "inputProperties": {
                "alternateGuestName": {
                    "type": "string",
                    "description": "The guest name for the operating system when guest_id is otherGuest or otherGuest64.\n"
                },
                "annotation": {
                    "type": "string",
                    "description": "User-provided description of the virtual machine.\n"
                },
                "bootDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before starting the boot sequence.\n"
                },
                "bootRetryDelay": {
                    "type": "integer",
                    "description": "The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.\n"
                },
                "bootRetryEnabled": {
                    "type": "boolean",
                    "description": "If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.\n"
                },
                "cdroms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom"
                    },
                    "description": "A specification for a CDROM device on this virtual machine.\n"
                },
                "clone": {
                    "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                    "description": "A specification for cloning a virtual machine from template.\n"
                },
                "cpuHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                },
                "cpuHotRemoveEnabled": {
                    "type": "boolean",
                    "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                },
                "cpuLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                },
                "cpuPerformanceCountersEnabled": {
                    "type": "boolean",
                    "description": "Enable CPU performance counters on this virtual machine.\n"
                },
                "cpuReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                },
                "cpuShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to cpu for a custom share level.\n"
                },
                "cpuShareLevel": {
                    "type": "string",
                    "description": "The allocation level for cpu resources. Can be one of high, low, normal, or custom.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A list of custom attributes to set on this resource.\n"
                },
                "datacenterId": {
                    "type": "string",
                    "description": "The ID of the datacenter where the VM is to be created.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The ID of a datastore cluster to put the virtual machine in.\n"
                },
                "datastoreId": {
                    "type": "string",
                    "description": "The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual\ndisks that are created without datastores.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                    },
                    "description": "A specification for a virtual disk device on this virtual machine.\n"
                },
                "efiSecureBootEnabled": {
                    "type": "boolean",
                    "description": "When the boot type set in firmware is efi, this enables EFI secure boot.\n"
                },
                "enableDiskUuid": {
                    "type": "boolean",
                    "description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enable logging on this virtual machine.\n"
                },
                "eptRviMode": {
                    "type": "string",
                    "description": "The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.\n"
                },
                "extraConfig": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata, or configuration data for OVF images.\n"
                },
                "extraConfigRebootRequired": {
                    "type": "boolean",
                    "description": "Allow the virtual machine to be rebooted when a change to `extra_config` occurs.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The firmware interface to use on the virtual machine. Can be one of bios or efi.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The name of the folder to locate the virtual machine in.\n"
                },
                "forcePowerOff": {
                    "type": "boolean",
                    "description": "Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.\n"
                },
                "guestId": {
                    "type": "string",
                    "description": "The guest ID for the operating system.\n"
                },
                "hardwareVersion": {
                    "type": "integer",
                    "description": "The hardware version for the virtual machine.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The ID of an optional host system to pin the virtual machine to.\n"
                },
                "hvMode": {
                    "type": "string",
                    "description": "The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.\n"
                },
                "ideControllerCount": {
                    "type": "integer"
                },
                "ignoredGuestIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP addresses and CIDR networks to ignore while waiting for an IP\n"
                },
                "latencySensitivity": {
                    "type": "string",
                    "description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard\ndevices. Can be one of low, normal, medium, or high.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The size of the virtual machine's memory, in MB.\n"
                },
                "memoryHotAddEnabled": {
                    "type": "boolean",
                    "description": "Allow memory to be added to this virtual machine while it is running.\n"
                },
                "memoryLimit": {
                    "type": "integer",
                    "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                },
                "memoryReservationLockedToMax": {
                    "type": "boolean",
                    "description": "If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine's memory\nsize;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature\nmay only be enabled if it is currently possible to reserve all of the virtual machine's memory.\n"
                },
                "memoryShareCount": {
                    "type": "integer",
                    "description": "The amount of shares to allocate to memory for a custom share level.\n"
                },
                "memoryShareLevel": {
                    "type": "string",
                    "description": "The allocation level for memory resources. Can be one of high, low, normal, or custom.\n"
                },
                "migrateWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for a vMotion operation to complete before failing.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of this virtual machine.\n"
                },
                "nestedHvEnabled": {
                    "type": "boolean",
                    "description": "Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                    },
                    "description": "A specification for a virtual NIC on this virtual machine.\n"
                },
                "numCoresPerSocket": {
                    "type": "integer",
                    "description": "The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus\nmust be evenly divisible by this value.\n"
                },
                "numCpus": {
                    "type": "integer",
                    "description": "The number of virtual processors to assign to this virtual machine.\n"
                },
                "ovfDeploy": {
                    "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                    "description": "A specification for deploying a virtual machine from ovf/ova template.\n"
                },
                "pciDeviceIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of PCI passthrough devices\n"
                },
                "poweronTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                },
                "replaceTrigger": {
                    "type": "string",
                    "description": "Triggers replacement of resource whenever it changes.\n",
                    "willReplaceOnChanges": true
                },
                "resourcePoolId": {
                    "type": "string",
                    "description": "The ID of a resource pool to put the virtual machine in.\n"
                },
                "runToolsScriptsAfterPowerOn": {
                    "type": "boolean",
                    "description": "Enable the run of scripts after virtual machine power-on when VMware Tools is installed.\n"
                },
                "runToolsScriptsAfterResume": {
                    "type": "boolean",
                    "description": "Enable the run of scripts after virtual machine resume when when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestReboot": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system reboot when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestShutdown": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.\n"
                },
                "runToolsScriptsBeforeGuestStandby": {
                    "type": "boolean",
                    "description": "Enable the run of scripts before guest operating system standby when VMware Tools is installed.\n"
                },
                "sataControllerCount": {
                    "type": "integer"
                },
                "scsiBusSharing": {
                    "type": "string",
                    "description": "Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.\n"
                },
                "scsiControllerCount": {
                    "type": "integer"
                },
                "scsiType": {
                    "type": "string",
                    "description": "The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.\n"
                },
                "shutdownWaitTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.\n"
                },
                "storagePolicyId": {
                    "type": "string",
                    "description": "The ID of the storage policy to assign to the virtual machine home directory.\n"
                },
                "swapPlacementPolicy": {
                    "type": "string",
                    "description": "The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.\n"
                },
                "syncTimeWithHost": {
                    "type": "boolean",
                    "description": "Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is\nsynchronized on startup and resume. Requires VMware Tools to be installed.\n"
                },
                "syncTimeWithHostPeriodically": {
                    "type": "boolean",
                    "description": "Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions\nsetting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of tag IDs to apply to this object.\n"
                },
                "toolsUpgradePolicy": {
                    "type": "string",
                    "description": "Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.\n"
                },
                "vapp": {
                    "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                    "description": "vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.\n"
                },
                "vbsEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if Virtualization-based security is enabled for this virtual machine.\n"
                },
                "vvtdEnabled": {
                    "type": "boolean",
                    "description": "Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD\nI/O Virtualization (AMD-Vi or IOMMU), is enabled.\n"
                },
                "waitForGuestIpTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                },
                "waitForGuestNetRoutable": {
                    "type": "boolean",
                    "description": "Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for\na default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.\n"
                },
                "waitForGuestNetTimeout": {
                    "type": "integer",
                    "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                }
            },
            "requiredInputs": [
                "resourcePoolId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachine resources.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The guest name for the operating system when guest_id is otherGuest or otherGuest64.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "User-provided description of the virtual machine.\n"
                    },
                    "bootDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before starting the boot sequence.\n"
                    },
                    "bootRetryDelay": {
                        "type": "integer",
                        "description": "The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.\n"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean",
                        "description": "If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.\n"
                    },
                    "cdroms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineCdrom:VirtualMachineCdrom"
                        },
                        "description": "A specification for a CDROM device on this virtual machine.\n"
                    },
                    "changeVersion": {
                        "type": "string",
                        "description": "A unique identifier for a given version of the last configuration was applied.\n"
                    },
                    "clone": {
                        "$ref": "#/types/vsphere:index/VirtualMachineClone:VirtualMachineClone",
                        "description": "A specification for cloning a virtual machine from template.\n"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean",
                        "description": "Allow CPUs to be added to this virtual machine while it is running.\n"
                    },
                    "cpuLimit": {
                        "type": "integer",
                        "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean",
                        "description": "Enable CPU performance counters on this virtual machine.\n"
                    },
                    "cpuReservation": {
                        "type": "integer",
                        "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                    },
                    "cpuShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to cpu for a custom share level.\n"
                    },
                    "cpuShareLevel": {
                        "type": "string",
                        "description": "The allocation level for cpu resources. Can be one of high, low, normal, or custom.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A list of custom attributes to set on this resource.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The ID of the datacenter where the VM is to be created.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The ID of a datastore cluster to put the virtual machine in.\n"
                    },
                    "datastoreId": {
                        "type": "string",
                        "description": "The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual\ndisks that are created without datastores.\n"
                    },
                    "defaultIpAddress": {
                        "type": "string",
                        "description": "The IP address selected by the provider to be used with any provisioners configured on this resource. When possible, this is the first IPv4 address that is reachable through the default gateway configured on the machine, then the first reachable IPv6 address, and then the first general discovered address if neither exists. If  VMware Tools is not running on the virtual machine, or if the virtual machine is powered off, this value will be blank.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineDisk:VirtualMachineDisk"
                        },
                        "description": "A specification for a virtual disk device on this virtual machine.\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean",
                        "description": "When the boot type set in firmware is efi, this enables EFI secure boot.\n"
                    },
                    "enableDiskUuid": {
                        "type": "boolean",
                        "description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.\n"
                    },
                    "enableLogging": {
                        "type": "boolean",
                        "description": "Enable logging on this virtual machine.\n"
                    },
                    "eptRviMode": {
                        "type": "string",
                        "description": "The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.\n"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in\nconfiguration, such as instance metadata, or configuration data for OVF images.\n"
                    },
                    "extraConfigRebootRequired": {
                        "type": "boolean",
                        "description": "Allow the virtual machine to be rebooted when a change to `extra_config` occurs.\n"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware interface to use on the virtual machine. Can be one of bios or efi.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The name of the folder to locate the virtual machine in.\n"
                    },
                    "forcePowerOff": {
                        "type": "boolean",
                        "description": "Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID for the operating system.\n"
                    },
                    "guestIpAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The current list of IP addresses on this machine, including the value of `default_ip_address`. If VMware Tools is not running on the virtual machine, or if the virtul machine is powered off, this list will be empty.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version for the virtual machine.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The ID of an optional host system to pin the virtual machine to.\n"
                    },
                    "hvMode": {
                        "type": "string",
                        "description": "The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.\n"
                    },
                    "ideControllerCount": {
                        "type": "integer"
                    },
                    "ignoredGuestIps": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP addresses and CIDR networks to ignore while waiting for an IP\n"
                    },
                    "imported": {
                        "type": "boolean",
                        "description": "Indicates if the virtual machine resource has been imported, or if the state has been migrated from a previous version of the resource. It influences the behavior of the first post-import apply operation. See the section on importing below.\n"
                    },
                    "latencySensitivity": {
                        "type": "string",
                        "description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower\nlatency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard\ndevices. Can be one of low, normal, medium, or high.\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean",
                        "description": "Allow memory to be added to this virtual machine while it is running.\n"
                    },
                    "memoryLimit": {
                        "type": "integer",
                        "description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available\nresources.\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.\n"
                    },
                    "memoryReservationLockedToMax": {
                        "type": "boolean",
                        "description": "If set true, memory resource reservation for this virtual machine will always be equal to the virtual machine's memory\nsize;increases in memory size will be rejected when a corresponding reservation increase is not possible. This feature\nmay only be enabled if it is currently possible to reserve all of the virtual machine's memory.\n"
                    },
                    "memoryShareCount": {
                        "type": "integer",
                        "description": "The amount of shares to allocate to memory for a custom share level.\n"
                    },
                    "memoryShareLevel": {
                        "type": "string",
                        "description": "The allocation level for memory resources. Can be one of high, low, normal, or custom.\n"
                    },
                    "migrateWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for a vMotion operation to complete before failing.\n"
                    },
                    "moid": {
                        "type": "string",
                        "description": "The managed object reference ID of the created virtual machine.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of this virtual machine.\n"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean",
                        "description": "Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.\n"
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VirtualMachineNetworkInterface:VirtualMachineNetworkInterface"
                        },
                        "description": "A specification for a virtual NIC on this virtual machine.\n"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus\nmust be evenly divisible by this value.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The number of virtual processors to assign to this virtual machine.\n"
                    },
                    "ovfDeploy": {
                        "$ref": "#/types/vsphere:index/VirtualMachineOvfDeploy:VirtualMachineOvfDeploy",
                        "description": "A specification for deploying a virtual machine from ovf/ova template.\n"
                    },
                    "pciDeviceIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of PCI passthrough devices\n"
                    },
                    "powerState": {
                        "type": "string",
                        "description": "A computed value for the current power state of the virtual machine. One of `on`, `off`, or `suspended`.\n"
                    },
                    "poweronTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in seconds, that we will be trying to power on a VM\n"
                    },
                    "rebootRequired": {
                        "type": "boolean"
                    },
                    "replaceTrigger": {
                        "type": "string",
                        "description": "Triggers replacement of resource whenever it changes.\n",
                        "willReplaceOnChanges": true
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The ID of a resource pool to put the virtual machine in.\n"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean",
                        "description": "Enable the run of scripts after virtual machine power-on when VMware Tools is installed.\n"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean",
                        "description": "Enable the run of scripts after virtual machine resume when when VMware Tools is installed.\n"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean",
                        "description": "Enable the run of scripts before guest operating system reboot when VMware Tools is installed.\n"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean",
                        "description": "Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.\n"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean",
                        "description": "Enable the run of scripts before guest operating system standby when VMware Tools is installed.\n"
                    },
                    "sataControllerCount": {
                        "type": "integer"
                    },
                    "scsiBusSharing": {
                        "type": "string",
                        "description": "Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.\n"
                    },
                    "scsiControllerCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "type": "string",
                        "description": "The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.\n"
                    },
                    "shutdownWaitTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.\n"
                    },
                    "storagePolicyId": {
                        "type": "string",
                        "description": "The ID of the storage policy to assign to the virtual machine home directory.\n"
                    },
                    "swapPlacementPolicy": {
                        "type": "string",
                        "description": "The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.\n"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean",
                        "description": "Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is\nsynchronized on startup and resume. Requires VMware Tools to be installed.\n"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean",
                        "description": "Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions\nsetting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs to apply to this object.\n"
                    },
                    "toolsUpgradePolicy": {
                        "type": "string",
                        "description": "Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.\n"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "The UUID of the virtual machine. Also exposed as the `id` of the resource.\n"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/VirtualMachineVapp:VirtualMachineVapp",
                        "description": "vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.\n"
                    },
                    "vappTransports": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Computed value which is only valid for cloned virtual machines. A list of vApp transport methods supported by the source virtual machine or template.\n"
                    },
                    "vbsEnabled": {
                        "type": "boolean",
                        "description": "Flag to specify if Virtualization-based security is enabled for this virtual machine.\n"
                    },
                    "vmwareToolsStatus": {
                        "type": "string",
                        "description": "The state of  VMware Tools in the guest. This will determine the proper course of action for some device operations.\n"
                    },
                    "vmxPath": {
                        "type": "string",
                        "description": "The path of the virtual machine configuration file on the datastore in which the virtual machine is placed.\n"
                    },
                    "vvtdEnabled": {
                        "type": "boolean",
                        "description": "Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD\nI/O Virtualization (AMD-Vi or IOMMU), is enabled.\n"
                    },
                    "waitForGuestIpTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                    },
                    "waitForGuestNetRoutable": {
                        "type": "boolean",
                        "description": "Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for\na default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.\n"
                    },
                    "waitForGuestNetTimeout": {
                        "type": "integer",
                        "description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1\ndisables the waiter.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachineClass:VirtualMachineClass": {
            "description": "Provides a resource for configuring a Virtual Machine class.\n\n## Example Usage\n\n### S\n\n**Create a basic class**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst basicClass = new vsphere.VirtualMachineClass(\"basic_class\", {\n    name: \"basic-class\",\n    cpus: 4,\n    memory: 4096,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nbasic_class = vsphere.VirtualMachineClass(\"basic_class\",\n    name=\"basic-class\",\n    cpus=4,\n    memory=4096)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var basicClass = new VSphere.VirtualMachineClass(\"basic_class\", new()\n    {\n        Name = \"basic-class\",\n        Cpus = 4,\n        Memory = 4096,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachineClass(ctx, \"basic_class\", \u0026vsphere.VirtualMachineClassArgs{\n\t\t\tName:   pulumi.String(\"basic-class\"),\n\t\t\tCpus:   pulumi.Int(4),\n\t\t\tMemory: pulumi.Int(4096),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachineClass;\nimport com.pulumi.vsphere.VirtualMachineClassArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var basicClass = new VirtualMachineClass(\"basicClass\", VirtualMachineClassArgs.builder()\n            .name(\"basic-class\")\n            .cpus(4)\n            .memory(4096)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  basicClass:\n    type: vsphere:VirtualMachineClass\n    name: basic_class\n    properties:\n      name: basic-class\n      cpus: 4\n      memory: 4096\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n**Create a class with a vGPU**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst vgpClass = new vsphere.VirtualMachineClass(\"vgp_class\", {\n    name: \"vgpu-class\",\n    cpus: 4,\n    memory: 4096,\n    memoryReservation: 100,\n    vgpuDevices: [\"vgpu1\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nvgp_class = vsphere.VirtualMachineClass(\"vgp_class\",\n    name=\"vgpu-class\",\n    cpus=4,\n    memory=4096,\n    memory_reservation=100,\n    vgpu_devices=[\"vgpu1\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vgpClass = new VSphere.VirtualMachineClass(\"vgp_class\", new()\n    {\n        Name = \"vgpu-class\",\n        Cpus = 4,\n        Memory = 4096,\n        MemoryReservation = 100,\n        VgpuDevices = new[]\n        {\n            \"vgpu1\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachineClass(ctx, \"vgp_class\", \u0026vsphere.VirtualMachineClassArgs{\n\t\t\tName:              pulumi.String(\"vgpu-class\"),\n\t\t\tCpus:              pulumi.Int(4),\n\t\t\tMemory:            pulumi.Int(4096),\n\t\t\tMemoryReservation: pulumi.Int(100),\n\t\t\tVgpuDevices: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vgpu1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachineClass;\nimport com.pulumi.vsphere.VirtualMachineClassArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vgpClass = new VirtualMachineClass(\"vgpClass\", VirtualMachineClassArgs.builder()\n            .name(\"vgpu-class\")\n            .cpus(4)\n            .memory(4096)\n            .memoryReservation(100)\n            .vgpuDevices(\"vgpu1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vgpClass:\n    type: vsphere:VirtualMachineClass\n    name: vgp_class\n    properties:\n      name: vgpu-class\n      cpus: 4\n      memory: 4096\n      memoryReservation: 100\n      vgpuDevices:\n        - vgpu1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "cpuReservation": {
                    "type": "integer",
                    "description": "The percentage of the available CPU capacity which will be reserved.\n"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of CPUs.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of memory in MB.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The percentage of memory reservation.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the class.\n"
                },
                "vgpuDevices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identifiers of the vGPU devices for the class. If this is set memory reservation needs to be 100.\n"
                }
            },
            "required": [
                "cpus",
                "memory",
                "name"
            ],
            "inputProperties": {
                "cpuReservation": {
                    "type": "integer",
                    "description": "The percentage of the available CPU capacity which will be reserved.\n"
                },
                "cpus": {
                    "type": "integer",
                    "description": "The number of CPUs.\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of memory in MB.\n"
                },
                "memoryReservation": {
                    "type": "integer",
                    "description": "The percentage of memory reservation.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name for the class.\n"
                },
                "vgpuDevices": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The identifiers of the vGPU devices for the class. If this is set memory reservation needs to be 100.\n"
                }
            },
            "requiredInputs": [
                "cpus",
                "memory"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachineClass resources.\n",
                "properties": {
                    "cpuReservation": {
                        "type": "integer",
                        "description": "The percentage of the available CPU capacity which will be reserved.\n"
                    },
                    "cpus": {
                        "type": "integer",
                        "description": "The number of CPUs.\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The amount of memory in MB.\n"
                    },
                    "memoryReservation": {
                        "type": "integer",
                        "description": "The percentage of memory reservation.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name for the class.\n"
                    },
                    "vgpuDevices": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The identifiers of the vGPU devices for the class. If this is set memory reservation needs to be 100.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/virtualMachineSnapshot:VirtualMachineSnapshot": {
            "description": "The `vsphere.VirtualMachineSnapshot` resource can be used to manage snapshots\nfor a virtual machine.\n\nFor more information on managing snapshots and how they work in VMware, see\n[here][ext-vm-snapshot-management].\n\n[ext-vm-snapshot-management]: https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-esxi-host-client/GUID-CA948C69-7F58-4519-AEB1-739545EA94E5.html\n\n\u003e **NOTE:** A snapshot in VMware differs from traditional disk snapshots, and\ncan contain the actual running state of the virtual machine, data for all disks\nthat have not been set to be independent from the snapshot (including ones that\nhave been attached via the `attach`\nparameter to the `vsphere.VirtualMachine` `disk` block), and even the\nconfiguration of the virtual machine at the time of the snapshot. Virtual\nmachine, disk activity, and configuration changes post-snapshot are not\nincluded in the original state. Use this resource with care! Neither VMware nor\nHashiCorp recommends retaining snapshots for a extended period of time and does\nNOT recommend using them as as backup feature. For more information on the\nlimitation of virtual machine snapshots, see [here][ext-vm-snap-limitations].\n\n[ext-vm-snap-limitations]: https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-53F65726-A23B-4CF0-A7D5-48E584B88613.html\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst demo1 = new vsphere.VirtualMachineSnapshot(\"demo1\", {\n    virtualMachineUuid: \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n    snapshotName: \"Snapshot Name\",\n    description: \"This is Demo Snapshot\",\n    memory: true,\n    quiesce: true,\n    removeChildren: false,\n    consolidate: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndemo1 = vsphere.VirtualMachineSnapshot(\"demo1\",\n    virtual_machine_uuid=\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n    snapshot_name=\"Snapshot Name\",\n    description=\"This is Demo Snapshot\",\n    memory=True,\n    quiesce=True,\n    remove_children=False,\n    consolidate=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var demo1 = new VSphere.VirtualMachineSnapshot(\"demo1\", new()\n    {\n        VirtualMachineUuid = \"9aac5551-a351-4158-8c5c-15a71e8ec5c9\",\n        SnapshotName = \"Snapshot Name\",\n        Description = \"This is Demo Snapshot\",\n        Memory = true,\n        Quiesce = true,\n        RemoveChildren = false,\n        Consolidate = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVirtualMachineSnapshot(ctx, \"demo1\", \u0026vsphere.VirtualMachineSnapshotArgs{\n\t\t\tVirtualMachineUuid: pulumi.String(\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\"),\n\t\t\tSnapshotName:       pulumi.String(\"Snapshot Name\"),\n\t\t\tDescription:        pulumi.String(\"This is Demo Snapshot\"),\n\t\t\tMemory:             pulumi.Bool(true),\n\t\t\tQuiesce:            pulumi.Bool(true),\n\t\t\tRemoveChildren:     pulumi.Bool(false),\n\t\t\tConsolidate:        pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VirtualMachineSnapshot;\nimport com.pulumi.vsphere.VirtualMachineSnapshotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var demo1 = new VirtualMachineSnapshot(\"demo1\", VirtualMachineSnapshotArgs.builder()\n            .virtualMachineUuid(\"9aac5551-a351-4158-8c5c-15a71e8ec5c9\")\n            .snapshotName(\"Snapshot Name\")\n            .description(\"This is Demo Snapshot\")\n            .memory(\"true\")\n            .quiesce(\"true\")\n            .removeChildren(\"false\")\n            .consolidate(\"true\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  demo1:\n    type: vsphere:VirtualMachineSnapshot\n    properties:\n      virtualMachineUuid: 9aac5551-a351-4158-8c5c-15a71e8ec5c9\n      snapshotName: Snapshot Name\n      description: This is Demo Snapshot\n      memory: 'true'\n      quiesce: 'true'\n      removeChildren: 'false'\n      consolidate: 'true'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n"
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n"
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n"
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n"
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n"
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n"
                }
            },
            "required": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "inputProperties": {
                "consolidate": {
                    "type": "boolean",
                    "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "A description for the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "memory": {
                    "type": "boolean",
                    "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "quiesce": {
                    "type": "boolean",
                    "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n",
                    "willReplaceOnChanges": true
                },
                "removeChildren": {
                    "type": "boolean",
                    "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n",
                    "willReplaceOnChanges": true
                },
                "snapshotName": {
                    "type": "string",
                    "description": "The name of the snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "virtualMachineUuid": {
                    "type": "string",
                    "description": "The virtual machine UUID.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "description",
                "memory",
                "quiesce",
                "snapshotName",
                "virtualMachineUuid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VirtualMachineSnapshot resources.\n",
                "properties": {
                    "consolidate": {
                        "type": "boolean",
                        "description": "If set to `true`, the delta disks involved in this\nsnapshot will be consolidated into the parent when this resource is\ndestroyed.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "A description for the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "memory": {
                        "type": "boolean",
                        "description": "If set to `true`, a dump of the internal state of the\nvirtual machine is included in the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "quiesce": {
                        "type": "boolean",
                        "description": "If set to `true`, and the virtual machine is powered\non when the snapshot is taken, VMware Tools is used to quiesce the file\nsystem in the virtual machine.\n",
                        "willReplaceOnChanges": true
                    },
                    "removeChildren": {
                        "type": "boolean",
                        "description": "If set to `true`, the entire snapshot subtree\nis removed when this resource is destroyed.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotName": {
                        "type": "string",
                        "description": "The name of the snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "virtualMachineUuid": {
                        "type": "string",
                        "description": "The virtual machine UUID.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vmStoragePolicy:VmStoragePolicy": {
            "description": "The `vsphere.VmStoragePolicy` resource can be used to create and manage storage\npolicies. Using this resource, tag based placement rules can be created to\nplace virtual machines on a datastore with matching tags. If storage requirements for the applications on the virtual machine change, you can modify the storage policy that was originally applied to the virtual machine.\n\n## Example Usage\n\nThe following example creates storage policies with `tag_rules` base on sets of environment, service level, and replication attributes.\n\nIn this example, tags are first applied to datastores.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst environment = vsphere.getTagCategory({\n    name: \"environment\",\n});\nconst serviceLevel = vsphere.getTagCategory({\n    name: \"service_level\",\n});\nconst replication = vsphere.getTagCategory({\n    name: \"replication\",\n});\nconst production = vsphere.getTag({\n    name: \"production\",\n    categoryId: \"data.vsphere_tag_category.environment.id\",\n});\nconst development = vsphere.getTag({\n    name: \"development\",\n    categoryId: \"data.vsphere_tag_category.environment.id\",\n});\nconst platinum = vsphere.getTag({\n    name: \"platinum\",\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n});\nconst gold = vsphere.getTag({\n    name: \"platinum\",\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n});\nconst silver = vsphere.getTag({\n    name: \"silver\",\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n});\nconst bronze = vsphere.getTag({\n    name: \"bronze\",\n    categoryId: \"data.vsphere_tag_category.service_level.id\",\n});\nconst replicated = vsphere.getTag({\n    name: \"replicated\",\n    categoryId: \"data.vsphere_tag_category.replication.id\",\n});\nconst nonReplicated = vsphere.getTag({\n    name: \"non_replicated\",\n    categoryId: \"data.vsphere_tag_category.replication.id\",\n});\nconst prodDatastore = new vsphere.VmfsDatastore(\"prod_datastore\", {tags: [\n    \"data.vsphere_tag.production.id\",\n    \"data.vsphere_tag.platinum.id\",\n    \"data.vsphere_tag.replicated.id\",\n]});\nconst devDatastore = new vsphere.NasDatastore(\"dev_datastore\", {tags: [\n    \"data.vsphere_tag.development.id\",\n    \"data.vsphere_tag.silver.id\",\n    \"data.vsphere_tag.non_replicated.id\",\n]});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nenvironment = vsphere.get_tag_category(name=\"environment\")\nservice_level = vsphere.get_tag_category(name=\"service_level\")\nreplication = vsphere.get_tag_category(name=\"replication\")\nproduction = vsphere.get_tag(name=\"production\",\n    category_id=\"data.vsphere_tag_category.environment.id\")\ndevelopment = vsphere.get_tag(name=\"development\",\n    category_id=\"data.vsphere_tag_category.environment.id\")\nplatinum = vsphere.get_tag(name=\"platinum\",\n    category_id=\"data.vsphere_tag_category.service_level.id\")\ngold = vsphere.get_tag(name=\"platinum\",\n    category_id=\"data.vsphere_tag_category.service_level.id\")\nsilver = vsphere.get_tag(name=\"silver\",\n    category_id=\"data.vsphere_tag_category.service_level.id\")\nbronze = vsphere.get_tag(name=\"bronze\",\n    category_id=\"data.vsphere_tag_category.service_level.id\")\nreplicated = vsphere.get_tag(name=\"replicated\",\n    category_id=\"data.vsphere_tag_category.replication.id\")\nnon_replicated = vsphere.get_tag(name=\"non_replicated\",\n    category_id=\"data.vsphere_tag_category.replication.id\")\nprod_datastore = vsphere.VmfsDatastore(\"prod_datastore\", tags=[\n    \"data.vsphere_tag.production.id\",\n    \"data.vsphere_tag.platinum.id\",\n    \"data.vsphere_tag.replicated.id\",\n])\ndev_datastore = vsphere.NasDatastore(\"dev_datastore\", tags=[\n    \"data.vsphere_tag.development.id\",\n    \"data.vsphere_tag.silver.id\",\n    \"data.vsphere_tag.non_replicated.id\",\n])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var environment = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"environment\",\n    });\n\n    var serviceLevel = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"service_level\",\n    });\n\n    var replication = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"replication\",\n    });\n\n    var production = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"production\",\n        CategoryId = \"data.vsphere_tag_category.environment.id\",\n    });\n\n    var development = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"development\",\n        CategoryId = \"data.vsphere_tag_category.environment.id\",\n    });\n\n    var platinum = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"platinum\",\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n    });\n\n    var gold = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"platinum\",\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n    });\n\n    var silver = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"silver\",\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n    });\n\n    var bronze = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"bronze\",\n        CategoryId = \"data.vsphere_tag_category.service_level.id\",\n    });\n\n    var replicated = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"replicated\",\n        CategoryId = \"data.vsphere_tag_category.replication.id\",\n    });\n\n    var nonReplicated = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"non_replicated\",\n        CategoryId = \"data.vsphere_tag_category.replication.id\",\n    });\n\n    var prodDatastore = new VSphere.VmfsDatastore(\"prod_datastore\", new()\n    {\n        Tags = new[]\n        {\n            \"data.vsphere_tag.production.id\",\n            \"data.vsphere_tag.platinum.id\",\n            \"data.vsphere_tag.replicated.id\",\n        },\n    });\n\n    var devDatastore = new VSphere.NasDatastore(\"dev_datastore\", new()\n    {\n        Tags = new[]\n        {\n            \"data.vsphere_tag.development.id\",\n            \"data.vsphere_tag.silver.id\",\n            \"data.vsphere_tag.non_replicated.id\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"environment\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"service_level\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"replication\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"production\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.environment.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"development\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.environment.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"platinum\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"platinum\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"silver\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"bronze\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.service_level.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"replicated\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.replication.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"non_replicated\",\n\t\t\tCategoryId: \"data.vsphere_tag_category.replication.id\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVmfsDatastore(ctx, \"prod_datastore\", \u0026vsphere.VmfsDatastoreArgs{\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"data.vsphere_tag.production.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.platinum.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.replicated.id\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewNasDatastore(ctx, \"dev_datastore\", \u0026vsphere.NasDatastoreArgs{\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"data.vsphere_tag.development.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.silver.id\"),\n\t\t\t\tpulumi.String(\"data.vsphere_tag.non_replicated.id\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport com.pulumi.vsphere.inputs.GetTagArgs;\nimport com.pulumi.vsphere.VmfsDatastore;\nimport com.pulumi.vsphere.VmfsDatastoreArgs;\nimport com.pulumi.vsphere.NasDatastore;\nimport com.pulumi.vsphere.NasDatastoreArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var environment = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"environment\")\n            .build());\n\n        final var serviceLevel = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"service_level\")\n            .build());\n\n        final var replication = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"replication\")\n            .build());\n\n        final var production = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"production\")\n            .categoryId(\"data.vsphere_tag_category.environment.id\")\n            .build());\n\n        final var development = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"development\")\n            .categoryId(\"data.vsphere_tag_category.environment.id\")\n            .build());\n\n        final var platinum = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"platinum\")\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .build());\n\n        final var gold = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"platinum\")\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .build());\n\n        final var silver = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"silver\")\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .build());\n\n        final var bronze = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"bronze\")\n            .categoryId(\"data.vsphere_tag_category.service_level.id\")\n            .build());\n\n        final var replicated = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"replicated\")\n            .categoryId(\"data.vsphere_tag_category.replication.id\")\n            .build());\n\n        final var nonReplicated = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"non_replicated\")\n            .categoryId(\"data.vsphere_tag_category.replication.id\")\n            .build());\n\n        var prodDatastore = new VmfsDatastore(\"prodDatastore\", VmfsDatastoreArgs.builder()\n            .tags(            \n                \"data.vsphere_tag.production.id\",\n                \"data.vsphere_tag.platinum.id\",\n                \"data.vsphere_tag.replicated.id\")\n            .build());\n\n        var devDatastore = new NasDatastore(\"devDatastore\", NasDatastoreArgs.builder()\n            .tags(            \n                \"data.vsphere_tag.development.id\",\n                \"data.vsphere_tag.silver.id\",\n                \"data.vsphere_tag.non_replicated.id\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodDatastore:\n    type: vsphere:VmfsDatastore\n    name: prod_datastore\n    properties:\n      tags: # ... other configuration ...\n        - data.vsphere_tag.production.id\n        - data.vsphere_tag.platinum.id\n        - data.vsphere_tag.replicated.id\n  devDatastore:\n    type: vsphere:NasDatastore\n    name: dev_datastore\n    properties:\n      tags: # ... other configuration ...\n        - data.vsphere_tag.development.id\n        - data.vsphere_tag.silver.id\n        - data.vsphere_tag.non_replicated.id\nvariables:\n  environment:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: environment\n  serviceLevel:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: service_level\n  replication:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: replication\n  production:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: production\n        categoryId: data.vsphere_tag_category.environment.id\n  development:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: development\n        categoryId: data.vsphere_tag_category.environment.id\n  platinum:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: platinum\n        categoryId: data.vsphere_tag_category.service_level.id\n  gold:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: platinum\n        categoryId: data.vsphere_tag_category.service_level.id\n  silver:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: silver\n        categoryId: data.vsphere_tag_category.service_level.id\n  bronze:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: bronze\n        categoryId: data.vsphere_tag_category.service_level.id\n  replicated:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: replicated\n        categoryId: data.vsphere_tag_category.replication.id\n  nonReplicated:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: non_replicated\n        categoryId: data.vsphere_tag_category.replication.id\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nNext, storage policies are created and `tag_rules` are applied.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodPlatinumReplicated = new vsphere.VmStoragePolicy(\"prod_platinum_replicated\", {\n    name: \"prod_platinum_replicated\",\n    description: \"prod_platinum_replicated\",\n    tagRules: [\n        {\n            tagCategory: environment.name,\n            tags: [production.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: serviceLevel.name,\n            tags: [platinum.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: replication.name,\n            tags: [replicated.name],\n            includeDatastoresWithTags: true,\n        },\n    ],\n});\nconst devSilverNonreplicated = new vsphere.VmStoragePolicy(\"dev_silver_nonreplicated\", {\n    name: \"dev_silver_nonreplicated\",\n    description: \"dev_silver_nonreplicated\",\n    tagRules: [\n        {\n            tagCategory: environment.name,\n            tags: [development.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: serviceLevel.name,\n            tags: [silver.name],\n            includeDatastoresWithTags: true,\n        },\n        {\n            tagCategory: replication.name,\n            tags: [nonReplicated.name],\n            includeDatastoresWithTags: true,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_platinum_replicated = vsphere.VmStoragePolicy(\"prod_platinum_replicated\",\n    name=\"prod_platinum_replicated\",\n    description=\"prod_platinum_replicated\",\n    tag_rules=[\n        {\n            \"tag_category\": environment[\"name\"],\n            \"tags\": [production[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n        {\n            \"tag_category\": service_level[\"name\"],\n            \"tags\": [platinum[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n        {\n            \"tag_category\": replication[\"name\"],\n            \"tags\": [replicated[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n    ])\ndev_silver_nonreplicated = vsphere.VmStoragePolicy(\"dev_silver_nonreplicated\",\n    name=\"dev_silver_nonreplicated\",\n    description=\"dev_silver_nonreplicated\",\n    tag_rules=[\n        {\n            \"tag_category\": environment[\"name\"],\n            \"tags\": [development[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n        {\n            \"tag_category\": service_level[\"name\"],\n            \"tags\": [silver[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n        {\n            \"tag_category\": replication[\"name\"],\n            \"tags\": [non_replicated[\"name\"]],\n            \"include_datastores_with_tags\": True,\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodPlatinumReplicated = new VSphere.VmStoragePolicy(\"prod_platinum_replicated\", new()\n    {\n        Name = \"prod_platinum_replicated\",\n        Description = \"prod_platinum_replicated\",\n        TagRules = new[]\n        {\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = environment.Name,\n                Tags = new[]\n                {\n                    production.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = serviceLevel.Name,\n                Tags = new[]\n                {\n                    platinum.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = replication.Name,\n                Tags = new[]\n                {\n                    replicated.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n        },\n    });\n\n    var devSilverNonreplicated = new VSphere.VmStoragePolicy(\"dev_silver_nonreplicated\", new()\n    {\n        Name = \"dev_silver_nonreplicated\",\n        Description = \"dev_silver_nonreplicated\",\n        TagRules = new[]\n        {\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = environment.Name,\n                Tags = new[]\n                {\n                    development.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = serviceLevel.Name,\n                Tags = new[]\n                {\n                    silver.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n            new VSphere.Inputs.VmStoragePolicyTagRuleArgs\n            {\n                TagCategory = replication.Name,\n                Tags = new[]\n                {\n                    nonReplicated.Name,\n                },\n                IncludeDatastoresWithTags = true,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.NewVmStoragePolicy(ctx, \"prod_platinum_replicated\", \u0026vsphere.VmStoragePolicyArgs{\n\t\t\tName:        pulumi.String(\"prod_platinum_replicated\"),\n\t\t\tDescription: pulumi.String(\"prod_platinum_replicated\"),\n\t\t\tTagRules: vsphere.VmStoragePolicyTagRuleArray{\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(environment.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tproduction.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(serviceLevel.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tplatinum.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(replication.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\treplicated.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVmStoragePolicy(ctx, \"dev_silver_nonreplicated\", \u0026vsphere.VmStoragePolicyArgs{\n\t\t\tName:        pulumi.String(\"dev_silver_nonreplicated\"),\n\t\t\tDescription: pulumi.String(\"dev_silver_nonreplicated\"),\n\t\t\tTagRules: vsphere.VmStoragePolicyTagRuleArray{\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(environment.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tdevelopment.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(serviceLevel.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tsilver.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026vsphere.VmStoragePolicyTagRuleArgs{\n\t\t\t\t\tTagCategory: pulumi.Any(replication.Name),\n\t\t\t\t\tTags: pulumi.StringArray{\n\t\t\t\t\t\tnonReplicated.Name,\n\t\t\t\t\t},\n\t\t\t\t\tIncludeDatastoresWithTags: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VmStoragePolicy;\nimport com.pulumi.vsphere.VmStoragePolicyArgs;\nimport com.pulumi.vsphere.inputs.VmStoragePolicyTagRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var prodPlatinumReplicated = new VmStoragePolicy(\"prodPlatinumReplicated\", VmStoragePolicyArgs.builder()\n            .name(\"prod_platinum_replicated\")\n            .description(\"prod_platinum_replicated\")\n            .tagRules(            \n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(environment.name())\n                    .tags(production.name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(serviceLevel.name())\n                    .tags(platinum.name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(replication.name())\n                    .tags(replicated.name())\n                    .includeDatastoresWithTags(true)\n                    .build())\n            .build());\n\n        var devSilverNonreplicated = new VmStoragePolicy(\"devSilverNonreplicated\", VmStoragePolicyArgs.builder()\n            .name(\"dev_silver_nonreplicated\")\n            .description(\"dev_silver_nonreplicated\")\n            .tagRules(            \n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(environment.name())\n                    .tags(development.name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(serviceLevel.name())\n                    .tags(silver.name())\n                    .includeDatastoresWithTags(true)\n                    .build(),\n                VmStoragePolicyTagRuleArgs.builder()\n                    .tagCategory(replication.name())\n                    .tags(nonReplicated.name())\n                    .includeDatastoresWithTags(true)\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodPlatinumReplicated:\n    type: vsphere:VmStoragePolicy\n    name: prod_platinum_replicated\n    properties:\n      name: prod_platinum_replicated\n      description: prod_platinum_replicated\n      tagRules:\n        - tagCategory: ${environment.name}\n          tags:\n            - ${production.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${serviceLevel.name}\n          tags:\n            - ${platinum.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${replication.name}\n          tags:\n            - ${replicated.name}\n          includeDatastoresWithTags: true\n  devSilverNonreplicated:\n    type: vsphere:VmStoragePolicy\n    name: dev_silver_nonreplicated\n    properties:\n      name: dev_silver_nonreplicated\n      description: dev_silver_nonreplicated\n      tagRules:\n        - tagCategory: ${environment.name}\n          tags:\n            - ${development.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${serviceLevel.name}\n          tags:\n            - ${silver.name}\n          includeDatastoresWithTags: true\n        - tagCategory: ${replication.name}\n          tags:\n            - ${nonReplicated.name}\n          includeDatastoresWithTags: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nLastly, when creating a virtual machine resource, a storage policy can be specified to direct virtual machine placement to a datastore which matches the policy's `tags_rules`.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodPlatinumReplicated = vsphere.getPolicy({\n    name: \"prod_platinum_replicated\",\n});\nconst devSilverNonreplicated = vsphere.getPolicy({\n    name: \"dev_silver_nonreplicated\",\n});\nconst prodVm = new vsphere.VirtualMachine(\"prod_vm\", {storagePolicyId: storagePolicy.prodPlatinumReplicated.id});\nconst devVm = new vsphere.VirtualMachine(\"dev_vm\", {storagePolicyId: storagePolicy.devSilverNonreplicated.id});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_platinum_replicated = vsphere.get_policy(name=\"prod_platinum_replicated\")\ndev_silver_nonreplicated = vsphere.get_policy(name=\"dev_silver_nonreplicated\")\nprod_vm = vsphere.VirtualMachine(\"prod_vm\", storage_policy_id=storage_policy[\"prodPlatinumReplicated\"][\"id\"])\ndev_vm = vsphere.VirtualMachine(\"dev_vm\", storage_policy_id=storage_policy[\"devSilverNonreplicated\"][\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodPlatinumReplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"prod_platinum_replicated\",\n    });\n\n    var devSilverNonreplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"dev_silver_nonreplicated\",\n    });\n\n    var prodVm = new VSphere.VirtualMachine(\"prod_vm\", new()\n    {\n        StoragePolicyId = storagePolicy.ProdPlatinumReplicated.Id,\n    });\n\n    var devVm = new VSphere.VirtualMachine(\"dev_vm\", new()\n    {\n        StoragePolicyId = storagePolicy.DevSilverNonreplicated.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"prod_platinum_replicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"dev_silver_nonreplicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVirtualMachine(ctx, \"prod_vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tStoragePolicyId: pulumi.Any(storagePolicy.ProdPlatinumReplicated.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVirtualMachine(ctx, \"dev_vm\", \u0026vsphere.VirtualMachineArgs{\n\t\t\tStoragePolicyId: pulumi.Any(storagePolicy.DevSilverNonreplicated.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetPolicyArgs;\nimport com.pulumi.vsphere.VirtualMachine;\nimport com.pulumi.vsphere.VirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var prodPlatinumReplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"prod_platinum_replicated\")\n            .build());\n\n        final var devSilverNonreplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"dev_silver_nonreplicated\")\n            .build());\n\n        var prodVm = new VirtualMachine(\"prodVm\", VirtualMachineArgs.builder()\n            .storagePolicyId(storagePolicy.prodPlatinumReplicated().id())\n            .build());\n\n        var devVm = new VirtualMachine(\"devVm\", VirtualMachineArgs.builder()\n            .storagePolicyId(storagePolicy.devSilverNonreplicated().id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  prodVm:\n    type: vsphere:VirtualMachine\n    name: prod_vm\n    properties:\n      storagePolicyId: ${storagePolicy.prodPlatinumReplicated.id}\n  devVm:\n    type: vsphere:VirtualMachine\n    name: dev_vm\n    properties:\n      storagePolicyId: ${storagePolicy.devSilverNonreplicated.id}\nvariables:\n  prodPlatinumReplicated:\n    fn::invoke:\n      Function: vsphere:getPolicy\n      Arguments:\n        name: prod_platinum_replicated\n  devSilverNonreplicated:\n    fn::invoke:\n      Function: vsphere:getPolicy\n      Arguments:\n        name: dev_silver_nonreplicated\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the storage policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "tagRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                    },
                    "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                }
            },
            "required": [
                "name",
                "tagRules"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the storage policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the storage policy.\n"
                },
                "tagRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                    },
                    "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                }
            },
            "requiredInputs": [
                "tagRules"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmStoragePolicy resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Description of the storage policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    },
                    "tagRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/vsphere:index/VmStoragePolicyTagRule:VmStoragePolicyTagRule"
                        },
                        "description": "List of tag rules. The tag category and tags to be associated to this storage policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vmfsDatastore:VmfsDatastore": {
            "properties": {
                "accessible": {
                    "type": "boolean",
                    "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                },
                "capacity": {
                    "type": "integer",
                    "description": "Maximum capacity of the datastore, in megabytes.\n"
                },
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "freeSpace": {
                    "type": "integer",
                    "description": "Available space of this datastore, in megabytes.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n"
                },
                "maintenanceMode": {
                    "type": "string",
                    "description": "The current maintenance mode state of the datastore.\n"
                },
                "multipleHostAccess": {
                    "type": "boolean",
                    "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                },
                "uncommittedSpace": {
                    "type": "integer",
                    "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                },
                "url": {
                    "type": "string",
                    "description": "The unique locator for the datastore.\n"
                }
            },
            "required": [
                "accessible",
                "capacity",
                "disks",
                "freeSpace",
                "hostSystemId",
                "maintenanceMode",
                "multipleHostAccess",
                "name",
                "uncommittedSpace",
                "url"
            ],
            "inputProperties": {
                "customAttributes": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                },
                "datastoreClusterId": {
                    "type": "string",
                    "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The disks to use with the datastore.\n"
                },
                "folder": {
                    "type": "string",
                    "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                },
                "hostSystemId": {
                    "type": "string",
                    "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                }
            },
            "requiredInputs": [
                "disks",
                "hostSystemId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VmfsDatastore resources.\n",
                "properties": {
                    "accessible": {
                        "type": "boolean",
                        "description": "The connectivity status of the datastore. If this is `false`,\nsome other computed attributes may be out of date.\n"
                    },
                    "capacity": {
                        "type": "integer",
                        "description": "Maximum capacity of the datastore, in megabytes.\n"
                    },
                    "customAttributes": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map of custom attribute ids to attribute \nvalue string to set on datastore resource.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi connections\nand require vCenter.\n"
                    },
                    "datastoreClusterId": {
                        "type": "string",
                        "description": "The managed object\nID of a datastore cluster to put this datastore in.\nConflicts with `folder`.\n"
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The disks to use with the datastore.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The relative path to a folder to put this datastore in.\nThis is a path relative to the datacenter you are deploying the datastore to.\nExample: for the `dc1` datacenter, and a provided `folder` of `foo/bar`,\nThe provider will place a datastore named `test` in a datastore folder\nlocated at `/dc1/datastore/foo/bar`, with the final inventory path being\n`/dc1/datastore/foo/bar/test`. Conflicts with\n`datastore_cluster_id`.\n"
                    },
                    "freeSpace": {
                        "type": "integer",
                        "description": "Available space of this datastore, in megabytes.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to set the datastore up on. Note that this is not necessarily the\nonly host that the datastore will be set up on - see\nhere for more info. Forces a\nnew resource if changed.\n",
                        "willReplaceOnChanges": true
                    },
                    "maintenanceMode": {
                        "type": "string",
                        "description": "The current maintenance mode state of the datastore.\n"
                    },
                    "multipleHostAccess": {
                        "type": "boolean",
                        "description": "If `true`, more than one host in the datacenter has\nbeen configured with access to the datastore.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. Forces a new resource if\nchanged.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The IDs of any tags to attach to this resource. \n\n\u003e **NOTE:** Tagging support is unsupported on direct ESXi connections and\nrequires vCenter 6.0 or higher.\n"
                    },
                    "uncommittedSpace": {
                        "type": "integer",
                        "description": "Total additional storage space, in megabytes,\npotentially used by all virtual machines on this datastore.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "The unique locator for the datastore.\n"
                    }
                },
                "type": "object"
            }
        },
        "vsphere:index/vnic:Vnic": {
            "description": "Provides a VMware vSphere vnic resource.\n\n## Example Usage\n\n### Create a vnic attached to a distributed virtual switch using the vmotion TCP/IP stack\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst vds = new vsphere.DistributedVirtualSwitch(\"vds\", {\n    name: \"vds-01\",\n    datacenterId: datacenter.then(datacenter =\u003e datacenter.id),\n    hosts: [{\n        hostSystemId: host.then(host =\u003e host.id),\n        devices: [\"vnic3\"],\n    }],\n});\nconst pg = new vsphere.DistributedPortGroup(\"pg\", {\n    name: \"pg-01\",\n    vlanId: 1234,\n    distributedVirtualSwitchUuid: vds.id,\n});\nconst vnic = new vsphere.Vnic(\"vnic\", {\n    host: host.then(host =\u003e host.id),\n    distributedSwitchPort: vds.id,\n    distributedPortGroup: pg.id,\n    ipv4: {\n        dhcp: true,\n    },\n    netstack: \"vmotion\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nvds = vsphere.DistributedVirtualSwitch(\"vds\",\n    name=\"vds-01\",\n    datacenter_id=datacenter.id,\n    hosts=[{\n        \"host_system_id\": host.id,\n        \"devices\": [\"vnic3\"],\n    }])\npg = vsphere.DistributedPortGroup(\"pg\",\n    name=\"pg-01\",\n    vlan_id=1234,\n    distributed_virtual_switch_uuid=vds.id)\nvnic = vsphere.Vnic(\"vnic\",\n    host=host.id,\n    distributed_switch_port=vds.id,\n    distributed_port_group=pg.id,\n    ipv4={\n        \"dhcp\": True,\n    },\n    netstack=\"vmotion\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vds = new VSphere.DistributedVirtualSwitch(\"vds\", new()\n    {\n        Name = \"vds-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n        Hosts = new[]\n        {\n            new VSphere.Inputs.DistributedVirtualSwitchHostArgs\n            {\n                HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n                Devices = new[]\n                {\n                    \"vnic3\",\n                },\n            },\n        },\n    });\n\n    var pg = new VSphere.DistributedPortGroup(\"pg\", new()\n    {\n        Name = \"pg-01\",\n        VlanId = 1234,\n        DistributedVirtualSwitchUuid = vds.Id,\n    });\n\n    var vnic = new VSphere.Vnic(\"vnic\", new()\n    {\n        Host = host.Apply(getHostResult =\u003e getHostResult.Id),\n        DistributedSwitchPort = vds.Id,\n        DistributedPortGroup = pg.Id,\n        Ipv4 = new VSphere.Inputs.VnicIpv4Args\n        {\n            Dhcp = true,\n        },\n        Netstack = \"vmotion\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvds, err := vsphere.NewDistributedVirtualSwitch(ctx, \"vds\", \u0026vsphere.DistributedVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"vds-01\"),\n\t\t\tDatacenterId: pulumi.String(datacenter.Id),\n\t\t\tHosts: vsphere.DistributedVirtualSwitchHostArray{\n\t\t\t\t\u0026vsphere.DistributedVirtualSwitchHostArgs{\n\t\t\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\t\t\tDevices: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"vnic3\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpg, err := vsphere.NewDistributedPortGroup(ctx, \"pg\", \u0026vsphere.DistributedPortGroupArgs{\n\t\t\tName:                         pulumi.String(\"pg-01\"),\n\t\t\tVlanId:                       pulumi.Int(1234),\n\t\t\tDistributedVirtualSwitchUuid: vds.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVnic(ctx, \"vnic\", \u0026vsphere.VnicArgs{\n\t\t\tHost:                  pulumi.String(host.Id),\n\t\t\tDistributedSwitchPort: vds.ID(),\n\t\t\tDistributedPortGroup:  pg.ID(),\n\t\t\tIpv4: \u0026vsphere.VnicIpv4Args{\n\t\t\t\tDhcp: pulumi.Bool(true),\n\t\t\t},\n\t\t\tNetstack: pulumi.String(\"vmotion\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.DistributedVirtualSwitch;\nimport com.pulumi.vsphere.DistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.inputs.DistributedVirtualSwitchHostArgs;\nimport com.pulumi.vsphere.DistributedPortGroup;\nimport com.pulumi.vsphere.DistributedPortGroupArgs;\nimport com.pulumi.vsphere.Vnic;\nimport com.pulumi.vsphere.VnicArgs;\nimport com.pulumi.vsphere.inputs.VnicIpv4Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var vds = new DistributedVirtualSwitch(\"vds\", DistributedVirtualSwitchArgs.builder()\n            .name(\"vds-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .hosts(DistributedVirtualSwitchHostArgs.builder()\n                .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n                .devices(\"vnic3\")\n                .build())\n            .build());\n\n        var pg = new DistributedPortGroup(\"pg\", DistributedPortGroupArgs.builder()\n            .name(\"pg-01\")\n            .vlanId(1234)\n            .distributedVirtualSwitchUuid(vds.id())\n            .build());\n\n        var vnic = new Vnic(\"vnic\", VnicArgs.builder()\n            .host(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .distributedSwitchPort(vds.id())\n            .distributedPortGroup(pg.id())\n            .ipv4(VnicIpv4Args.builder()\n                .dhcp(true)\n                .build())\n            .netstack(\"vmotion\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  vds:\n    type: vsphere:DistributedVirtualSwitch\n    properties:\n      name: vds-01\n      datacenterId: ${datacenter.id}\n      hosts:\n        - hostSystemId: ${host.id}\n          devices:\n            - vnic3\n  pg:\n    type: vsphere:DistributedPortGroup\n    properties:\n      name: pg-01\n      vlanId: 1234\n      distributedVirtualSwitchUuid: ${vds.id}\n  vnic:\n    type: vsphere:Vnic\n    properties:\n      host: ${host.id}\n      distributedSwitchPort: ${vds.id}\n      distributedPortGroup: ${pg.id}\n      ipv4:\n        dhcp: true\n      netstack: vmotion\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Create a vnic attached to a portgroup using the default TCP/IP stack\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst hvs = new vsphere.HostVirtualSwitch(\"hvs\", {\n    name: \"hvs-01\",\n    hostSystemId: host.then(host =\u003e host.id),\n    networkAdapters: [\n        \"vmnic3\",\n        \"vmnic4\",\n    ],\n    activeNics: [\"vmnic3\"],\n    standbyNics: [\"vmnic4\"],\n});\nconst pg = new vsphere.HostPortGroup(\"pg\", {\n    name: \"pg-01\",\n    virtualSwitchName: hvs.name,\n    hostSystemId: host.then(host =\u003e host.id),\n});\nconst vnic = new vsphere.Vnic(\"vnic\", {\n    host: host.then(host =\u003e host.id),\n    portgroup: pg.name,\n    ipv4: {\n        dhcp: true,\n    },\n    services: [\n        \"vsan\",\n        \"management\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nhvs = vsphere.HostVirtualSwitch(\"hvs\",\n    name=\"hvs-01\",\n    host_system_id=host.id,\n    network_adapters=[\n        \"vmnic3\",\n        \"vmnic4\",\n    ],\n    active_nics=[\"vmnic3\"],\n    standby_nics=[\"vmnic4\"])\npg = vsphere.HostPortGroup(\"pg\",\n    name=\"pg-01\",\n    virtual_switch_name=hvs.name,\n    host_system_id=host.id)\nvnic = vsphere.Vnic(\"vnic\",\n    host=host.id,\n    portgroup=pg.name,\n    ipv4={\n        \"dhcp\": True,\n    },\n    services=[\n        \"vsan\",\n        \"management\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hvs = new VSphere.HostVirtualSwitch(\"hvs\", new()\n    {\n        Name = \"hvs-01\",\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NetworkAdapters = new[]\n        {\n            \"vmnic3\",\n            \"vmnic4\",\n        },\n        ActiveNics = new[]\n        {\n            \"vmnic3\",\n        },\n        StandbyNics = new[]\n        {\n            \"vmnic4\",\n        },\n    });\n\n    var pg = new VSphere.HostPortGroup(\"pg\", new()\n    {\n        Name = \"pg-01\",\n        VirtualSwitchName = hvs.Name,\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n    });\n\n    var vnic = new VSphere.Vnic(\"vnic\", new()\n    {\n        Host = host.Apply(getHostResult =\u003e getHostResult.Id),\n        Portgroup = pg.Name,\n        Ipv4 = new VSphere.Inputs.VnicIpv4Args\n        {\n            Dhcp = true,\n        },\n        Services = new[]\n        {\n            \"vsan\",\n            \"management\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thvs, err := vsphere.NewHostVirtualSwitch(ctx, \"hvs\", \u0026vsphere.HostVirtualSwitchArgs{\n\t\t\tName:         pulumi.String(\"hvs-01\"),\n\t\t\tHostSystemId: pulumi.String(host.Id),\n\t\t\tNetworkAdapters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic3\"),\n\t\t\t\tpulumi.String(\"vmnic4\"),\n\t\t\t},\n\t\t\tActiveNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic3\"),\n\t\t\t},\n\t\t\tStandbyNics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vmnic4\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpg, err := vsphere.NewHostPortGroup(ctx, \"pg\", \u0026vsphere.HostPortGroupArgs{\n\t\t\tName:              pulumi.String(\"pg-01\"),\n\t\t\tVirtualSwitchName: hvs.Name,\n\t\t\tHostSystemId:      pulumi.String(host.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewVnic(ctx, \"vnic\", \u0026vsphere.VnicArgs{\n\t\t\tHost:      pulumi.String(host.Id),\n\t\t\tPortgroup: pg.Name,\n\t\t\tIpv4: \u0026vsphere.VnicIpv4Args{\n\t\t\t\tDhcp: pulumi.Bool(true),\n\t\t\t},\n\t\t\tServices: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"vsan\"),\n\t\t\t\tpulumi.String(\"management\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.HostVirtualSwitch;\nimport com.pulumi.vsphere.HostVirtualSwitchArgs;\nimport com.pulumi.vsphere.HostPortGroup;\nimport com.pulumi.vsphere.HostPortGroupArgs;\nimport com.pulumi.vsphere.Vnic;\nimport com.pulumi.vsphere.VnicArgs;\nimport com.pulumi.vsphere.inputs.VnicIpv4Args;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var hvs = new HostVirtualSwitch(\"hvs\", HostVirtualSwitchArgs.builder()\n            .name(\"hvs-01\")\n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .networkAdapters(            \n                \"vmnic3\",\n                \"vmnic4\")\n            .activeNics(\"vmnic3\")\n            .standbyNics(\"vmnic4\")\n            .build());\n\n        var pg = new HostPortGroup(\"pg\", HostPortGroupArgs.builder()\n            .name(\"pg-01\")\n            .virtualSwitchName(hvs.name())\n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .build());\n\n        var vnic = new Vnic(\"vnic\", VnicArgs.builder()\n            .host(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .portgroup(pg.name())\n            .ipv4(VnicIpv4Args.builder()\n                .dhcp(true)\n                .build())\n            .services(            \n                \"vsan\",\n                \"management\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hvs:\n    type: vsphere:HostVirtualSwitch\n    properties:\n      name: hvs-01\n      hostSystemId: ${host.id}\n      networkAdapters:\n        - vmnic3\n        - vmnic4\n      activeNics:\n        - vmnic3\n      standbyNics:\n        - vmnic4\n  pg:\n    type: vsphere:HostPortGroup\n    properties:\n      name: pg-01\n      virtualSwitchName: ${hvs.name}\n      hostSystemId: ${host.id}\n  vnic:\n    type: vsphere:Vnic\n    properties:\n      host: ${host.id}\n      portgroup: ${pg.name}\n      ipv4:\n        dhcp: true\n      services:\n        - vsan\n        - management\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Importing\n\nAn existing vNic can be [imported][docs-import] into this resource\nvia supplying the vNic's ID. An example is below:\n\n[docs-import]: /docs/import/index.html\n\n```\nterraform import vsphere_vnic.vnic host-123_vmk2\n```\n\nThe above would import the vnic `vmk2` from host with ID `host-123`.\n",
            "properties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to.\n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the vdswitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n"
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See IPv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See IPv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are `defaultTcpipStack``, 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default:`defaultTcpipStack`)\n"
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Enabled services setting for this interface. Currently support values are `vmotion`, `management`, and `vsan`.\n"
                }
            },
            "required": [
                "host",
                "mac",
                "mtu"
            ],
            "inputProperties": {
                "distributedPortGroup": {
                    "type": "string",
                    "description": "Key of the distributed portgroup the nic will connect to.\n"
                },
                "distributedSwitchPort": {
                    "type": "string",
                    "description": "UUID of the vdswitch the nic will be attached to. Do not set if you set portgroup.\n"
                },
                "host": {
                    "type": "string",
                    "description": "ESX host the interface belongs to\n",
                    "willReplaceOnChanges": true
                },
                "ipv4": {
                    "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                    "description": "IPv4 settings. Either this or `ipv6` needs to be set. See IPv4 options below.\n"
                },
                "ipv6": {
                    "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                    "description": "IPv6 settings. Either this or `ipv6` needs to be set. See IPv6 options below.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "MAC address of the interface.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU of the interface.\n"
                },
                "netstack": {
                    "type": "string",
                    "description": "TCP/IP stack setting for this interface. Possible values are `defaultTcpipStack``, 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default:`defaultTcpipStack`)\n",
                    "willReplaceOnChanges": true
                },
                "portgroup": {
                    "type": "string",
                    "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Enabled services setting for this interface. Currently support values are `vmotion`, `management`, and `vsan`.\n"
                }
            },
            "requiredInputs": [
                "host"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vnic resources.\n",
                "properties": {
                    "distributedPortGroup": {
                        "type": "string",
                        "description": "Key of the distributed portgroup the nic will connect to.\n"
                    },
                    "distributedSwitchPort": {
                        "type": "string",
                        "description": "UUID of the vdswitch the nic will be attached to. Do not set if you set portgroup.\n"
                    },
                    "host": {
                        "type": "string",
                        "description": "ESX host the interface belongs to\n",
                        "willReplaceOnChanges": true
                    },
                    "ipv4": {
                        "$ref": "#/types/vsphere:index/VnicIpv4:VnicIpv4",
                        "description": "IPv4 settings. Either this or `ipv6` needs to be set. See IPv4 options below.\n"
                    },
                    "ipv6": {
                        "$ref": "#/types/vsphere:index/VnicIpv6:VnicIpv6",
                        "description": "IPv6 settings. Either this or `ipv6` needs to be set. See IPv6 options below.\n"
                    },
                    "mac": {
                        "type": "string",
                        "description": "MAC address of the interface.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "MTU of the interface.\n"
                    },
                    "netstack": {
                        "type": "string",
                        "description": "TCP/IP stack setting for this interface. Possible values are `defaultTcpipStack``, 'vmotion', 'vSphereProvisioning'. Changing this will force the creation of a new interface since it's not possible to change the stack once it gets created. (Default:`defaultTcpipStack`)\n",
                        "willReplaceOnChanges": true
                    },
                    "portgroup": {
                        "type": "string",
                        "description": "Portgroup to attach the nic to. Do not set if you set distributed_switch_port.\n"
                    },
                    "services": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Enabled services setting for this interface. Currently support values are `vmotion`, `management`, and `vsan`.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "vsphere:index/getComputeCluster:getComputeCluster": {
            "description": "The `vsphere.ComputeCluster` data source can be used to discover the ID of a\ncluster in vSphere. This is useful to fetch the ID of a cluster that you want\nto use for virtual machine placement via the `vsphere.VirtualMachine` resource, allowing to specify the cluster's root resource pool directly versus\nusing the alias available through the `vsphere.ResourcePool`\ndata source.\n\n\u003e You may also wish to see the `vsphere.ComputeCluster`\n resource for more information about clusters and how to managed the resource\n in this provider.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst computeCluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncompute_cluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var computeCluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var computeCluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  computeCluster:\n    fn::invoke:\n      Function: vsphere:getComputeCluster\n      Arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the cluster is located in.  This can be omitted if the\nsearch path used in `name` is an absolute path. For default datacenters,\nuse the `id` attribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getComputeCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "description": "The managed object reference ID of\nthe root resource pool for the cluster.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "resourcePoolId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getComputeClusterHostGroup:getComputeClusterHostGroup": {
            "description": "The `vsphere.ComputeClusterHostGroup` data source can be used to discover\nthe IDs ESXi hosts in a host group and return host group attributes to other\nresources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst cluster = datacenter.then(datacenter =\u003e vsphere.getComputeCluster({\n    name: \"cluster-01\",\n    datacenterId: datacenter.id,\n}));\nconst hostGroup = cluster.then(cluster =\u003e vsphere.getComputeClusterHostGroup({\n    name: \"hostgroup-01\",\n    computeClusterId: cluster.id,\n}));\nconst hostRule = new vsphere.ComputeClusterVmHostRule(\"host_rule\", {\n    computeClusterId: cluster.then(cluster =\u003e cluster.id),\n    name: \"terraform-host-rule1\",\n    vmGroupName: \"vmgroup-01\",\n    affinityHostGroupName: hostGroup.then(hostGroup =\u003e hostGroup.name),\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ncluster = vsphere.get_compute_cluster(name=\"cluster-01\",\n    datacenter_id=datacenter.id)\nhost_group = vsphere.get_compute_cluster_host_group(name=\"hostgroup-01\",\n    compute_cluster_id=cluster.id)\nhost_rule = vsphere.ComputeClusterVmHostRule(\"host_rule\",\n    compute_cluster_id=cluster.id,\n    name=\"terraform-host-rule1\",\n    vm_group_name=\"vmgroup-01\",\n    affinity_host_group_name=host_group.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var cluster = VSphere.GetComputeCluster.Invoke(new()\n    {\n        Name = \"cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var hostGroup = VSphere.GetComputeClusterHostGroup.Invoke(new()\n    {\n        Name = \"hostgroup-01\",\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n    });\n\n    var hostRule = new VSphere.ComputeClusterVmHostRule(\"host_rule\", new()\n    {\n        ComputeClusterId = cluster.Apply(getComputeClusterResult =\u003e getComputeClusterResult.Id),\n        Name = \"terraform-host-rule1\",\n        VmGroupName = \"vmgroup-01\",\n        AffinityHostGroupName = hostGroup.Apply(getComputeClusterHostGroupResult =\u003e getComputeClusterHostGroupResult.Name),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcluster, err := vsphere.LookupComputeCluster(ctx, \u0026vsphere.LookupComputeClusterArgs{\n\t\t\tName:         \"cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostGroup, err := vsphere.LookupComputeClusterHostGroup(ctx, \u0026vsphere.LookupComputeClusterHostGroupArgs{\n\t\t\tName:             \"hostgroup-01\",\n\t\t\tComputeClusterId: cluster.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewComputeClusterVmHostRule(ctx, \"host_rule\", \u0026vsphere.ComputeClusterVmHostRuleArgs{\n\t\t\tComputeClusterId:      pulumi.String(cluster.Id),\n\t\t\tName:                  pulumi.String(\"terraform-host-rule1\"),\n\t\t\tVmGroupName:           pulumi.String(\"vmgroup-01\"),\n\t\t\tAffinityHostGroupName: pulumi.String(hostGroup.Name),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterArgs;\nimport com.pulumi.vsphere.inputs.GetComputeClusterHostGroupArgs;\nimport com.pulumi.vsphere.ComputeClusterVmHostRule;\nimport com.pulumi.vsphere.ComputeClusterVmHostRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var cluster = VsphereFunctions.getComputeCluster(GetComputeClusterArgs.builder()\n            .name(\"cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var hostGroup = VsphereFunctions.getComputeClusterHostGroup(GetComputeClusterHostGroupArgs.builder()\n            .name(\"hostgroup-01\")\n            .computeClusterId(cluster.applyValue(getComputeClusterResult -\u003e getComputeClusterResult.id()))\n            .build());\n\n        var hostRule = new ComputeClusterVmHostRule(\"hostRule\", ComputeClusterVmHostRuleArgs.builder()\n            .computeClusterId(cluster.applyValue(getComputeClusterResult -\u003e getComputeClusterResult.id()))\n            .name(\"terraform-host-rule1\")\n            .vmGroupName(\"vmgroup-01\")\n            .affinityHostGroupName(hostGroup.applyValue(getComputeClusterHostGroupResult -\u003e getComputeClusterHostGroupResult.name()))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  hostRule:\n    type: vsphere:ComputeClusterVmHostRule\n    name: host_rule\n    properties:\n      computeClusterId: ${cluster.id}\n      name: terraform-host-rule1\n      vmGroupName: vmgroup-01\n      affinityHostGroupName: ${hostGroup.name}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  cluster:\n    fn::invoke:\n      Function: vsphere:getComputeCluster\n      Arguments:\n        name: cluster-01\n        datacenterId: ${datacenter.id}\n  hostGroup:\n    fn::invoke:\n      Function: vsphere:getComputeClusterHostGroup\n      Arguments:\n        name: hostgroup-01\n        computeClusterId: ${cluster.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getComputeClusterHostGroup.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string",
                        "description": "The\n[managed object reference ID][docs-about-morefs] of the compute cluster for\nthe host group.\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the host group.\n"
                    }
                },
                "type": "object",
                "required": [
                    "computeClusterId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getComputeClusterHostGroup.\n",
                "properties": {
                    "computeClusterId": {
                        "type": "string"
                    },
                    "hostSystemIds": {
                        "description": "The [managed object reference ID][docs-about-morefs] of\nthe ESXi hosts in the host group.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "computeClusterId",
                    "hostSystemIds",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getContentLibrary:getContentLibrary": {
            "description": "The `vsphere.ContentLibrary` data source can be used to discover the ID of a\ncontent library.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nhost connections.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst contentLibrary = vsphere.getContentLibrary({\n    name: \"Content Library\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncontent_library = vsphere.get_content_library(name=\"Content Library\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var contentLibrary = VSphere.GetContentLibrary.Invoke(new()\n    {\n        Name = \"Content Library\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupContentLibrary(ctx, \u0026vsphere.LookupContentLibraryArgs{\n\t\t\tName: \"Content Library\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetContentLibraryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var contentLibrary = VsphereFunctions.getContentLibrary(GetContentLibraryArgs.builder()\n            .name(\"Content Library\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  contentLibrary:\n    fn::invoke:\n      Function: vsphere:getContentLibrary\n      Arguments:\n        name: Content Library\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibrary.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the content library.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibrary.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getContentLibraryItem:getContentLibraryItem": {
            "description": "The `vsphere.ContentLibraryItem` data source can be used to discover the ID\nof a content library item.\n\n\u003e **NOTE:** This resource requires vCenter and is not available on direct ESXi\nhost connections.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getContentLibraryItem.\n",
                "properties": {
                    "libraryId": {
                        "type": "string",
                        "description": "The ID of the content library in which the item\nexists.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the content library item.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "The type for the content library item. One of `ovf`,\n`vm-template`, or `iso`\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "libraryId",
                    "name",
                    "type"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getContentLibraryItem.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "libraryId": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "libraryId",
                    "name",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getCustomAttribute:getCustomAttribute": {
            "description": "The `vsphere.CustomAttribute` data source can be used to reference custom\nattributes that are not managed by this provider. Its attributes are exactly the\nsame as the `vsphere.CustomAttribute` resource,\nand, like importing, the data source takes a name argument for the search. The\n`id` and other attributes are then populated with the data found by the search.\n\n\u003e **NOTE:** Custom attributes are unsupported on direct ESXi host connections\nand require vCenter Server.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst attribute = vsphere.getCustomAttribute({\n    name: \"test-attribute\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nattribute = vsphere.get_custom_attribute(name=\"test-attribute\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var attribute = VSphere.GetCustomAttribute.Invoke(new()\n    {\n        Name = \"test-attribute\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupCustomAttribute(ctx, \u0026vsphere.LookupCustomAttributeArgs{\n\t\t\tName: \"test-attribute\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetCustomAttributeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var attribute = VsphereFunctions.getCustomAttribute(GetCustomAttributeArgs.builder()\n            .name(\"test-attribute\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  attribute:\n    fn::invoke:\n      Function: vsphere:getCustomAttribute\n      Arguments:\n        name: test-attribute\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomAttribute.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the custom attribute.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomAttribute.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "managedObjectType": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "managedObjectType",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDatacenter:getDatacenter": {
            "description": "The `vsphere.Datacenter` data source can be used to discover the ID of a\nvSphere datacenter object. This can then be used with resources or data sources\nthat require a datacenter, such as the `vsphere.Host`\ndata source.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatacenter.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the datacenter. This can be a name or path.\nCan be omitted if there is only one datacenter in the inventory.\n\n\u003e **NOTE:** When used with an ESXi host, this data source _always_ returns the\nhost's \"default\" datacenter, which is a special datacenter name unrelated to the\ndatacenters that exist in the vSphere inventory when managed by a vCenter Server\ninstance. Hence, the `name` attribute is completely ignored.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getDatacenter.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDatastore:getDatastore": {
            "description": "The `vsphere.getDatastore` data source can be used to discover the ID of a\nvSphere datastore object. This can then be used with resources or data sources\nthat require a datastore. For example, to create virtual machines in using the\n`vsphere.VirtualMachine` resource.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastore = datacenter.then(datacenter =\u003e vsphere.getDatastore({\n    name: \"datastore-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore = vsphere.get_datastore(name=\"datastore-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastore = VSphere.GetDatastore.Invoke(new()\n    {\n        Name = \"datastore-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetDatastore(ctx, \u0026vsphere.GetDatastoreArgs{\n\t\t\tName:         \"datastore-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastore = VsphereFunctions.getDatastore(GetDatastoreArgs.builder()\n            .name(\"datastore-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  datastore:\n    fn::invoke:\n      Function: vsphere:getDatastore\n      Arguments:\n        name: datastore-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the datastore is located in. This can be omitted if the\nsearch path used in `name` is an absolute path. For default datacenters, use\nthe `id` attribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the datastore. This can be a name or path.\n"
                    },
                    "stats": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The disk space usage statistics for the specific datastore. The\ntotal datastore capacity is represented as `capacity` and the free remaining\ndisk is represented as `free`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastore.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "stats": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The disk space usage statistics for the specific datastore. The\ntotal datastore capacity is represented as `capacity` and the free remaining\ndisk is represented as `free`.\n",
                        "type": "object"
                    }
                },
                "required": [
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDatastoreCluster:getDatastoreCluster": {
            "description": "The `vsphere.DatastoreCluster` data source can be used to discover the ID of a\nvSphere datastore cluster object. This can then be used with resources or data sources\nthat require a datastore. For example, to assign datastores using the\n`vsphere.NasDatastore` or `vsphere.VmfsDatastore` resources, or to create virtual machines in using the `vsphere.VirtualMachine` resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastoreCluster = datacenter.then(datacenter =\u003e vsphere.getDatastoreCluster({\n    name: \"datastore-cluster-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore_cluster = vsphere.get_datastore_cluster(name=\"datastore-cluster-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastoreCluster = VSphere.GetDatastoreCluster.Invoke(new()\n    {\n        Name = \"datastore-cluster-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupDatastoreCluster(ctx, \u0026vsphere.LookupDatastoreClusterArgs{\n\t\t\tName:         \"datastore-cluster-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastoreCluster = VsphereFunctions.getDatastoreCluster(GetDatastoreClusterArgs.builder()\n            .name(\"datastore-cluster-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  datastoreCluster:\n    fn::invoke:\n      Function: vsphere:getDatastoreCluster\n      Arguments:\n        name: datastore-cluster-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the datastore cluster is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the id attribute from an empty\n`vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name or absolute path to the datastore cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastoreCluster.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDatastoreStats:getDatastoreStats": {
            "description": "The `vsphere.getDatastoreStats` data source can be used to retrieve the usage\nstats of all vSphere datastore objects in a datacenter. This can then be used as\na standalone data source to get information required as input to other data\nsources.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst datastoreStats = datacenter.then(datacenter =\u003e vsphere.getDatastoreStats({\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ndatastore_stats = vsphere.get_datastore_stats(datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var datastoreStats = VSphere.GetDatastoreStats.Invoke(new()\n    {\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetDatastoreStats(ctx, \u0026vsphere.GetDatastoreStatsArgs{\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDatastoreStatsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var datastoreStats = VsphereFunctions.getDatastoreStats(GetDatastoreStatsArgs.builder()\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  datastoreStats:\n    fn::invoke:\n      Function: vsphere:getDatastoreStats\n      Arguments:\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nA useful example of this data source would be to determine the datastore with\nthe most free space. For example, in addition to the above:\n\nCreate an `outputs.tf` like that:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const maxFreeSpaceName = theirMaxFreeSpaceName;\nexport const maxFreeSpace = theirMaxFreeSpace;\n```\n```python\nimport pulumi\n\npulumi.export(\"maxFreeSpaceName\", their_max_free_space_name)\npulumi.export(\"maxFreeSpace\", their_max_free_space)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"maxFreeSpaceName\"] = theirMaxFreeSpaceName,\n        [\"maxFreeSpace\"] = theirMaxFreeSpace,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"maxFreeSpaceName\", theirMaxFreeSpaceName)\n\t\tctx.Export(\"maxFreeSpace\", theirMaxFreeSpace)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"maxFreeSpaceName\", theirMaxFreeSpaceName);\n        ctx.export(\"maxFreeSpace\", theirMaxFreeSpace);\n    }\n}\n```\n```yaml\noutputs:\n  maxFreeSpaceName: ${theirMaxFreeSpaceName}\n  maxFreeSpace: ${theirMaxFreeSpace}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nand a `locals.tf` like that:\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatastoreStats.\n",
                "properties": {
                    "capacity": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A mapping of the capacity for all datastore in the datacenter,\nwhere the name of the datastore is used as key and the capacity as value.\n"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The\n[managed object reference ID][docs-about-morefs] of the datacenter the\ndatastores are located in. For default datacenters, use the `id` attribute\nfrom an empty `vsphere.Datacenter` data source.\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n"
                    },
                    "freeSpace": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A mapping of the free space for each datastore in the\ndatacenter, where the name of the datastore is used as key and the free space\nas value.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatastoreStats.\n",
                "properties": {
                    "capacity": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A mapping of the capacity for all datastore in the datacenter,\nwhere the name of the datastore is used as key and the capacity as value.\n",
                        "type": "object"
                    },
                    "datacenterId": {
                        "description": "The [managed object reference ID][docs-about-morefs] of the\ndatacenter the datastores are located in.\n",
                        "type": "string"
                    },
                    "freeSpace": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A mapping of the free space for each datastore in the\ndatacenter, where the name of the datastore is used as key and the free space\nas value.\n",
                        "type": "object"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "datacenterId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDistributedVirtualSwitch:getDistributedVirtualSwitch": {
            "description": "The `vsphere.DistributedVirtualSwitch` data source can be used to discover\nthe ID and uplink data of a of a vSphere distributed switch (VDS). This\ncan then be used with resources or data sources that require a VDS, such as the\n`vsphere.DistributedPortGroup` resource, for which\nan example is shown below.\n\n\u003e **NOTE:** This data source requires vCenter Server and is not available on\ndirect ESXi host connections.\n\n## Example Usage\n\nThe following example locates a distributed switch named `vds-01`, in the\ndatacenter `dc-01`. It then uses this distributed switch to set up a\n`vsphere.DistributedPortGroup` resource that uses the first uplink as a\nprimary uplink and the second uplink as a secondary.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst vds = datacenter.then(datacenter =\u003e vsphere.getDistributedVirtualSwitch({\n    name: \"vds-01\",\n    datacenterId: datacenter.id,\n}));\nconst dvpg = new vsphere.DistributedPortGroup(\"dvpg\", {\n    name: \"dvpg-01\",\n    distributedVirtualSwitchUuid: vds.then(vds =\u003e vds.id),\n    activeUplinks: [vds.then(vds =\u003e vds.uplinks?.[0])],\n    standbyUplinks: [vds.then(vds =\u003e vds.uplinks?.[1])],\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nvds = vsphere.get_distributed_virtual_switch(name=\"vds-01\",\n    datacenter_id=datacenter.id)\ndvpg = vsphere.DistributedPortGroup(\"dvpg\",\n    name=\"dvpg-01\",\n    distributed_virtual_switch_uuid=vds.id,\n    active_uplinks=[vds.uplinks[0]],\n    standby_uplinks=[vds.uplinks[1]])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var vds = VSphere.GetDistributedVirtualSwitch.Invoke(new()\n    {\n        Name = \"vds-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var dvpg = new VSphere.DistributedPortGroup(\"dvpg\", new()\n    {\n        Name = \"dvpg-01\",\n        DistributedVirtualSwitchUuid = vds.Apply(getDistributedVirtualSwitchResult =\u003e getDistributedVirtualSwitchResult.Id),\n        ActiveUplinks = new[]\n        {\n            vds.Apply(getDistributedVirtualSwitchResult =\u003e getDistributedVirtualSwitchResult.Uplinks[0]),\n        },\n        StandbyUplinks = new[]\n        {\n            vds.Apply(getDistributedVirtualSwitchResult =\u003e getDistributedVirtualSwitchResult.Uplinks[1]),\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvds, err := vsphere.LookupDistributedVirtualSwitch(ctx, \u0026vsphere.LookupDistributedVirtualSwitchArgs{\n\t\t\tName:         \"vds-01\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.NewDistributedPortGroup(ctx, \"dvpg\", \u0026vsphere.DistributedPortGroupArgs{\n\t\t\tName:                         pulumi.String(\"dvpg-01\"),\n\t\t\tDistributedVirtualSwitchUuid: pulumi.String(vds.Id),\n\t\t\tActiveUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(vds.Uplinks[0]),\n\t\t\t},\n\t\t\tStandbyUplinks: pulumi.StringArray{\n\t\t\t\tpulumi.String(vds.Uplinks[1]),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetDistributedVirtualSwitchArgs;\nimport com.pulumi.vsphere.DistributedPortGroup;\nimport com.pulumi.vsphere.DistributedPortGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var vds = VsphereFunctions.getDistributedVirtualSwitch(GetDistributedVirtualSwitchArgs.builder()\n            .name(\"vds-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        var dvpg = new DistributedPortGroup(\"dvpg\", DistributedPortGroupArgs.builder()\n            .name(\"dvpg-01\")\n            .distributedVirtualSwitchUuid(vds.applyValue(getDistributedVirtualSwitchResult -\u003e getDistributedVirtualSwitchResult.id()))\n            .activeUplinks(vds.applyValue(getDistributedVirtualSwitchResult -\u003e getDistributedVirtualSwitchResult.uplinks()[0]))\n            .standbyUplinks(vds.applyValue(getDistributedVirtualSwitchResult -\u003e getDistributedVirtualSwitchResult.uplinks()[1]))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dvpg:\n    type: vsphere:DistributedPortGroup\n    properties:\n      name: dvpg-01\n      distributedVirtualSwitchUuid: ${vds.id}\n      activeUplinks:\n        - ${vds.uplinks[0]}\n      standbyUplinks:\n        - ${vds.uplinks[1]}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  vds:\n    fn::invoke:\n      Function: vsphere:getDistributedVirtualSwitch\n      Arguments:\n        name: vds-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the VDS is located in. This can be omitted if the search\npath used in `name` is an absolute path. For default datacenters, use the `id`\nattribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the VDS. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDistributedVirtualSwitch.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "uplinks": {
                        "description": "The list of the uplinks on this vSphere distributed switch, as per the\n`uplinks` argument to the\n`vsphere.DistributedVirtualSwitch`\nresource.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "name",
                    "uplinks",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getDynamic:getDynamic": {
            "description": "[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n\nThe `vsphere.getDynamic` data source can be used to get the\n[managed object reference ID][docs-about-morefs] of any tagged managed object in\nvCenter Server by providing a list of tag IDs and an optional regular expression\nto filter objects by name.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = vsphere.getTagCategory({\n    name: \"SomeCategory\",\n});\nconst tag1 = vsphere.getTag({\n    name: \"FirstTag\",\n    categoryId: cat.id,\n});\nconst tag2 = vsphere.getTag({\n    name: \"SecondTag\",\n    categoryId: cat.id,\n});\nconst dyn = Promise.all([tag1, tag1]).then(([tag1, tag11]) =\u003e vsphere.getDynamic({\n    filters: [\n        tag1.id,\n        tag11.id,\n    ],\n    nameRegex: \"ubuntu\",\n    type: \"Datacenter\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"SomeCategory\")\ntag1 = vsphere.get_tag(name=\"FirstTag\",\n    category_id=cat[\"id\"])\ntag2 = vsphere.get_tag(name=\"SecondTag\",\n    category_id=cat[\"id\"])\ndyn = vsphere.get_dynamic(filters=[\n        tag1.id,\n        tag1.id,\n    ],\n    name_regex=\"ubuntu\",\n    type=\"Datacenter\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"SomeCategory\",\n    });\n\n    var tag1 = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"FirstTag\",\n        CategoryId = cat.Id,\n    });\n\n    var tag2 = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"SecondTag\",\n        CategoryId = cat.Id,\n    });\n\n    var dyn = VSphere.GetDynamic.Invoke(new()\n    {\n        Filters = new[]\n        {\n            tag1.Apply(getTagResult =\u003e getTagResult.Id),\n            tag1.Apply(getTagResult =\u003e getTagResult.Id),\n        },\n        NameRegex = \"ubuntu\",\n        Type = \"Datacenter\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\nfunc main() {\npulumi.Run(func(ctx *pulumi.Context) error {\n_, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\nName: \"SomeCategory\",\n}, nil);\nif err != nil {\nreturn err\n}\ntag1, err := vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\nName: \"FirstTag\",\nCategoryId: cat.Id,\n}, nil);\nif err != nil {\nreturn err\n}\n_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\nName: \"SecondTag\",\nCategoryId: cat.Id,\n}, nil);\nif err != nil {\nreturn err\n}\n_, err = vsphere.GetDynamic(ctx, \u0026vsphere.GetDynamicArgs{\nFilters: interface{}{\ntag1.Id,\ntag1.Id,\n},\nNameRegex: pulumi.StringRef(\"ubuntu\"),\nType: pulumi.StringRef(\"Datacenter\"),\n}, nil);\nif err != nil {\nreturn err\n}\nreturn nil\n})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport com.pulumi.vsphere.inputs.GetTagArgs;\nimport com.pulumi.vsphere.inputs.GetDynamicArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var category = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"SomeCategory\")\n            .build());\n\n        final var tag1 = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"FirstTag\")\n            .categoryId(cat.id())\n            .build());\n\n        final var tag2 = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"SecondTag\")\n            .categoryId(cat.id())\n            .build());\n\n        final var dyn = VsphereFunctions.getDynamic(GetDynamicArgs.builder()\n            .filters(            \n                tag1.applyValue(getTagResult -\u003e getTagResult.id()),\n                tag1.applyValue(getTagResult -\u003e getTagResult.id()))\n            .nameRegex(\"ubuntu\")\n            .type(\"Datacenter\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  category:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: SomeCategory\n  tag1:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: FirstTag\n        categoryId: ${cat.id}\n  tag2:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: SecondTag\n        categoryId: ${cat.id}\n  dyn:\n    fn::invoke:\n      Function: vsphere:getDynamic\n      Arguments:\n        filters:\n          - ${tag1.id}\n          - ${tag1.id}\n        nameRegex: ubuntu\n        type: Datacenter\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDynamic.\n",
                "properties": {
                    "filters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of tag IDs that must be present on an object to\nbe a match.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match the\nobject's name.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The managed object type the returned object must match.\nThe managed object types can be found in the managed object type section\n[here](https://developer.broadcom.com/xapis/vsphere-web-services-api/latest/).\n"
                    }
                },
                "type": "object",
                "required": [
                    "filters"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDynamic.\n",
                "properties": {
                    "filters": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "nameRegex": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "filters",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getFolder:getFolder": {
            "description": "The `vsphere.Folder` data source can be used to get the general attributes of a\nvSphere inventory folder. The data source supports creating folders of the 5\nmajor types - datacenter folders, host and cluster folders, virtual machine\nfolders, storage folders, and network folders.\n\nPaths are absolute and must include the datacenter.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst folder = vsphere.getFolder({\n    path: \"/dc-01/datastore-01/folder-01\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nfolder = vsphere.get_folder(path=\"/dc-01/datastore-01/folder-01\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var folder = VSphere.GetFolder.Invoke(new()\n    {\n        Path = \"/dc-01/datastore-01/folder-01\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupFolder(ctx, \u0026vsphere.LookupFolderArgs{\n\t\t\tPath: \"/dc-01/datastore-01/folder-01\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetFolderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var folder = VsphereFunctions.getFolder(GetFolderArgs.builder()\n            .path(\"/dc-01/datastore-01/folder-01\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  folder:\n    fn::invoke:\n      Function: vsphere:getFolder\n      Arguments:\n        path: /dc-01/datastore-01/folder-01\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFolder.\n",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The absolute path of the folder. For example, given a\ndefault datacenter of `default-dc`, a folder of type `vm`, and a folder name\nof `test-folder`, the resulting path would be\n`/default-dc/vm/test-folder`. The valid folder types to be used in\nthe path are: `vm`, `host`, `datacenter`, `datastore`, or `network`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "path"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFolder.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "path": {
                        "type": "string"
                    }
                },
                "required": [
                    "path",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getGuestOsCustomization:getGuestOsCustomization": {
            "description": "The `vsphere.GuestOsCustomization` data source can be used to discover the\ndetails about a customization specification for a guest operating system.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  vm:\n    type: vsphere:VirtualMachine\n    properties:\n      templateUuid: ${template.id}\n      customizationSpec:\n        - id: ${windows.id}\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  template:\n    fn::invoke:\n      Function: vsphere:getVirtualMachine\n      Arguments:\n        name: windows-template\n        datacenterId: ${datacenter.id}\n  windows:\n    fn::invoke:\n      Function: vsphere:getGuestOsCustomization\n      Arguments:\n        name: windows\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGuestOsCustomization.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the customization specification is the unique\nidentifier per vCenter Server instance. ## Attribute Reference\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGuestOsCustomization.\n",
                "properties": {
                    "changeVersion": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lastUpdateTime": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "specs": {
                        "items": {
                            "$ref": "#/types/vsphere:index/getGuestOsCustomizationSpec:getGuestOsCustomizationSpec"
                        },
                        "type": "array"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "changeVersion",
                    "description",
                    "lastUpdateTime",
                    "name",
                    "specs",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHost:getHost": {
            "description": "The `vsphere.Host` data source can be used to discover the ID of an ESXi host.\nThis can then be used with resources or data sources that require an ESX\nhost's managed object reference ID.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof a vSphere datacenter object.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ESXI host. This can be a name or path.\nCan be omitted if there is only one host in your inventory.\n\n\u003e **NOTE:** When used against an ESXi host directly, this data source _always_\nreturns the ESXi host's object ID, regardless of what is entered into `name`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHost.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "description": "The managed object ID of the ESXi\nhost's root resource pool.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "datacenterId",
                    "resourcePoolId",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHostBaseImages:getHostBaseImages": {
            "description": "The `vsphere.getHostBaseImages` data source can be used to get the list of ESXi\nbase images available for cluster software management.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst baseImages = vsphere.getHostBaseImages({});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nbase_images = vsphere.get_host_base_images()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var baseImages = VSphere.GetHostBaseImages.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetHostBaseImages(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var baseImages = VsphereFunctions.getHostBaseImages();\n\n    }\n}\n```\n```yaml\nvariables:\n  baseImages:\n    fn::invoke:\n      Function: vsphere:getHostBaseImages\n      Arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getHostBaseImages.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "versions": {
                        "description": "The ESXi version identifier for the image\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "versions",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHostPciDevice:getHostPciDevice": {
            "description": "The `vsphere.getHostPciDevice` data source can be used to discover the device ID\nof a vSphere host's PCI device. This can then be used with\n`vsphere.VirtualMachine`'s `pci_device_id`.\n\n## Example Usage\n\n### With Vendor ID And Class ID\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst dev = host.then(host =\u003e vsphere.getHostPciDevice({\n    hostId: host.id,\n    classId: \"123\",\n    vendorId: \"456\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\ndev = vsphere.get_host_pci_device(host_id=host.id,\n    class_id=\"123\",\n    vendor_id=\"456\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var dev = VSphere.GetHostPciDevice.Invoke(new()\n    {\n        HostId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        ClassId = \"123\",\n        VendorId = \"456\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostPciDevice(ctx, \u0026vsphere.GetHostPciDeviceArgs{\n\t\t\tHostId:   host.Id,\n\t\t\tClassId:  pulumi.StringRef(\"123\"),\n\t\t\tVendorId: pulumi.StringRef(\"456\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetHostPciDeviceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var dev = VsphereFunctions.getHostPciDevice(GetHostPciDeviceArgs.builder()\n            .hostId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .classId(123)\n            .vendorId(456)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  dev:\n    fn::invoke:\n      Function: vsphere:getHostPciDevice\n      Arguments:\n        hostId: ${host.id}\n        classId: 123\n        vendorId: 456\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### With Name Regular Expression\n\n \u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst dev = host.then(host =\u003e vsphere.getHostPciDevice({\n    hostId: host.id,\n    nameRegex: \"MMC\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\ndev = vsphere.get_host_pci_device(host_id=host.id,\n    name_regex=\"MMC\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var dev = VSphere.GetHostPciDevice.Invoke(new()\n    {\n        HostId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NameRegex = \"MMC\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostPciDevice(ctx, \u0026vsphere.GetHostPciDeviceArgs{\n\t\t\tHostId:    host.Id,\n\t\t\tNameRegex: pulumi.StringRef(\"MMC\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetHostPciDeviceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var dev = VsphereFunctions.getHostPciDevice(GetHostPciDeviceArgs.builder()\n            .hostId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .nameRegex(\"MMC\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  dev:\n    fn::invoke:\n      Function: vsphere:getHostPciDevice\n      Arguments:\n        hostId: ${host.id}\n        nameRegex: MMC\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHostPciDevice.\n",
                "properties": {
                    "classId": {
                        "type": "string",
                        "description": "The hexadecimal PCI device class ID\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n\n\u003e **NOTE:** `name_regex`, `vendor_id`, and `class_id` can all be used together.\n"
                    },
                    "hostId": {
                        "type": "string",
                        "description": "The [managed object reference ID][docs-about-morefs] of\na host.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match the\nhost PCI device name.\n"
                    },
                    "vendorId": {
                        "type": "string",
                        "description": "The hexadecimal PCI device vendor ID.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostPciDevice.\n",
                "properties": {
                    "classId": {
                        "type": "string"
                    },
                    "hostId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the PCI device.\n",
                        "type": "string"
                    },
                    "nameRegex": {
                        "type": "string"
                    },
                    "vendorId": {
                        "type": "string"
                    }
                },
                "required": [
                    "hostId",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHostThumbprint:getHostThumbprint": {
            "description": "The `vsphere_thumbprint` data source can be used to discover the host thumbprint\nof an ESXi host. This can be used when adding the `vsphere.Host` resource. If\nthe ESXi host is using a certificate chain, the first one returned will be used\nto generate the thumbprint.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst thumbprint = vsphere.getHostThumbprint({\n    address: \"esxi-01.example.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nthumbprint = vsphere.get_host_thumbprint(address=\"esxi-01.example.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var thumbprint = VSphere.GetHostThumbprint.Invoke(new()\n    {\n        Address = \"esxi-01.example.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetHostThumbprint(ctx, \u0026vsphere.GetHostThumbprintArgs{\n\t\t\tAddress: \"esxi-01.example.com\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetHostThumbprintArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var thumbprint = VsphereFunctions.getHostThumbprint(GetHostThumbprintArgs.builder()\n            .address(\"esxi-01.example.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  thumbprint:\n    fn::invoke:\n      Function: vsphere:getHostThumbprint\n      Arguments:\n        address: esxi-01.example.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHostThumbprint.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The address of the ESXi host to retrieve the thumbprint\nfrom.\n"
                    },
                    "insecure": {
                        "type": "boolean",
                        "description": "Disables SSL certificate verification.\nDefault: `false`\n"
                    },
                    "port": {
                        "type": "string",
                        "description": "The port to use connecting to the ESXi host. Default: 443\n"
                    }
                },
                "type": "object",
                "required": [
                    "address"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostThumbprint.\n",
                "properties": {
                    "address": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "insecure": {
                        "type": "boolean"
                    },
                    "port": {
                        "type": "string"
                    }
                },
                "required": [
                    "address",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getHostVgpuProfile:getHostVgpuProfile": {
            "description": "The `vsphere.getHostVgpuProfile` data source can be used to discover the\navailable vGPU profiles of a vSphere host.\n\n## Example Usage\n\n### To Return All VGPU Profiles\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst vgpuProfile = host.then(host =\u003e vsphere.getHostVgpuProfile({\n    hostId: host.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nvgpu_profile = vsphere.get_host_vgpu_profile(host_id=host.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vgpuProfile = VSphere.GetHostVgpuProfile.Invoke(new()\n    {\n        HostId = host.Apply(getHostResult =\u003e getHostResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostVgpuProfile(ctx, \u0026vsphere.GetHostVgpuProfileArgs{\n\t\t\tHostId: host.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetHostVgpuProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var vgpuProfile = VsphereFunctions.getHostVgpuProfile(GetHostVgpuProfileArgs.builder()\n            .hostId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  vgpuProfile:\n    fn::invoke:\n      Function: vsphere:getHostVgpuProfile\n      Arguments:\n        hostId: ${host.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### With VGPU Profile Name_regex\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst vgpuProfile = host.then(host =\u003e vsphere.getHostVgpuProfile({\n    hostId: host.id,\n    nameRegex: \"a100\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nvgpu_profile = vsphere.get_host_vgpu_profile(host_id=host.id,\n    name_regex=\"a100\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vgpuProfile = VSphere.GetHostVgpuProfile.Invoke(new()\n    {\n        HostId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        NameRegex = \"a100\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetHostVgpuProfile(ctx, \u0026vsphere.GetHostVgpuProfileArgs{\n\t\t\tHostId:    host.Id,\n\t\t\tNameRegex: pulumi.StringRef(\"a100\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetHostVgpuProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var vgpuProfile = VsphereFunctions.getHostVgpuProfile(GetHostVgpuProfileArgs.builder()\n            .hostId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .nameRegex(\"a100\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  vgpuProfile:\n    fn::invoke:\n      Function: vsphere:getHostVgpuProfile\n      Arguments:\n        hostId: ${host.id}\n        nameRegex: a100\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getHostVgpuProfile.\n",
                "properties": {
                    "hostId": {
                        "type": "string",
                        "description": "The [managed object reference ID][docs-about-morefs] of\na host.\n"
                    },
                    "nameRegex": {
                        "type": "string",
                        "description": "A regular expression that will be used to match the\nhost vGPU profile name.\n\n[docs-about-morefs]: /docs/providers/vsphere/index.html#use-of-managed-object-references-by-the-vsphere-provider\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getHostVgpuProfile.\n",
                "properties": {
                    "hostId": {
                        "description": "The [managed objectID][docs-about-morefs] of the ESXi host.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "nameRegex": {
                        "description": "(Optional) A regular expression that will be used to match the\nhost vGPU profile name.\n",
                        "type": "string"
                    },
                    "vgpuProfiles": {
                        "description": "The list of available vGPU profiles on the ESXi host.\nThis may be and empty array if no vGPU profile are identified.\n",
                        "items": {
                            "$ref": "#/types/vsphere:index/getHostVgpuProfileVgpuProfile:getHostVgpuProfileVgpuProfile"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "hostId",
                    "vgpuProfiles",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getLicense:getLicense": {
            "description": "The `vsphere.License` data source can be used to get the general attributes of\na license keys from a vCenter Server instance.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst license = vsphere.getLicense({\n    licenseKey: \"00000-00000-00000-00000-00000\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nlicense = vsphere.get_license(license_key=\"00000-00000-00000-00000-00000\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var license = VSphere.GetLicense.Invoke(new()\n    {\n        LicenseKey = \"00000-00000-00000-00000-00000\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupLicense(ctx, \u0026vsphere.LookupLicenseArgs{\n\t\t\tLicenseKey: \"00000-00000-00000-00000-00000\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetLicenseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var license = VsphereFunctions.getLicense(GetLicenseArgs.builder()\n            .licenseKey(\"00000-00000-00000-00000-00000\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  license:\n    fn::invoke:\n      Function: vsphere:getLicense\n      Arguments:\n        licenseKey: 00000-00000-00000-00000-00000\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLicense.\n",
                "properties": {
                    "licenseKey": {
                        "type": "string",
                        "description": "The license key.\n"
                    }
                },
                "type": "object",
                "required": [
                    "licenseKey"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLicense.\n",
                "properties": {
                    "editionKey": {
                        "description": "The product edition of the license key.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "labels": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of key/value pairs attached as labels (tags) to the license\nkey.\n",
                        "type": "object"
                    },
                    "licenseKey": {
                        "type": "string"
                    },
                    "name": {
                        "description": "The display name for the license.\n",
                        "type": "string"
                    },
                    "total": {
                        "description": "Total number of units (example: CPUs) contained in the license.\n",
                        "type": "integer"
                    },
                    "used": {
                        "description": "The number of units (example: CPUs) assigned to this license.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "editionKey",
                    "id",
                    "labels",
                    "licenseKey",
                    "name",
                    "total",
                    "used"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getNetwork:getNetwork": {
            "description": "The `vsphere.getNetwork` data source can be used to discover the ID of a network in\nvSphere. This can be any network that can be used as the backing for a network\ninterface for `vsphere.VirtualMachine` or any other vSphere resource that\nrequires a network. This includes standard (host-based) port groups, distributed\nport groups, or opaque networks such as those managed by NSX.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst network = datacenter.then(datacenter =\u003e vsphere.getNetwork({\n    name: \"VM Network\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nnetwork = vsphere.get_network(name=\"VM Network\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var network = VSphere.GetNetwork.Invoke(new()\n    {\n        Name = \"VM Network\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetNetwork(ctx, \u0026vsphere.GetNetworkArgs{\n\t\t\tName:         \"VM Network\",\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var network = VsphereFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"VM Network\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  network:\n    fn::invoke:\n      Function: vsphere:getNetwork\n      Arguments:\n        name: VM Network\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter the network is located in. This can be omitted if the\nsearch path used in `name` is an absolute path. For default datacenters,\nuse the `id` attribute from an empty `vsphere.Datacenter` data source.\n"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string",
                        "description": "For distributed port group type\nnetwork objects, the ID of the distributed virtual switch for which the port\ngroup belongs. It is useful to differentiate port groups with same name using\nthe distributed virtual switch ID.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the network. This can be a name or path.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetwork.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "distributedVirtualSwitchUuid": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "type": {
                        "description": "The managed object type for the discovered network. This will be one\nof `DistributedVirtualPortgroup` for distributed port groups, `Network` for\nstandard (host-based) port groups, or `OpaqueNetwork` for networks managed\nexternally, such as those managed by NSX.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getOvfVmTemplate:getOvfVmTemplate": {
            "description": "The `vsphere.getOvfVmTemplate` data source can be used to submit an OVF to\nvSphere and extract its hardware settings in a form that can be then used as\ninputs for a `vsphere.VirtualMachine` resource.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOvfVmTemplate.\n",
                "properties": {
                    "allowUnverifiedSslCert": {
                        "type": "boolean",
                        "description": "Allow unverified SSL certificates\nwhen deploying OVF/OVA from a URL.\n"
                    },
                    "datastoreId": {
                        "type": "string",
                        "description": "The ID of the virtual machine's datastore. The\nvirtual machine configuration is placed here, along with any virtual disks\nthat are created without datastores.\n"
                    },
                    "deploymentOption": {
                        "type": "string",
                        "description": "The key of the chosen deployment option. If\nempty, the default option is chosen.\n",
                        "willReplaceOnChanges": true
                    },
                    "diskProvisioning": {
                        "type": "string",
                        "description": "The disk provisioning type. If set, all the\ndisks in the deployed OVA/OVF will have the same specified disk type. Can be\none of `thin`, `flat`, `thick` or `sameAsSource`.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableHiddenProperties": {
                        "type": "boolean",
                        "description": "Allow properties with\n`ovf:userConfigurable=false` to be set.\n",
                        "willReplaceOnChanges": true
                    },
                    "folder": {
                        "type": "string",
                        "description": "The name of the folder in which to place the virtual\nmachine.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The ID of the ESXi host system to deploy the\nvirtual machine.\n"
                    },
                    "ipAllocationPolicy": {
                        "type": "string",
                        "description": "The IP allocation policy.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipProtocol": {
                        "type": "string",
                        "description": "The IP protocol.\n",
                        "willReplaceOnChanges": true
                    },
                    "localOvfPath": {
                        "type": "string",
                        "description": "The absolute path to the OVF/OVA file on the\nlocal system. When deploying from an OVF, ensure all necessary files such as\nthe `.vmdk` files are present in the same directory as the OVF.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the virtual machine to create.\n"
                    },
                    "ovfNetworkMap": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The mapping of name of network identifiers\nfrom the OVF descriptor to network UUID in the environment.\n",
                        "willReplaceOnChanges": true
                    },
                    "remoteOvfUrl": {
                        "type": "string",
                        "description": "URL of the remote OVF/OVA file to be deployed.\n\n\u003e **NOTE:** Either `local_ovf_path` or `remote_ovf_url` is required, both can\nnot be empty.\n",
                        "willReplaceOnChanges": true
                    },
                    "resourcePoolId": {
                        "type": "string",
                        "description": "The ID of a resource pool in which to place\nthe virtual machine.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostSystemId",
                    "name",
                    "resourcePoolId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOvfVmTemplate.\n",
                "properties": {
                    "allowUnverifiedSslCert": {
                        "type": "boolean"
                    },
                    "alternateGuestName": {
                        "description": "An alternate guest operating system name.\n",
                        "type": "string"
                    },
                    "annotation": {
                        "description": "A description of the virtual machine.\n",
                        "type": "string"
                    },
                    "cpuHotAddEnabled": {
                        "description": "Allow CPUs to be added to the virtual machine while\npowered on.\n",
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "description": "Allow CPUs to be removed from the virtual machine\nwhile powered on.\n",
                        "type": "boolean"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "datastoreId": {
                        "type": "string"
                    },
                    "deploymentOption": {
                        "type": "string"
                    },
                    "diskProvisioning": {
                        "type": "string"
                    },
                    "enableHiddenProperties": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "description": "The firmware to use on the virtual machine.\n",
                        "type": "string"
                    },
                    "folder": {
                        "type": "string"
                    },
                    "guestId": {
                        "description": "The ID for the guest operating system\n",
                        "type": "string"
                    },
                    "hostSystemId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ideControllerCount": {
                        "type": "integer"
                    },
                    "ipAllocationPolicy": {
                        "type": "string"
                    },
                    "ipProtocol": {
                        "type": "string"
                    },
                    "localOvfPath": {
                        "type": "string"
                    },
                    "memory": {
                        "description": "The size of the virtual machine memory, in MB.\n",
                        "type": "integer"
                    },
                    "memoryHotAddEnabled": {
                        "description": "Allow memory to be added to the virtual machine\nwhile powered on.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nestedHvEnabled": {
                        "description": "Enable nested hardware virtualization on the virtual\nmachine, facilitating nested virtualization in the guest.\n",
                        "type": "boolean"
                    },
                    "numCoresPerSocket": {
                        "description": "The number of cores per virtual CPU in the virtual\nmachine.\n",
                        "type": "integer"
                    },
                    "numCpus": {
                        "description": "The number of virtual CPUs to assign to the virtual machine.\n",
                        "type": "integer"
                    },
                    "ovfNetworkMap": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "remoteOvfUrl": {
                        "type": "string"
                    },
                    "resourcePoolId": {
                        "type": "string"
                    },
                    "sataControllerCount": {
                        "type": "integer"
                    },
                    "scsiControllerCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "description": "The swap file placement policy for the virtual\nmachine.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "alternateGuestName",
                    "annotation",
                    "cpuHotAddEnabled",
                    "cpuHotRemoveEnabled",
                    "cpuPerformanceCountersEnabled",
                    "firmware",
                    "guestId",
                    "hostSystemId",
                    "ideControllerCount",
                    "memory",
                    "memoryHotAddEnabled",
                    "name",
                    "nestedHvEnabled",
                    "numCoresPerSocket",
                    "numCpus",
                    "resourcePoolId",
                    "sataControllerCount",
                    "scsiControllerCount",
                    "scsiType",
                    "swapPlacementPolicy",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getPolicy:getPolicy": {
            "description": "The `vsphere.getPolicy` data source can be used to discover the UUID of a\nstorage policy. This can then be used with other resources or data sources that\nuse a storage policy.\n\n\u003e **NOTE:** Storage policies are not supported on direct ESXi hosts and\nrequires vCenter Server.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst prodPlatinumReplicated = vsphere.getPolicy({\n    name: \"prod_platinum_replicated\",\n});\nconst devSilverNonreplicated = vsphere.getPolicy({\n    name: \"dev_silver_nonreplicated\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nprod_platinum_replicated = vsphere.get_policy(name=\"prod_platinum_replicated\")\ndev_silver_nonreplicated = vsphere.get_policy(name=\"dev_silver_nonreplicated\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var prodPlatinumReplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"prod_platinum_replicated\",\n    });\n\n    var devSilverNonreplicated = VSphere.GetPolicy.Invoke(new()\n    {\n        Name = \"dev_silver_nonreplicated\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"prod_platinum_replicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetPolicy(ctx, \u0026vsphere.GetPolicyArgs{\n\t\t\tName: \"dev_silver_nonreplicated\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var prodPlatinumReplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"prod_platinum_replicated\")\n            .build());\n\n        final var devSilverNonreplicated = VsphereFunctions.getPolicy(GetPolicyArgs.builder()\n            .name(\"dev_silver_nonreplicated\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  prodPlatinumReplicated:\n    fn::invoke:\n      Function: vsphere:getPolicy\n      Arguments:\n        name: prod_platinum_replicated\n  devSilverNonreplicated:\n    fn::invoke:\n      Function: vsphere:getPolicy\n      Arguments:\n        name: dev_silver_nonreplicated\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the storage policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPolicy.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getResourcePool:getResourcePool": {
            "description": "The `vsphere.ResourcePool` data source can be used to discover the ID of a\nresource pool in vSphere. This is useful to return the ID of a resource pool\nthat you want to use to create virtual machines in using the\n`vsphere.VirtualMachine` resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst pool = datacenter.then(datacenter =\u003e vsphere.getResourcePool({\n    name: \"resource-pool-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\npool = vsphere.get_resource_pool(name=\"resource-pool-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var pool = VSphere.GetResourcePool.Invoke(new()\n    {\n        Name = \"resource-pool-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupResourcePool(ctx, \u0026vsphere.LookupResourcePoolArgs{\n\t\t\tName:         pulumi.StringRef(\"resource-pool-01\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var pool = VsphereFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"resource-pool-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  pool:\n    fn::invoke:\n      Function: vsphere:getResourcePool\n      Arguments:\n        name: resource-pool-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Specifying the Root Resource Pool for a Standalone ESXi Host\n\n\u003e **NOTE:** Returning the root resource pool for a cluster can be done\ndirectly via the `vsphere.ComputeCluster`\ndata source.\n\nAll compute resources in vSphere have a resource pool, even if one has not been\nexplicitly created. This resource pool is referred to as the _root resource\npool_ and can be looked up by specifying the path.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst pool = vsphere.getResourcePool({\n    name: \"esxi-01.example.com/Resources\",\n    datacenterId: datacenter.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\npool = vsphere.get_resource_pool(name=\"esxi-01.example.com/Resources\",\n    datacenter_id=datacenter[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pool = VSphere.GetResourcePool.Invoke(new()\n    {\n        Name = \"esxi-01.example.com/Resources\",\n        DatacenterId = datacenter.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupResourcePool(ctx, \u0026vsphere.LookupResourcePoolArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com/Resources\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetResourcePoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var pool = VsphereFunctions.getResourcePool(GetResourcePoolArgs.builder()\n            .name(\"esxi-01.example.com/Resources\")\n            .datacenterId(datacenter.id())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  pool:\n    fn::invoke:\n      Function: vsphere:getResourcePool\n      Arguments:\n        name: esxi-01.example.com/Resources\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nFor more information on the root resource pool, see\n[Managing Resource Pools][vmware-docs-resource-pools] in the vSphere\ndocumentation.\n\n[vmware-docs-resource-pools]: https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-resource-management/GUID-60077B40-66FF-4625-934A-641703ED7601.html\n",
            "inputs": {
                "description": "A collection of arguments for invoking getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter in which the resource pool is located. This can be omitted\nif the search path used in `name` is an absolute path. For default\ndatacenters, use the id attribute from an empty `vsphere.Datacenter` data\nsource.\n\n\u003e **Note:** When using ESXi without a vCenter Server instance, you do not\nneed to specify either attribute to use this data source. An empty declaration\nwill load the ESXi host's root resource pool.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the resource pool. This can be a name or\npath. This is required when using vCenter.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getResourcePool.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getRole:getRole": {
            "description": "The `vsphere.Role` data source can be used to discover the `id` and privileges\nassociated with a role given its name or display label.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst terraformRole = vsphere.getRole({\n    label: \"Terraform to vSphere Integration Role\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\nterraform_role = vsphere.get_role(label=\"Terraform to vSphere Integration Role\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var terraformRole = VSphere.GetRole.Invoke(new()\n    {\n        Label = \"Terraform to vSphere Integration Role\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupRole(ctx, \u0026vsphere.LookupRoleArgs{\n\t\t\tLabel: \"Terraform to vSphere Integration Role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var terraformRole = VsphereFunctions.getRole(GetRoleArgs.builder()\n            .label(\"Terraform to vSphere Integration Role\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  terraformRole:\n    fn::invoke:\n      Function: vsphere:getRole\n      Arguments:\n        label: Terraform to vSphere Integration Role\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getRole.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "The description of the role.\n"
                    },
                    "label": {
                        "type": "string",
                        "description": "The label of the role.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rolePrivileges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The privileges associated with the role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "label"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getRole.\n",
                "properties": {
                    "description": {
                        "description": "The description of the role.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "label": {
                        "description": "The display label of the role.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "rolePrivileges": {
                        "description": "The privileges associated with the role.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "label",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getTag:getTag": {
            "description": "The `vsphere.Tag` data source can be used to reference tags that are not\nmanaged by this provider. Its attributes are exactly the same as the `vsphere.Tag`\nresource, and, like importing, the data source takes a name and\ncategory to search on. The `id` and other attributes are then populated with\nthe data found by the search.\n\n\u003e **NOTE:** Tagging is not supported on direct ESXi hosts connections and\nrequires vCenter Server.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = vsphere.getTagCategory({\n    name: \"example-category\",\n});\nconst tag = category.then(category =\u003e vsphere.getTag({\n    name: \"example-tag\",\n    categoryId: category.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"example-category\")\ntag = vsphere.get_tag(name=\"example-tag\",\n    category_id=category.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"example-category\",\n    });\n\n    var tag = VSphere.GetTag.Invoke(new()\n    {\n        Name = \"example-tag\",\n        CategoryId = category.Apply(getTagCategoryResult =\u003e getTagCategoryResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcategory, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"example-category\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupTag(ctx, \u0026vsphere.LookupTagArgs{\n\t\t\tName:       \"example-tag\",\n\t\t\tCategoryId: category.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport com.pulumi.vsphere.inputs.GetTagArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var category = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"example-category\")\n            .build());\n\n        final var tag = VsphereFunctions.getTag(GetTagArgs.builder()\n            .name(\"example-tag\")\n            .categoryId(category.applyValue(getTagCategoryResult -\u003e getTagCategoryResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  category:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: example-category\n  tag:\n    fn::invoke:\n      Function: vsphere:getTag\n      Arguments:\n        name: example-tag\n        categoryId: ${category.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string",
                        "description": "The ID of the tag category in which the tag is\nlocated.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the tag.\n"
                    }
                },
                "type": "object",
                "required": [
                    "categoryId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTag.\n",
                "properties": {
                    "categoryId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "categoryId",
                    "description",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getTagCategory:getTagCategory": {
            "description": "The `vsphere.TagCategory` data source can be used to reference tag categories\nthat are not managed by this provider. Its attributes are the same as the\n`vsphere.TagCategory` resource, and, like importing,\nthe data source uses a name and category as search criteria. The `id` and other\nattributes are populated with the data found by the search.\n\n\u003e **NOTE:** Tagging is not supported on direct ESXi hosts connections and\nrequires vCenter Server.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst category = vsphere.getTagCategory({\n    name: \"example-category\",\n});\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ncategory = vsphere.get_tag_category(name=\"example-category\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var category = VSphere.GetTagCategory.Invoke(new()\n    {\n        Name = \"example-category\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := vsphere.LookupTagCategory(ctx, \u0026vsphere.LookupTagCategoryArgs{\n\t\t\tName: \"example-category\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetTagCategoryArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var category = VsphereFunctions.getTagCategory(GetTagCategoryArgs.builder()\n            .name(\"example-category\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  category:\n    fn::invoke:\n      Function: vsphere:getTagCategory\n      Arguments:\n        name: example-category\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTagCategory.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the tag category.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTagCategory.\n",
                "properties": {
                    "associableTypes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "cardinality": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "associableTypes",
                    "cardinality",
                    "description",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getVappContainer:getVappContainer": {
            "description": "The `vsphere.VappContainer` data source can be used to discover the ID of a\nvApp container in vSphere. This is useful to return the ID of a vApp container\nthat you want to use to create virtual machines in using the\n`vsphere.VirtualMachine` resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst pool = datacenter.then(datacenter =\u003e vsphere.getVappContainer({\n    name: \"vapp-container-01\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\npool = vsphere.get_vapp_container(name=\"vapp-container-01\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var pool = VSphere.GetVappContainer.Invoke(new()\n    {\n        Name = \"vapp-container-01\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVappContainer(ctx, \u0026vsphere.LookupVappContainerArgs{\n\t\t\tName:         \"vapp-container-01\",\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetVappContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var pool = VsphereFunctions.getVappContainer(GetVappContainerArgs.builder()\n            .name(\"vapp-container-01\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  pool:\n    fn::invoke:\n      Function: vsphere:getVappContainer\n      Arguments:\n        name: vapp-container-01\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference ID\nof the datacenter in which the vApp container is located.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the vApp container. This can be a name or\npath.\n"
                    }
                },
                "type": "object",
                "required": [
                    "datacenterId",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVappContainer.\n",
                "properties": {
                    "datacenterId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    }
                },
                "required": [
                    "datacenterId",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getVirtualMachine:getVirtualMachine": {
            "description": "The `vsphere.VirtualMachine` data source can be used to find the UUID of an\nexisting virtual machine or template. The most common purpose is for finding\nthe UUID of a template to be used as the source for cloning to a new\n`vsphere.VirtualMachine` resource. It also\nreads the guest ID so that can be supplied as well.\n\n## Example Usage\n\nIn the following example, a virtual machine template is returned by its unique\nname within the `vsphere.Datacenter`.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst template = datacenter.then(datacenter =\u003e vsphere.getVirtualMachine({\n    name: \"ubuntu-server-template\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\ntemplate = vsphere.get_virtual_machine(name=\"ubuntu-server-template\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var template = VSphere.GetVirtualMachine.Invoke(new()\n    {\n        Name = \"ubuntu-server-template\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026vsphere.LookupVirtualMachineArgs{\n\t\t\tName:         pulumi.StringRef(\"ubuntu-server-template\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetVirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var template = VsphereFunctions.getVirtualMachine(GetVirtualMachineArgs.builder()\n            .name(\"ubuntu-server-template\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  template:\n    fn::invoke:\n      Function: vsphere:getVirtualMachine\n      Arguments:\n        name: ubuntu-server-template\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nIn the following example, each virtual machine template is returned by its\nunique full path within the `vsphere.Datacenter`.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst productionTemplate = datacenter.then(datacenter =\u003e vsphere.getVirtualMachine({\n    name: \"production/templates/ubuntu-server-template\",\n    datacenterId: datacenter.id,\n}));\nconst developmentTemplate = datacenter.then(datacenter =\u003e vsphere.getVirtualMachine({\n    name: \"development/templates/ubuntu-server-template\",\n    datacenterId: datacenter.id,\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nproduction_template = vsphere.get_virtual_machine(name=\"production/templates/ubuntu-server-template\",\n    datacenter_id=datacenter.id)\ndevelopment_template = vsphere.get_virtual_machine(name=\"development/templates/ubuntu-server-template\",\n    datacenter_id=datacenter.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var productionTemplate = VSphere.GetVirtualMachine.Invoke(new()\n    {\n        Name = \"production/templates/ubuntu-server-template\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var developmentTemplate = VSphere.GetVirtualMachine.Invoke(new()\n    {\n        Name = \"development/templates/ubuntu-server-template\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026vsphere.LookupVirtualMachineArgs{\n\t\t\tName:         pulumi.StringRef(\"production/templates/ubuntu-server-template\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.LookupVirtualMachine(ctx, \u0026vsphere.LookupVirtualMachineArgs{\n\t\t\tName:         pulumi.StringRef(\"development/templates/ubuntu-server-template\"),\n\t\t\tDatacenterId: pulumi.StringRef(datacenter.Id),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetVirtualMachineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var productionTemplate = VsphereFunctions.getVirtualMachine(GetVirtualMachineArgs.builder()\n            .name(\"production/templates/ubuntu-server-template\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var developmentTemplate = VsphereFunctions.getVirtualMachine(GetVirtualMachineArgs.builder()\n            .name(\"development/templates/ubuntu-server-template\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  productionTemplate:\n    fn::invoke:\n      Function: vsphere:getVirtualMachine\n      Arguments:\n        name: production/templates/ubuntu-server-template\n        datacenterId: ${datacenter.id}\n  developmentTemplate:\n    fn::invoke:\n      Function: vsphere:getVirtualMachine\n      Arguments:\n        name: development/templates/ubuntu-server-template\n        datacenterId: ${datacenter.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVirtualMachine.\n",
                "properties": {
                    "alternateGuestName": {
                        "type": "string",
                        "description": "The alternate guest name of the virtual machine when\n`guest_id` is a non-specific operating system, like `otherGuest` or\n`otherGuest64`.\n"
                    },
                    "annotation": {
                        "type": "string",
                        "description": "The user-provided description of this virtual machine.\n"
                    },
                    "bootDelay": {
                        "type": "integer"
                    },
                    "bootRetryDelay": {
                        "type": "integer"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "type": "integer"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "cpuReservation": {
                        "type": "integer"
                    },
                    "cpuShareCount": {
                        "type": "integer"
                    },
                    "cpuShareLevel": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string",
                        "description": "The managed object reference\nID of the datacenter the virtual machine is located in.\nThis can be omitted if the search path used in `name` is an absolute path.\nFor default datacenters, use the `id` attribute from an empty\n`vsphere.Datacenter` data source.\n"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean"
                    },
                    "enableDiskUuid": {
                        "type": "boolean"
                    },
                    "enableLogging": {
                        "type": "boolean"
                    },
                    "eptRviMode": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "extraConfigRebootRequired": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The firmware type for this virtual machine. Can be `bios` or\n`efi`.\n"
                    },
                    "folder": {
                        "type": "string",
                        "description": "The name of the virtual machine folder where the virtual machine is located. The `name` argument is limited to 80 characters. If the `name` argument includes the full path to the virtual machine and exceeds the 80 characters limit, the `folder` folder argument can be used.\n"
                    },
                    "guestId": {
                        "type": "string",
                        "description": "The guest ID of the virtual machine or template.\n"
                    },
                    "hardwareVersion": {
                        "type": "integer",
                        "description": "The hardware version number on this virtual machine.\n"
                    },
                    "hvMode": {
                        "type": "string"
                    },
                    "ideControllerScanCount": {
                        "type": "integer"
                    },
                    "latencySensitivity": {
                        "type": "string"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The size of the virtual machine's memory, in MB.\n"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "type": "integer"
                    },
                    "memoryReservation": {
                        "type": "integer"
                    },
                    "memoryReservationLockedToMax": {
                        "type": "boolean"
                    },
                    "memoryShareCount": {
                        "type": "integer"
                    },
                    "memoryShareLevel": {
                        "type": "string"
                    },
                    "moid": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the virtual machine. This can be a name or\nthe full path relative to the datacenter. This is required if a UUID lookup\nis not performed.\n"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean"
                    },
                    "numCoresPerSocket": {
                        "type": "integer",
                        "description": "The number of cores per socket for this virtual\nmachine.\n"
                    },
                    "numCpus": {
                        "type": "integer",
                        "description": "The total number of virtual processor cores assigned to this\nvirtual machine.\n"
                    },
                    "replaceTrigger": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean"
                    },
                    "sataControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer",
                        "description": "The number of SCSI controllers to\nscan for disk attributes and controller types on. Default: `1`.\n\n\u003e **NOTE:** For best results, ensure that all the disks on any templates you\nuse with this data source reside on the primary controller, and leave this\nvalue at the default. See the `vsphere.VirtualMachine`\nresource documentation for the significance of this setting, specifically the\nadditional requirements and notes for cloning section.\n"
                    },
                    "storagePolicyId": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean"
                    },
                    "toolsUpgradePolicy": {
                        "type": "string"
                    },
                    "uuid": {
                        "type": "string",
                        "description": "Specify this field for a UUID lookup, `name` and `datacenter_id`\nare not required if this is specified.\n"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp"
                    },
                    "vbsEnabled": {
                        "type": "boolean"
                    },
                    "vvtdEnabled": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getVirtualMachine.\n",
                "properties": {
                    "alternateGuestName": {
                        "description": "The alternate guest name of the virtual machine when\n`guest_id` is a non-specific operating system, like `otherGuest` or\n`otherGuest64`.\n",
                        "type": "string"
                    },
                    "annotation": {
                        "description": "The user-provided description of this virtual machine.\n",
                        "type": "string"
                    },
                    "bootDelay": {
                        "type": "integer"
                    },
                    "bootRetryDelay": {
                        "type": "integer"
                    },
                    "bootRetryEnabled": {
                        "type": "boolean"
                    },
                    "changeVersion": {
                        "type": "string"
                    },
                    "cpuHotAddEnabled": {
                        "type": "boolean"
                    },
                    "cpuHotRemoveEnabled": {
                        "type": "boolean"
                    },
                    "cpuLimit": {
                        "type": "integer"
                    },
                    "cpuPerformanceCountersEnabled": {
                        "type": "boolean"
                    },
                    "cpuReservation": {
                        "type": "integer"
                    },
                    "cpuShareCount": {
                        "type": "integer"
                    },
                    "cpuShareLevel": {
                        "type": "string"
                    },
                    "datacenterId": {
                        "type": "string"
                    },
                    "defaultIpAddress": {
                        "description": "Whenever possible, this is the first IPv4 address that\nis reachable through the default gateway configured on the machine, then the\nfirst reachable IPv6 address, and then the first general discovered address if\nneither exist. If VMware Tools is not running on the virtual machine, or if\nthe VM is powered off, this value will be blank.\n",
                        "type": "string"
                    },
                    "disks": {
                        "description": "Information about each of the disks on this virtual machine or\ntemplate. These are sorted by bus and unit number so that they can be applied\nto a `vsphere.VirtualMachine` resource in the order the resource expects\nwhile cloning. This is useful for discovering certain disk settings while\nperforming a linked clone, as all settings that are output by this data source\nmust be the same on the destination virtual machine as the source. Only the\nfirst number of controllers defined by `scsi_controller_scan_count` are\nscanned for disks. The sub-attributes are:\n",
                        "items": {
                            "$ref": "#/types/vsphere:index/getVirtualMachineDisk:getVirtualMachineDisk"
                        },
                        "type": "array"
                    },
                    "efiSecureBootEnabled": {
                        "type": "boolean"
                    },
                    "enableDiskUuid": {
                        "type": "boolean"
                    },
                    "enableLogging": {
                        "type": "boolean"
                    },
                    "eptRviMode": {
                        "type": "string"
                    },
                    "extraConfig": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "extraConfigRebootRequired": {
                        "type": "boolean"
                    },
                    "firmware": {
                        "description": "The firmware type for this virtual machine. Can be `bios` or\n`efi`.\n",
                        "type": "string"
                    },
                    "folder": {
                        "type": "string"
                    },
                    "guestId": {
                        "description": "The guest ID of the virtual machine or template.\n",
                        "type": "string"
                    },
                    "guestIpAddresses": {
                        "description": "A list of IP addresses as reported by VMware Tools.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "hardwareVersion": {
                        "description": "The hardware version number on this virtual machine.\n",
                        "type": "integer"
                    },
                    "hvMode": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ideControllerScanCount": {
                        "type": "integer"
                    },
                    "instanceUuid": {
                        "description": "The instance UUID of the virtual machine or template.\n",
                        "type": "string"
                    },
                    "latencySensitivity": {
                        "type": "string"
                    },
                    "memory": {
                        "description": "The size of the virtual machine's memory, in MB.\n",
                        "type": "integer"
                    },
                    "memoryHotAddEnabled": {
                        "type": "boolean"
                    },
                    "memoryLimit": {
                        "type": "integer"
                    },
                    "memoryReservation": {
                        "type": "integer"
                    },
                    "memoryReservationLockedToMax": {
                        "type": "boolean"
                    },
                    "memoryShareCount": {
                        "type": "integer"
                    },
                    "memoryShareLevel": {
                        "type": "string"
                    },
                    "moid": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "nestedHvEnabled": {
                        "type": "boolean"
                    },
                    "networkInterfaceTypes": {
                        "description": "The network interface types for each network\ninterface found on the virtual machine, in device bus order. Will be one of\n`e1000`, `e1000e`, `pcnet32`, `sriov`, `vmxnet2`, `vmxnet3vrdma`, or\n`vmxnet3`.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "networkInterfaces": {
                        "description": "Information about each of the network interfaces on\nthis virtual machine or template. These are sorted by device bus order so that\nthey can be applied to a `vsphere.VirtualMachine` resource in the order the\nresource expects while cloning. This is useful for discovering certain network\ninterface settings while performing a linked clone, as all settings that are\noutput by this data source must be the same on the destination virtual machine\nas the source. The sub-attributes are:\n",
                        "items": {
                            "$ref": "#/types/vsphere:index/getVirtualMachineNetworkInterface:getVirtualMachineNetworkInterface"
                        },
                        "type": "array"
                    },
                    "numCoresPerSocket": {
                        "description": "The number of cores per socket for this virtual\nmachine.\n",
                        "type": "integer"
                    },
                    "numCpus": {
                        "description": "The total number of virtual processor cores assigned to this\nvirtual machine.\n",
                        "type": "integer"
                    },
                    "replaceTrigger": {
                        "type": "string"
                    },
                    "runToolsScriptsAfterPowerOn": {
                        "type": "boolean"
                    },
                    "runToolsScriptsAfterResume": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestReboot": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestShutdown": {
                        "type": "boolean"
                    },
                    "runToolsScriptsBeforeGuestStandby": {
                        "type": "boolean"
                    },
                    "sataControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiBusSharing": {
                        "description": "Mode for sharing the SCSI bus. The modes are\nphysicalSharing, virtualSharing, and noSharing. Only the first number of\ncontrollers defined by `scsi_controller_scan_count` are scanned.\n",
                        "type": "string"
                    },
                    "scsiControllerScanCount": {
                        "type": "integer"
                    },
                    "scsiType": {
                        "description": "The common type of all SCSI controllers on this virtual machine.\nWill be one of `lsilogic` (LSI Logic Parallel), `lsilogic-sas` (LSI Logic\nSAS), `pvscsi` (VMware Paravirtual), `buslogic` (BusLogic), or `mixed` when\nthere are multiple controller types. Only the first number of controllers\ndefined by `scsi_controller_scan_count` are scanned.\n",
                        "type": "string"
                    },
                    "storagePolicyId": {
                        "type": "string"
                    },
                    "swapPlacementPolicy": {
                        "type": "string"
                    },
                    "syncTimeWithHost": {
                        "type": "boolean"
                    },
                    "syncTimeWithHostPeriodically": {
                        "type": "boolean"
                    },
                    "toolsUpgradePolicy": {
                        "type": "string"
                    },
                    "uuid": {
                        "type": "string"
                    },
                    "vapp": {
                        "$ref": "#/types/vsphere:index/getVirtualMachineVapp:getVirtualMachineVapp"
                    },
                    "vappTransports": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "vbsEnabled": {
                        "type": "boolean"
                    },
                    "vvtdEnabled": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "annotation",
                    "changeVersion",
                    "cpuShareCount",
                    "defaultIpAddress",
                    "disks",
                    "eptRviMode",
                    "guestId",
                    "guestIpAddresses",
                    "hardwareVersion",
                    "hvMode",
                    "instanceUuid",
                    "memoryShareCount",
                    "moid",
                    "networkInterfaceTypes",
                    "networkInterfaces",
                    "scsiBusSharing",
                    "scsiType",
                    "storagePolicyId",
                    "uuid",
                    "vappTransports",
                    "id"
                ],
                "type": "object"
            }
        },
        "vsphere:index/getVmfsDisks:getVmfsDisks": {
            "description": "The `vsphere.getVmfsDisks` data source can be used to discover the storage\ndevices available on an ESXi host. This data source can be combined with the\n`vsphere.VmfsDatastore` resource to create VMFS\ndatastores based off a set of discovered disks.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as vsphere from \"@pulumi/vsphere\";\n\nconst datacenter = vsphere.getDatacenter({\n    name: \"dc-01\",\n});\nconst host = datacenter.then(datacenter =\u003e vsphere.getHost({\n    name: \"esxi-01.example.com\",\n    datacenterId: datacenter.id,\n}));\nconst vmfsDisks = host.then(host =\u003e vsphere.getVmfsDisks({\n    hostSystemId: host.id,\n    rescan: true,\n    filter: \"mpx.vmhba1:C0:T[12]:L0\",\n}));\n```\n```python\nimport pulumi\nimport pulumi_vsphere as vsphere\n\ndatacenter = vsphere.get_datacenter(name=\"dc-01\")\nhost = vsphere.get_host(name=\"esxi-01.example.com\",\n    datacenter_id=datacenter.id)\nvmfs_disks = vsphere.get_vmfs_disks(host_system_id=host.id,\n    rescan=True,\n    filter=\"mpx.vmhba1:C0:T[12]:L0\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing VSphere = Pulumi.VSphere;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var datacenter = VSphere.GetDatacenter.Invoke(new()\n    {\n        Name = \"dc-01\",\n    });\n\n    var host = VSphere.GetHost.Invoke(new()\n    {\n        Name = \"esxi-01.example.com\",\n        DatacenterId = datacenter.Apply(getDatacenterResult =\u003e getDatacenterResult.Id),\n    });\n\n    var vmfsDisks = VSphere.GetVmfsDisks.Invoke(new()\n    {\n        HostSystemId = host.Apply(getHostResult =\u003e getHostResult.Id),\n        Rescan = true,\n        Filter = \"mpx.vmhba1:C0:T[12]:L0\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-vsphere/sdk/v4/go/vsphere\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdatacenter, err := vsphere.LookupDatacenter(ctx, \u0026vsphere.LookupDatacenterArgs{\n\t\t\tName: pulumi.StringRef(\"dc-01\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thost, err := vsphere.LookupHost(ctx, \u0026vsphere.LookupHostArgs{\n\t\t\tName:         pulumi.StringRef(\"esxi-01.example.com\"),\n\t\t\tDatacenterId: datacenter.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = vsphere.GetVmfsDisks(ctx, \u0026vsphere.GetVmfsDisksArgs{\n\t\t\tHostSystemId: host.Id,\n\t\t\tRescan:       pulumi.BoolRef(true),\n\t\t\tFilter:       pulumi.StringRef(\"mpx.vmhba1:C0:T[12]:L0\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.vsphere.VsphereFunctions;\nimport com.pulumi.vsphere.inputs.GetDatacenterArgs;\nimport com.pulumi.vsphere.inputs.GetHostArgs;\nimport com.pulumi.vsphere.inputs.GetVmfsDisksArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var datacenter = VsphereFunctions.getDatacenter(GetDatacenterArgs.builder()\n            .name(\"dc-01\")\n            .build());\n\n        final var host = VsphereFunctions.getHost(GetHostArgs.builder()\n            .name(\"esxi-01.example.com\")\n            .datacenterId(datacenter.applyValue(getDatacenterResult -\u003e getDatacenterResult.id()))\n            .build());\n\n        final var vmfsDisks = VsphereFunctions.getVmfsDisks(GetVmfsDisksArgs.builder()\n            .hostSystemId(host.applyValue(getHostResult -\u003e getHostResult.id()))\n            .rescan(true)\n            .filter(\"mpx.vmhba1:C0:T[12]:L0\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  datacenter:\n    fn::invoke:\n      Function: vsphere:getDatacenter\n      Arguments:\n        name: dc-01\n  host:\n    fn::invoke:\n      Function: vsphere:getHost\n      Arguments:\n        name: esxi-01.example.com\n        datacenterId: ${datacenter.id}\n  vmfsDisks:\n    fn::invoke:\n      Function: vsphere:getVmfsDisks\n      Arguments:\n        hostSystemId: ${host.id}\n        rescan: true\n        filter: mpx.vmhba1:C0:T[12]:L0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getVmfsDisks.\n",
                "properties": {
                    "filter": {
                        "type": "string",
                        "description": "A regular expression to filter the disks against. Only\ndisks with canonical names that match will be included.\n\n\u003e **NOTE:** Using a `filter` is recommended if there is any chance the host\nwill have any specific storage devices added to it that may affect the order of\nthe output `disks` attribute below, which is lexicographically sorted.\n"
                    },
                    "hostSystemId": {
                        "type": "string",
                        "description": "The managed object ID of\nthe host to look for disks on.\n"
                    },
                    "rescan": {
                        "type": "boolean",
                        "description": "Whether or not to rescan storage adapters before\nsearching for disks. This may lengthen the time it takes to perform the\nsearch. Default: `false`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "hostSystemId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getVmfsDisks.\n",
                "properties": {
                    "disks": {
                        "description": "A lexicographically sorted list of devices discovered by the\noperation, matching the supplied `filter`, if provided.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "hostSystemId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "rescan": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "disks",
                    "hostSystemId",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}